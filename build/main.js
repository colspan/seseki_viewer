/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {
	__webpack_require__(2);
	var $ = window.jQuery = __webpack_require__(8); /* materialize-cssのバグ対策 https://github.com/Dogfalo/materialize/issues/1229 */
	__webpack_require__(9);
	__webpack_require__(12)
	var Handsontable = __webpack_require__(36);
	__webpack_require__(38);
	var Encoding = __webpack_require__(40);

	__webpack_require__(41);
	__webpack_require__(42);
	__webpack_require__(44);

	$(document).ready(function(){
	  var initialized = false;
	  var map_elem = $('<div>');
	  var new_id = 'map';
	  var tip_elem = $('<div>');
	  var modal_table_elem = $('<table>');
	  var data = {};
	  var data_array;
	  var csv_keys = [];
	  var communes;

	  var ua = navigator.userAgent; // ユーザーエージェントを代入
	  var isIE = false;
	  if (ua.match("MSIE") || ua.match("Trident")) {
	    isIE = true;
	  }

	  // 起動
	  d3.json('params/communes.json', function(d){
	    communes = d;
	    csv_viewer([]);
	  })

	  function clear_data(){
	    data = {};
	    data_array = [];
	    csv_keys = [];
	  }
	  function csv_viewer(d){
	    if(!initialized){
	      initialize(d);
	      initialized = true;
	    }
	    update(d);

	    function initialize(d){
	      // ヒートマップ描画
	      map_elem.attr('id', new_id);
	      $('#map_container').append(map_elem);

	      // 列選択ボタン作成
	      d3.select('#map_datatype_selector')
	      .append('select')
	      .attr('class','browser-default')
	      .attr('style','margin:9px 20px 0 -10px; display: inline;color:#0d47a1;')
	      .on('change', function () {
	        draw_map(this.value);
	      })
	      .selectAll('option')
	      .data([])
	      .enter()
	      .append('option')
	      .html(function(d){return d});

	      // 北海道地図描画
	      $('#'+new_id).hokkaidoHeatmap({title:'',subtitle:'',subsubtitle:'',max_width:800},function(){init_sample();}); // TODO 一時的な対応

	      // tip作成
	      tip_elem.attr('class', 'card-panel')
	      .css('width', '180px')
	      .css('height', '48px')
	      .css('padding', '10px')
	      .css('position', 'absolute')
	      .css('visibility', 'hidden')
	      .css('font-size', '14pt')
	      .appendTo('body');

	      // modal作成
	      modal_table_elem.attr('class','table bordered striped highlight');
	      $("#modal_commune_data").append(modal_table_elem);

	    }
	    function update(d){
	      if(!d.length){
	        console.log("No Records");
	        Materialize.toast('CSVファイルを入力してください。', 3000);
	        clear_data();
	        return;
	      }
	      csv_keys = Object.keys(d[0]);
	      if(csv_keys.length<2){
	        console.log("Too Few Columns");
	        Materialize.toast('CSVファイル(2列以上のデータ)を入力してください。', 3000);
	        clear_data();
	        return;
	      }
	      data_array = d;
	      data = {};
	      // データアクセスを容易にするために自治体名でObject作成
	      d.forEach(function(x){
	        var commune_name = x[csv_keys[0]]; // 1列目は自治体名(制約)
	        if(commune_name.length<2) return; // 文字列が短過ぎたらスキップ
	        data[commune_name] = x;
	      });
	      // タイトル更新
	      $('#report_title').text(csv_keys[0]);

	      // 地図更新
	      draw_map(csv_keys[1]);

	      // 列選択ボタン作成
	      var options = d3.select('#map_datatype_selector')
	      .select('select')
	      .selectAll('option')
	      .data(csv_keys.slice(1));
	      options.enter().append('option');
	      options.exit().remove();
	      options.html(function(d){return d});
	    }
	    // 描画関数
	    function draw_map(key){
	      var get_value = function(x){
	        try{
	          var value;
	          value = x[key];
	          return isNaN(+value) ? value : +value;
	        }
	        catch(e){
	          return null;
	        }
	      }
	      var format = function(x){
	        if(isNaN(x)) return x;
	        var format_str = (+x%1===0 && +x%1===0? ',.0f' : '0.4f' );
	        return d3.format(format_str)(x);
	      }

	      // max,minを算出
	      data_array.sort(function(a,b){return d3.descending(get_value(a),get_value(b));});
	      var max = d3.max(data_array, get_value);
	      var min = d3.min(data_array, get_value);
	      var domain, range;
	      if(min < 0 && max < 0){
	        domain = [min,max];
	        range = ["white", "#ff5722"];
	      }
	      else if(min < 0 && max >= 0){
	        if(get_value(data_array[1])>0&&get_value(data_array[0])/get_value(data_array[1]) > 3.0){
	          // 1位と2位の比率が5倍を超えるとき
	          domain = [min,0,get_value(data_array[1]),get_value(data_array[0])];
	          range = ["#03a9f4", "white", "#ff5722", "#dd2c00"];
	        }
	        else{
	          domain = [min,0,max];
	          range = ["#03a9f4", "white", "#ff5722"];
	        }
	      }
	      else { // (min >= 0 && max >= 0)
	        if(get_value(data_array[1])>0&&get_value(data_array[0])/get_value(data_array[1]) > 3.0){
	          // 1位と2位の比率が5倍を超えるとき
	          domain = [0,get_value(data_array[1]),get_value(data_array[0])];
	          range = ["white", "#ff5722", "#dd2c00"];
	        }
	        else{
	          domain = [0,max];
	          range = ["white", "#ff5722"];
	        }
	      }
	      // domain正規化
	      var norm_domain = [];
	      domain.forEach(function(v){
	        if(v==0){
	          norm_domain.push(v);
	          return;
	        }
	        var abs_v = Math.abs(v);
	        var digits = Math.floor(Math.log(abs_v)/Math.log(10));
	        var new_v = Math.floor(abs_v/Math.pow(10,digits-1)+1)*Math.pow(10,digits-1);
	        norm_domain.push(v>0?new_v:-new_v);
	      });
	      domain = norm_domain;

	      // color_scale作成
	      var color_scale = d3.scale.linear().domain(domain).range(range);
	      // title作成
	      var titles = key.replace(/\)/g,'').split('(');
	      // ヒートマップのパラメタ生成
	      // click時の動作
	      var last_touched = null;
	      var click = function(d){
	        if(last_touched) d3.select(last_touched.elem).attr('fill', '#ffff00');
	        $("#modal_commune_name").html('<a href="tourism_stat_commune.html#'+d.name+'" target="_new">'+d.name+'</a>');
	        // データ取得
	        var row = data[d.name];
	        var items = [];
	        var i = 0;
	        for(var c in row){
	          i++;
	          if(i==1) continue;
	          items.push({key:c,value:format(row[c])})
	        }
	        // table作成
	        var th = $('<tr>')
	        .append('<th>項目</th>')
	        .append('<th>値</th>')
	        modal_table_elem.html('');
	        modal_table_elem.append($('<thead>').append(th));
	        var tbody = $('<tbody>');
	        for (var item in items) {
	            var td = $('<tr' + (items[item].key==key?' style="background:#eeee00;"':'') + '>')
	            .append('<td>' + items[item].key + '</td>')
	            .append('<td style="text-align:right;">' + items[item].value + '</td>')
	            tbody.append(td);
	        }
	        modal_table_elem.append(tbody);
	        $("#myModal").openModal({in_duration:0,out_duration:0});
	      }
	      // touch & over時の動作
	      var mouseover = function(x){
	        var pos;
	        var commune = x.name;
	        // 座標取得
	        if(d3.event.targetTouches){// touch
	          d3.event.preventDefault();
	          pos = {x:d3.event.targetTouches[0].pageX, y:d3.event.targetTouches[0].pageY};
	          if(last_touched && last_touched.elem == this){
	            click(x);
	          }
	        }
	        else{
	          if(isIE) pos = {x:d3.event.x,y:d3.event.y};
	          else pos = {x:$(window).scrollLeft() + d3.event.x,y:$(window).scrollTop() + d3.event.y};
	        }
	        // 元に戻す
	        if(last_touched) d3.select(last_touched.elem).attr('fill', last_touched.color);
	        last_touched = {elem:this, color:options.map_filler(x)};
	        // 色塗替え
	        d3.select(this).attr('fill', '#dddd00');
	        // tip更新
	        tip_elem.css('top' , pos.y+'px');
	        tip_elem.css('left', pos.x+'px');
	        tip_elem.css('visibility', 'visible');
	        tip_elem.html('<span>' + commune + ' <span class="badge">' + format(get_value(data[commune])) + '</span>'  );
	      }
	      var options = {
	        title : titles[0],
	        subtitle : titles[1]?titles[1]:'',
	        subsubtitle : titles[2]?titles[2]:'',
	        auto_resize : true,
	        show_legend : true,
	        color_scale : color_scale,
	        save_filename : titles.join('-'),
	        map_filler:function(x){
	          if(!data[x.name]) return "#888";
	          return color_scale(get_value(data[x.name]));
	        },
	        on_mouseover : function(d){
	          d3.select(this).attr('fill', '#dddd00');
	          tip_elem.css('top' , $(window).scrollTop() + d3.event.y+'px');
	          tip_elem.css('left', $(window).scrollLeft() + d3.event.x+'px');
	          tip_elem.css('visibility', 'visible');
	          tip_elem.html('<span>' + d.name + ' <span class="badge">' + format(get_value(data[d.name])) + '</span>'  );
	        },
	        on_mouseover : mouseover,
	        on_mouseout  : function(x){
	          d3.select(this).attr('fill', options.map_filler);
	          tip_elem.css('visibility', 'hidden');
	        },
	        on_mousedown : click,
	        on_touchstart : mouseover
	      };
	      $('#'+new_id).hokkaidoHeatmap('update', options);

	      // ランキング表示
	      var items = [];
	      data_array.forEach(function(x){
	        var commune_name = x[csv_keys[0]]; // 1列目は自治体名(制約)
	        var value = isNaN(+x[key]) ? x[key] : +x[key];
	        if(commune_name.length<2) return; // 文字列が短過ぎたらスキップ
	        items.push({key:commune_name, value:value});
	      });
	      //// ソート
	      items.sort(function(a,b){
	      if( a.value > b.value ) return -1;
	      if( a.value < b.value ) return 1;
	      return 0;})

	      // table作成
	      var ranking_table_rows = d3.select('#ranking_table')
	      .selectAll('tr')
	      .data(items);
	      ranking_table_rows.enter().append('tr');
	      ranking_table_rows.exit().remove();
	      ranking_table_rows.style('background-color', function(x){return options.color_scale(x.value)});
	      ranking_table_rows.html(function(x,i){
	        var html = '<td style="text-align:right;">' + (i+1) + '</td>';
	        html +='<td>'+x.key+'</td>';
	        html +='<td style="text-align:right;">' + format(x.value) + '</td>';
	        return html;
	      });
	      ranking_table_rows.on('mouseover', function(x){
	        $('#map').hokkaidoHeatmap('update_partial', function(y){return y.name==x.key}, function(x){return '#dddd00'});
	      })
	      .on('mouseout', function(x){
	        $('#map').hokkaidoHeatmap('update_partial', function(y){return y.name==x.key}, function(){return options.color_scale(x.value)});
	      })
	      .on('click', function(x){
	        click({name:x.key});
	      });
	    }
	  }

	  var input_file = 'instant_data/20151125_population_analysis.csv';
	  $('#file_loader').change(function(e){
	    var file = e.target.files[0];
	    file.type = "text/plain;charset=UTF-8"
	    var reader = new FileReader();
	    reader.onloadend = function(evt){
	      Materialize.toast('ファイル"'+file.name+'"を読み込みました', 3000);
	      var input = new Uint8Array(reader.result);
	      var data = Encoding.codeToString(Encoding.convert(input, {to:'UNICODE'}));
	      csv_viewer(d3.csv.parse(data));
	      // サンプルローダーを初期化
	      $("#sample_data_selector").val("");
	      $("#data-info").css("visibility", "hidden");
	    }
	    reader.readAsArrayBuffer(file);
	  });

	  function init_sample(){
	    // サンプルデータ一覧更新
	    d3.json('params/sample_data.json',function(d){
	      function get_by_filename(k){var i;for(i=0;i<d.length;i++){if(d[i].file==k) return d[i];}return null;}
	      function load_sample(filename){
	        // サンプルファイルの説明を表示
	        $("#data-info").css("visibility", "visible");
	        var data_info = get_by_filename(filename);
	        $("#data-description").html(data_info.file_description);
	        $("#data-title").html(data_info.title);
	        $("#data-url").html(data_info.right_holder).attr("href", data_info.url);
	        $("#convertedcsv-url").attr("href", filename);
	        // ファイルローダーを初期化
	        $("#file_loader").val("");
	        $("#file_loader_filename").val("CSVファイルを開く");
	        // 読み込み
	        d3.xhr(filename)
	        .responseType("arraybuffer")
	        .response(function(r){
	          return new Uint8Array(r.response);
	        })
	        .get(function(error,d){
	          if(error){
	            Materialize.toast('ファイルを読み込めませんでした', 3000);
	          }
	          else{
	            var data = Encoding.codeToString(Encoding.convert(d, {to:'UNICODE'}));
	            Materialize.toast('ファイルを読み込みました', 3000);
	            csv_viewer(d3.csv.parse(data));
	          }
	        });
	      }
	      // 列選択ボタン作成
	      d3.select('#sample_data_selector')
	      .on('change', function (x) {
	        load_sample(this.value);
	      })
	      .selectAll('option')
	      .data(d)
	      .enter()
	      .append('option')
	      .attr("value",function(d){return d.file})
	      .html(function(d){return d.title});
	      // ハッシュにサンプルデータ読み出しが指定されていた場合
	      function getHashVars()
	      {
	          var vars = [], hash;
	          var hashes = window.location.href.slice(window.location.href.indexOf('#') + 1).split('&');
	          for(var i = 0; i < hashes.length; i++) {
	              hash = hashes[i].split('=');
	              vars[hash[0]] = hash[1];
	          }
	          return vars;
	      }
	      var hashvars = getHashVars();
	      if(hashvars.sample && get_by_filename(hashvars.sample)){
	        load_sample(hashvars.sample);
	      }
	    });
	  }
	  // スプレッドシート
	  var spreadsheet_obj;
	  function spreadsheet_open(){
	    var spreadsheet_elem = document.getElementById('spreadsheet');
	    var options = {
	      startRows: 30,
	      startCols: 200,
	      width: "100%",
	      height: 500,
	      colWidths: 80,
	      rowHeights: 23,
	      rowHeaders: true,
	      colHeaders: true
	    };
	    spreadsheet_obj = new Handsontable(spreadsheet_elem, options);
	    //データを代入
	    var input_data = [];
	    if(data_array && data_array.length>2){
	      // 読み込み済みの場合
	      input_data.push(csv_keys);
	      $.map(data_array, function(d){
	        input_data.push($.map(csv_keys,function(x){return d[x]===null?"":d[x]}));
	      });
	    }
	    else{
	      // まだ読み込んでいない場合
	      input_data.push(["データの名前","サンプルデータ系列1(説明A)(説明B)","サンプルデータ系列2(説明C)(説明D)","サンプルデータ系列3(説明E)(説明F)"]);
	      $.map(communes,function(d,i){
	        var r = [d,i,parseInt(Math.random()*1000,10),Math.random()*10-5];
	        input_data.push(r);
	      });
	    }
	    spreadsheet_obj.loadData(input_data);
	    spreadsheet_obj.alter('insert_col',null,50-input_data[0].length);
	  }
	  function spreadsheet_close(){
	    var data = spreadsheet_obj.getData();
	    // 列数を数える
	    var min_nullnum = data.length;
	    for(var i=0;i<data.length;i++){
	      var nullnum = 0;
	      for(var j=data[i].length-1;j>=0;j--){
	        if(data[i][j]!==null) break;
	        nullnum++;
	      }
	      if(min_nullnum>nullnum) min_nullnum = nullnum;
	    }
	    // 列数に応じてスプレッドシートを削る
	    spreadsheet_obj.alter('remove_col', data[0].length-min_nullnum, min_nullnum);
	    // データを再取得
	    data = spreadsheet_obj.getData();
	    var keys = data[0];//.shift();
	    // NULLの列名があったら足す
	    for(var i=0;i<keys.length;i++){
	      if(keys[i]===null) keys[i] = i+'系列'
	    }
	    var json = [];
	    for(var i=1;i<data.length;i++){
	      var r = {};
	      $.map(keys,function(x,j){
	        r[x] = data[i][j];
	      });
	      json.push(r);
	    }
	    Materialize.toast('データを更新しました', 3000);
	    csv_viewer(json);
	    spreadsheet_obj.destroy();
	    // ファイルローダーを初期化
	    $("#file_loader").val("");
	    $("#file_loader_filename").val("CSVファイルを開く");
	    // サンプルローダーを初期化
	    $("#sample_data_selector").val("");
	    $("#data-info").css("visibility", "hidden");
	  }
	  $('.modal-trigger').leanModal({
	      dismissible: true,
	      in_duration: 0,
	      out_duration: 0,
	      ready: spreadsheet_open,
	      complete: spreadsheet_close
	    }
	  );

	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {
	  var d3 = {
	    version: "3.5.17"
	  };
	  var d3_arraySlice = [].slice, d3_array = function(list) {
	    return d3_arraySlice.call(list);
	  };
	  var d3_document = this.document;
	  function d3_documentElement(node) {
	    return node && (node.ownerDocument || node.document || node).documentElement;
	  }
	  function d3_window(node) {
	    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
	  }
	  if (d3_document) {
	    try {
	      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
	    } catch (e) {
	      d3_array = function(list) {
	        var i = list.length, array = new Array(i);
	        while (i--) array[i] = list[i];
	        return array;
	      };
	    }
	  }
	  if (!Date.now) Date.now = function() {
	    return +new Date();
	  };
	  if (d3_document) {
	    try {
	      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
	    } catch (error) {
	      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
	      d3_element_prototype.setAttribute = function(name, value) {
	        d3_element_setAttribute.call(this, name, value + "");
	      };
	      d3_element_prototype.setAttributeNS = function(space, local, value) {
	        d3_element_setAttributeNS.call(this, space, local, value + "");
	      };
	      d3_style_prototype.setProperty = function(name, value, priority) {
	        d3_style_setProperty.call(this, name, value + "", priority);
	      };
	    }
	  }
	  d3.ascending = d3_ascending;
	  function d3_ascending(a, b) {
	    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	  }
	  d3.descending = function(a, b) {
	    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	  };
	  d3.min = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
	    }
	    return a;
	  };
	  d3.max = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
	    }
	    return a;
	  };
	  d3.extent = function(array, f) {
	    var i = -1, n = array.length, a, b, c;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = c = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = c = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    }
	    return [ a, c ];
	  };
	  function d3_number(x) {
	    return x === null ? NaN : +x;
	  }
	  function d3_numeric(x) {
	    return !isNaN(x);
	  }
	  d3.sum = function(array, f) {
	    var s = 0, n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
	    } else {
	      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
	    }
	    return s;
	  };
	  d3.mean = function(array, f) {
	    var s = 0, n = array.length, a, i = -1, j = n;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
	    }
	    if (j) return s / j;
	  };
	  d3.quantile = function(values, p) {
	    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
	    return e ? v + e * (values[h] - v) : v;
	  };
	  d3.median = function(array, f) {
	    var numbers = [], n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
	    }
	    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
	  };
	  d3.variance = function(array, f) {
	    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
	    if (arguments.length === 1) {
	      while (++i < n) {
	        if (d3_numeric(a = d3_number(array[i]))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    } else {
	      while (++i < n) {
	        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    }
	    if (j > 1) return s / (j - 1);
	  };
	  d3.deviation = function() {
	    var v = d3.variance.apply(this, arguments);
	    return v ? Math.sqrt(v) : v;
	  };
	  function d3_bisector(compare) {
	    return {
	      left: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
	        }
	        return lo;
	      },
	      right: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
	        }
	        return lo;
	      }
	    };
	  }
	  var d3_bisect = d3_bisector(d3_ascending);
	  d3.bisectLeft = d3_bisect.left;
	  d3.bisect = d3.bisectRight = d3_bisect.right;
	  d3.bisector = function(f) {
	    return d3_bisector(f.length === 1 ? function(d, x) {
	      return d3_ascending(f(d), x);
	    } : f);
	  };
	  d3.shuffle = function(array, i0, i1) {
	    if ((m = arguments.length) < 3) {
	      i1 = array.length;
	      if (m < 2) i0 = 0;
	    }
	    var m = i1 - i0, t, i;
	    while (m) {
	      i = Math.random() * m-- | 0;
	      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
	    }
	    return array;
	  };
	  d3.permute = function(array, indexes) {
	    var i = indexes.length, permutes = new Array(i);
	    while (i--) permutes[i] = array[indexes[i]];
	    return permutes;
	  };
	  d3.pairs = function(array) {
	    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
	    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
	    return pairs;
	  };
	  d3.transpose = function(matrix) {
	    if (!(n = matrix.length)) return [];
	    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
	      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
	        row[j] = matrix[j][i];
	      }
	    }
	    return transpose;
	  };
	  function d3_transposeLength(d) {
	    return d.length;
	  }
	  d3.zip = function() {
	    return d3.transpose(arguments);
	  };
	  d3.keys = function(map) {
	    var keys = [];
	    for (var key in map) keys.push(key);
	    return keys;
	  };
	  d3.values = function(map) {
	    var values = [];
	    for (var key in map) values.push(map[key]);
	    return values;
	  };
	  d3.entries = function(map) {
	    var entries = [];
	    for (var key in map) entries.push({
	      key: key,
	      value: map[key]
	    });
	    return entries;
	  };
	  d3.merge = function(arrays) {
	    var n = arrays.length, m, i = -1, j = 0, merged, array;
	    while (++i < n) j += arrays[i].length;
	    merged = new Array(j);
	    while (--n >= 0) {
	      array = arrays[n];
	      m = array.length;
	      while (--m >= 0) {
	        merged[--j] = array[m];
	      }
	    }
	    return merged;
	  };
	  var abs = Math.abs;
	  d3.range = function(start, stop, step) {
	    if (arguments.length < 3) {
	      step = 1;
	      if (arguments.length < 2) {
	        stop = start;
	        start = 0;
	      }
	    }
	    if ((stop - start) / step === Infinity) throw new Error("infinite range");
	    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
	    start *= k, stop *= k, step *= k;
	    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
	    return range;
	  };
	  function d3_range_integerScale(x) {
	    var k = 1;
	    while (x * k % 1) k *= 10;
	    return k;
	  }
	  function d3_class(ctor, properties) {
	    for (var key in properties) {
	      Object.defineProperty(ctor.prototype, key, {
	        value: properties[key],
	        enumerable: false
	      });
	    }
	  }
	  d3.map = function(object, f) {
	    var map = new d3_Map();
	    if (object instanceof d3_Map) {
	      object.forEach(function(key, value) {
	        map.set(key, value);
	      });
	    } else if (Array.isArray(object)) {
	      var i = -1, n = object.length, o;
	      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
	    } else {
	      for (var key in object) map.set(key, object[key]);
	    }
	    return map;
	  };
	  function d3_Map() {
	    this._ = Object.create(null);
	  }
	  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
	  d3_class(d3_Map, {
	    has: d3_map_has,
	    get: function(key) {
	      return this._[d3_map_escape(key)];
	    },
	    set: function(key, value) {
	      return this._[d3_map_escape(key)] = value;
	    },
	    remove: d3_map_remove,
	    keys: d3_map_keys,
	    values: function() {
	      var values = [];
	      for (var key in this._) values.push(this._[key]);
	      return values;
	    },
	    entries: function() {
	      var entries = [];
	      for (var key in this._) entries.push({
	        key: d3_map_unescape(key),
	        value: this._[key]
	      });
	      return entries;
	    },
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
	    }
	  });
	  function d3_map_escape(key) {
	    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
	  }
	  function d3_map_unescape(key) {
	    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
	  }
	  function d3_map_has(key) {
	    return d3_map_escape(key) in this._;
	  }
	  function d3_map_remove(key) {
	    return (key = d3_map_escape(key)) in this._ && delete this._[key];
	  }
	  function d3_map_keys() {
	    var keys = [];
	    for (var key in this._) keys.push(d3_map_unescape(key));
	    return keys;
	  }
	  function d3_map_size() {
	    var size = 0;
	    for (var key in this._) ++size;
	    return size;
	  }
	  function d3_map_empty() {
	    for (var key in this._) return false;
	    return true;
	  }
	  d3.nest = function() {
	    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
	    function map(mapType, array, depth) {
	      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
	      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
	      while (++i < n) {
	        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
	          values.push(object);
	        } else {
	          valuesByKey.set(keyValue, [ object ]);
	        }
	      }
	      if (mapType) {
	        object = mapType();
	        setter = function(keyValue, values) {
	          object.set(keyValue, map(mapType, values, depth));
	        };
	      } else {
	        object = {};
	        setter = function(keyValue, values) {
	          object[keyValue] = map(mapType, values, depth);
	        };
	      }
	      valuesByKey.forEach(setter);
	      return object;
	    }
	    function entries(map, depth) {
	      if (depth >= keys.length) return map;
	      var array = [], sortKey = sortKeys[depth++];
	      map.forEach(function(key, keyMap) {
	        array.push({
	          key: key,
	          values: entries(keyMap, depth)
	        });
	      });
	      return sortKey ? array.sort(function(a, b) {
	        return sortKey(a.key, b.key);
	      }) : array;
	    }
	    nest.map = function(array, mapType) {
	      return map(mapType, array, 0);
	    };
	    nest.entries = function(array) {
	      return entries(map(d3.map, array, 0), 0);
	    };
	    nest.key = function(d) {
	      keys.push(d);
	      return nest;
	    };
	    nest.sortKeys = function(order) {
	      sortKeys[keys.length - 1] = order;
	      return nest;
	    };
	    nest.sortValues = function(order) {
	      sortValues = order;
	      return nest;
	    };
	    nest.rollup = function(f) {
	      rollup = f;
	      return nest;
	    };
	    return nest;
	  };
	  d3.set = function(array) {
	    var set = new d3_Set();
	    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
	    return set;
	  };
	  function d3_Set() {
	    this._ = Object.create(null);
	  }
	  d3_class(d3_Set, {
	    has: d3_map_has,
	    add: function(key) {
	      this._[d3_map_escape(key += "")] = true;
	      return key;
	    },
	    remove: d3_map_remove,
	    values: d3_map_keys,
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key));
	    }
	  });
	  d3.behavior = {};
	  function d3_identity(d) {
	    return d;
	  }
	  d3.rebind = function(target, source) {
	    var i = 1, n = arguments.length, method;
	    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
	    return target;
	  };
	  function d3_rebind(target, source, method) {
	    return function() {
	      var value = method.apply(source, arguments);
	      return value === source ? target : value;
	    };
	  }
	  function d3_vendorSymbol(object, name) {
	    if (name in object) return name;
	    name = name.charAt(0).toUpperCase() + name.slice(1);
	    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
	      var prefixName = d3_vendorPrefixes[i] + name;
	      if (prefixName in object) return prefixName;
	    }
	  }
	  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
	  function d3_noop() {}
	  d3.dispatch = function() {
	    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    return dispatch;
	  };
	  function d3_dispatch() {}
	  d3_dispatch.prototype.on = function(type, listener) {
	    var i = type.indexOf("."), name = "";
	    if (i >= 0) {
	      name = type.slice(i + 1);
	      type = type.slice(0, i);
	    }
	    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
	    if (arguments.length === 2) {
	      if (listener == null) for (type in this) {
	        if (this.hasOwnProperty(type)) this[type].on(name, null);
	      }
	      return this;
	    }
	  };
	  function d3_dispatch_event(dispatch) {
	    var listeners = [], listenerByName = new d3_Map();
	    function event() {
	      var z = listeners, i = -1, n = z.length, l;
	      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
	      return dispatch;
	    }
	    event.on = function(name, listener) {
	      var l = listenerByName.get(name), i;
	      if (arguments.length < 2) return l && l.on;
	      if (l) {
	        l.on = null;
	        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
	        listenerByName.remove(name);
	      }
	      if (listener) listeners.push(listenerByName.set(name, {
	        on: listener
	      }));
	      return dispatch;
	    };
	    return event;
	  }
	  d3.event = null;
	  function d3_eventPreventDefault() {
	    d3.event.preventDefault();
	  }
	  function d3_eventSource() {
	    var e = d3.event, s;
	    while (s = e.sourceEvent) e = s;
	    return e;
	  }
	  function d3_eventDispatch(target) {
	    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    dispatch.of = function(thiz, argumentz) {
	      return function(e1) {
	        try {
	          var e0 = e1.sourceEvent = d3.event;
	          e1.target = target;
	          d3.event = e1;
	          dispatch[e1.type].apply(thiz, argumentz);
	        } finally {
	          d3.event = e0;
	        }
	      };
	    };
	    return dispatch;
	  }
	  d3.requote = function(s) {
	    return s.replace(d3_requote_re, "\\$&");
	  };
	  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
	  var d3_subclass = {}.__proto__ ? function(object, prototype) {
	    object.__proto__ = prototype;
	  } : function(object, prototype) {
	    for (var property in prototype) object[property] = prototype[property];
	  };
	  function d3_selection(groups) {
	    d3_subclass(groups, d3_selectionPrototype);
	    return groups;
	  }
	  var d3_select = function(s, n) {
	    return n.querySelector(s);
	  }, d3_selectAll = function(s, n) {
	    return n.querySelectorAll(s);
	  }, d3_selectMatches = function(n, s) {
	    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
	    d3_selectMatches = function(n, s) {
	      return d3_selectMatcher.call(n, s);
	    };
	    return d3_selectMatches(n, s);
	  };
	  if (typeof Sizzle === "function") {
	    d3_select = function(s, n) {
	      return Sizzle(s, n)[0] || null;
	    };
	    d3_selectAll = Sizzle;
	    d3_selectMatches = Sizzle.matchesSelector;
	  }
	  d3.selection = function() {
	    return d3.select(d3_document.documentElement);
	  };
	  var d3_selectionPrototype = d3.selection.prototype = [];
	  d3_selectionPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, group, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
	          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selector(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_select(selector, this);
	    };
	  }
	  d3_selectionPrototype.selectAll = function(selector) {
	    var subgroups = [], subgroup, node;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
	          subgroup.parentNode = node;
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selectorAll(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_selectAll(selector, this);
	    };
	  }
	  var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
	  var d3_nsPrefix = {
	    svg: "http://www.w3.org/2000/svg",
	    xhtml: d3_nsXhtml,
	    xlink: "http://www.w3.org/1999/xlink",
	    xml: "http://www.w3.org/XML/1998/namespace",
	    xmlns: "http://www.w3.org/2000/xmlns/"
	  };
	  d3.ns = {
	    prefix: d3_nsPrefix,
	    qualify: function(name) {
	      var i = name.indexOf(":"), prefix = name;
	      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
	      return d3_nsPrefix.hasOwnProperty(prefix) ? {
	        space: d3_nsPrefix[prefix],
	        local: name
	      } : name;
	    }
	  };
	  d3_selectionPrototype.attr = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node();
	        name = d3.ns.qualify(name);
	        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
	      }
	      for (value in name) this.each(d3_selection_attr(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_attr(name, value));
	  };
	  function d3_selection_attr(name, value) {
	    name = d3.ns.qualify(name);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrConstant() {
	      this.setAttribute(name, value);
	    }
	    function attrConstantNS() {
	      this.setAttributeNS(name.space, name.local, value);
	    }
	    function attrFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
	    }
	    function attrFunctionNS() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
	    }
	    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
	  }
	  function d3_collapse(s) {
	    return s.trim().replace(/\s+/g, " ");
	  }
	  d3_selectionPrototype.classed = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
	        if (value = node.classList) {
	          while (++i < n) if (!value.contains(name[i])) return false;
	        } else {
	          value = node.getAttribute("class");
	          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
	        }
	        return true;
	      }
	      for (value in name) this.each(d3_selection_classed(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_classed(name, value));
	  };
	  function d3_selection_classedRe(name) {
	    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
	  }
	  function d3_selection_classes(name) {
	    return (name + "").trim().split(/^|\s+/);
	  }
	  function d3_selection_classed(name, value) {
	    name = d3_selection_classes(name).map(d3_selection_classedName);
	    var n = name.length;
	    function classedConstant() {
	      var i = -1;
	      while (++i < n) name[i](this, value);
	    }
	    function classedFunction() {
	      var i = -1, x = value.apply(this, arguments);
	      while (++i < n) name[i](this, x);
	    }
	    return typeof value === "function" ? classedFunction : classedConstant;
	  }
	  function d3_selection_classedName(name) {
	    var re = d3_selection_classedRe(name);
	    return function(node, value) {
	      if (c = node.classList) return value ? c.add(name) : c.remove(name);
	      var c = node.getAttribute("class") || "";
	      if (value) {
	        re.lastIndex = 0;
	        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
	      } else {
	        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
	      }
	    };
	  }
	  d3_selectionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
	        return this;
	      }
	      if (n < 2) {
	        var node = this.node();
	        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
	      }
	      priority = "";
	    }
	    return this.each(d3_selection_style(name, value, priority));
	  };
	  function d3_selection_style(name, value, priority) {
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleConstant() {
	      this.style.setProperty(name, value, priority);
	    }
	    function styleFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
	    }
	    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
	  }
	  d3_selectionPrototype.property = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") return this.node()[name];
	      for (value in name) this.each(d3_selection_property(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_property(name, value));
	  };
	  function d3_selection_property(name, value) {
	    function propertyNull() {
	      delete this[name];
	    }
	    function propertyConstant() {
	      this[name] = value;
	    }
	    function propertyFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) delete this[name]; else this[name] = x;
	    }
	    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
	  }
	  d3_selectionPrototype.text = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.textContent = v == null ? "" : v;
	    } : value == null ? function() {
	      this.textContent = "";
	    } : function() {
	      this.textContent = value;
	    }) : this.node().textContent;
	  };
	  d3_selectionPrototype.html = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.innerHTML = v == null ? "" : v;
	    } : value == null ? function() {
	      this.innerHTML = "";
	    } : function() {
	      this.innerHTML = value;
	    }) : this.node().innerHTML;
	  };
	  d3_selectionPrototype.append = function(name) {
	    name = d3_selection_creator(name);
	    return this.select(function() {
	      return this.appendChild(name.apply(this, arguments));
	    });
	  };
	  function d3_selection_creator(name) {
	    function create() {
	      var document = this.ownerDocument, namespace = this.namespaceURI;
	      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
	    }
	    function createNS() {
	      return this.ownerDocument.createElementNS(name.space, name.local);
	    }
	    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
	  }
	  d3_selectionPrototype.insert = function(name, before) {
	    name = d3_selection_creator(name);
	    before = d3_selection_selector(before);
	    return this.select(function() {
	      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
	    });
	  };
	  d3_selectionPrototype.remove = function() {
	    return this.each(d3_selectionRemove);
	  };
	  function d3_selectionRemove() {
	    var parent = this.parentNode;
	    if (parent) parent.removeChild(this);
	  }
	  d3_selectionPrototype.data = function(value, key) {
	    var i = -1, n = this.length, group, node;
	    if (!arguments.length) {
	      value = new Array(n = (group = this[0]).length);
	      while (++i < n) {
	        if (node = group[i]) {
	          value[i] = node.__data__;
	        }
	      }
	      return value;
	    }
	    function bind(group, groupData) {
	      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
	      if (key) {
	        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
	        for (i = -1; ++i < n; ) {
	          if (node = group[i]) {
	            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
	              exitNodes[i] = node;
	            } else {
	              nodeByKeyValue.set(keyValue, node);
	            }
	            keyValues[i] = keyValue;
	          }
	        }
	        for (i = -1; ++i < m; ) {
	          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          } else if (node !== true) {
	            updateNodes[i] = node;
	            node.__data__ = nodeData;
	          }
	          nodeByKeyValue.set(keyValue, true);
	        }
	        for (i = -1; ++i < n; ) {
	          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
	            exitNodes[i] = group[i];
	          }
	        }
	      } else {
	        for (i = -1; ++i < n0; ) {
	          node = group[i];
	          nodeData = groupData[i];
	          if (node) {
	            node.__data__ = nodeData;
	            updateNodes[i] = node;
	          } else {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          }
	        }
	        for (;i < m; ++i) {
	          enterNodes[i] = d3_selection_dataNode(groupData[i]);
	        }
	        for (;i < n; ++i) {
	          exitNodes[i] = group[i];
	        }
	      }
	      enterNodes.update = updateNodes;
	      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
	      enter.push(enterNodes);
	      update.push(updateNodes);
	      exit.push(exitNodes);
	    }
	    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
	    if (typeof value === "function") {
	      while (++i < n) {
	        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
	      }
	    } else {
	      while (++i < n) {
	        bind(group = this[i], value);
	      }
	    }
	    update.enter = function() {
	      return enter;
	    };
	    update.exit = function() {
	      return exit;
	    };
	    return update;
	  };
	  function d3_selection_dataNode(data) {
	    return {
	      __data__: data
	    };
	  }
	  d3_selectionPrototype.datum = function(value) {
	    return arguments.length ? this.property("__data__", value) : this.property("__data__");
	  };
	  d3_selectionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_filter(selector) {
	    return function() {
	      return d3_selectMatches(this, selector);
	    };
	  }
	  d3_selectionPrototype.order = function() {
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
	        if (node = group[i]) {
	          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
	          next = node;
	        }
	      }
	    }
	    return this;
	  };
	  d3_selectionPrototype.sort = function(comparator) {
	    comparator = d3_selection_sortComparator.apply(this, arguments);
	    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
	    return this.order();
	  };
	  function d3_selection_sortComparator(comparator) {
	    if (!arguments.length) comparator = d3_ascending;
	    return function(a, b) {
	      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
	    };
	  }
	  d3_selectionPrototype.each = function(callback) {
	    return d3_selection_each(this, function(node, i, j) {
	      callback.call(node, node.__data__, i, j);
	    });
	  };
	  function d3_selection_each(groups, callback) {
	    for (var j = 0, m = groups.length; j < m; j++) {
	      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
	        if (node = group[i]) callback(node, i, j);
	      }
	    }
	    return groups;
	  }
	  d3_selectionPrototype.call = function(callback) {
	    var args = d3_array(arguments);
	    callback.apply(args[0] = this, args);
	    return this;
	  };
	  d3_selectionPrototype.empty = function() {
	    return !this.node();
	  };
	  d3_selectionPrototype.node = function() {
	    for (var j = 0, m = this.length; j < m; j++) {
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        var node = group[i];
	        if (node) return node;
	      }
	    }
	    return null;
	  };
	  d3_selectionPrototype.size = function() {
	    var n = 0;
	    d3_selection_each(this, function() {
	      ++n;
	    });
	    return n;
	  };
	  function d3_selection_enter(selection) {
	    d3_subclass(selection, d3_selection_enterPrototype);
	    return selection;
	  }
	  var d3_selection_enterPrototype = [];
	  d3.selection.enter = d3_selection_enter;
	  d3.selection.enter.prototype = d3_selection_enterPrototype;
	  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
	  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
	  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
	  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
	  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
	  d3_selection_enterPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, upgroup, group, node;
	    for (var j = -1, m = this.length; ++j < m; ) {
	      upgroup = (group = this[j]).update;
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = group.parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
	          subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  d3_selection_enterPrototype.insert = function(name, before) {
	    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
	    return d3_selectionPrototype.insert.call(this, name, before);
	  };
	  function d3_selection_enterInsertBefore(enter) {
	    var i0, j0;
	    return function(d, i, j) {
	      var group = enter[j].update, n = group.length, node;
	      if (j != j0) j0 = j, i0 = 0;
	      if (i >= i0) i0 = i + 1;
	      while (!(node = group[i0]) && ++i0 < n) ;
	      return node;
	    };
	  }
	  d3.select = function(node) {
	    var group;
	    if (typeof node === "string") {
	      group = [ d3_select(node, d3_document) ];
	      group.parentNode = d3_document.documentElement;
	    } else {
	      group = [ node ];
	      group.parentNode = d3_documentElement(node);
	    }
	    return d3_selection([ group ]);
	  };
	  d3.selectAll = function(nodes) {
	    var group;
	    if (typeof nodes === "string") {
	      group = d3_array(d3_selectAll(nodes, d3_document));
	      group.parentNode = d3_document.documentElement;
	    } else {
	      group = d3_array(nodes);
	      group.parentNode = null;
	    }
	    return d3_selection([ group ]);
	  };
	  d3_selectionPrototype.on = function(type, listener, capture) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof type !== "string") {
	        if (n < 2) listener = false;
	        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
	        return this;
	      }
	      if (n < 2) return (n = this.node()["__on" + type]) && n._;
	      capture = false;
	    }
	    return this.each(d3_selection_on(type, listener, capture));
	  };
	  function d3_selection_on(type, listener, capture) {
	    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
	    if (i > 0) type = type.slice(0, i);
	    var filter = d3_selection_onFilters.get(type);
	    if (filter) type = filter, wrap = d3_selection_onFilter;
	    function onRemove() {
	      var l = this[name];
	      if (l) {
	        this.removeEventListener(type, l, l.$);
	        delete this[name];
	      }
	    }
	    function onAdd() {
	      var l = wrap(listener, d3_array(arguments));
	      onRemove.call(this);
	      this.addEventListener(type, this[name] = l, l.$ = capture);
	      l._ = listener;
	    }
	    function removeAll() {
	      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
	      for (var name in this) {
	        if (match = name.match(re)) {
	          var l = this[name];
	          this.removeEventListener(match[1], l, l.$);
	          delete this[name];
	        }
	      }
	    }
	    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
	  }
	  var d3_selection_onFilters = d3.map({
	    mouseenter: "mouseover",
	    mouseleave: "mouseout"
	  });
	  if (d3_document) {
	    d3_selection_onFilters.forEach(function(k) {
	      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
	    });
	  }
	  function d3_selection_onListener(listener, argumentz) {
	    return function(e) {
	      var o = d3.event;
	      d3.event = e;
	      argumentz[0] = this.__data__;
	      try {
	        listener.apply(this, argumentz);
	      } finally {
	        d3.event = o;
	      }
	    };
	  }
	  function d3_selection_onFilter(listener, argumentz) {
	    var l = d3_selection_onListener(listener, argumentz);
	    return function(e) {
	      var target = this, related = e.relatedTarget;
	      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
	        l.call(target, e);
	      }
	    };
	  }
	  var d3_event_dragSelect, d3_event_dragId = 0;
	  function d3_event_dragSuppress(node) {
	    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
	    if (d3_event_dragSelect == null) {
	      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
	    }
	    if (d3_event_dragSelect) {
	      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
	      style[d3_event_dragSelect] = "none";
	    }
	    return function(suppressClick) {
	      w.on(name, null);
	      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
	      if (suppressClick) {
	        var off = function() {
	          w.on(click, null);
	        };
	        w.on(click, function() {
	          d3_eventPreventDefault();
	          off();
	        }, true);
	        setTimeout(off, 0);
	      }
	    };
	  }
	  d3.mouse = function(container) {
	    return d3_mousePoint(container, d3_eventSource());
	  };
	  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
	  function d3_mousePoint(container, e) {
	    if (e.changedTouches) e = e.changedTouches[0];
	    var svg = container.ownerSVGElement || container;
	    if (svg.createSVGPoint) {
	      var point = svg.createSVGPoint();
	      if (d3_mouse_bug44083 < 0) {
	        var window = d3_window(container);
	        if (window.scrollX || window.scrollY) {
	          svg = d3.select("body").append("svg").style({
	            position: "absolute",
	            top: 0,
	            left: 0,
	            margin: 0,
	            padding: 0,
	            border: "none"
	          }, "important");
	          var ctm = svg[0][0].getScreenCTM();
	          d3_mouse_bug44083 = !(ctm.f || ctm.e);
	          svg.remove();
	        }
	      }
	      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
	      point.y = e.clientY;
	      point = point.matrixTransform(container.getScreenCTM().inverse());
	      return [ point.x, point.y ];
	    }
	    var rect = container.getBoundingClientRect();
	    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
	  }
	  d3.touch = function(container, touches, identifier) {
	    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
	    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
	      if ((touch = touches[i]).identifier === identifier) {
	        return d3_mousePoint(container, touch);
	      }
	    }
	  };
	  d3.behavior.drag = function() {
	    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
	    function drag() {
	      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
	    }
	    function dragstart(id, position, subject, move, end) {
	      return function() {
	        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
	        if (origin) {
	          dragOffset = origin.apply(that, arguments);
	          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
	        } else {
	          dragOffset = [ 0, 0 ];
	        }
	        dispatch({
	          type: "dragstart"
	        });
	        function moved() {
	          var position1 = position(parent, dragId), dx, dy;
	          if (!position1) return;
	          dx = position1[0] - position0[0];
	          dy = position1[1] - position0[1];
	          dragged |= dx | dy;
	          position0 = position1;
	          dispatch({
	            type: "drag",
	            x: position1[0] + dragOffset[0],
	            y: position1[1] + dragOffset[1],
	            dx: dx,
	            dy: dy
	          });
	        }
	        function ended() {
	          if (!position(parent, dragId)) return;
	          dragSubject.on(move + dragName, null).on(end + dragName, null);
	          dragRestore(dragged);
	          dispatch({
	            type: "dragend"
	          });
	        }
	      };
	    }
	    drag.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return drag;
	    };
	    return d3.rebind(drag, event, "on");
	  };
	  function d3_behavior_dragTouchId() {
	    return d3.event.changedTouches[0].identifier;
	  }
	  d3.touches = function(container, touches) {
	    if (arguments.length < 2) touches = d3_eventSource().touches;
	    return touches ? d3_array(touches).map(function(touch) {
	      var point = d3_mousePoint(container, touch);
	      point.identifier = touch.identifier;
	      return point;
	    }) : [];
	  };
	  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
	  function d3_sgn(x) {
	    return x > 0 ? 1 : x < 0 ? -1 : 0;
	  }
	  function d3_cross2d(a, b, c) {
	    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
	  }
	  function d3_acos(x) {
	    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
	  }
	  function d3_asin(x) {
	    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
	  }
	  function d3_sinh(x) {
	    return ((x = Math.exp(x)) - 1 / x) / 2;
	  }
	  function d3_cosh(x) {
	    return ((x = Math.exp(x)) + 1 / x) / 2;
	  }
	  function d3_tanh(x) {
	    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
	  }
	  function d3_haversin(x) {
	    return (x = Math.sin(x / 2)) * x;
	  }
	  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
	  d3.interpolateZoom = function(p0, p1) {
	    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
	    if (d2 < ε2) {
	      S = Math.log(w1 / w0) / ρ;
	      i = function(t) {
	        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ];
	      };
	    } else {
	      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
	      S = (r1 - r0) / ρ;
	      i = function(t) {
	        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
	        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
	      };
	    }
	    i.duration = S * 1e3;
	    return i;
	  };
	  d3.behavior.zoom = function() {
	    var view = {
	      x: 0,
	      y: 0,
	      k: 1
	    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
	    if (!d3_behavior_zoomWheel) {
	      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
	      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	        return d3.event.wheelDelta;
	      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
	        return -d3.event.detail;
	      }, "MozMousePixelScroll");
	    }
	    function zoom(g) {
	      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
	    }
	    zoom.event = function(g) {
	      g.each(function() {
	        var dispatch = event.of(this, arguments), view1 = view;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.zoom", function() {
	            view = this.__chart__ || {
	              x: 0,
	              y: 0,
	              k: 1
	            };
	            zoomstarted(dispatch);
	          }).tween("zoom:zoom", function() {
	            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
	            return function(t) {
	              var l = i(t), k = dx / l[2];
	              this.__chart__ = view = {
	                x: cx - l[0] * k,
	                y: cy - l[1] * k,
	                k: k
	              };
	              zoomed(dispatch);
	            };
	          }).each("interrupt.zoom", function() {
	            zoomended(dispatch);
	          }).each("end.zoom", function() {
	            zoomended(dispatch);
	          });
	        } else {
	          this.__chart__ = view;
	          zoomstarted(dispatch);
	          zoomed(dispatch);
	          zoomended(dispatch);
	        }
	      });
	    };
	    zoom.translate = function(_) {
	      if (!arguments.length) return [ view.x, view.y ];
	      view = {
	        x: +_[0],
	        y: +_[1],
	        k: view.k
	      };
	      rescale();
	      return zoom;
	    };
	    zoom.scale = function(_) {
	      if (!arguments.length) return view.k;
	      view = {
	        x: view.x,
	        y: view.y,
	        k: null
	      };
	      scaleTo(+_);
	      rescale();
	      return zoom;
	    };
	    zoom.scaleExtent = function(_) {
	      if (!arguments.length) return scaleExtent;
	      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.center = function(_) {
	      if (!arguments.length) return center;
	      center = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.size = function(_) {
	      if (!arguments.length) return size;
	      size = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.duration = function(_) {
	      if (!arguments.length) return duration;
	      duration = +_;
	      return zoom;
	    };
	    zoom.x = function(z) {
	      if (!arguments.length) return x1;
	      x1 = z;
	      x0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    zoom.y = function(z) {
	      if (!arguments.length) return y1;
	      y1 = z;
	      y0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    function location(p) {
	      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
	    }
	    function point(l) {
	      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
	    }
	    function scaleTo(s) {
	      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
	    }
	    function translateTo(p, l) {
	      l = point(l);
	      view.x += p[0] - l[0];
	      view.y += p[1] - l[1];
	    }
	    function zoomTo(that, p, l, k) {
	      that.__chart__ = {
	        x: view.x,
	        y: view.y,
	        k: view.k
	      };
	      scaleTo(Math.pow(2, k));
	      translateTo(center0 = p, l);
	      that = d3.select(that);
	      if (duration > 0) that = that.transition().duration(duration);
	      that.call(zoom.event);
	    }
	    function rescale() {
	      if (x1) x1.domain(x0.range().map(function(x) {
	        return (x - view.x) / view.k;
	      }).map(x0.invert));
	      if (y1) y1.domain(y0.range().map(function(y) {
	        return (y - view.y) / view.k;
	      }).map(y0.invert));
	    }
	    function zoomstarted(dispatch) {
	      if (!zooming++) dispatch({
	        type: "zoomstart"
	      });
	    }
	    function zoomed(dispatch) {
	      rescale();
	      dispatch({
	        type: "zoom",
	        scale: view.k,
	        translate: [ view.x, view.y ]
	      });
	    }
	    function zoomended(dispatch) {
	      if (!--zooming) dispatch({
	        type: "zoomend"
	      }), center0 = null;
	    }
	    function mousedowned() {
	      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
	      d3_selection_interrupt.call(that);
	      zoomstarted(dispatch);
	      function moved() {
	        dragged = 1;
	        translateTo(d3.mouse(that), location0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        subject.on(mousemove, null).on(mouseup, null);
	        dragRestore(dragged);
	        zoomended(dispatch);
	      }
	    }
	    function touchstarted() {
	      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
	      started();
	      zoomstarted(dispatch);
	      subject.on(mousedown, null).on(touchstart, started);
	      function relocate() {
	        var touches = d3.touches(that);
	        scale0 = view.k;
	        touches.forEach(function(t) {
	          if (t.identifier in locations0) locations0[t.identifier] = location(t);
	        });
	        return touches;
	      }
	      function started() {
	        var target = d3.event.target;
	        d3.select(target).on(touchmove, moved).on(touchend, ended);
	        targets.push(target);
	        var changed = d3.event.changedTouches;
	        for (var i = 0, n = changed.length; i < n; ++i) {
	          locations0[changed[i].identifier] = null;
	        }
	        var touches = relocate(), now = Date.now();
	        if (touches.length === 1) {
	          if (now - touchtime < 500) {
	            var p = touches[0];
	            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
	            d3_eventPreventDefault();
	          }
	          touchtime = now;
	        } else if (touches.length > 1) {
	          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
	          distance0 = dx * dx + dy * dy;
	        }
	      }
	      function moved() {
	        var touches = d3.touches(that), p0, l0, p1, l1;
	        d3_selection_interrupt.call(that);
	        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
	          p1 = touches[i];
	          if (l1 = locations0[p1.identifier]) {
	            if (l0) break;
	            p0 = p1, l0 = l1;
	          }
	        }
	        if (l1) {
	          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
	          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
	          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
	          scaleTo(scale1 * scale0);
	        }
	        touchtime = null;
	        translateTo(p0, l0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        if (d3.event.touches.length) {
	          var changed = d3.event.changedTouches;
	          for (var i = 0, n = changed.length; i < n; ++i) {
	            delete locations0[changed[i].identifier];
	          }
	          for (var identifier in locations0) {
	            return void relocate();
	          }
	        }
	        d3.selectAll(targets).on(zoomName, null);
	        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
	        dragRestore();
	        zoomended(dispatch);
	      }
	    }
	    function mousewheeled() {
	      var dispatch = event.of(this, arguments);
	      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
	      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
	      mousewheelTimer = setTimeout(function() {
	        mousewheelTimer = null;
	        zoomended(dispatch);
	      }, 50);
	      d3_eventPreventDefault();
	      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
	      translateTo(center0, translate0);
	      zoomed(dispatch);
	    }
	    function dblclicked() {
	      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
	      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
	    }
	    return d3.rebind(zoom, event, "on");
	  };
	  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
	  d3.color = d3_color;
	  function d3_color() {}
	  d3_color.prototype.toString = function() {
	    return this.rgb() + "";
	  };
	  d3.hsl = d3_hsl;
	  function d3_hsl(h, s, l) {
	    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
	  }
	  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
	  d3_hslPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, this.l / k);
	  };
	  d3_hslPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, k * this.l);
	  };
	  d3_hslPrototype.rgb = function() {
	    return d3_hsl_rgb(this.h, this.s, this.l);
	  };
	  function d3_hsl_rgb(h, s, l) {
	    var m1, m2;
	    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
	    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
	    l = l < 0 ? 0 : l > 1 ? 1 : l;
	    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
	    m1 = 2 * l - m2;
	    function v(h) {
	      if (h > 360) h -= 360; else if (h < 0) h += 360;
	      if (h < 60) return m1 + (m2 - m1) * h / 60;
	      if (h < 180) return m2;
	      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
	      return m1;
	    }
	    function vv(h) {
	      return Math.round(v(h) * 255);
	    }
	    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
	  }
	  d3.hcl = d3_hcl;
	  function d3_hcl(h, c, l) {
	    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
	  }
	  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
	  d3_hclPrototype.brighter = function(k) {
	    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.darker = function(k) {
	    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.rgb = function() {
	    return d3_hcl_lab(this.h, this.c, this.l).rgb();
	  };
	  function d3_hcl_lab(h, c, l) {
	    if (isNaN(h)) h = 0;
	    if (isNaN(c)) c = 0;
	    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
	  }
	  d3.lab = d3_lab;
	  function d3_lab(l, a, b) {
	    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
	  }
	  var d3_lab_K = 18;
	  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
	  var d3_labPrototype = d3_lab.prototype = new d3_color();
	  d3_labPrototype.brighter = function(k) {
	    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.darker = function(k) {
	    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.rgb = function() {
	    return d3_lab_rgb(this.l, this.a, this.b);
	  };
	  function d3_lab_rgb(l, a, b) {
	    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
	    x = d3_lab_xyz(x) * d3_lab_X;
	    y = d3_lab_xyz(y) * d3_lab_Y;
	    z = d3_lab_xyz(z) * d3_lab_Z;
	    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
	  }
	  function d3_lab_hcl(l, a, b) {
	    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
	  }
	  function d3_lab_xyz(x) {
	    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
	  }
	  function d3_xyz_lab(x) {
	    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
	  }
	  function d3_xyz_rgb(r) {
	    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
	  }
	  d3.rgb = d3_rgb;
	  function d3_rgb(r, g, b) {
	    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
	  }
	  function d3_rgbNumber(value) {
	    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
	  }
	  function d3_rgbString(value) {
	    return d3_rgbNumber(value) + "";
	  }
	  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
	  d3_rgbPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    var r = this.r, g = this.g, b = this.b, i = 30;
	    if (!r && !g && !b) return new d3_rgb(i, i, i);
	    if (r && r < i) r = i;
	    if (g && g < i) g = i;
	    if (b && b < i) b = i;
	    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
	  };
	  d3_rgbPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_rgb(k * this.r, k * this.g, k * this.b);
	  };
	  d3_rgbPrototype.hsl = function() {
	    return d3_rgb_hsl(this.r, this.g, this.b);
	  };
	  d3_rgbPrototype.toString = function() {
	    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
	  };
	  function d3_rgb_hex(v) {
	    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
	  }
	  function d3_rgb_parse(format, rgb, hsl) {
	    var r = 0, g = 0, b = 0, m1, m2, color;
	    m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
	    if (m1) {
	      m2 = m1[2].split(",");
	      switch (m1[1]) {
	       case "hsl":
	        {
	          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
	        }

	       case "rgb":
	        {
	          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
	        }
	      }
	    }
	    if (color = d3_rgb_names.get(format)) {
	      return rgb(color.r, color.g, color.b);
	    }
	    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
	      if (format.length === 4) {
	        r = (color & 3840) >> 4;
	        r = r >> 4 | r;
	        g = color & 240;
	        g = g >> 4 | g;
	        b = color & 15;
	        b = b << 4 | b;
	      } else if (format.length === 7) {
	        r = (color & 16711680) >> 16;
	        g = (color & 65280) >> 8;
	        b = color & 255;
	      }
	    }
	    return rgb(r, g, b);
	  }
	  function d3_rgb_hsl(r, g, b) {
	    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
	    if (d) {
	      s = l < .5 ? d / (max + min) : d / (2 - max - min);
	      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
	      h *= 60;
	    } else {
	      h = NaN;
	      s = l > 0 && l < 1 ? 0 : h;
	    }
	    return new d3_hsl(h, s, l);
	  }
	  function d3_rgb_lab(r, g, b) {
	    r = d3_rgb_xyz(r);
	    g = d3_rgb_xyz(g);
	    b = d3_rgb_xyz(b);
	    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
	    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
	  }
	  function d3_rgb_xyz(r) {
	    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
	  }
	  function d3_rgb_parseNumber(c) {
	    var f = parseFloat(c);
	    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
	  }
	  var d3_rgb_names = d3.map({
	    aliceblue: 15792383,
	    antiquewhite: 16444375,
	    aqua: 65535,
	    aquamarine: 8388564,
	    azure: 15794175,
	    beige: 16119260,
	    bisque: 16770244,
	    black: 0,
	    blanchedalmond: 16772045,
	    blue: 255,
	    blueviolet: 9055202,
	    brown: 10824234,
	    burlywood: 14596231,
	    cadetblue: 6266528,
	    chartreuse: 8388352,
	    chocolate: 13789470,
	    coral: 16744272,
	    cornflowerblue: 6591981,
	    cornsilk: 16775388,
	    crimson: 14423100,
	    cyan: 65535,
	    darkblue: 139,
	    darkcyan: 35723,
	    darkgoldenrod: 12092939,
	    darkgray: 11119017,
	    darkgreen: 25600,
	    darkgrey: 11119017,
	    darkkhaki: 12433259,
	    darkmagenta: 9109643,
	    darkolivegreen: 5597999,
	    darkorange: 16747520,
	    darkorchid: 10040012,
	    darkred: 9109504,
	    darksalmon: 15308410,
	    darkseagreen: 9419919,
	    darkslateblue: 4734347,
	    darkslategray: 3100495,
	    darkslategrey: 3100495,
	    darkturquoise: 52945,
	    darkviolet: 9699539,
	    deeppink: 16716947,
	    deepskyblue: 49151,
	    dimgray: 6908265,
	    dimgrey: 6908265,
	    dodgerblue: 2003199,
	    firebrick: 11674146,
	    floralwhite: 16775920,
	    forestgreen: 2263842,
	    fuchsia: 16711935,
	    gainsboro: 14474460,
	    ghostwhite: 16316671,
	    gold: 16766720,
	    goldenrod: 14329120,
	    gray: 8421504,
	    green: 32768,
	    greenyellow: 11403055,
	    grey: 8421504,
	    honeydew: 15794160,
	    hotpink: 16738740,
	    indianred: 13458524,
	    indigo: 4915330,
	    ivory: 16777200,
	    khaki: 15787660,
	    lavender: 15132410,
	    lavenderblush: 16773365,
	    lawngreen: 8190976,
	    lemonchiffon: 16775885,
	    lightblue: 11393254,
	    lightcoral: 15761536,
	    lightcyan: 14745599,
	    lightgoldenrodyellow: 16448210,
	    lightgray: 13882323,
	    lightgreen: 9498256,
	    lightgrey: 13882323,
	    lightpink: 16758465,
	    lightsalmon: 16752762,
	    lightseagreen: 2142890,
	    lightskyblue: 8900346,
	    lightslategray: 7833753,
	    lightslategrey: 7833753,
	    lightsteelblue: 11584734,
	    lightyellow: 16777184,
	    lime: 65280,
	    limegreen: 3329330,
	    linen: 16445670,
	    magenta: 16711935,
	    maroon: 8388608,
	    mediumaquamarine: 6737322,
	    mediumblue: 205,
	    mediumorchid: 12211667,
	    mediumpurple: 9662683,
	    mediumseagreen: 3978097,
	    mediumslateblue: 8087790,
	    mediumspringgreen: 64154,
	    mediumturquoise: 4772300,
	    mediumvioletred: 13047173,
	    midnightblue: 1644912,
	    mintcream: 16121850,
	    mistyrose: 16770273,
	    moccasin: 16770229,
	    navajowhite: 16768685,
	    navy: 128,
	    oldlace: 16643558,
	    olive: 8421376,
	    olivedrab: 7048739,
	    orange: 16753920,
	    orangered: 16729344,
	    orchid: 14315734,
	    palegoldenrod: 15657130,
	    palegreen: 10025880,
	    paleturquoise: 11529966,
	    palevioletred: 14381203,
	    papayawhip: 16773077,
	    peachpuff: 16767673,
	    peru: 13468991,
	    pink: 16761035,
	    plum: 14524637,
	    powderblue: 11591910,
	    purple: 8388736,
	    rebeccapurple: 6697881,
	    red: 16711680,
	    rosybrown: 12357519,
	    royalblue: 4286945,
	    saddlebrown: 9127187,
	    salmon: 16416882,
	    sandybrown: 16032864,
	    seagreen: 3050327,
	    seashell: 16774638,
	    sienna: 10506797,
	    silver: 12632256,
	    skyblue: 8900331,
	    slateblue: 6970061,
	    slategray: 7372944,
	    slategrey: 7372944,
	    snow: 16775930,
	    springgreen: 65407,
	    steelblue: 4620980,
	    tan: 13808780,
	    teal: 32896,
	    thistle: 14204888,
	    tomato: 16737095,
	    turquoise: 4251856,
	    violet: 15631086,
	    wheat: 16113331,
	    white: 16777215,
	    whitesmoke: 16119285,
	    yellow: 16776960,
	    yellowgreen: 10145074
	  });
	  d3_rgb_names.forEach(function(key, value) {
	    d3_rgb_names.set(key, d3_rgbNumber(value));
	  });
	  function d3_functor(v) {
	    return typeof v === "function" ? v : function() {
	      return v;
	    };
	  }
	  d3.functor = d3_functor;
	  d3.xhr = d3_xhrType(d3_identity);
	  function d3_xhrType(response) {
	    return function(url, mimeType, callback) {
	      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
	      mimeType = null;
	      return d3_xhr(url, mimeType, response, callback);
	    };
	  }
	  function d3_xhr(url, mimeType, response, callback) {
	    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
	    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
	    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
	      request.readyState > 3 && respond();
	    };
	    function respond() {
	      var status = request.status, result;
	      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
	        try {
	          result = response.call(xhr, request);
	        } catch (e) {
	          dispatch.error.call(xhr, e);
	          return;
	        }
	        dispatch.load.call(xhr, result);
	      } else {
	        dispatch.error.call(xhr, request);
	      }
	    }
	    request.onprogress = function(event) {
	      var o = d3.event;
	      d3.event = event;
	      try {
	        dispatch.progress.call(xhr, request);
	      } finally {
	        d3.event = o;
	      }
	    };
	    xhr.header = function(name, value) {
	      name = (name + "").toLowerCase();
	      if (arguments.length < 2) return headers[name];
	      if (value == null) delete headers[name]; else headers[name] = value + "";
	      return xhr;
	    };
	    xhr.mimeType = function(value) {
	      if (!arguments.length) return mimeType;
	      mimeType = value == null ? null : value + "";
	      return xhr;
	    };
	    xhr.responseType = function(value) {
	      if (!arguments.length) return responseType;
	      responseType = value;
	      return xhr;
	    };
	    xhr.response = function(value) {
	      response = value;
	      return xhr;
	    };
	    [ "get", "post" ].forEach(function(method) {
	      xhr[method] = function() {
	        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
	      };
	    });
	    xhr.send = function(method, data, callback) {
	      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
	      request.open(method, url, true);
	      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
	      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
	      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
	      if (responseType != null) request.responseType = responseType;
	      if (callback != null) xhr.on("error", callback).on("load", function(request) {
	        callback(null, request);
	      });
	      dispatch.beforesend.call(xhr, request);
	      request.send(data == null ? null : data);
	      return xhr;
	    };
	    xhr.abort = function() {
	      request.abort();
	      return xhr;
	    };
	    d3.rebind(xhr, dispatch, "on");
	    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
	  }
	  function d3_xhr_fixCallback(callback) {
	    return callback.length === 1 ? function(error, request) {
	      callback(error == null ? request : null);
	    } : callback;
	  }
	  function d3_xhrHasResponse(request) {
	    var type = request.responseType;
	    return type && type !== "text" ? request.response : request.responseText;
	  }
	  d3.dsv = function(delimiter, mimeType) {
	    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
	    function dsv(url, row, callback) {
	      if (arguments.length < 3) callback = row, row = null;
	      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
	      xhr.row = function(_) {
	        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
	      };
	      return xhr;
	    }
	    function response(request) {
	      return dsv.parse(request.responseText);
	    }
	    function typedResponse(f) {
	      return function(request) {
	        return dsv.parse(request.responseText, f);
	      };
	    }
	    dsv.parse = function(text, f) {
	      var o;
	      return dsv.parseRows(text, function(row, i) {
	        if (o) return o(row, i - 1);
	        var a = new Function("d", "return {" + row.map(function(name, i) {
	          return JSON.stringify(name) + ": d[" + i + "]";
	        }).join(",") + "}");
	        o = f ? function(row, i) {
	          return f(a(row), i);
	        } : a;
	      });
	    };
	    dsv.parseRows = function(text, f) {
	      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
	      function token() {
	        if (I >= N) return EOF;
	        if (eol) return eol = false, EOL;
	        var j = I;
	        if (text.charCodeAt(j) === 34) {
	          var i = j;
	          while (i++ < N) {
	            if (text.charCodeAt(i) === 34) {
	              if (text.charCodeAt(i + 1) !== 34) break;
	              ++i;
	            }
	          }
	          I = i + 2;
	          var c = text.charCodeAt(i + 1);
	          if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(i + 2) === 10) ++I;
	          } else if (c === 10) {
	            eol = true;
	          }
	          return text.slice(j + 1, i).replace(/""/g, '"');
	        }
	        while (I < N) {
	          var c = text.charCodeAt(I++), k = 1;
	          if (c === 10) eol = true; else if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(I) === 10) ++I, ++k;
	          } else if (c !== delimiterCode) continue;
	          return text.slice(j, I - k);
	        }
	        return text.slice(j);
	      }
	      while ((t = token()) !== EOF) {
	        var a = [];
	        while (t !== EOL && t !== EOF) {
	          a.push(t);
	          t = token();
	        }
	        if (f && (a = f(a, n++)) == null) continue;
	        rows.push(a);
	      }
	      return rows;
	    };
	    dsv.format = function(rows) {
	      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
	      var fieldSet = new d3_Set(), fields = [];
	      rows.forEach(function(row) {
	        for (var field in row) {
	          if (!fieldSet.has(field)) {
	            fields.push(fieldSet.add(field));
	          }
	        }
	      });
	      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
	        return fields.map(function(field) {
	          return formatValue(row[field]);
	        }).join(delimiter);
	      })).join("\n");
	    };
	    dsv.formatRows = function(rows) {
	      return rows.map(formatRow).join("\n");
	    };
	    function formatRow(row) {
	      return row.map(formatValue).join(delimiter);
	    }
	    function formatValue(text) {
	      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
	    }
	    return dsv;
	  };
	  d3.csv = d3.dsv(",", "text/csv");
	  d3.tsv = d3.dsv("	", "text/tab-separated-values");
	  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
	    setTimeout(callback, 17);
	  };
	  d3.timer = function() {
	    d3_timer.apply(this, arguments);
	  };
	  function d3_timer(callback, delay, then) {
	    var n = arguments.length;
	    if (n < 2) delay = 0;
	    if (n < 3) then = Date.now();
	    var time = then + delay, timer = {
	      c: callback,
	      t: time,
	      n: null
	    };
	    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
	    d3_timer_queueTail = timer;
	    if (!d3_timer_interval) {
	      d3_timer_timeout = clearTimeout(d3_timer_timeout);
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	    return timer;
	  }
	  function d3_timer_step() {
	    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
	    if (delay > 24) {
	      if (isFinite(delay)) {
	        clearTimeout(d3_timer_timeout);
	        d3_timer_timeout = setTimeout(d3_timer_step, delay);
	      }
	      d3_timer_interval = 0;
	    } else {
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	  }
	  d3.timer.flush = function() {
	    d3_timer_mark();
	    d3_timer_sweep();
	  };
	  function d3_timer_mark() {
	    var now = Date.now(), timer = d3_timer_queueHead;
	    while (timer) {
	      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
	      timer = timer.n;
	    }
	    return now;
	  }
	  function d3_timer_sweep() {
	    var t0, t1 = d3_timer_queueHead, time = Infinity;
	    while (t1) {
	      if (t1.c) {
	        if (t1.t < time) time = t1.t;
	        t1 = (t0 = t1).n;
	      } else {
	        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
	      }
	    }
	    d3_timer_queueTail = t0;
	    return time;
	  }
	  function d3_format_precision(x, p) {
	    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
	  }
	  d3.round = function(x, n) {
	    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
	  };
	  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
	  d3.formatPrefix = function(value, precision) {
	    var i = 0;
	    if (value = +value) {
	      if (value < 0) value *= -1;
	      if (precision) value = d3.round(value, d3_format_precision(value, precision));
	      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
	      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
	    }
	    return d3_formatPrefixes[8 + i / 3];
	  };
	  function d3_formatPrefix(d, i) {
	    var k = Math.pow(10, abs(8 - i) * 3);
	    return {
	      scale: i > 8 ? function(d) {
	        return d / k;
	      } : function(d) {
	        return d * k;
	      },
	      symbol: d
	    };
	  }
	  function d3_locale_numberFormat(locale) {
	    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
	      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
	      while (i > 0 && g > 0) {
	        if (length + g + 1 > width) g = Math.max(1, width - length);
	        t.push(value.substring(i -= g, i + g));
	        if ((length += g + 1) > width) break;
	        g = locale_grouping[j = (j + 1) % locale_grouping.length];
	      }
	      return t.reverse().join(locale_thousands);
	    } : d3_identity;
	    return function(specifier) {
	      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
	      if (precision) precision = +precision.substring(1);
	      if (zfill || fill === "0" && align === "=") {
	        zfill = fill = "0";
	        align = "=";
	      }
	      switch (type) {
	       case "n":
	        comma = true;
	        type = "g";
	        break;

	       case "%":
	        scale = 100;
	        suffix = "%";
	        type = "f";
	        break;

	       case "p":
	        scale = 100;
	        suffix = "%";
	        type = "r";
	        break;

	       case "b":
	       case "o":
	       case "x":
	       case "X":
	        if (symbol === "#") prefix = "0" + type.toLowerCase();

	       case "c":
	        exponent = false;

	       case "d":
	        integer = true;
	        precision = 0;
	        break;

	       case "s":
	        scale = -1;
	        type = "r";
	        break;
	      }
	      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
	      if (type == "r" && !precision) type = "g";
	      if (precision != null) {
	        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
	      }
	      type = d3_format_types.get(type) || d3_format_typeDefault;
	      var zcomma = zfill && comma;
	      return function(value) {
	        var fullSuffix = suffix;
	        if (integer && value % 1) return "";
	        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
	        if (scale < 0) {
	          var unit = d3.formatPrefix(value, precision);
	          value = unit.scale(value);
	          fullSuffix = unit.symbol + suffix;
	        } else {
	          value *= scale;
	        }
	        value = type(value, precision);
	        var i = value.lastIndexOf("."), before, after;
	        if (i < 0) {
	          var j = exponent ? value.lastIndexOf("e") : -1;
	          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
	        } else {
	          before = value.substring(0, i);
	          after = locale_decimal + value.substring(i + 1);
	        }
	        if (!zfill && comma) before = formatGroup(before, Infinity);
	        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
	        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
	        negative += prefix;
	        value = before + after;
	        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
	      };
	    };
	  }
	  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
	  var d3_format_types = d3.map({
	    b: function(x) {
	      return x.toString(2);
	    },
	    c: function(x) {
	      return String.fromCharCode(x);
	    },
	    o: function(x) {
	      return x.toString(8);
	    },
	    x: function(x) {
	      return x.toString(16);
	    },
	    X: function(x) {
	      return x.toString(16).toUpperCase();
	    },
	    g: function(x, p) {
	      return x.toPrecision(p);
	    },
	    e: function(x, p) {
	      return x.toExponential(p);
	    },
	    f: function(x, p) {
	      return x.toFixed(p);
	    },
	    r: function(x, p) {
	      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
	    }
	  });
	  function d3_format_typeDefault(x) {
	    return x + "";
	  }
	  var d3_time = d3.time = {}, d3_date = Date;
	  function d3_date_utc() {
	    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
	  }
	  d3_date_utc.prototype = {
	    getDate: function() {
	      return this._.getUTCDate();
	    },
	    getDay: function() {
	      return this._.getUTCDay();
	    },
	    getFullYear: function() {
	      return this._.getUTCFullYear();
	    },
	    getHours: function() {
	      return this._.getUTCHours();
	    },
	    getMilliseconds: function() {
	      return this._.getUTCMilliseconds();
	    },
	    getMinutes: function() {
	      return this._.getUTCMinutes();
	    },
	    getMonth: function() {
	      return this._.getUTCMonth();
	    },
	    getSeconds: function() {
	      return this._.getUTCSeconds();
	    },
	    getTime: function() {
	      return this._.getTime();
	    },
	    getTimezoneOffset: function() {
	      return 0;
	    },
	    valueOf: function() {
	      return this._.valueOf();
	    },
	    setDate: function() {
	      d3_time_prototype.setUTCDate.apply(this._, arguments);
	    },
	    setDay: function() {
	      d3_time_prototype.setUTCDay.apply(this._, arguments);
	    },
	    setFullYear: function() {
	      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
	    },
	    setHours: function() {
	      d3_time_prototype.setUTCHours.apply(this._, arguments);
	    },
	    setMilliseconds: function() {
	      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
	    },
	    setMinutes: function() {
	      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
	    },
	    setMonth: function() {
	      d3_time_prototype.setUTCMonth.apply(this._, arguments);
	    },
	    setSeconds: function() {
	      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
	    },
	    setTime: function() {
	      d3_time_prototype.setTime.apply(this._, arguments);
	    }
	  };
	  var d3_time_prototype = Date.prototype;
	  function d3_time_interval(local, step, number) {
	    function round(date) {
	      var d0 = local(date), d1 = offset(d0, 1);
	      return date - d0 < d1 - date ? d0 : d1;
	    }
	    function ceil(date) {
	      step(date = local(new d3_date(date - 1)), 1);
	      return date;
	    }
	    function offset(date, k) {
	      step(date = new d3_date(+date), k);
	      return date;
	    }
	    function range(t0, t1, dt) {
	      var time = ceil(t0), times = [];
	      if (dt > 1) {
	        while (time < t1) {
	          if (!(number(time) % dt)) times.push(new Date(+time));
	          step(time, 1);
	        }
	      } else {
	        while (time < t1) times.push(new Date(+time)), step(time, 1);
	      }
	      return times;
	    }
	    function range_utc(t0, t1, dt) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = t0;
	        return range(utc, t1, dt);
	      } finally {
	        d3_date = Date;
	      }
	    }
	    local.floor = local;
	    local.round = round;
	    local.ceil = ceil;
	    local.offset = offset;
	    local.range = range;
	    var utc = local.utc = d3_time_interval_utc(local);
	    utc.floor = utc;
	    utc.round = d3_time_interval_utc(round);
	    utc.ceil = d3_time_interval_utc(ceil);
	    utc.offset = d3_time_interval_utc(offset);
	    utc.range = range_utc;
	    return local;
	  }
	  function d3_time_interval_utc(method) {
	    return function(date, k) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = date;
	        return method(utc, k)._;
	      } finally {
	        d3_date = Date;
	      }
	    };
	  }
	  d3_time.year = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setMonth(0, 1);
	    return date;
	  }, function(date, offset) {
	    date.setFullYear(date.getFullYear() + offset);
	  }, function(date) {
	    return date.getFullYear();
	  });
	  d3_time.years = d3_time.year.range;
	  d3_time.years.utc = d3_time.year.utc.range;
	  d3_time.day = d3_time_interval(function(date) {
	    var day = new d3_date(2e3, 0);
	    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
	    return day;
	  }, function(date, offset) {
	    date.setDate(date.getDate() + offset);
	  }, function(date) {
	    return date.getDate() - 1;
	  });
	  d3_time.days = d3_time.day.range;
	  d3_time.days.utc = d3_time.day.utc.range;
	  d3_time.dayOfYear = function(date) {
	    var year = d3_time.year(date);
	    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
	  };
	  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
	    i = 7 - i;
	    var interval = d3_time[day] = d3_time_interval(function(date) {
	      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
	      return date;
	    }, function(date, offset) {
	      date.setDate(date.getDate() + Math.floor(offset) * 7);
	    }, function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
	    });
	    d3_time[day + "s"] = interval.range;
	    d3_time[day + "s"].utc = interval.utc.range;
	    d3_time[day + "OfYear"] = function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
	    };
	  });
	  d3_time.week = d3_time.sunday;
	  d3_time.weeks = d3_time.sunday.range;
	  d3_time.weeks.utc = d3_time.sunday.utc.range;
	  d3_time.weekOfYear = d3_time.sundayOfYear;
	  function d3_locale_timeFormat(locale) {
	    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
	    function d3_time_format(template) {
	      var n = template.length;
	      function format(date) {
	        var string = [], i = -1, j = 0, c, p, f;
	        while (++i < n) {
	          if (template.charCodeAt(i) === 37) {
	            string.push(template.slice(j, i));
	            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
	            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
	            string.push(c);
	            j = i + 1;
	          }
	        }
	        string.push(template.slice(j, i));
	        return string.join("");
	      }
	      format.parse = function(string) {
	        var d = {
	          y: 1900,
	          m: 0,
	          d: 1,
	          H: 0,
	          M: 0,
	          S: 0,
	          L: 0,
	          Z: null
	        }, i = d3_time_parse(d, template, string, 0);
	        if (i != string.length) return null;
	        if ("p" in d) d.H = d.H % 12 + d.p * 12;
	        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
	        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) {
	          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
	          date.setFullYear(d.y, 0, 1);
	          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
	        } else date.setFullYear(d.y, d.m, d.d);
	        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
	        return localZ ? date._ : date;
	      };
	      format.toString = function() {
	        return template;
	      };
	      return format;
	    }
	    function d3_time_parse(date, template, string, j) {
	      var c, p, t, i = 0, n = template.length, m = string.length;
	      while (i < n) {
	        if (j >= m) return -1;
	        c = template.charCodeAt(i++);
	        if (c === 37) {
	          t = template.charAt(i++);
	          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
	          if (!p || (j = p(date, string, j)) < 0) return -1;
	        } else if (c != string.charCodeAt(j++)) {
	          return -1;
	        }
	      }
	      return j;
	    }
	    d3_time_format.utc = function(template) {
	      var local = d3_time_format(template);
	      function format(date) {
	        try {
	          d3_date = d3_date_utc;
	          var utc = new d3_date();
	          utc._ = date;
	          return local(utc);
	        } finally {
	          d3_date = Date;
	        }
	      }
	      format.parse = function(string) {
	        try {
	          d3_date = d3_date_utc;
	          var date = local.parse(string);
	          return date && date._;
	        } finally {
	          d3_date = Date;
	        }
	      };
	      format.toString = local.toString;
	      return format;
	    };
	    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
	    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
	    locale_periods.forEach(function(p, i) {
	      d3_time_periodLookup.set(p.toLowerCase(), i);
	    });
	    var d3_time_formats = {
	      a: function(d) {
	        return locale_shortDays[d.getDay()];
	      },
	      A: function(d) {
	        return locale_days[d.getDay()];
	      },
	      b: function(d) {
	        return locale_shortMonths[d.getMonth()];
	      },
	      B: function(d) {
	        return locale_months[d.getMonth()];
	      },
	      c: d3_time_format(locale_dateTime),
	      d: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      e: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      H: function(d, p) {
	        return d3_time_formatPad(d.getHours(), p, 2);
	      },
	      I: function(d, p) {
	        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
	      },
	      j: function(d, p) {
	        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
	      },
	      L: function(d, p) {
	        return d3_time_formatPad(d.getMilliseconds(), p, 3);
	      },
	      m: function(d, p) {
	        return d3_time_formatPad(d.getMonth() + 1, p, 2);
	      },
	      M: function(d, p) {
	        return d3_time_formatPad(d.getMinutes(), p, 2);
	      },
	      p: function(d) {
	        return locale_periods[+(d.getHours() >= 12)];
	      },
	      S: function(d, p) {
	        return d3_time_formatPad(d.getSeconds(), p, 2);
	      },
	      U: function(d, p) {
	        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
	      },
	      w: function(d) {
	        return d.getDay();
	      },
	      W: function(d, p) {
	        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
	      },
	      x: d3_time_format(locale_date),
	      X: d3_time_format(locale_time),
	      y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
	      },
	      Y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
	      },
	      Z: d3_time_zone,
	      "%": function() {
	        return "%";
	      }
	    };
	    var d3_time_parsers = {
	      a: d3_time_parseWeekdayAbbrev,
	      A: d3_time_parseWeekday,
	      b: d3_time_parseMonthAbbrev,
	      B: d3_time_parseMonth,
	      c: d3_time_parseLocaleFull,
	      d: d3_time_parseDay,
	      e: d3_time_parseDay,
	      H: d3_time_parseHour24,
	      I: d3_time_parseHour24,
	      j: d3_time_parseDayOfYear,
	      L: d3_time_parseMilliseconds,
	      m: d3_time_parseMonthNumber,
	      M: d3_time_parseMinutes,
	      p: d3_time_parseAmPm,
	      S: d3_time_parseSeconds,
	      U: d3_time_parseWeekNumberSunday,
	      w: d3_time_parseWeekdayNumber,
	      W: d3_time_parseWeekNumberMonday,
	      x: d3_time_parseLocaleDate,
	      X: d3_time_parseLocaleTime,
	      y: d3_time_parseYear,
	      Y: d3_time_parseFullYear,
	      Z: d3_time_parseZone,
	      "%": d3_time_parseLiteralPercent
	    };
	    function d3_time_parseWeekdayAbbrev(date, string, i) {
	      d3_time_dayAbbrevRe.lastIndex = 0;
	      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseWeekday(date, string, i) {
	      d3_time_dayRe.lastIndex = 0;
	      var n = d3_time_dayRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonthAbbrev(date, string, i) {
	      d3_time_monthAbbrevRe.lastIndex = 0;
	      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonth(date, string, i) {
	      d3_time_monthRe.lastIndex = 0;
	      var n = d3_time_monthRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseLocaleFull(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
	    }
	    function d3_time_parseLocaleDate(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
	    }
	    function d3_time_parseLocaleTime(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
	    }
	    function d3_time_parseAmPm(date, string, i) {
	      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
	      return n == null ? -1 : (date.p = n, i);
	    }
	    return d3_time_format;
	  }
	  var d3_time_formatPads = {
	    "-": "",
	    _: " ",
	    "0": "0"
	  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
	  function d3_time_formatPad(value, fill, width) {
	    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
	    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
	  }
	  function d3_time_formatRe(names) {
	    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
	  }
	  function d3_time_formatLookup(names) {
	    var map = new d3_Map(), i = -1, n = names.length;
	    while (++i < n) map.set(names[i].toLowerCase(), i);
	    return map;
	  }
	  function d3_time_parseWeekdayNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
	    return n ? (date.w = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberSunday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.U = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberMonday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.W = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseFullYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
	    return n ? (date.y = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
	  }
	  function d3_time_parseZone(date, string, i) {
	    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
	    i + 5) : -1;
	  }
	  function d3_time_expandYear(d) {
	    return d + (d > 68 ? 1900 : 2e3);
	  }
	  function d3_time_parseMonthNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
	  }
	  function d3_time_parseDay(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.d = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseDayOfYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.j = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseHour24(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.H = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMinutes(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.M = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseSeconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.S = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMilliseconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.L = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_zone(d) {
	    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
	    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
	  }
	  function d3_time_parseLiteralPercent(date, string, i) {
	    d3_time_percentRe.lastIndex = 0;
	    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
	    return n ? i + n[0].length : -1;
	  }
	  function d3_time_formatMulti(formats) {
	    var n = formats.length, i = -1;
	    while (++i < n) formats[i][0] = this(formats[i][0]);
	    return function(date) {
	      var i = 0, f = formats[i];
	      while (!f[1](date)) f = formats[++i];
	      return f[0](date);
	    };
	  }
	  d3.locale = function(locale) {
	    return {
	      numberFormat: d3_locale_numberFormat(locale),
	      timeFormat: d3_locale_timeFormat(locale)
	    };
	  };
	  var d3_locale_enUS = d3.locale({
	    decimal: ".",
	    thousands: ",",
	    grouping: [ 3 ],
	    currency: [ "$", "" ],
	    dateTime: "%a %b %e %X %Y",
	    date: "%m/%d/%Y",
	    time: "%H:%M:%S",
	    periods: [ "AM", "PM" ],
	    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
	    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
	    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
	    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
	  });
	  d3.format = d3_locale_enUS.numberFormat;
	  d3.geo = {};
	  function d3_adder() {}
	  d3_adder.prototype = {
	    s: 0,
	    t: 0,
	    add: function(y) {
	      d3_adderSum(y, this.t, d3_adderTemp);
	      d3_adderSum(d3_adderTemp.s, this.s, this);
	      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
	    },
	    reset: function() {
	      this.s = this.t = 0;
	    },
	    valueOf: function() {
	      return this.s;
	    }
	  };
	  var d3_adderTemp = new d3_adder();
	  function d3_adderSum(a, b, o) {
	    var x = o.s = a + b, bv = x - a, av = x - bv;
	    o.t = a - av + (b - bv);
	  }
	  d3.geo.stream = function(object, listener) {
	    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
	      d3_geo_streamObjectType[object.type](object, listener);
	    } else {
	      d3_geo_streamGeometry(object, listener);
	    }
	  };
	  function d3_geo_streamGeometry(geometry, listener) {
	    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
	      d3_geo_streamGeometryType[geometry.type](geometry, listener);
	    }
	  }
	  var d3_geo_streamObjectType = {
	    Feature: function(feature, listener) {
	      d3_geo_streamGeometry(feature.geometry, listener);
	    },
	    FeatureCollection: function(object, listener) {
	      var features = object.features, i = -1, n = features.length;
	      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
	    }
	  };
	  var d3_geo_streamGeometryType = {
	    Sphere: function(object, listener) {
	      listener.sphere();
	    },
	    Point: function(object, listener) {
	      object = object.coordinates;
	      listener.point(object[0], object[1], object[2]);
	    },
	    MultiPoint: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
	    },
	    LineString: function(object, listener) {
	      d3_geo_streamLine(object.coordinates, listener, 0);
	    },
	    MultiLineString: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
	    },
	    Polygon: function(object, listener) {
	      d3_geo_streamPolygon(object.coordinates, listener);
	    },
	    MultiPolygon: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
	    },
	    GeometryCollection: function(object, listener) {
	      var geometries = object.geometries, i = -1, n = geometries.length;
	      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
	    }
	  };
	  function d3_geo_streamLine(coordinates, listener, closed) {
	    var i = -1, n = coordinates.length - closed, coordinate;
	    listener.lineStart();
	    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
	    listener.lineEnd();
	  }
	  function d3_geo_streamPolygon(coordinates, listener) {
	    var i = -1, n = coordinates.length;
	    listener.polygonStart();
	    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
	    listener.polygonEnd();
	  }
	  d3.geo.area = function(object) {
	    d3_geo_areaSum = 0;
	    d3.geo.stream(object, d3_geo_area);
	    return d3_geo_areaSum;
	  };
	  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
	  var d3_geo_area = {
	    sphere: function() {
	      d3_geo_areaSum += 4 * π;
	    },
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_areaRingSum.reset();
	      d3_geo_area.lineStart = d3_geo_areaRingStart;
	    },
	    polygonEnd: function() {
	      var area = 2 * d3_geo_areaRingSum;
	      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
	      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
	    }
	  };
	  function d3_geo_areaRingStart() {
	    var λ00, φ00, λ0, cosφ0, sinφ0;
	    d3_geo_area.point = function(λ, φ) {
	      d3_geo_area.point = nextPoint;
	      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
	      sinφ0 = Math.sin(φ);
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      φ = φ * d3_radians / 2 + π / 4;
	      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
	      d3_geo_areaRingSum.add(Math.atan2(v, u));
	      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
	    }
	    d3_geo_area.lineEnd = function() {
	      nextPoint(λ00, φ00);
	    };
	  }
	  function d3_geo_cartesian(spherical) {
	    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
	    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
	  }
	  function d3_geo_cartesianDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	  }
	  function d3_geo_cartesianCross(a, b) {
	    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
	  }
	  function d3_geo_cartesianAdd(a, b) {
	    a[0] += b[0];
	    a[1] += b[1];
	    a[2] += b[2];
	  }
	  function d3_geo_cartesianScale(vector, k) {
	    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
	  }
	  function d3_geo_cartesianNormalize(d) {
	    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
	    d[0] /= l;
	    d[1] /= l;
	    d[2] /= l;
	  }
	  function d3_geo_spherical(cartesian) {
	    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
	  }
	  function d3_geo_sphericalEqual(a, b) {
	    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
	  }
	  d3.geo.bounds = function() {
	    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
	    var bound = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        bound.point = ringPoint;
	        bound.lineStart = ringStart;
	        bound.lineEnd = ringEnd;
	        dλSum = 0;
	        d3_geo_area.polygonStart();
	      },
	      polygonEnd: function() {
	        d3_geo_area.polygonEnd();
	        bound.point = point;
	        bound.lineStart = lineStart;
	        bound.lineEnd = lineEnd;
	        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
	        range[0] = λ0, range[1] = λ1;
	      }
	    };
	    function point(λ, φ) {
	      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
	      if (φ < φ0) φ0 = φ;
	      if (φ > φ1) φ1 = φ;
	    }
	    function linePoint(λ, φ) {
	      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
	      if (p0) {
	        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
	        d3_geo_cartesianNormalize(inflection);
	        inflection = d3_geo_spherical(inflection);
	        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
	        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
	          var φi = inflection[1] * d3_degrees;
	          if (φi > φ1) φ1 = φi;
	        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
	          var φi = -inflection[1] * d3_degrees;
	          if (φi < φ0) φ0 = φi;
	        } else {
	          if (φ < φ0) φ0 = φ;
	          if (φ > φ1) φ1 = φ;
	        }
	        if (antimeridian) {
	          if (λ < λ_) {
	            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
	          } else {
	            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
	          }
	        } else {
	          if (λ1 >= λ0) {
	            if (λ < λ0) λ0 = λ;
	            if (λ > λ1) λ1 = λ;
	          } else {
	            if (λ > λ_) {
	              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
	            } else {
	              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
	            }
	          }
	        }
	      } else {
	        point(λ, φ);
	      }
	      p0 = p, λ_ = λ;
	    }
	    function lineStart() {
	      bound.point = linePoint;
	    }
	    function lineEnd() {
	      range[0] = λ0, range[1] = λ1;
	      bound.point = point;
	      p0 = null;
	    }
	    function ringPoint(λ, φ) {
	      if (p0) {
	        var dλ = λ - λ_;
	        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
	      } else λ__ = λ, φ__ = φ;
	      d3_geo_area.point(λ, φ);
	      linePoint(λ, φ);
	    }
	    function ringStart() {
	      d3_geo_area.lineStart();
	    }
	    function ringEnd() {
	      ringPoint(λ__, φ__);
	      d3_geo_area.lineEnd();
	      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
	      range[0] = λ0, range[1] = λ1;
	      p0 = null;
	    }
	    function angle(λ0, λ1) {
	      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
	    }
	    function compareRanges(a, b) {
	      return a[0] - b[0];
	    }
	    function withinRange(x, range) {
	      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
	    }
	    return function(feature) {
	      φ1 = λ1 = -(λ0 = φ0 = Infinity);
	      ranges = [];
	      d3.geo.stream(feature, bound);
	      var n = ranges.length;
	      if (n) {
	        ranges.sort(compareRanges);
	        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
	          b = ranges[i];
	          if (withinRange(b[0], a) || withinRange(b[1], a)) {
	            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
	            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
	          } else {
	            merged.push(a = b);
	          }
	        }
	        var best = -Infinity, dλ;
	        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
	          b = merged[i];
	          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
	        }
	      }
	      ranges = range = null;
	      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
	    };
	  }();
	  d3.geo.centroid = function(object) {
	    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	    d3.geo.stream(object, d3_geo_centroid);
	    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
	    if (m < ε2) {
	      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
	      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
	      m = x * x + y * y + z * z;
	      if (m < ε2) return [ NaN, NaN ];
	    }
	    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
	  };
	  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
	  var d3_geo_centroid = {
	    sphere: d3_noop,
	    point: d3_geo_centroidPoint,
	    lineStart: d3_geo_centroidLineStart,
	    lineEnd: d3_geo_centroidLineEnd,
	    polygonStart: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
	    }
	  };
	  function d3_geo_centroidPoint(λ, φ) {
	    λ *= d3_radians;
	    var cosφ = Math.cos(φ *= d3_radians);
	    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
	  }
	  function d3_geo_centroidPointXYZ(x, y, z) {
	    ++d3_geo_centroidW0;
	    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
	    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
	    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
	  }
	  function d3_geo_centroidLineStart() {
	    var x0, y0, z0;
	    d3_geo_centroid.point = function(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians);
	      x0 = cosφ * Math.cos(λ);
	      y0 = cosφ * Math.sin(λ);
	      z0 = Math.sin(φ);
	      d3_geo_centroid.point = nextPoint;
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_geo_centroidLineEnd() {
	    d3_geo_centroid.point = d3_geo_centroidPoint;
	  }
	  function d3_geo_centroidRingStart() {
	    var λ00, φ00, x0, y0, z0;
	    d3_geo_centroid.point = function(λ, φ) {
	      λ00 = λ, φ00 = φ;
	      d3_geo_centroid.point = nextPoint;
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians);
	      x0 = cosφ * Math.cos(λ);
	      y0 = cosφ * Math.sin(λ);
	      z0 = Math.sin(φ);
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    d3_geo_centroid.lineEnd = function() {
	      nextPoint(λ00, φ00);
	      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
	      d3_geo_centroid.point = d3_geo_centroidPoint;
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
	      d3_geo_centroidX2 += v * cx;
	      d3_geo_centroidY2 += v * cy;
	      d3_geo_centroidZ2 += v * cz;
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_geo_compose(a, b) {
	    function compose(x, y) {
	      return x = a(x, y), b(x[0], x[1]);
	    }
	    if (a.invert && b.invert) compose.invert = function(x, y) {
	      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
	    };
	    return compose;
	  }
	  function d3_true() {
	    return true;
	  }
	  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
	    var subject = [], clip = [];
	    segments.forEach(function(segment) {
	      if ((n = segment.length - 1) <= 0) return;
	      var n, p0 = segment[0], p1 = segment[n];
	      if (d3_geo_sphericalEqual(p0, p1)) {
	        listener.lineStart();
	        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
	        listener.lineEnd();
	        return;
	      }
	      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
	      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	    });
	    clip.sort(compare);
	    d3_geo_clipPolygonLinkCircular(subject);
	    d3_geo_clipPolygonLinkCircular(clip);
	    if (!subject.length) return;
	    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
	      clip[i].e = entry = !entry;
	    }
	    var start = subject[0], points, point;
	    while (1) {
	      var current = start, isSubject = true;
	      while (current.v) if ((current = current.n) === start) return;
	      points = current.z;
	      listener.lineStart();
	      do {
	        current.v = current.o.v = true;
	        if (current.e) {
	          if (isSubject) {
	            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.n.x, 1, listener);
	          }
	          current = current.n;
	        } else {
	          if (isSubject) {
	            points = current.p.z;
	            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.p.x, -1, listener);
	          }
	          current = current.p;
	        }
	        current = current.o;
	        points = current.z;
	        isSubject = !isSubject;
	      } while (!current.v);
	      listener.lineEnd();
	    }
	  }
	  function d3_geo_clipPolygonLinkCircular(array) {
	    if (!(n = array.length)) return;
	    var n, i = 0, a = array[0], b;
	    while (++i < n) {
	      a.n = b = array[i];
	      b.p = a;
	      a = b;
	    }
	    a.n = b = array[0];
	    b.p = a;
	  }
	  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
	    this.x = point;
	    this.z = points;
	    this.o = other;
	    this.e = entry;
	    this.v = false;
	    this.n = this.p = null;
	  }
	  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
	    return function(rotate, listener) {
	      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          clip.point = pointRing;
	          clip.lineStart = ringStart;
	          clip.lineEnd = ringEnd;
	          segments = [];
	          polygon = [];
	        },
	        polygonEnd: function() {
	          clip.point = point;
	          clip.lineStart = lineStart;
	          clip.lineEnd = lineEnd;
	          segments = d3.merge(segments);
	          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
	          if (segments.length) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
	          } else if (clipStartInside) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            interpolate(null, null, 1, listener);
	            listener.lineEnd();
	          }
	          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
	          segments = polygon = null;
	        },
	        sphere: function() {
	          listener.polygonStart();
	          listener.lineStart();
	          interpolate(null, null, 1, listener);
	          listener.lineEnd();
	          listener.polygonEnd();
	        }
	      };
	      function point(λ, φ) {
	        var point = rotate(λ, φ);
	        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
	      }
	      function pointLine(λ, φ) {
	        var point = rotate(λ, φ);
	        line.point(point[0], point[1]);
	      }
	      function lineStart() {
	        clip.point = pointLine;
	        line.lineStart();
	      }
	      function lineEnd() {
	        clip.point = point;
	        line.lineEnd();
	      }
	      var segments;
	      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
	      function pointRing(λ, φ) {
	        ring.push([ λ, φ ]);
	        var point = rotate(λ, φ);
	        ringListener.point(point[0], point[1]);
	      }
	      function ringStart() {
	        ringListener.lineStart();
	        ring = [];
	      }
	      function ringEnd() {
	        pointRing(ring[0][0], ring[0][1]);
	        ringListener.lineEnd();
	        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
	        ring.pop();
	        polygon.push(ring);
	        ring = null;
	        if (!n) return;
	        if (clean & 1) {
	          segment = ringSegments[0];
	          var n = segment.length - 1, i = -1, point;
	          if (n > 0) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            while (++i < n) listener.point((point = segment[i])[0], point[1]);
	            listener.lineEnd();
	          }
	          return;
	        }
	        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
	        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
	      }
	      return clip;
	    };
	  }
	  function d3_geo_clipSegmentLength1(segment) {
	    return segment.length > 1;
	  }
	  function d3_geo_clipBufferListener() {
	    var lines = [], line;
	    return {
	      lineStart: function() {
	        lines.push(line = []);
	      },
	      point: function(λ, φ) {
	        line.push([ λ, φ ]);
	      },
	      lineEnd: d3_noop,
	      buffer: function() {
	        var buffer = lines;
	        lines = [];
	        line = null;
	        return buffer;
	      },
	      rejoin: function() {
	        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
	      }
	    };
	  }
	  function d3_geo_clipSort(a, b) {
	    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
	  }
	  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
	  function d3_geo_clipAntimeridianLine(listener) {
	    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
	    return {
	      lineStart: function() {
	        listener.lineStart();
	        clean = 1;
	      },
	      point: function(λ1, φ1) {
	        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
	        if (abs(dλ - π) < ε) {
	          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
	          listener.point(sλ0, φ0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(sλ1, φ0);
	          listener.point(λ1, φ0);
	          clean = 0;
	        } else if (sλ0 !== sλ1 && dλ >= π) {
	          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
	          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
	          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
	          listener.point(sλ0, φ0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(sλ1, φ0);
	          clean = 0;
	        }
	        listener.point(λ0 = λ1, φ0 = φ1);
	        sλ0 = sλ1;
	      },
	      lineEnd: function() {
	        listener.lineEnd();
	        λ0 = φ0 = NaN;
	      },
	      clean: function() {
	        return 2 - clean;
	      }
	    };
	  }
	  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
	    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
	    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
	  }
	  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
	    var φ;
	    if (from == null) {
	      φ = direction * halfπ;
	      listener.point(-π, φ);
	      listener.point(0, φ);
	      listener.point(π, φ);
	      listener.point(π, 0);
	      listener.point(π, -φ);
	      listener.point(0, -φ);
	      listener.point(-π, -φ);
	      listener.point(-π, 0);
	      listener.point(-π, φ);
	    } else if (abs(from[0] - to[0]) > ε) {
	      var s = from[0] < to[0] ? π : -π;
	      φ = direction * s / 2;
	      listener.point(-s, φ);
	      listener.point(0, φ);
	      listener.point(s, φ);
	    } else {
	      listener.point(to[0], to[1]);
	    }
	  }
	  function d3_geo_pointInPolygon(point, polygon) {
	    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
	    d3_geo_areaRingSum.reset();
	    for (var i = 0, n = polygon.length; i < n; ++i) {
	      var ring = polygon[i], m = ring.length;
	      if (!m) continue;
	      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
	      while (true) {
	        if (j === m) j = 0;
	        point = ring[j];
	        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
	        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
	        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
	        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
	          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
	          d3_geo_cartesianNormalize(arc);
	          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
	          d3_geo_cartesianNormalize(intersection);
	          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
	          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
	            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
	          }
	        }
	        if (!j++) break;
	        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
	      }
	    }
	    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < -ε) ^ winding & 1;
	  }
	  function d3_geo_clipCircle(radius) {
	    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
	    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
	    function visible(λ, φ) {
	      return Math.cos(λ) * Math.cos(φ) > cr;
	    }
	    function clipLine(listener) {
	      var point0, c0, v0, v00, clean;
	      return {
	        lineStart: function() {
	          v00 = v0 = false;
	          clean = 1;
	        },
	        point: function(λ, φ) {
	          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
	          if (!point0 && (v00 = v0 = v)) listener.lineStart();
	          if (v !== v0) {
	            point2 = intersect(point0, point1);
	            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
	              point1[0] += ε;
	              point1[1] += ε;
	              v = visible(point1[0], point1[1]);
	            }
	          }
	          if (v !== v0) {
	            clean = 0;
	            if (v) {
	              listener.lineStart();
	              point2 = intersect(point1, point0);
	              listener.point(point2[0], point2[1]);
	            } else {
	              point2 = intersect(point0, point1);
	              listener.point(point2[0], point2[1]);
	              listener.lineEnd();
	            }
	            point0 = point2;
	          } else if (notHemisphere && point0 && smallRadius ^ v) {
	            var t;
	            if (!(c & c0) && (t = intersect(point1, point0, true))) {
	              clean = 0;
	              if (smallRadius) {
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	              } else {
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	              }
	            }
	          }
	          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
	            listener.point(point1[0], point1[1]);
	          }
	          point0 = point1, v0 = v, c0 = c;
	        },
	        lineEnd: function() {
	          if (v0) listener.lineEnd();
	          point0 = null;
	        },
	        clean: function() {
	          return clean | (v00 && v0) << 1;
	        }
	      };
	    }
	    function intersect(a, b, two) {
	      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
	      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
	      if (!determinant) return !two && a;
	      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
	      d3_geo_cartesianAdd(A, B);
	      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
	      if (t2 < 0) return;
	      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
	      d3_geo_cartesianAdd(q, A);
	      q = d3_geo_spherical(q);
	      if (!two) return q;
	      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
	      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
	      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
	      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
	      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
	        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
	        d3_geo_cartesianAdd(q1, A);
	        return [ q, d3_geo_spherical(q1) ];
	      }
	    }
	    function code(λ, φ) {
	      var r = smallRadius ? radius : π - radius, code = 0;
	      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
	      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
	      return code;
	    }
	  }
	  function d3_geom_clipLine(x0, y0, x1, y1) {
	    return function(line) {
	      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
	      r = x0 - ax;
	      if (!dx && r > 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dx > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = x1 - ax;
	      if (!dx && r < 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dx > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      r = y0 - ay;
	      if (!dy && r > 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dy > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = y1 - ay;
	      if (!dy && r < 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dy > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      if (t0 > 0) line.a = {
	        x: ax + t0 * dx,
	        y: ay + t0 * dy
	      };
	      if (t1 < 1) line.b = {
	        x: ax + t1 * dx,
	        y: ay + t1 * dy
	      };
	      return line;
	    };
	  }
	  var d3_geo_clipExtentMAX = 1e9;
	  d3.geo.clipExtent = function() {
	    var x0, y0, x1, y1, stream, clip, clipExtent = {
	      stream: function(output) {
	        if (stream) stream.valid = false;
	        stream = clip(output);
	        stream.valid = true;
	        return stream;
	      },
	      extent: function(_) {
	        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
	        if (stream) stream.valid = false, stream = null;
	        return clipExtent;
	      }
	    };
	    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
	  };
	  function d3_geo_clipExtent(x0, y0, x1, y1) {
	    return function(listener) {
	      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          listener = bufferListener;
	          segments = [];
	          polygon = [];
	          clean = true;
	        },
	        polygonEnd: function() {
	          listener = listener_;
	          segments = d3.merge(segments);
	          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
	          if (inside || visible) {
	            listener.polygonStart();
	            if (inside) {
	              listener.lineStart();
	              interpolate(null, null, 1, listener);
	              listener.lineEnd();
	            }
	            if (visible) {
	              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
	            }
	            listener.polygonEnd();
	          }
	          segments = polygon = ring = null;
	        }
	      };
	      function insidePolygon(p) {
	        var wn = 0, n = polygon.length, y = p[1];
	        for (var i = 0; i < n; ++i) {
	          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
	            b = v[j];
	            if (a[1] <= y) {
	              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
	            } else {
	              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
	            }
	            a = b;
	          }
	        }
	        return wn !== 0;
	      }
	      function interpolate(from, to, direction, listener) {
	        var a = 0, a1 = 0;
	        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
	          do {
	            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
	          } while ((a = (a + direction + 4) % 4) !== a1);
	        } else {
	          listener.point(to[0], to[1]);
	        }
	      }
	      function pointVisible(x, y) {
	        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
	      }
	      function point(x, y) {
	        if (pointVisible(x, y)) listener.point(x, y);
	      }
	      var x__, y__, v__, x_, y_, v_, first, clean;
	      function lineStart() {
	        clip.point = linePoint;
	        if (polygon) polygon.push(ring = []);
	        first = true;
	        v_ = false;
	        x_ = y_ = NaN;
	      }
	      function lineEnd() {
	        if (segments) {
	          linePoint(x__, y__);
	          if (v__ && v_) bufferListener.rejoin();
	          segments.push(bufferListener.buffer());
	        }
	        clip.point = point;
	        if (v_) listener.lineEnd();
	      }
	      function linePoint(x, y) {
	        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
	        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
	        var v = pointVisible(x, y);
	        if (polygon) ring.push([ x, y ]);
	        if (first) {
	          x__ = x, y__ = y, v__ = v;
	          first = false;
	          if (v) {
	            listener.lineStart();
	            listener.point(x, y);
	          }
	        } else {
	          if (v && v_) listener.point(x, y); else {
	            var l = {
	              a: {
	                x: x_,
	                y: y_
	              },
	              b: {
	                x: x,
	                y: y
	              }
	            };
	            if (clipLine(l)) {
	              if (!v_) {
	                listener.lineStart();
	                listener.point(l.a.x, l.a.y);
	              }
	              listener.point(l.b.x, l.b.y);
	              if (!v) listener.lineEnd();
	              clean = false;
	            } else if (v) {
	              listener.lineStart();
	              listener.point(x, y);
	              clean = false;
	            }
	          }
	        }
	        x_ = x, y_ = y, v_ = v;
	      }
	      return clip;
	    };
	    function corner(p, direction) {
	      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
	    }
	    function compare(a, b) {
	      return comparePoints(a.x, b.x);
	    }
	    function comparePoints(a, b) {
	      var ca = corner(a, 1), cb = corner(b, 1);
	      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
	    }
	  }
	  function d3_geo_conic(projectAt) {
	    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
	    p.parallels = function(_) {
	      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
	      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
	    };
	    return p;
	  }
	  function d3_geo_conicEqualArea(φ0, φ1) {
	    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
	    function forward(λ, φ) {
	      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
	      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = ρ0 - y;
	      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEqualArea = function() {
	    return d3_geo_conic(d3_geo_conicEqualArea);
	  }).raw = d3_geo_conicEqualArea;
	  d3.geo.albers = function() {
	    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
	  };
	  d3.geo.albersUsa = function() {
	    var lower48 = d3.geo.albers();
	    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
	    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
	    var point, pointStream = {
	      point: function(x, y) {
	        point = [ x, y ];
	      }
	    }, lower48Point, alaskaPoint, hawaiiPoint;
	    function albersUsa(coordinates) {
	      var x = coordinates[0], y = coordinates[1];
	      point = null;
	      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
	      return point;
	    }
	    albersUsa.invert = function(coordinates) {
	      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
	      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
	    };
	    albersUsa.stream = function(stream) {
	      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
	      return {
	        point: function(x, y) {
	          lower48Stream.point(x, y);
	          alaskaStream.point(x, y);
	          hawaiiStream.point(x, y);
	        },
	        sphere: function() {
	          lower48Stream.sphere();
	          alaskaStream.sphere();
	          hawaiiStream.sphere();
	        },
	        lineStart: function() {
	          lower48Stream.lineStart();
	          alaskaStream.lineStart();
	          hawaiiStream.lineStart();
	        },
	        lineEnd: function() {
	          lower48Stream.lineEnd();
	          alaskaStream.lineEnd();
	          hawaiiStream.lineEnd();
	        },
	        polygonStart: function() {
	          lower48Stream.polygonStart();
	          alaskaStream.polygonStart();
	          hawaiiStream.polygonStart();
	        },
	        polygonEnd: function() {
	          lower48Stream.polygonEnd();
	          alaskaStream.polygonEnd();
	          hawaiiStream.polygonEnd();
	        }
	      };
	    };
	    albersUsa.precision = function(_) {
	      if (!arguments.length) return lower48.precision();
	      lower48.precision(_);
	      alaska.precision(_);
	      hawaii.precision(_);
	      return albersUsa;
	    };
	    albersUsa.scale = function(_) {
	      if (!arguments.length) return lower48.scale();
	      lower48.scale(_);
	      alaska.scale(_ * .35);
	      hawaii.scale(_);
	      return albersUsa.translate(lower48.translate());
	    };
	    albersUsa.translate = function(_) {
	      if (!arguments.length) return lower48.translate();
	      var k = lower48.scale(), x = +_[0], y = +_[1];
	      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
	      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
	      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
	      return albersUsa;
	    };
	    return albersUsa.scale(1070);
	  };
	  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_pathAreaPolygon = 0;
	      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
	      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
	    }
	  };
	  function d3_geo_pathAreaRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathArea.point = function(x, y) {
	      d3_geo_pathArea.point = nextPoint;
	      x00 = x0 = x, y00 = y0 = y;
	    };
	    function nextPoint(x, y) {
	      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
	      x0 = x, y0 = y;
	    }
	    d3_geo_pathArea.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
	  var d3_geo_pathBounds = {
	    point: d3_geo_pathBoundsPoint,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_pathBoundsPoint(x, y) {
	    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
	    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
	    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
	    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
	  }
	  function d3_geo_pathBuffer() {
	    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointCircle = d3_geo_pathBufferCircle(_);
	        return stream;
	      },
	      result: function() {
	        if (buffer.length) {
	          var result = buffer.join("");
	          buffer = [];
	          return result;
	        }
	      }
	    };
	    function point(x, y) {
	      buffer.push("M", x, ",", y, pointCircle);
	    }
	    function pointLineStart(x, y) {
	      buffer.push("M", x, ",", y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      buffer.push("L", x, ",", y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      buffer.push("Z");
	    }
	    return stream;
	  }
	  function d3_geo_pathBufferCircle(radius) {
	    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
	  }
	  var d3_geo_pathCentroid = {
	    point: d3_geo_pathCentroidPoint,
	    lineStart: d3_geo_pathCentroidLineStart,
	    lineEnd: d3_geo_pathCentroidLineEnd,
	    polygonStart: function() {
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
	      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
	    }
	  };
	  function d3_geo_pathCentroidPoint(x, y) {
	    d3_geo_centroidX0 += x;
	    d3_geo_centroidY0 += y;
	    ++d3_geo_centroidZ0;
	  }
	  function d3_geo_pathCentroidLineStart() {
	    var x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	  }
	  function d3_geo_pathCentroidLineEnd() {
	    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	  }
	  function d3_geo_pathCentroidRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      z = y0 * x - x0 * y;
	      d3_geo_centroidX2 += z * (x0 + x);
	      d3_geo_centroidY2 += z * (y0 + y);
	      d3_geo_centroidZ2 += z * 3;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	    d3_geo_pathCentroid.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  function d3_geo_pathContext(context) {
	    var pointRadius = 4.5;
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointRadius = _;
	        return stream;
	      },
	      result: d3_noop
	    };
	    function point(x, y) {
	      context.moveTo(x + pointRadius, y);
	      context.arc(x, y, pointRadius, 0, τ);
	    }
	    function pointLineStart(x, y) {
	      context.moveTo(x, y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      context.lineTo(x, y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      context.closePath();
	    }
	    return stream;
	  }
	  function d3_geo_resample(project) {
	    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
	    function resample(stream) {
	      return (maxDepth ? resampleRecursive : resampleNone)(stream);
	    }
	    function resampleNone(stream) {
	      return d3_geo_transformPoint(stream, function(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      });
	    }
	    function resampleRecursive(stream) {
	      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
	      var resample = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          stream.polygonStart();
	          resample.lineStart = ringStart;
	        },
	        polygonEnd: function() {
	          stream.polygonEnd();
	          resample.lineStart = lineStart;
	        }
	      };
	      function point(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      }
	      function lineStart() {
	        x0 = NaN;
	        resample.point = linePoint;
	        stream.lineStart();
	      }
	      function linePoint(λ, φ) {
	        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
	        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
	        stream.point(x0, y0);
	      }
	      function lineEnd() {
	        resample.point = point;
	        stream.lineEnd();
	      }
	      function ringStart() {
	        lineStart();
	        resample.point = ringPoint;
	        resample.lineEnd = ringEnd;
	      }
	      function ringPoint(λ, φ) {
	        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
	        resample.point = linePoint;
	      }
	      function ringEnd() {
	        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
	        resample.lineEnd = lineEnd;
	        lineEnd();
	      }
	      return resample;
	    }
	    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
	      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
	      if (d2 > 4 * δ2 && depth--) {
	        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
	        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
	          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
	          stream.point(x2, y2);
	          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
	        }
	      }
	    }
	    resample.precision = function(_) {
	      if (!arguments.length) return Math.sqrt(δ2);
	      maxDepth = (δ2 = _ * _) > 0 && 16;
	      return resample;
	    };
	    return resample;
	  }
	  d3.geo.path = function() {
	    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
	    function path(object) {
	      if (object) {
	        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
	        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
	        d3.geo.stream(object, cacheStream);
	      }
	      return contextStream.result();
	    }
	    path.area = function(object) {
	      d3_geo_pathAreaSum = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathArea));
	      return d3_geo_pathAreaSum;
	    };
	    path.centroid = function(object) {
	      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
	      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
	    };
	    path.bounds = function(object) {
	      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
	      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
	      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
	    };
	    path.projection = function(_) {
	      if (!arguments.length) return projection;
	      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
	      return reset();
	    };
	    path.context = function(_) {
	      if (!arguments.length) return context;
	      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
	      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
	      return reset();
	    };
	    path.pointRadius = function(_) {
	      if (!arguments.length) return pointRadius;
	      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
	      return path;
	    };
	    function reset() {
	      cacheStream = null;
	      return path;
	    }
	    return path.projection(d3.geo.albersUsa()).context(null);
	  };
	  function d3_geo_pathProjectStream(project) {
	    var resample = d3_geo_resample(function(x, y) {
	      return project([ x * d3_degrees, y * d3_degrees ]);
	    });
	    return function(stream) {
	      return d3_geo_projectionRadians(resample(stream));
	    };
	  }
	  d3.geo.transform = function(methods) {
	    return {
	      stream: function(stream) {
	        var transform = new d3_geo_transform(stream);
	        for (var k in methods) transform[k] = methods[k];
	        return transform;
	      }
	    };
	  };
	  function d3_geo_transform(stream) {
	    this.stream = stream;
	  }
	  d3_geo_transform.prototype = {
	    point: function(x, y) {
	      this.stream.point(x, y);
	    },
	    sphere: function() {
	      this.stream.sphere();
	    },
	    lineStart: function() {
	      this.stream.lineStart();
	    },
	    lineEnd: function() {
	      this.stream.lineEnd();
	    },
	    polygonStart: function() {
	      this.stream.polygonStart();
	    },
	    polygonEnd: function() {
	      this.stream.polygonEnd();
	    }
	  };
	  function d3_geo_transformPoint(stream, point) {
	    return {
	      point: point,
	      sphere: function() {
	        stream.sphere();
	      },
	      lineStart: function() {
	        stream.lineStart();
	      },
	      lineEnd: function() {
	        stream.lineEnd();
	      },
	      polygonStart: function() {
	        stream.polygonStart();
	      },
	      polygonEnd: function() {
	        stream.polygonEnd();
	      }
	    };
	  }
	  d3.geo.projection = d3_geo_projection;
	  d3.geo.projectionMutator = d3_geo_projectionMutator;
	  function d3_geo_projection(project) {
	    return d3_geo_projectionMutator(function() {
	      return project;
	    })();
	  }
	  function d3_geo_projectionMutator(projectAt) {
	    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
	      x = project(x, y);
	      return [ x[0] * k + δx, δy - x[1] * k ];
	    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
	    function projection(point) {
	      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
	      return [ point[0] * k + δx, δy - point[1] * k ];
	    }
	    function invert(point) {
	      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
	      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
	    }
	    projection.stream = function(output) {
	      if (stream) stream.valid = false;
	      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
	      stream.valid = true;
	      return stream;
	    };
	    projection.clipAngle = function(_) {
	      if (!arguments.length) return clipAngle;
	      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
	      return invalidate();
	    };
	    projection.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent;
	      clipExtent = _;
	      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
	      return invalidate();
	    };
	    projection.scale = function(_) {
	      if (!arguments.length) return k;
	      k = +_;
	      return reset();
	    };
	    projection.translate = function(_) {
	      if (!arguments.length) return [ x, y ];
	      x = +_[0];
	      y = +_[1];
	      return reset();
	    };
	    projection.center = function(_) {
	      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
	      λ = _[0] % 360 * d3_radians;
	      φ = _[1] % 360 * d3_radians;
	      return reset();
	    };
	    projection.rotate = function(_) {
	      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
	      δλ = _[0] % 360 * d3_radians;
	      δφ = _[1] % 360 * d3_radians;
	      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
	      return reset();
	    };
	    d3.rebind(projection, projectResample, "precision");
	    function reset() {
	      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
	      var center = project(λ, φ);
	      δx = x - center[0] * k;
	      δy = y + center[1] * k;
	      return invalidate();
	    }
	    function invalidate() {
	      if (stream) stream.valid = false, stream = null;
	      return projection;
	    }
	    return function() {
	      project = projectAt.apply(this, arguments);
	      projection.invert = project.invert && invert;
	      return reset();
	    };
	  }
	  function d3_geo_projectionRadians(stream) {
	    return d3_geo_transformPoint(stream, function(x, y) {
	      stream.point(x * d3_radians, y * d3_radians);
	    });
	  }
	  function d3_geo_equirectangular(λ, φ) {
	    return [ λ, φ ];
	  }
	  (d3.geo.equirectangular = function() {
	    return d3_geo_projection(d3_geo_equirectangular);
	  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
	  d3.geo.rotation = function(rotate) {
	    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
	    function forward(coordinates) {
	      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    }
	    forward.invert = function(coordinates) {
	      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    };
	    return forward;
	  };
	  function d3_geo_identityRotation(λ, φ) {
	    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
	  }
	  d3_geo_identityRotation.invert = d3_geo_equirectangular;
	  function d3_geo_rotation(δλ, δφ, δγ) {
	    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
	  }
	  function d3_geo_forwardRotationλ(δλ) {
	    return function(λ, φ) {
	      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
	    };
	  }
	  function d3_geo_rotationλ(δλ) {
	    var rotation = d3_geo_forwardRotationλ(δλ);
	    rotation.invert = d3_geo_forwardRotationλ(-δλ);
	    return rotation;
	  }
	  function d3_geo_rotationφγ(δφ, δγ) {
	    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
	    function rotation(λ, φ) {
	      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
	      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
	    }
	    rotation.invert = function(λ, φ) {
	      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
	      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
	    };
	    return rotation;
	  }
	  d3.geo.circle = function() {
	    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
	    function circle() {
	      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
	      interpolate(null, null, 1, {
	        point: function(x, y) {
	          ring.push(x = rotate(x, y));
	          x[0] *= d3_degrees, x[1] *= d3_degrees;
	        }
	      });
	      return {
	        type: "Polygon",
	        coordinates: [ ring ]
	      };
	    }
	    circle.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return circle;
	    };
	    circle.angle = function(x) {
	      if (!arguments.length) return angle;
	      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
	      return circle;
	    };
	    circle.precision = function(_) {
	      if (!arguments.length) return precision;
	      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
	      return circle;
	    };
	    return circle.angle(90);
	  };
	  function d3_geo_circleInterpolate(radius, precision) {
	    var cr = Math.cos(radius), sr = Math.sin(radius);
	    return function(from, to, direction, listener) {
	      var step = direction * precision;
	      if (from != null) {
	        from = d3_geo_circleAngle(cr, from);
	        to = d3_geo_circleAngle(cr, to);
	        if (direction > 0 ? from < to : from > to) from += direction * τ;
	      } else {
	        from = radius + direction * τ;
	        to = radius - .5 * step;
	      }
	      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
	        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
	      }
	    };
	  }
	  function d3_geo_circleAngle(cr, point) {
	    var a = d3_geo_cartesian(point);
	    a[0] -= cr;
	    d3_geo_cartesianNormalize(a);
	    var angle = d3_acos(-a[1]);
	    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
	  }
	  d3.geo.distance = function(a, b) {
	    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
	    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
	  };
	  d3.geo.graticule = function() {
	    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
	    function graticule() {
	      return {
	        type: "MultiLineString",
	        coordinates: lines()
	      };
	    }
	    function lines() {
	      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
	        return abs(x % DX) > ε;
	      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
	        return abs(y % DY) > ε;
	      }).map(y));
	    }
	    graticule.lines = function() {
	      return lines().map(function(coordinates) {
	        return {
	          type: "LineString",
	          coordinates: coordinates
	        };
	      });
	    };
	    graticule.outline = function() {
	      return {
	        type: "Polygon",
	        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
	      };
	    };
	    graticule.extent = function(_) {
	      if (!arguments.length) return graticule.minorExtent();
	      return graticule.majorExtent(_).minorExtent(_);
	    };
	    graticule.majorExtent = function(_) {
	      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
	      X0 = +_[0][0], X1 = +_[1][0];
	      Y0 = +_[0][1], Y1 = +_[1][1];
	      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
	      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.minorExtent = function(_) {
	      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	      x0 = +_[0][0], x1 = +_[1][0];
	      y0 = +_[0][1], y1 = +_[1][1];
	      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
	      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.step = function(_) {
	      if (!arguments.length) return graticule.minorStep();
	      return graticule.majorStep(_).minorStep(_);
	    };
	    graticule.majorStep = function(_) {
	      if (!arguments.length) return [ DX, DY ];
	      DX = +_[0], DY = +_[1];
	      return graticule;
	    };
	    graticule.minorStep = function(_) {
	      if (!arguments.length) return [ dx, dy ];
	      dx = +_[0], dy = +_[1];
	      return graticule;
	    };
	    graticule.precision = function(_) {
	      if (!arguments.length) return precision;
	      precision = +_;
	      x = d3_geo_graticuleX(y0, y1, 90);
	      y = d3_geo_graticuleY(x0, x1, precision);
	      X = d3_geo_graticuleX(Y0, Y1, 90);
	      Y = d3_geo_graticuleY(X0, X1, precision);
	      return graticule;
	    };
	    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
	  };
	  function d3_geo_graticuleX(y0, y1, dy) {
	    var y = d3.range(y0, y1 - ε, dy).concat(y1);
	    return function(x) {
	      return y.map(function(y) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_geo_graticuleY(x0, x1, dx) {
	    var x = d3.range(x0, x1 - ε, dx).concat(x1);
	    return function(y) {
	      return x.map(function(x) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_source(d) {
	    return d.source;
	  }
	  function d3_target(d) {
	    return d.target;
	  }
	  d3.geo.greatArc = function() {
	    var source = d3_source, source_, target = d3_target, target_;
	    function greatArc() {
	      return {
	        type: "LineString",
	        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
	      };
	    }
	    greatArc.distance = function() {
	      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
	    };
	    greatArc.source = function(_) {
	      if (!arguments.length) return source;
	      source = _, source_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.target = function(_) {
	      if (!arguments.length) return target;
	      target = _, target_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.precision = function() {
	      return arguments.length ? greatArc : 0;
	    };
	    return greatArc;
	  };
	  d3.geo.interpolate = function(source, target) {
	    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
	  };
	  function d3_geo_interpolate(x0, y0, x1, y1) {
	    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
	    var interpolate = d ? function(t) {
	      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
	      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
	    } : function() {
	      return [ x0 * d3_degrees, y0 * d3_degrees ];
	    };
	    interpolate.distance = d;
	    return interpolate;
	  }
	  d3.geo.length = function(object) {
	    d3_geo_lengthSum = 0;
	    d3.geo.stream(object, d3_geo_length);
	    return d3_geo_lengthSum;
	  };
	  var d3_geo_lengthSum;
	  var d3_geo_length = {
	    sphere: d3_noop,
	    point: d3_noop,
	    lineStart: d3_geo_lengthLineStart,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_lengthLineStart() {
	    var λ0, sinφ0, cosφ0;
	    d3_geo_length.point = function(λ, φ) {
	      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
	      d3_geo_length.point = nextPoint;
	    };
	    d3_geo_length.lineEnd = function() {
	      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
	    };
	    function nextPoint(λ, φ) {
	      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
	      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
	      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
	    }
	  }
	  function d3_geo_azimuthal(scale, angle) {
	    function azimuthal(λ, φ) {
	      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
	      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
	    }
	    azimuthal.invert = function(x, y) {
	      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
	      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
	    };
	    return azimuthal;
	  }
	  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
	    return Math.sqrt(2 / (1 + cosλcosφ));
	  }, function(ρ) {
	    return 2 * Math.asin(ρ / 2);
	  });
	  (d3.geo.azimuthalEqualArea = function() {
	    return d3_geo_projection(d3_geo_azimuthalEqualArea);
	  }).raw = d3_geo_azimuthalEqualArea;
	  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
	    var c = Math.acos(cosλcosφ);
	    return c && c / Math.sin(c);
	  }, d3_identity);
	  (d3.geo.azimuthalEquidistant = function() {
	    return d3_geo_projection(d3_geo_azimuthalEquidistant);
	  }).raw = d3_geo_azimuthalEquidistant;
	  function d3_geo_conicConformal(φ0, φ1) {
	    var cosφ0 = Math.cos(φ0), t = function(φ) {
	      return Math.tan(π / 4 + φ / 2);
	    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
	    if (!n) return d3_geo_mercator;
	    function forward(λ, φ) {
	      if (F > 0) {
	        if (φ < -halfπ + ε) φ = -halfπ + ε;
	      } else {
	        if (φ > halfπ - ε) φ = halfπ - ε;
	      }
	      var ρ = F / Math.pow(t(φ), n);
	      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
	      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
	    };
	    return forward;
	  }
	  (d3.geo.conicConformal = function() {
	    return d3_geo_conic(d3_geo_conicConformal);
	  }).raw = d3_geo_conicConformal;
	  function d3_geo_conicEquidistant(φ0, φ1) {
	    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
	    if (abs(n) < ε) return d3_geo_equirectangular;
	    function forward(λ, φ) {
	      var ρ = G - φ;
	      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = G - y;
	      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEquidistant = function() {
	    return d3_geo_conic(d3_geo_conicEquidistant);
	  }).raw = d3_geo_conicEquidistant;
	  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
	    return 1 / cosλcosφ;
	  }, Math.atan);
	  (d3.geo.gnomonic = function() {
	    return d3_geo_projection(d3_geo_gnomonic);
	  }).raw = d3_geo_gnomonic;
	  function d3_geo_mercator(λ, φ) {
	    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
	  }
	  d3_geo_mercator.invert = function(x, y) {
	    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
	  };
	  function d3_geo_mercatorProjection(project) {
	    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
	    m.scale = function() {
	      var v = scale.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.translate = function() {
	      var v = translate.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.clipExtent = function(_) {
	      var v = clipExtent.apply(m, arguments);
	      if (v === m) {
	        if (clipAuto = _ == null) {
	          var k = π * scale(), t = translate();
	          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
	        }
	      } else if (clipAuto) {
	        v = null;
	      }
	      return v;
	    };
	    return m.clipExtent(null);
	  }
	  (d3.geo.mercator = function() {
	    return d3_geo_mercatorProjection(d3_geo_mercator);
	  }).raw = d3_geo_mercator;
	  var d3_geo_orthographic = d3_geo_azimuthal(function() {
	    return 1;
	  }, Math.asin);
	  (d3.geo.orthographic = function() {
	    return d3_geo_projection(d3_geo_orthographic);
	  }).raw = d3_geo_orthographic;
	  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
	    return 1 / (1 + cosλcosφ);
	  }, function(ρ) {
	    return 2 * Math.atan(ρ);
	  });
	  (d3.geo.stereographic = function() {
	    return d3_geo_projection(d3_geo_stereographic);
	  }).raw = d3_geo_stereographic;
	  function d3_geo_transverseMercator(λ, φ) {
	    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
	  }
	  d3_geo_transverseMercator.invert = function(x, y) {
	    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
	  };
	  (d3.geo.transverseMercator = function() {
	    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
	    projection.center = function(_) {
	      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
	    };
	    projection.rotate = function(_) {
	      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
	      [ _[0], _[1], _[2] - 90 ]);
	    };
	    return rotate([ 0, 0, 90 ]);
	  }).raw = d3_geo_transverseMercator;
	  d3.geom = {};
	  function d3_geom_pointX(d) {
	    return d[0];
	  }
	  function d3_geom_pointY(d) {
	    return d[1];
	  }
	  d3.geom.hull = function(vertices) {
	    var x = d3_geom_pointX, y = d3_geom_pointY;
	    if (arguments.length) return hull(vertices);
	    function hull(data) {
	      if (data.length < 3) return [];
	      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
	      for (i = 0; i < n; i++) {
	        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
	      }
	      points.sort(d3_geom_hullOrder);
	      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
	      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
	      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
	      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
	      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
	      return polygon;
	    }
	    hull.x = function(_) {
	      return arguments.length ? (x = _, hull) : x;
	    };
	    hull.y = function(_) {
	      return arguments.length ? (y = _, hull) : y;
	    };
	    return hull;
	  };
	  function d3_geom_hullUpper(points) {
	    var n = points.length, hull = [ 0, 1 ], hs = 2;
	    for (var i = 2; i < n; i++) {
	      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
	      hull[hs++] = i;
	    }
	    return hull.slice(0, hs);
	  }
	  function d3_geom_hullOrder(a, b) {
	    return a[0] - b[0] || a[1] - b[1];
	  }
	  d3.geom.polygon = function(coordinates) {
	    d3_subclass(coordinates, d3_geom_polygonPrototype);
	    return coordinates;
	  };
	  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
	  d3_geom_polygonPrototype.area = function() {
	    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      area += a[1] * b[0] - a[0] * b[1];
	    }
	    return area * .5;
	  };
	  d3_geom_polygonPrototype.centroid = function(k) {
	    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
	    if (!arguments.length) k = -1 / (6 * this.area());
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      c = a[0] * b[1] - b[0] * a[1];
	      x += (a[0] + b[0]) * c;
	      y += (a[1] + b[1]) * c;
	    }
	    return [ x * k, y * k ];
	  };
	  d3_geom_polygonPrototype.clip = function(subject) {
	    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
	    while (++i < n) {
	      input = subject.slice();
	      subject.length = 0;
	      b = this[i];
	      c = input[(m = input.length - closed) - 1];
	      j = -1;
	      while (++j < m) {
	        d = input[j];
	        if (d3_geom_polygonInside(d, a, b)) {
	          if (!d3_geom_polygonInside(c, a, b)) {
	            subject.push(d3_geom_polygonIntersect(c, d, a, b));
	          }
	          subject.push(d);
	        } else if (d3_geom_polygonInside(c, a, b)) {
	          subject.push(d3_geom_polygonIntersect(c, d, a, b));
	        }
	        c = d;
	      }
	      if (closed) subject.push(subject[0]);
	      a = b;
	    }
	    return subject;
	  };
	  function d3_geom_polygonInside(p, a, b) {
	    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
	  }
	  function d3_geom_polygonIntersect(c, d, a, b) {
	    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
	    return [ x1 + ua * x21, y1 + ua * y21 ];
	  }
	  function d3_geom_polygonClosed(coordinates) {
	    var a = coordinates[0], b = coordinates[coordinates.length - 1];
	    return !(a[0] - b[0] || a[1] - b[1]);
	  }
	  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
	  function d3_geom_voronoiBeach() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.edge = this.site = this.circle = null;
	  }
	  function d3_geom_voronoiCreateBeach(site) {
	    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
	    beach.site = site;
	    return beach;
	  }
	  function d3_geom_voronoiDetachBeach(beach) {
	    d3_geom_voronoiDetachCircle(beach);
	    d3_geom_voronoiBeaches.remove(beach);
	    d3_geom_voronoiBeachPool.push(beach);
	    d3_geom_voronoiRedBlackNode(beach);
	  }
	  function d3_geom_voronoiRemoveBeach(beach) {
	    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
	      x: x,
	      y: y
	    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
	    d3_geom_voronoiDetachBeach(beach);
	    var lArc = previous;
	    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
	      previous = lArc.P;
	      disappearing.unshift(lArc);
	      d3_geom_voronoiDetachBeach(lArc);
	      lArc = previous;
	    }
	    disappearing.unshift(lArc);
	    d3_geom_voronoiDetachCircle(lArc);
	    var rArc = next;
	    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
	      next = rArc.N;
	      disappearing.push(rArc);
	      d3_geom_voronoiDetachBeach(rArc);
	      rArc = next;
	    }
	    disappearing.push(rArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var nArcs = disappearing.length, iArc;
	    for (iArc = 1; iArc < nArcs; ++iArc) {
	      rArc = disappearing[iArc];
	      lArc = disappearing[iArc - 1];
	      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
	    }
	    lArc = disappearing[0];
	    rArc = disappearing[nArcs - 1];
	    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiAddBeach(site) {
	    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
	    while (node) {
	      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
	      if (dxl > ε) node = node.L; else {
	        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
	        if (dxr > ε) {
	          if (!node.R) {
	            lArc = node;
	            break;
	          }
	          node = node.R;
	        } else {
	          if (dxl > -ε) {
	            lArc = node.P;
	            rArc = node;
	          } else if (dxr > -ε) {
	            lArc = node;
	            rArc = node.N;
	          } else {
	            lArc = rArc = node;
	          }
	          break;
	        }
	      }
	    }
	    var newArc = d3_geom_voronoiCreateBeach(site);
	    d3_geom_voronoiBeaches.insert(lArc, newArc);
	    if (!lArc && !rArc) return;
	    if (lArc === rArc) {
	      d3_geom_voronoiDetachCircle(lArc);
	      rArc = d3_geom_voronoiCreateBeach(lArc.site);
	      d3_geom_voronoiBeaches.insert(newArc, rArc);
	      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      d3_geom_voronoiAttachCircle(lArc);
	      d3_geom_voronoiAttachCircle(rArc);
	      return;
	    }
	    if (!rArc) {
	      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      return;
	    }
	    d3_geom_voronoiDetachCircle(lArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
	      x: (cy * hb - by * hc) / d + ax,
	      y: (bx * hc - cx * hb) / d + ay
	    };
	    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
	    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
	    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
	    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
	    if (!pby2) return rfocx;
	    var lArc = arc.P;
	    if (!lArc) return -Infinity;
	    site = lArc.site;
	    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
	    if (!plby2) return lfocx;
	    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
	    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
	    return (rfocx + lfocx) / 2;
	  }
	  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
	    var rArc = arc.N;
	    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
	    var site = arc.site;
	    return site.y === directrix ? site.x : Infinity;
	  }
	  function d3_geom_voronoiCell(site) {
	    this.site = site;
	    this.edges = [];
	  }
	  d3_geom_voronoiCell.prototype.prepare = function() {
	    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
	    while (iHalfEdge--) {
	      edge = halfEdges[iHalfEdge].edge;
	      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
	    }
	    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
	    return halfEdges.length;
	  };
	  function d3_geom_voronoiCloseCells(extent) {
	    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
	    while (iCell--) {
	      cell = cells[iCell];
	      if (!cell || !cell.prepare()) continue;
	      halfEdges = cell.edges;
	      nHalfEdges = halfEdges.length;
	      iHalfEdge = 0;
	      while (iHalfEdge < nHalfEdges) {
	        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
	        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
	        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
	          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
	            x: x0,
	            y: abs(x2 - x0) < ε ? y2 : y1
	          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
	            x: abs(y2 - y1) < ε ? x2 : x1,
	            y: y1
	          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
	            x: x1,
	            y: abs(x2 - x1) < ε ? y2 : y0
	          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
	            x: abs(y2 - y0) < ε ? x2 : x0,
	            y: y0
	          } : null), cell.site, null));
	          ++nHalfEdges;
	        }
	      }
	    }
	  }
	  function d3_geom_voronoiHalfEdgeOrder(a, b) {
	    return b.angle - a.angle;
	  }
	  function d3_geom_voronoiCircle() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.x = this.y = this.arc = this.site = this.cy = null;
	  }
	  function d3_geom_voronoiAttachCircle(arc) {
	    var lArc = arc.P, rArc = arc.N;
	    if (!lArc || !rArc) return;
	    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
	    if (lSite === rSite) return;
	    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
	    var d = 2 * (ax * cy - ay * cx);
	    if (d >= -ε2) return;
	    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
	    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
	    circle.arc = arc;
	    circle.site = cSite;
	    circle.x = x + bx;
	    circle.y = cy + Math.sqrt(x * x + y * y);
	    circle.cy = cy;
	    arc.circle = circle;
	    var before = null, node = d3_geom_voronoiCircles._;
	    while (node) {
	      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
	        if (node.L) node = node.L; else {
	          before = node.P;
	          break;
	        }
	      } else {
	        if (node.R) node = node.R; else {
	          before = node;
	          break;
	        }
	      }
	    }
	    d3_geom_voronoiCircles.insert(before, circle);
	    if (!before) d3_geom_voronoiFirstCircle = circle;
	  }
	  function d3_geom_voronoiDetachCircle(arc) {
	    var circle = arc.circle;
	    if (circle) {
	      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
	      d3_geom_voronoiCircles.remove(circle);
	      d3_geom_voronoiCirclePool.push(circle);
	      d3_geom_voronoiRedBlackNode(circle);
	      arc.circle = null;
	    }
	  }
	  function d3_geom_voronoiClipEdges(extent) {
	    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
	    while (i--) {
	      e = edges[i];
	      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
	        e.a = e.b = null;
	        edges.splice(i, 1);
	      }
	    }
	  }
	  function d3_geom_voronoiConnectEdge(edge, extent) {
	    var vb = edge.b;
	    if (vb) return true;
	    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
	    if (ry === ly) {
	      if (fx < x0 || fx >= x1) return;
	      if (lx > rx) {
	        if (!va) va = {
	          x: fx,
	          y: y0
	        }; else if (va.y >= y1) return;
	        vb = {
	          x: fx,
	          y: y1
	        };
	      } else {
	        if (!va) va = {
	          x: fx,
	          y: y1
	        }; else if (va.y < y0) return;
	        vb = {
	          x: fx,
	          y: y0
	        };
	      }
	    } else {
	      fm = (lx - rx) / (ry - ly);
	      fb = fy - fm * fx;
	      if (fm < -1 || fm > 1) {
	        if (lx > rx) {
	          if (!va) va = {
	            x: (y0 - fb) / fm,
	            y: y0
	          }; else if (va.y >= y1) return;
	          vb = {
	            x: (y1 - fb) / fm,
	            y: y1
	          };
	        } else {
	          if (!va) va = {
	            x: (y1 - fb) / fm,
	            y: y1
	          }; else if (va.y < y0) return;
	          vb = {
	            x: (y0 - fb) / fm,
	            y: y0
	          };
	        }
	      } else {
	        if (ly < ry) {
	          if (!va) va = {
	            x: x0,
	            y: fm * x0 + fb
	          }; else if (va.x >= x1) return;
	          vb = {
	            x: x1,
	            y: fm * x1 + fb
	          };
	        } else {
	          if (!va) va = {
	            x: x1,
	            y: fm * x1 + fb
	          }; else if (va.x < x0) return;
	          vb = {
	            x: x0,
	            y: fm * x0 + fb
	          };
	        }
	      }
	    }
	    edge.a = va;
	    edge.b = vb;
	    return true;
	  }
	  function d3_geom_voronoiEdge(lSite, rSite) {
	    this.l = lSite;
	    this.r = rSite;
	    this.a = this.b = null;
	  }
	  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, rSite);
	    d3_geom_voronoiEdges.push(edge);
	    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
	    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
	    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
	    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
	    return edge;
	  }
	  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, null);
	    edge.a = va;
	    edge.b = vb;
	    d3_geom_voronoiEdges.push(edge);
	    return edge;
	  }
	  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
	    if (!edge.a && !edge.b) {
	      edge.a = vertex;
	      edge.l = lSite;
	      edge.r = rSite;
	    } else if (edge.l === rSite) {
	      edge.b = vertex;
	    } else {
	      edge.a = vertex;
	    }
	  }
	  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
	    var va = edge.a, vb = edge.b;
	    this.edge = edge;
	    this.site = lSite;
	    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
	  }
	  d3_geom_voronoiHalfEdge.prototype = {
	    start: function() {
	      return this.edge.l === this.site ? this.edge.a : this.edge.b;
	    },
	    end: function() {
	      return this.edge.l === this.site ? this.edge.b : this.edge.a;
	    }
	  };
	  function d3_geom_voronoiRedBlackTree() {
	    this._ = null;
	  }
	  function d3_geom_voronoiRedBlackNode(node) {
	    node.U = node.C = node.L = node.R = node.P = node.N = null;
	  }
	  d3_geom_voronoiRedBlackTree.prototype = {
	    insert: function(after, node) {
	      var parent, grandpa, uncle;
	      if (after) {
	        node.P = after;
	        node.N = after.N;
	        if (after.N) after.N.P = node;
	        after.N = node;
	        if (after.R) {
	          after = after.R;
	          while (after.L) after = after.L;
	          after.L = node;
	        } else {
	          after.R = node;
	        }
	        parent = after;
	      } else if (this._) {
	        after = d3_geom_voronoiRedBlackFirst(this._);
	        node.P = null;
	        node.N = after;
	        after.P = after.L = node;
	        parent = after;
	      } else {
	        node.P = node.N = null;
	        this._ = node;
	        parent = null;
	      }
	      node.L = node.R = null;
	      node.U = parent;
	      node.C = true;
	      after = node;
	      while (parent && parent.C) {
	        grandpa = parent.U;
	        if (parent === grandpa.L) {
	          uncle = grandpa.R;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.R) {
	              d3_geom_voronoiRedBlackRotateLeft(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
	          }
	        } else {
	          uncle = grandpa.L;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.L) {
	              d3_geom_voronoiRedBlackRotateRight(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
	          }
	        }
	        parent = after.U;
	      }
	      this._.C = false;
	    },
	    remove: function(node) {
	      if (node.N) node.N.P = node.P;
	      if (node.P) node.P.N = node.N;
	      node.N = node.P = null;
	      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
	      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
	      if (parent) {
	        if (parent.L === node) parent.L = next; else parent.R = next;
	      } else {
	        this._ = next;
	      }
	      if (left && right) {
	        red = next.C;
	        next.C = node.C;
	        next.L = left;
	        left.U = next;
	        if (next !== right) {
	          parent = next.U;
	          next.U = node.U;
	          node = next.R;
	          parent.L = node;
	          next.R = right;
	          right.U = next;
	        } else {
	          next.U = parent;
	          parent = next;
	          node = next.R;
	        }
	      } else {
	        red = node.C;
	        node = next;
	      }
	      if (node) node.U = parent;
	      if (red) return;
	      if (node && node.C) {
	        node.C = false;
	        return;
	      }
	      do {
	        if (node === this._) break;
	        if (node === parent.L) {
	          sibling = parent.R;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            sibling = parent.R;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.R || !sibling.R.C) {
	              sibling.L.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateRight(this, sibling);
	              sibling = parent.R;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.R.C = false;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            node = this._;
	            break;
	          }
	        } else {
	          sibling = parent.L;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            sibling = parent.L;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.L || !sibling.L.C) {
	              sibling.R.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
	              sibling = parent.L;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.L.C = false;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            node = this._;
	            break;
	          }
	        }
	        sibling.C = true;
	        node = parent;
	        parent = parent.U;
	      } while (!node.C);
	      if (node) node.C = false;
	    }
	  };
	  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
	    var p = node, q = node.R, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.R = q.L;
	    if (p.R) p.R.U = p;
	    q.L = p;
	  }
	  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
	    var p = node, q = node.L, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.L = q.R;
	    if (p.L) p.L.U = p;
	    q.R = p;
	  }
	  function d3_geom_voronoiRedBlackFirst(node) {
	    while (node.L) node = node.L;
	    return node;
	  }
	  function d3_geom_voronoi(sites, bbox) {
	    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
	    d3_geom_voronoiEdges = [];
	    d3_geom_voronoiCells = new Array(sites.length);
	    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
	    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
	    while (true) {
	      circle = d3_geom_voronoiFirstCircle;
	      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
	        if (site.x !== x0 || site.y !== y0) {
	          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
	          d3_geom_voronoiAddBeach(site);
	          x0 = site.x, y0 = site.y;
	        }
	        site = sites.pop();
	      } else if (circle) {
	        d3_geom_voronoiRemoveBeach(circle.arc);
	      } else {
	        break;
	      }
	    }
	    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
	    var diagram = {
	      cells: d3_geom_voronoiCells,
	      edges: d3_geom_voronoiEdges
	    };
	    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
	    return diagram;
	  }
	  function d3_geom_voronoiVertexOrder(a, b) {
	    return b.y - a.y || b.x - a.x;
	  }
	  d3.geom.voronoi = function(points) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
	    if (points) return voronoi(points);
	    function voronoi(data) {
	      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
	      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
	        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
	          var s = e.start();
	          return [ s.x, s.y ];
	        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
	        polygon.point = data[i];
	      });
	      return polygons;
	    }
	    function sites(data) {
	      return data.map(function(d, i) {
	        return {
	          x: Math.round(fx(d, i) / ε) * ε,
	          y: Math.round(fy(d, i) / ε) * ε,
	          i: i
	        };
	      });
	    }
	    voronoi.links = function(data) {
	      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
	        return edge.l && edge.r;
	      }).map(function(edge) {
	        return {
	          source: data[edge.l.i],
	          target: data[edge.r.i]
	        };
	      });
	    };
	    voronoi.triangles = function(data) {
	      var triangles = [];
	      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
	        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
	        while (++j < m) {
	          e0 = e1;
	          s0 = s1;
	          e1 = edges[j].edge;
	          s1 = e1.l === site ? e1.r : e1.l;
	          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
	            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
	          }
	        }
	      });
	      return triangles;
	    };
	    voronoi.x = function(_) {
	      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
	    };
	    voronoi.y = function(_) {
	      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
	    };
	    voronoi.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
	      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
	      return voronoi;
	    };
	    voronoi.size = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
	      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
	    };
	    return voronoi;
	  };
	  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
	  function d3_geom_voronoiTriangleArea(a, b, c) {
	    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
	  }
	  d3.geom.delaunay = function(vertices) {
	    return d3.geom.voronoi().triangles(vertices);
	  };
	  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
	    if (compat = arguments.length) {
	      x = d3_geom_quadtreeCompatX;
	      y = d3_geom_quadtreeCompatY;
	      if (compat === 3) {
	        y2 = y1;
	        x2 = x1;
	        y1 = x1 = 0;
	      }
	      return quadtree(points);
	    }
	    function quadtree(data) {
	      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
	      if (x1 != null) {
	        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
	      } else {
	        x2_ = y2_ = -(x1_ = y1_ = Infinity);
	        xs = [], ys = [];
	        n = data.length;
	        if (compat) for (i = 0; i < n; ++i) {
	          d = data[i];
	          if (d.x < x1_) x1_ = d.x;
	          if (d.y < y1_) y1_ = d.y;
	          if (d.x > x2_) x2_ = d.x;
	          if (d.y > y2_) y2_ = d.y;
	          xs.push(d.x);
	          ys.push(d.y);
	        } else for (i = 0; i < n; ++i) {
	          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
	          if (x_ < x1_) x1_ = x_;
	          if (y_ < y1_) y1_ = y_;
	          if (x_ > x2_) x2_ = x_;
	          if (y_ > y2_) y2_ = y_;
	          xs.push(x_);
	          ys.push(y_);
	        }
	      }
	      var dx = x2_ - x1_, dy = y2_ - y1_;
	      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
	      function insert(n, d, x, y, x1, y1, x2, y2) {
	        if (isNaN(x) || isNaN(y)) return;
	        if (n.leaf) {
	          var nx = n.x, ny = n.y;
	          if (nx != null) {
	            if (abs(nx - x) + abs(ny - y) < .01) {
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            } else {
	              var nPoint = n.point;
	              n.x = n.y = n.point = null;
	              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            }
	          } else {
	            n.x = x, n.y = y, n.point = d;
	          }
	        } else {
	          insertChild(n, d, x, y, x1, y1, x2, y2);
	        }
	      }
	      function insertChild(n, d, x, y, x1, y1, x2, y2) {
	        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
	        n.leaf = false;
	        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
	        if (right) x1 = xm; else x2 = xm;
	        if (below) y1 = ym; else y2 = ym;
	        insert(n, d, x, y, x1, y1, x2, y2);
	      }
	      var root = d3_geom_quadtreeNode();
	      root.add = function(d) {
	        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
	      };
	      root.visit = function(f) {
	        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
	      };
	      root.find = function(point) {
	        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
	      };
	      i = -1;
	      if (x1 == null) {
	        while (++i < n) {
	          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
	        }
	        --i;
	      } else data.forEach(root.add);
	      xs = ys = data = d = null;
	      return root;
	    }
	    quadtree.x = function(_) {
	      return arguments.length ? (x = _, quadtree) : x;
	    };
	    quadtree.y = function(_) {
	      return arguments.length ? (y = _, quadtree) : y;
	    };
	    quadtree.extent = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
	      y2 = +_[1][1];
	      return quadtree;
	    };
	    quadtree.size = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
	      return quadtree;
	    };
	    return quadtree;
	  };
	  function d3_geom_quadtreeCompatX(d) {
	    return d.x;
	  }
	  function d3_geom_quadtreeCompatY(d) {
	    return d.y;
	  }
	  function d3_geom_quadtreeNode() {
	    return {
	      leaf: true,
	      nodes: [],
	      point: null,
	      x: null,
	      y: null
	    };
	  }
	  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
	    if (!f(node, x1, y1, x2, y2)) {
	      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
	      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
	      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
	      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
	      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
	    }
	  }
	  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
	    var minDistance2 = Infinity, closestPoint;
	    (function find(node, x1, y1, x2, y2) {
	      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
	      if (point = node.point) {
	        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
	        if (distance2 < minDistance2) {
	          var distance = Math.sqrt(minDistance2 = distance2);
	          x0 = x - distance, y0 = y - distance;
	          x3 = x + distance, y3 = y + distance;
	          closestPoint = point;
	        }
	      }
	      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
	      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
	        if (node = children[i & 3]) switch (i & 3) {
	         case 0:
	          find(node, x1, y1, xm, ym);
	          break;

	         case 1:
	          find(node, xm, y1, x2, ym);
	          break;

	         case 2:
	          find(node, x1, ym, xm, y2);
	          break;

	         case 3:
	          find(node, xm, ym, x2, y2);
	          break;
	        }
	      }
	    })(root, x0, y0, x3, y3);
	    return closestPoint;
	  }
	  d3.interpolateRgb = d3_interpolateRgb;
	  function d3_interpolateRgb(a, b) {
	    a = d3.rgb(a);
	    b = d3.rgb(b);
	    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
	    return function(t) {
	      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
	    };
	  }
	  d3.interpolateObject = d3_interpolateObject;
	  function d3_interpolateObject(a, b) {
	    var i = {}, c = {}, k;
	    for (k in a) {
	      if (k in b) {
	        i[k] = d3_interpolate(a[k], b[k]);
	      } else {
	        c[k] = a[k];
	      }
	    }
	    for (k in b) {
	      if (!(k in a)) {
	        c[k] = b[k];
	      }
	    }
	    return function(t) {
	      for (k in i) c[k] = i[k](t);
	      return c;
	    };
	  }
	  d3.interpolateNumber = d3_interpolateNumber;
	  function d3_interpolateNumber(a, b) {
	    a = +a, b = +b;
	    return function(t) {
	      return a * (1 - t) + b * t;
	    };
	  }
	  d3.interpolateString = d3_interpolateString;
	  function d3_interpolateString(a, b) {
	    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
	    a = a + "", b = b + "";
	    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
	      if ((bs = bm.index) > bi) {
	        bs = b.slice(bi, bs);
	        if (s[i]) s[i] += bs; else s[++i] = bs;
	      }
	      if ((am = am[0]) === (bm = bm[0])) {
	        if (s[i]) s[i] += bm; else s[++i] = bm;
	      } else {
	        s[++i] = null;
	        q.push({
	          i: i,
	          x: d3_interpolateNumber(am, bm)
	        });
	      }
	      bi = d3_interpolate_numberB.lastIndex;
	    }
	    if (bi < b.length) {
	      bs = b.slice(bi);
	      if (s[i]) s[i] += bs; else s[++i] = bs;
	    }
	    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
	      return b(t) + "";
	    }) : function() {
	      return b;
	    } : (b = q.length, function(t) {
	      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    });
	  }
	  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
	  d3.interpolate = d3_interpolate;
	  function d3_interpolate(a, b) {
	    var i = d3.interpolators.length, f;
	    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
	    return f;
	  }
	  d3.interpolators = [ function(a, b) {
	    var t = typeof b;
	    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
	  } ];
	  d3.interpolateArray = d3_interpolateArray;
	  function d3_interpolateArray(a, b) {
	    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
	    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
	    for (;i < na; ++i) c[i] = a[i];
	    for (;i < nb; ++i) c[i] = b[i];
	    return function(t) {
	      for (i = 0; i < n0; ++i) c[i] = x[i](t);
	      return c;
	    };
	  }
	  var d3_ease_default = function() {
	    return d3_identity;
	  };
	  var d3_ease = d3.map({
	    linear: d3_ease_default,
	    poly: d3_ease_poly,
	    quad: function() {
	      return d3_ease_quad;
	    },
	    cubic: function() {
	      return d3_ease_cubic;
	    },
	    sin: function() {
	      return d3_ease_sin;
	    },
	    exp: function() {
	      return d3_ease_exp;
	    },
	    circle: function() {
	      return d3_ease_circle;
	    },
	    elastic: d3_ease_elastic,
	    back: d3_ease_back,
	    bounce: function() {
	      return d3_ease_bounce;
	    }
	  });
	  var d3_ease_mode = d3.map({
	    "in": d3_identity,
	    out: d3_ease_reverse,
	    "in-out": d3_ease_reflect,
	    "out-in": function(f) {
	      return d3_ease_reflect(d3_ease_reverse(f));
	    }
	  });
	  d3.ease = function(name) {
	    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
	    t = d3_ease.get(t) || d3_ease_default;
	    m = d3_ease_mode.get(m) || d3_identity;
	    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
	  };
	  function d3_ease_clamp(f) {
	    return function(t) {
	      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
	    };
	  }
	  function d3_ease_reverse(f) {
	    return function(t) {
	      return 1 - f(1 - t);
	    };
	  }
	  function d3_ease_reflect(f) {
	    return function(t) {
	      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
	    };
	  }
	  function d3_ease_quad(t) {
	    return t * t;
	  }
	  function d3_ease_cubic(t) {
	    return t * t * t;
	  }
	  function d3_ease_cubicInOut(t) {
	    if (t <= 0) return 0;
	    if (t >= 1) return 1;
	    var t2 = t * t, t3 = t2 * t;
	    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
	  }
	  function d3_ease_poly(e) {
	    return function(t) {
	      return Math.pow(t, e);
	    };
	  }
	  function d3_ease_sin(t) {
	    return 1 - Math.cos(t * halfπ);
	  }
	  function d3_ease_exp(t) {
	    return Math.pow(2, 10 * (t - 1));
	  }
	  function d3_ease_circle(t) {
	    return 1 - Math.sqrt(1 - t * t);
	  }
	  function d3_ease_elastic(a, p) {
	    var s;
	    if (arguments.length < 2) p = .45;
	    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
	    return function(t) {
	      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
	    };
	  }
	  function d3_ease_back(s) {
	    if (!s) s = 1.70158;
	    return function(t) {
	      return t * t * ((s + 1) * t - s);
	    };
	  }
	  function d3_ease_bounce(t) {
	    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
	  }
	  d3.interpolateHcl = d3_interpolateHcl;
	  function d3_interpolateHcl(a, b) {
	    a = d3.hcl(a);
	    b = d3.hcl(b);
	    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
	    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateHsl = d3_interpolateHsl;
	  function d3_interpolateHsl(a, b) {
	    a = d3.hsl(a);
	    b = d3.hsl(b);
	    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
	    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateLab = d3_interpolateLab;
	  function d3_interpolateLab(a, b) {
	    a = d3.lab(a);
	    b = d3.lab(b);
	    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
	    return function(t) {
	      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
	    };
	  }
	  d3.interpolateRound = d3_interpolateRound;
	  function d3_interpolateRound(a, b) {
	    b -= a;
	    return function(t) {
	      return Math.round(a + b * t);
	    };
	  }
	  d3.transform = function(string) {
	    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
	    return (d3.transform = function(string) {
	      if (string != null) {
	        g.setAttribute("transform", string);
	        var t = g.transform.baseVal.consolidate();
	      }
	      return new d3_transform(t ? t.matrix : d3_transformIdentity);
	    })(string);
	  };
	  function d3_transform(m) {
	    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
	    if (r0[0] * r1[1] < r1[0] * r0[1]) {
	      r0[0] *= -1;
	      r0[1] *= -1;
	      kx *= -1;
	      kz *= -1;
	    }
	    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
	    this.translate = [ m.e, m.f ];
	    this.scale = [ kx, ky ];
	    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
	  }
	  d3_transform.prototype.toString = function() {
	    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
	  };
	  function d3_transformDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1];
	  }
	  function d3_transformNormalize(a) {
	    var k = Math.sqrt(d3_transformDot(a, a));
	    if (k) {
	      a[0] /= k;
	      a[1] /= k;
	    }
	    return k;
	  }
	  function d3_transformCombine(a, b, k) {
	    a[0] += k * b[0];
	    a[1] += k * b[1];
	    return a;
	  }
	  var d3_transformIdentity = {
	    a: 1,
	    b: 0,
	    c: 0,
	    d: 1,
	    e: 0,
	    f: 0
	  };
	  d3.interpolateTransform = d3_interpolateTransform;
	  function d3_interpolateTransformPop(s) {
	    return s.length ? s.pop() + "," : "";
	  }
	  function d3_interpolateTranslate(ta, tb, s, q) {
	    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
	      var i = s.push("translate(", null, ",", null, ")");
	      q.push({
	        i: i - 4,
	        x: d3_interpolateNumber(ta[0], tb[0])
	      }, {
	        i: i - 2,
	        x: d3_interpolateNumber(ta[1], tb[1])
	      });
	    } else if (tb[0] || tb[1]) {
	      s.push("translate(" + tb + ")");
	    }
	  }
	  function d3_interpolateRotate(ra, rb, s, q) {
	    if (ra !== rb) {
	      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
	      q.push({
	        i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
	        x: d3_interpolateNumber(ra, rb)
	      });
	    } else if (rb) {
	      s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
	    }
	  }
	  function d3_interpolateSkew(wa, wb, s, q) {
	    if (wa !== wb) {
	      q.push({
	        i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
	        x: d3_interpolateNumber(wa, wb)
	      });
	    } else if (wb) {
	      s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
	    }
	  }
	  function d3_interpolateScale(ka, kb, s, q) {
	    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
	      var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
	      q.push({
	        i: i - 4,
	        x: d3_interpolateNumber(ka[0], kb[0])
	      }, {
	        i: i - 2,
	        x: d3_interpolateNumber(ka[1], kb[1])
	      });
	    } else if (kb[0] !== 1 || kb[1] !== 1) {
	      s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
	    }
	  }
	  function d3_interpolateTransform(a, b) {
	    var s = [], q = [];
	    a = d3.transform(a), b = d3.transform(b);
	    d3_interpolateTranslate(a.translate, b.translate, s, q);
	    d3_interpolateRotate(a.rotate, b.rotate, s, q);
	    d3_interpolateSkew(a.skew, b.skew, s, q);
	    d3_interpolateScale(a.scale, b.scale, s, q);
	    a = b = null;
	    return function(t) {
	      var i = -1, n = q.length, o;
	      while (++i < n) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    };
	  }
	  function d3_uninterpolateNumber(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return (x - a) / b;
	    };
	  }
	  function d3_uninterpolateClamp(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return Math.max(0, Math.min(1, (x - a) / b));
	    };
	  }
	  d3.layout = {};
	  d3.layout.bundle = function() {
	    return function(links) {
	      var paths = [], i = -1, n = links.length;
	      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
	      return paths;
	    };
	  };
	  function d3_layout_bundlePath(link) {
	    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
	    while (start !== lca) {
	      start = start.parent;
	      points.push(start);
	    }
	    var k = points.length;
	    while (end !== lca) {
	      points.splice(k, 0, end);
	      end = end.parent;
	    }
	    return points;
	  }
	  function d3_layout_bundleAncestors(node) {
	    var ancestors = [], parent = node.parent;
	    while (parent != null) {
	      ancestors.push(node);
	      node = parent;
	      parent = parent.parent;
	    }
	    ancestors.push(node);
	    return ancestors;
	  }
	  function d3_layout_bundleLeastCommonAncestor(a, b) {
	    if (a === b) return a;
	    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
	    while (aNode === bNode) {
	      sharedNode = aNode;
	      aNode = aNodes.pop();
	      bNode = bNodes.pop();
	    }
	    return sharedNode;
	  }
	  d3.layout.chord = function() {
	    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
	    function relayout() {
	      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
	      chords = [];
	      groups = [];
	      k = 0, i = -1;
	      while (++i < n) {
	        x = 0, j = -1;
	        while (++j < n) {
	          x += matrix[i][j];
	        }
	        groupSums.push(x);
	        subgroupIndex.push(d3.range(n));
	        k += x;
	      }
	      if (sortGroups) {
	        groupIndex.sort(function(a, b) {
	          return sortGroups(groupSums[a], groupSums[b]);
	        });
	      }
	      if (sortSubgroups) {
	        subgroupIndex.forEach(function(d, i) {
	          d.sort(function(a, b) {
	            return sortSubgroups(matrix[i][a], matrix[i][b]);
	          });
	        });
	      }
	      k = (τ - padding * n) / k;
	      x = 0, i = -1;
	      while (++i < n) {
	        x0 = x, j = -1;
	        while (++j < n) {
	          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
	          subgroups[di + "-" + dj] = {
	            index: di,
	            subindex: dj,
	            startAngle: a0,
	            endAngle: a1,
	            value: v
	          };
	        }
	        groups[di] = {
	          index: di,
	          startAngle: x0,
	          endAngle: x,
	          value: groupSums[di]
	        };
	        x += padding;
	      }
	      i = -1;
	      while (++i < n) {
	        j = i - 1;
	        while (++j < n) {
	          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
	          if (source.value || target.value) {
	            chords.push(source.value < target.value ? {
	              source: target,
	              target: source
	            } : {
	              source: source,
	              target: target
	            });
	          }
	        }
	      }
	      if (sortChords) resort();
	    }
	    function resort() {
	      chords.sort(function(a, b) {
	        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
	      });
	    }
	    chord.matrix = function(x) {
	      if (!arguments.length) return matrix;
	      n = (matrix = x) && matrix.length;
	      chords = groups = null;
	      return chord;
	    };
	    chord.padding = function(x) {
	      if (!arguments.length) return padding;
	      padding = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortGroups = function(x) {
	      if (!arguments.length) return sortGroups;
	      sortGroups = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortSubgroups = function(x) {
	      if (!arguments.length) return sortSubgroups;
	      sortSubgroups = x;
	      chords = null;
	      return chord;
	    };
	    chord.sortChords = function(x) {
	      if (!arguments.length) return sortChords;
	      sortChords = x;
	      if (chords) resort();
	      return chord;
	    };
	    chord.chords = function() {
	      if (!chords) relayout();
	      return chords;
	    };
	    chord.groups = function() {
	      if (!groups) relayout();
	      return groups;
	    };
	    return chord;
	  };
	  d3.layout.force = function() {
	    var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
	    function repulse(node) {
	      return function(quad, x1, _, x2) {
	        if (quad.point !== node) {
	          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
	          if (dw * dw / theta2 < dn) {
	            if (dn < chargeDistance2) {
	              var k = quad.charge / dn;
	              node.px -= dx * k;
	              node.py -= dy * k;
	            }
	            return true;
	          }
	          if (quad.point && dn && dn < chargeDistance2) {
	            var k = quad.pointCharge / dn;
	            node.px -= dx * k;
	            node.py -= dy * k;
	          }
	        }
	        return !quad.charge;
	      };
	    }
	    force.tick = function() {
	      if ((alpha *= .99) < .005) {
	        timer = null;
	        event.end({
	          type: "end",
	          alpha: alpha = 0
	        });
	        return true;
	      }
	      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        s = o.source;
	        t = o.target;
	        x = t.x - s.x;
	        y = t.y - s.y;
	        if (l = x * x + y * y) {
	          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
	          x *= l;
	          y *= l;
	          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
	          t.y -= y * k;
	          s.x += x * (k = 1 - k);
	          s.y += y * k;
	        }
	      }
	      if (k = alpha * gravity) {
	        x = size[0] / 2;
	        y = size[1] / 2;
	        i = -1;
	        if (k) while (++i < n) {
	          o = nodes[i];
	          o.x += (x - o.x) * k;
	          o.y += (y - o.y) * k;
	        }
	      }
	      if (charge) {
	        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
	        i = -1;
	        while (++i < n) {
	          if (!(o = nodes[i]).fixed) {
	            q.visit(repulse(o));
	          }
	        }
	      }
	      i = -1;
	      while (++i < n) {
	        o = nodes[i];
	        if (o.fixed) {
	          o.x = o.px;
	          o.y = o.py;
	        } else {
	          o.x -= (o.px - (o.px = o.x)) * friction;
	          o.y -= (o.py - (o.py = o.y)) * friction;
	        }
	      }
	      event.tick({
	        type: "tick",
	        alpha: alpha
	      });
	    };
	    force.nodes = function(x) {
	      if (!arguments.length) return nodes;
	      nodes = x;
	      return force;
	    };
	    force.links = function(x) {
	      if (!arguments.length) return links;
	      links = x;
	      return force;
	    };
	    force.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return force;
	    };
	    force.linkDistance = function(x) {
	      if (!arguments.length) return linkDistance;
	      linkDistance = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.distance = force.linkDistance;
	    force.linkStrength = function(x) {
	      if (!arguments.length) return linkStrength;
	      linkStrength = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.friction = function(x) {
	      if (!arguments.length) return friction;
	      friction = +x;
	      return force;
	    };
	    force.charge = function(x) {
	      if (!arguments.length) return charge;
	      charge = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.chargeDistance = function(x) {
	      if (!arguments.length) return Math.sqrt(chargeDistance2);
	      chargeDistance2 = x * x;
	      return force;
	    };
	    force.gravity = function(x) {
	      if (!arguments.length) return gravity;
	      gravity = +x;
	      return force;
	    };
	    force.theta = function(x) {
	      if (!arguments.length) return Math.sqrt(theta2);
	      theta2 = x * x;
	      return force;
	    };
	    force.alpha = function(x) {
	      if (!arguments.length) return alpha;
	      x = +x;
	      if (alpha) {
	        if (x > 0) {
	          alpha = x;
	        } else {
	          timer.c = null, timer.t = NaN, timer = null;
	          event.end({
	            type: "end",
	            alpha: alpha = 0
	          });
	        }
	      } else if (x > 0) {
	        event.start({
	          type: "start",
	          alpha: alpha = x
	        });
	        timer = d3_timer(force.tick);
	      }
	      return force;
	    };
	    force.start = function() {
	      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
	      for (i = 0; i < n; ++i) {
	        (o = nodes[i]).index = i;
	        o.weight = 0;
	      }
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        if (typeof o.source == "number") o.source = nodes[o.source];
	        if (typeof o.target == "number") o.target = nodes[o.target];
	        ++o.source.weight;
	        ++o.target.weight;
	      }
	      for (i = 0; i < n; ++i) {
	        o = nodes[i];
	        if (isNaN(o.x)) o.x = position("x", w);
	        if (isNaN(o.y)) o.y = position("y", h);
	        if (isNaN(o.px)) o.px = o.x;
	        if (isNaN(o.py)) o.py = o.y;
	      }
	      distances = [];
	      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
	      strengths = [];
	      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
	      charges = [];
	      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
	      function position(dimension, size) {
	        if (!neighbors) {
	          neighbors = new Array(n);
	          for (j = 0; j < n; ++j) {
	            neighbors[j] = [];
	          }
	          for (j = 0; j < m; ++j) {
	            var o = links[j];
	            neighbors[o.source.index].push(o.target);
	            neighbors[o.target.index].push(o.source);
	          }
	        }
	        var candidates = neighbors[i], j = -1, l = candidates.length, x;
	        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
	        return Math.random() * size;
	      }
	      return force.resume();
	    };
	    force.resume = function() {
	      return force.alpha(.1);
	    };
	    force.stop = function() {
	      return force.alpha(0);
	    };
	    force.drag = function() {
	      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
	      if (!arguments.length) return drag;
	      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
	    };
	    function dragmove(d) {
	      d.px = d3.event.x, d.py = d3.event.y;
	      force.resume();
	    }
	    return d3.rebind(force, event, "on");
	  };
	  function d3_layout_forceDragstart(d) {
	    d.fixed |= 2;
	  }
	  function d3_layout_forceDragend(d) {
	    d.fixed &= ~6;
	  }
	  function d3_layout_forceMouseover(d) {
	    d.fixed |= 4;
	    d.px = d.x, d.py = d.y;
	  }
	  function d3_layout_forceMouseout(d) {
	    d.fixed &= ~4;
	  }
	  function d3_layout_forceAccumulate(quad, alpha, charges) {
	    var cx = 0, cy = 0;
	    quad.charge = 0;
	    if (!quad.leaf) {
	      var nodes = quad.nodes, n = nodes.length, i = -1, c;
	      while (++i < n) {
	        c = nodes[i];
	        if (c == null) continue;
	        d3_layout_forceAccumulate(c, alpha, charges);
	        quad.charge += c.charge;
	        cx += c.charge * c.cx;
	        cy += c.charge * c.cy;
	      }
	    }
	    if (quad.point) {
	      if (!quad.leaf) {
	        quad.point.x += Math.random() - .5;
	        quad.point.y += Math.random() - .5;
	      }
	      var k = alpha * charges[quad.point.index];
	      quad.charge += quad.pointCharge = k;
	      cx += k * quad.point.x;
	      cy += k * quad.point.y;
	    }
	    quad.cx = cx / quad.charge;
	    quad.cy = cy / quad.charge;
	  }
	  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
	  d3.layout.hierarchy = function() {
	    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
	    function hierarchy(root) {
	      var stack = [ root ], nodes = [], node;
	      root.depth = 0;
	      while ((node = stack.pop()) != null) {
	        nodes.push(node);
	        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
	          var n, childs, child;
	          while (--n >= 0) {
	            stack.push(child = childs[n]);
	            child.parent = node;
	            child.depth = node.depth + 1;
	          }
	          if (value) node.value = 0;
	          node.children = childs;
	        } else {
	          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          delete node.children;
	        }
	      }
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var childs, parent;
	        if (sort && (childs = node.children)) childs.sort(sort);
	        if (value && (parent = node.parent)) parent.value += node.value;
	      });
	      return nodes;
	    }
	    hierarchy.sort = function(x) {
	      if (!arguments.length) return sort;
	      sort = x;
	      return hierarchy;
	    };
	    hierarchy.children = function(x) {
	      if (!arguments.length) return children;
	      children = x;
	      return hierarchy;
	    };
	    hierarchy.value = function(x) {
	      if (!arguments.length) return value;
	      value = x;
	      return hierarchy;
	    };
	    hierarchy.revalue = function(root) {
	      if (value) {
	        d3_layout_hierarchyVisitBefore(root, function(node) {
	          if (node.children) node.value = 0;
	        });
	        d3_layout_hierarchyVisitAfter(root, function(node) {
	          var parent;
	          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          if (parent = node.parent) parent.value += node.value;
	        });
	      }
	      return root;
	    };
	    return hierarchy;
	  };
	  function d3_layout_hierarchyRebind(object, hierarchy) {
	    d3.rebind(object, hierarchy, "sort", "children", "value");
	    object.nodes = object;
	    object.links = d3_layout_hierarchyLinks;
	    return object;
	  }
	  function d3_layout_hierarchyVisitBefore(node, callback) {
	    var nodes = [ node ];
	    while ((node = nodes.pop()) != null) {
	      callback(node);
	      if ((children = node.children) && (n = children.length)) {
	        var n, children;
	        while (--n >= 0) nodes.push(children[n]);
	      }
	    }
	  }
	  function d3_layout_hierarchyVisitAfter(node, callback) {
	    var nodes = [ node ], nodes2 = [];
	    while ((node = nodes.pop()) != null) {
	      nodes2.push(node);
	      if ((children = node.children) && (n = children.length)) {
	        var i = -1, n, children;
	        while (++i < n) nodes.push(children[i]);
	      }
	    }
	    while ((node = nodes2.pop()) != null) {
	      callback(node);
	    }
	  }
	  function d3_layout_hierarchyChildren(d) {
	    return d.children;
	  }
	  function d3_layout_hierarchyValue(d) {
	    return d.value;
	  }
	  function d3_layout_hierarchySort(a, b) {
	    return b.value - a.value;
	  }
	  function d3_layout_hierarchyLinks(nodes) {
	    return d3.merge(nodes.map(function(parent) {
	      return (parent.children || []).map(function(child) {
	        return {
	          source: parent,
	          target: child
	        };
	      });
	    }));
	  }
	  d3.layout.partition = function() {
	    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
	    function position(node, x, dx, dy) {
	      var children = node.children;
	      node.x = x;
	      node.y = node.depth * dy;
	      node.dx = dx;
	      node.dy = dy;
	      if (children && (n = children.length)) {
	        var i = -1, n, c, d;
	        dx = node.value ? dx / node.value : 0;
	        while (++i < n) {
	          position(c = children[i], x, d = c.value * dx, dy);
	          x += d;
	        }
	      }
	    }
	    function depth(node) {
	      var children = node.children, d = 0;
	      if (children && (n = children.length)) {
	        var i = -1, n;
	        while (++i < n) d = Math.max(d, depth(children[i]));
	      }
	      return 1 + d;
	    }
	    function partition(d, i) {
	      var nodes = hierarchy.call(this, d, i);
	      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
	      return nodes;
	    }
	    partition.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return partition;
	    };
	    return d3_layout_hierarchyRebind(partition, hierarchy);
	  };
	  d3.layout.pie = function() {
	    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
	    function pie(data) {
	      var n = data.length, values = data.map(function(d, i) {
	        return +value.call(pie, d, i);
	      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
	      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
	        return values[j] - values[i];
	      } : function(i, j) {
	        return sort(data[i], data[j]);
	      });
	      index.forEach(function(i) {
	        arcs[i] = {
	          data: data[i],
	          value: v = values[i],
	          startAngle: a,
	          endAngle: a += v * k + pa,
	          padAngle: p
	        };
	      });
	      return arcs;
	    }
	    pie.value = function(_) {
	      if (!arguments.length) return value;
	      value = _;
	      return pie;
	    };
	    pie.sort = function(_) {
	      if (!arguments.length) return sort;
	      sort = _;
	      return pie;
	    };
	    pie.startAngle = function(_) {
	      if (!arguments.length) return startAngle;
	      startAngle = _;
	      return pie;
	    };
	    pie.endAngle = function(_) {
	      if (!arguments.length) return endAngle;
	      endAngle = _;
	      return pie;
	    };
	    pie.padAngle = function(_) {
	      if (!arguments.length) return padAngle;
	      padAngle = _;
	      return pie;
	    };
	    return pie;
	  };
	  var d3_layout_pieSortByValue = {};
	  d3.layout.stack = function() {
	    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
	    function stack(data, index) {
	      if (!(n = data.length)) return data;
	      var series = data.map(function(d, i) {
	        return values.call(stack, d, i);
	      });
	      var points = series.map(function(d) {
	        return d.map(function(v, i) {
	          return [ x.call(stack, v, i), y.call(stack, v, i) ];
	        });
	      });
	      var orders = order.call(stack, points, index);
	      series = d3.permute(series, orders);
	      points = d3.permute(points, orders);
	      var offsets = offset.call(stack, points, index);
	      var m = series[0].length, n, i, j, o;
	      for (j = 0; j < m; ++j) {
	        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
	        for (i = 1; i < n; ++i) {
	          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
	        }
	      }
	      return data;
	    }
	    stack.values = function(x) {
	      if (!arguments.length) return values;
	      values = x;
	      return stack;
	    };
	    stack.order = function(x) {
	      if (!arguments.length) return order;
	      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
	      return stack;
	    };
	    stack.offset = function(x) {
	      if (!arguments.length) return offset;
	      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
	      return stack;
	    };
	    stack.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      return stack;
	    };
	    stack.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      return stack;
	    };
	    stack.out = function(z) {
	      if (!arguments.length) return out;
	      out = z;
	      return stack;
	    };
	    return stack;
	  };
	  function d3_layout_stackX(d) {
	    return d.x;
	  }
	  function d3_layout_stackY(d) {
	    return d.y;
	  }
	  function d3_layout_stackOut(d, y0, y) {
	    d.y0 = y0;
	    d.y = y;
	  }
	  var d3_layout_stackOrders = d3.map({
	    "inside-out": function(data) {
	      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
	        return max[a] - max[b];
	      }), top = 0, bottom = 0, tops = [], bottoms = [];
	      for (i = 0; i < n; ++i) {
	        j = index[i];
	        if (top < bottom) {
	          top += sums[j];
	          tops.push(j);
	        } else {
	          bottom += sums[j];
	          bottoms.push(j);
	        }
	      }
	      return bottoms.reverse().concat(tops);
	    },
	    reverse: function(data) {
	      return d3.range(data.length).reverse();
	    },
	    "default": d3_layout_stackOrderDefault
	  });
	  var d3_layout_stackOffsets = d3.map({
	    silhouette: function(data) {
	      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o > max) max = o;
	        sums.push(o);
	      }
	      for (j = 0; j < m; ++j) {
	        y0[j] = (max - sums[j]) / 2;
	      }
	      return y0;
	    },
	    wiggle: function(data) {
	      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
	      y0[0] = o = o0 = 0;
	      for (j = 1; j < m; ++j) {
	        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
	        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
	          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
	            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
	          }
	          s2 += s3 * data[i][j][1];
	        }
	        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
	        if (o < o0) o0 = o;
	      }
	      for (j = 0; j < m; ++j) y0[j] -= o0;
	      return y0;
	    },
	    expand: function(data) {
	      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
	      }
	      for (j = 0; j < m; ++j) y0[j] = 0;
	      return y0;
	    },
	    zero: d3_layout_stackOffsetZero
	  });
	  function d3_layout_stackOrderDefault(data) {
	    return d3.range(data.length);
	  }
	  function d3_layout_stackOffsetZero(data) {
	    var j = -1, m = data[0].length, y0 = [];
	    while (++j < m) y0[j] = 0;
	    return y0;
	  }
	  function d3_layout_stackMaxIndex(array) {
	    var i = 1, j = 0, v = array[0][1], k, n = array.length;
	    for (;i < n; ++i) {
	      if ((k = array[i][1]) > v) {
	        j = i;
	        v = k;
	      }
	    }
	    return j;
	  }
	  function d3_layout_stackReduceSum(d) {
	    return d.reduce(d3_layout_stackSum, 0);
	  }
	  function d3_layout_stackSum(p, d) {
	    return p + d[1];
	  }
	  d3.layout.histogram = function() {
	    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
	    function histogram(data, i) {
	      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
	      while (++i < m) {
	        bin = bins[i] = [];
	        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
	        bin.y = 0;
	      }
	      if (m > 0) {
	        i = -1;
	        while (++i < n) {
	          x = values[i];
	          if (x >= range[0] && x <= range[1]) {
	            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
	            bin.y += k;
	            bin.push(data[i]);
	          }
	        }
	      }
	      return bins;
	    }
	    histogram.value = function(x) {
	      if (!arguments.length) return valuer;
	      valuer = x;
	      return histogram;
	    };
	    histogram.range = function(x) {
	      if (!arguments.length) return ranger;
	      ranger = d3_functor(x);
	      return histogram;
	    };
	    histogram.bins = function(x) {
	      if (!arguments.length) return binner;
	      binner = typeof x === "number" ? function(range) {
	        return d3_layout_histogramBinFixed(range, x);
	      } : d3_functor(x);
	      return histogram;
	    };
	    histogram.frequency = function(x) {
	      if (!arguments.length) return frequency;
	      frequency = !!x;
	      return histogram;
	    };
	    return histogram;
	  };
	  function d3_layout_histogramBinSturges(range, values) {
	    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
	  }
	  function d3_layout_histogramBinFixed(range, n) {
	    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
	    while (++x <= n) f[x] = m * x + b;
	    return f;
	  }
	  function d3_layout_histogramRange(values) {
	    return [ d3.min(values), d3.max(values) ];
	  }
	  d3.layout.pack = function() {
	    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
	    function pack(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
	        return radius;
	      };
	      root.x = root.y = 0;
	      d3_layout_hierarchyVisitAfter(root, function(d) {
	        d.r = +r(d.value);
	      });
	      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	      if (padding) {
	        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r += dr;
	        });
	        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r -= dr;
	        });
	      }
	      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
	      return nodes;
	    }
	    pack.size = function(_) {
	      if (!arguments.length) return size;
	      size = _;
	      return pack;
	    };
	    pack.radius = function(_) {
	      if (!arguments.length) return radius;
	      radius = _ == null || typeof _ === "function" ? _ : +_;
	      return pack;
	    };
	    pack.padding = function(_) {
	      if (!arguments.length) return padding;
	      padding = +_;
	      return pack;
	    };
	    return d3_layout_hierarchyRebind(pack, hierarchy);
	  };
	  function d3_layout_packSort(a, b) {
	    return a.value - b.value;
	  }
	  function d3_layout_packInsert(a, b) {
	    var c = a._pack_next;
	    a._pack_next = b;
	    b._pack_prev = a;
	    b._pack_next = c;
	    c._pack_prev = b;
	  }
	  function d3_layout_packSplice(a, b) {
	    a._pack_next = b;
	    b._pack_prev = a;
	  }
	  function d3_layout_packIntersects(a, b) {
	    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
	    return .999 * dr * dr > dx * dx + dy * dy;
	  }
	  function d3_layout_packSiblings(node) {
	    if (!(nodes = node.children) || !(n = nodes.length)) return;
	    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
	    function bound(node) {
	      xMin = Math.min(node.x - node.r, xMin);
	      xMax = Math.max(node.x + node.r, xMax);
	      yMin = Math.min(node.y - node.r, yMin);
	      yMax = Math.max(node.y + node.r, yMax);
	    }
	    nodes.forEach(d3_layout_packLink);
	    a = nodes[0];
	    a.x = -a.r;
	    a.y = 0;
	    bound(a);
	    if (n > 1) {
	      b = nodes[1];
	      b.x = b.r;
	      b.y = 0;
	      bound(b);
	      if (n > 2) {
	        c = nodes[2];
	        d3_layout_packPlace(a, b, c);
	        bound(c);
	        d3_layout_packInsert(a, c);
	        a._pack_prev = c;
	        d3_layout_packInsert(c, b);
	        b = a._pack_next;
	        for (i = 3; i < n; i++) {
	          d3_layout_packPlace(a, b, c = nodes[i]);
	          var isect = 0, s1 = 1, s2 = 1;
	          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
	            if (d3_layout_packIntersects(j, c)) {
	              isect = 1;
	              break;
	            }
	          }
	          if (isect == 1) {
	            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
	              if (d3_layout_packIntersects(k, c)) {
	                break;
	              }
	            }
	          }
	          if (isect) {
	            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
	            i--;
	          } else {
	            d3_layout_packInsert(a, c);
	            b = c;
	            bound(c);
	          }
	        }
	      }
	    }
	    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
	    for (i = 0; i < n; i++) {
	      c = nodes[i];
	      c.x -= cx;
	      c.y -= cy;
	      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
	    }
	    node.r = cr;
	    nodes.forEach(d3_layout_packUnlink);
	  }
	  function d3_layout_packLink(node) {
	    node._pack_next = node._pack_prev = node;
	  }
	  function d3_layout_packUnlink(node) {
	    delete node._pack_next;
	    delete node._pack_prev;
	  }
	  function d3_layout_packTransform(node, x, y, k) {
	    var children = node.children;
	    node.x = x += k * node.x;
	    node.y = y += k * node.y;
	    node.r *= k;
	    if (children) {
	      var i = -1, n = children.length;
	      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
	    }
	  }
	  function d3_layout_packPlace(a, b, c) {
	    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
	    if (db && (dx || dy)) {
	      var da = b.r + c.r, dc = dx * dx + dy * dy;
	      da *= da;
	      db *= db;
	      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
	      c.x = a.x + x * dx + y * dy;
	      c.y = a.y + x * dy - y * dx;
	    } else {
	      c.x = a.x + db;
	      c.y = a.y;
	    }
	  }
	  d3.layout.tree = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
	    function tree(d, i) {
	      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
	      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
	      d3_layout_hierarchyVisitBefore(root1, secondWalk);
	      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
	        var left = root0, right = root0, bottom = root0;
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          if (node.x < left.x) left = node;
	          if (node.x > right.x) right = node;
	          if (node.depth > bottom.depth) bottom = node;
	        });
	        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          node.x = (node.x + tx) * kx;
	          node.y = node.depth * ky;
	        });
	      }
	      return nodes;
	    }
	    function wrapTree(root0) {
	      var root1 = {
	        A: null,
	        children: [ root0 ]
	      }, queue = [ root1 ], node1;
	      while ((node1 = queue.pop()) != null) {
	        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
	          queue.push((children[i] = child = {
	            _: children[i],
	            parent: node1,
	            children: (child = children[i].children) && child.slice() || [],
	            A: null,
	            a: null,
	            z: 0,
	            m: 0,
	            c: 0,
	            s: 0,
	            t: null,
	            i: i
	          }).a = child);
	        }
	      }
	      return root1.children[0];
	    }
	    function firstWalk(v) {
	      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
	      if (children.length) {
	        d3_layout_treeShift(v);
	        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
	        if (w) {
	          v.z = w.z + separation(v._, w._);
	          v.m = v.z - midpoint;
	        } else {
	          v.z = midpoint;
	        }
	      } else if (w) {
	        v.z = w.z + separation(v._, w._);
	      }
	      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
	    }
	    function secondWalk(v) {
	      v._.x = v.z + v.parent.m;
	      v.m += v.parent.m;
	    }
	    function apportion(v, w, ancestor) {
	      if (w) {
	        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
	        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
	          vom = d3_layout_treeLeft(vom);
	          vop = d3_layout_treeRight(vop);
	          vop.a = v;
	          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
	          if (shift > 0) {
	            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
	            sip += shift;
	            sop += shift;
	          }
	          sim += vim.m;
	          sip += vip.m;
	          som += vom.m;
	          sop += vop.m;
	        }
	        if (vim && !d3_layout_treeRight(vop)) {
	          vop.t = vim;
	          vop.m += sim - sop;
	        }
	        if (vip && !d3_layout_treeLeft(vom)) {
	          vom.t = vip;
	          vom.m += sip - som;
	          ancestor = v;
	        }
	      }
	      return ancestor;
	    }
	    function sizeNode(node) {
	      node.x *= size[0];
	      node.y = node.depth * size[1];
	    }
	    tree.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return tree;
	    };
	    tree.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null ? sizeNode : null;
	      return tree;
	    };
	    tree.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) == null ? null : sizeNode;
	      return tree;
	    };
	    return d3_layout_hierarchyRebind(tree, hierarchy);
	  };
	  function d3_layout_treeSeparation(a, b) {
	    return a.parent == b.parent ? 1 : 2;
	  }
	  function d3_layout_treeLeft(v) {
	    var children = v.children;
	    return children.length ? children[0] : v.t;
	  }
	  function d3_layout_treeRight(v) {
	    var children = v.children, n;
	    return (n = children.length) ? children[n - 1] : v.t;
	  }
	  function d3_layout_treeMove(wm, wp, shift) {
	    var change = shift / (wp.i - wm.i);
	    wp.c -= change;
	    wp.s += shift;
	    wm.c += change;
	    wp.z += shift;
	    wp.m += shift;
	  }
	  function d3_layout_treeShift(v) {
	    var shift = 0, change = 0, children = v.children, i = children.length, w;
	    while (--i >= 0) {
	      w = children[i];
	      w.z += shift;
	      w.m += shift;
	      shift += w.s + (change += w.c);
	    }
	  }
	  function d3_layout_treeAncestor(vim, v, ancestor) {
	    return vim.a.parent === v.parent ? vim.a : ancestor;
	  }
	  d3.layout.cluster = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
	    function cluster(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var children = node.children;
	        if (children && children.length) {
	          node.x = d3_layout_clusterX(children);
	          node.y = d3_layout_clusterY(children);
	        } else {
	          node.x = previousNode ? x += separation(node, previousNode) : 0;
	          node.y = 0;
	          previousNode = node;
	        }
	      });
	      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
	      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
	        node.x = (node.x - root.x) * size[0];
	        node.y = (root.y - node.y) * size[1];
	      } : function(node) {
	        node.x = (node.x - x0) / (x1 - x0) * size[0];
	        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
	      });
	      return nodes;
	    }
	    cluster.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return cluster;
	    };
	    cluster.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null;
	      return cluster;
	    };
	    cluster.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) != null;
	      return cluster;
	    };
	    return d3_layout_hierarchyRebind(cluster, hierarchy);
	  };
	  function d3_layout_clusterY(children) {
	    return 1 + d3.max(children, function(child) {
	      return child.y;
	    });
	  }
	  function d3_layout_clusterX(children) {
	    return children.reduce(function(x, child) {
	      return x + child.x;
	    }, 0) / children.length;
	  }
	  function d3_layout_clusterLeft(node) {
	    var children = node.children;
	    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
	  }
	  function d3_layout_clusterRight(node) {
	    var children = node.children, n;
	    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
	  }
	  d3.layout.treemap = function() {
	    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
	    function scale(children, k) {
	      var i = -1, n = children.length, child, area;
	      while (++i < n) {
	        area = (child = children[i]).value * (k < 0 ? 0 : k);
	        child.area = isNaN(area) || area <= 0 ? 0 : area;
	      }
	    }
	    function squarify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while ((n = remaining.length) > 0) {
	          row.push(child = remaining[n - 1]);
	          row.area += child.area;
	          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
	            remaining.pop();
	            best = score;
	          } else {
	            row.area -= row.pop().area;
	            position(row, u, rect, false);
	            u = Math.min(rect.dx, rect.dy);
	            row.length = row.area = 0;
	            best = Infinity;
	          }
	        }
	        if (row.length) {
	          position(row, u, rect, true);
	          row.length = row.area = 0;
	        }
	        children.forEach(squarify);
	      }
	    }
	    function stickify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), remaining = children.slice(), child, row = [];
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while (child = remaining.pop()) {
	          row.push(child);
	          row.area += child.area;
	          if (child.z != null) {
	            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
	            row.length = row.area = 0;
	          }
	        }
	        children.forEach(stickify);
	      }
	    }
	    function worst(row, u) {
	      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
	      while (++i < n) {
	        if (!(r = row[i].area)) continue;
	        if (r < rmin) rmin = r;
	        if (r > rmax) rmax = r;
	      }
	      s *= s;
	      u *= u;
	      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
	    }
	    function position(row, u, rect, flush) {
	      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
	      if (u == rect.dx) {
	        if (flush || v > rect.dy) v = rect.dy;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dy = v;
	          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
	        }
	        o.z = true;
	        o.dx += rect.x + rect.dx - x;
	        rect.y += v;
	        rect.dy -= v;
	      } else {
	        if (flush || v > rect.dx) v = rect.dx;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dx = v;
	          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
	        }
	        o.z = false;
	        o.dy += rect.y + rect.dy - y;
	        rect.x += v;
	        rect.dx -= v;
	      }
	    }
	    function treemap(d) {
	      var nodes = stickies || hierarchy(d), root = nodes[0];
	      root.x = root.y = 0;
	      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;
	      if (stickies) hierarchy.revalue(root);
	      scale([ root ], root.dx * root.dy / root.value);
	      (stickies ? stickify : squarify)(root);
	      if (sticky) stickies = nodes;
	      return nodes;
	    }
	    treemap.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return treemap;
	    };
	    treemap.padding = function(x) {
	      if (!arguments.length) return padding;
	      function padFunction(node) {
	        var p = x.call(treemap, node, node.depth);
	        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
	      }
	      function padConstant(node) {
	        return d3_layout_treemapPad(node, x);
	      }
	      var type;
	      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
	      padConstant) : padConstant;
	      return treemap;
	    };
	    treemap.round = function(x) {
	      if (!arguments.length) return round != Number;
	      round = x ? Math.round : Number;
	      return treemap;
	    };
	    treemap.sticky = function(x) {
	      if (!arguments.length) return sticky;
	      sticky = x;
	      stickies = null;
	      return treemap;
	    };
	    treemap.ratio = function(x) {
	      if (!arguments.length) return ratio;
	      ratio = x;
	      return treemap;
	    };
	    treemap.mode = function(x) {
	      if (!arguments.length) return mode;
	      mode = x + "";
	      return treemap;
	    };
	    return d3_layout_hierarchyRebind(treemap, hierarchy);
	  };
	  function d3_layout_treemapPadNull(node) {
	    return {
	      x: node.x,
	      y: node.y,
	      dx: node.dx,
	      dy: node.dy
	    };
	  }
	  function d3_layout_treemapPad(node, padding) {
	    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
	    if (dx < 0) {
	      x += dx / 2;
	      dx = 0;
	    }
	    if (dy < 0) {
	      y += dy / 2;
	      dy = 0;
	    }
	    return {
	      x: x,
	      y: y,
	      dx: dx,
	      dy: dy
	    };
	  }
	  d3.random = {
	    normal: function(µ, σ) {
	      var n = arguments.length;
	      if (n < 2) σ = 1;
	      if (n < 1) µ = 0;
	      return function() {
	        var x, y, r;
	        do {
	          x = Math.random() * 2 - 1;
	          y = Math.random() * 2 - 1;
	          r = x * x + y * y;
	        } while (!r || r > 1);
	        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
	      };
	    },
	    logNormal: function() {
	      var random = d3.random.normal.apply(d3, arguments);
	      return function() {
	        return Math.exp(random());
	      };
	    },
	    bates: function(m) {
	      var random = d3.random.irwinHall(m);
	      return function() {
	        return random() / m;
	      };
	    },
	    irwinHall: function(m) {
	      return function() {
	        for (var s = 0, j = 0; j < m; j++) s += Math.random();
	        return s;
	      };
	    }
	  };
	  d3.scale = {};
	  function d3_scaleExtent(domain) {
	    var start = domain[0], stop = domain[domain.length - 1];
	    return start < stop ? [ start, stop ] : [ stop, start ];
	  }
	  function d3_scaleRange(scale) {
	    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
	  }
	  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
	    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
	    return function(x) {
	      return i(u(x));
	    };
	  }
	  function d3_scale_nice(domain, nice) {
	    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
	    if (x1 < x0) {
	      dx = i0, i0 = i1, i1 = dx;
	      dx = x0, x0 = x1, x1 = dx;
	    }
	    domain[i0] = nice.floor(x0);
	    domain[i1] = nice.ceil(x1);
	    return domain;
	  }
	  function d3_scale_niceStep(step) {
	    return step ? {
	      floor: function(x) {
	        return Math.floor(x / step) * step;
	      },
	      ceil: function(x) {
	        return Math.ceil(x / step) * step;
	      }
	    } : d3_scale_niceIdentity;
	  }
	  var d3_scale_niceIdentity = {
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
	    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
	    if (domain[k] < domain[0]) {
	      domain = domain.slice().reverse();
	      range = range.slice().reverse();
	    }
	    while (++j <= k) {
	      u.push(uninterpolate(domain[j - 1], domain[j]));
	      i.push(interpolate(range[j - 1], range[j]));
	    }
	    return function(x) {
	      var j = d3.bisect(domain, x, 1, k) - 1;
	      return i[j](u[j](x));
	    };
	  }
	  d3.scale.linear = function() {
	    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
	  };
	  function d3_scale_linear(domain, range, interpolate, clamp) {
	    var output, input;
	    function rescale() {
	      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
	      output = linear(domain, range, uninterpolate, interpolate);
	      input = linear(range, domain, uninterpolate, d3_interpolate);
	      return scale;
	    }
	    function scale(x) {
	      return output(x);
	    }
	    scale.invert = function(y) {
	      return input(y);
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(Number);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.rangeRound = function(x) {
	      return scale.range(x).interpolate(d3_interpolateRound);
	    };
	    scale.clamp = function(x) {
	      if (!arguments.length) return clamp;
	      clamp = x;
	      return rescale();
	    };
	    scale.interpolate = function(x) {
	      if (!arguments.length) return interpolate;
	      interpolate = x;
	      return rescale();
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      d3_scale_linearNice(domain, m);
	      return rescale();
	    };
	    scale.copy = function() {
	      return d3_scale_linear(domain, range, interpolate, clamp);
	    };
	    return rescale();
	  }
	  function d3_scale_linearRebind(scale, linear) {
	    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
	  }
	  function d3_scale_linearNice(domain, m) {
	    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
	    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
	    return domain;
	  }
	  function d3_scale_linearTickRange(domain, m) {
	    if (m == null) m = 10;
	    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
	    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
	    extent[0] = Math.ceil(extent[0] / step) * step;
	    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
	    extent[2] = step;
	    return extent;
	  }
	  function d3_scale_linearTicks(domain, m) {
	    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
	  }
	  function d3_scale_linearTickFormat(domain, m, format) {
	    var range = d3_scale_linearTickRange(domain, m);
	    if (format) {
	      var match = d3_format_re.exec(format);
	      match.shift();
	      if (match[8] === "s") {
	        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
	        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
	        match[8] = "f";
	        format = d3.format(match.join(""));
	        return function(d) {
	          return format(prefix.scale(d)) + prefix.symbol;
	        };
	      }
	      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
	      format = match.join("");
	    } else {
	      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
	    }
	    return d3.format(format);
	  }
	  var d3_scale_linearFormatSignificant = {
	    s: 1,
	    g: 1,
	    p: 1,
	    r: 1,
	    e: 1
	  };
	  function d3_scale_linearPrecision(value) {
	    return -Math.floor(Math.log(value) / Math.LN10 + .01);
	  }
	  function d3_scale_linearFormatPrecision(type, range) {
	    var p = d3_scale_linearPrecision(range[2]);
	    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
	  }
	  d3.scale.log = function() {
	    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
	  };
	  function d3_scale_log(linear, base, positive, domain) {
	    function log(x) {
	      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
	    }
	    function pow(x) {
	      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
	    }
	    function scale(x) {
	      return linear(log(x));
	    }
	    scale.invert = function(x) {
	      return pow(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      positive = x[0] >= 0;
	      linear.domain((domain = x.map(Number)).map(log));
	      return scale;
	    };
	    scale.base = function(_) {
	      if (!arguments.length) return base;
	      base = +_;
	      linear.domain(domain.map(log));
	      return scale;
	    };
	    scale.nice = function() {
	      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
	      linear.domain(niced);
	      domain = niced.map(pow);
	      return scale;
	    };
	    scale.ticks = function() {
	      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
	      if (isFinite(j - i)) {
	        if (positive) {
	          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
	          ticks.push(pow(i));
	        } else {
	          ticks.push(pow(i));
	          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
	        }
	        for (i = 0; ticks[i] < u; i++) {}
	        for (j = ticks.length; ticks[j - 1] > v; j--) {}
	        ticks = ticks.slice(i, j);
	      }
	      return ticks;
	    };
	    scale.tickFormat = function(n, format) {
	      if (!arguments.length) return d3_scale_logFormat;
	      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
	      var k = Math.max(1, base * n / scale.ticks().length);
	      return function(d) {
	        var i = d / pow(Math.round(log(d)));
	        if (i * base < base - .5) i *= base;
	        return i <= k ? format(d) : "";
	      };
	    };
	    scale.copy = function() {
	      return d3_scale_log(linear.copy(), base, positive, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
	    floor: function(x) {
	      return -Math.ceil(-x);
	    },
	    ceil: function(x) {
	      return -Math.floor(-x);
	    }
	  };
	  d3.scale.pow = function() {
	    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
	  };
	  function d3_scale_pow(linear, exponent, domain) {
	    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
	    function scale(x) {
	      return linear(powp(x));
	    }
	    scale.invert = function(x) {
	      return powb(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      linear.domain((domain = x.map(Number)).map(powp));
	      return scale;
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      return scale.domain(d3_scale_linearNice(domain, m));
	    };
	    scale.exponent = function(x) {
	      if (!arguments.length) return exponent;
	      powp = d3_scale_powPow(exponent = x);
	      powb = d3_scale_powPow(1 / exponent);
	      linear.domain(domain.map(powp));
	      return scale;
	    };
	    scale.copy = function() {
	      return d3_scale_pow(linear.copy(), exponent, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_scale_powPow(e) {
	    return function(x) {
	      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
	    };
	  }
	  d3.scale.sqrt = function() {
	    return d3.scale.pow().exponent(.5);
	  };
	  d3.scale.ordinal = function() {
	    return d3_scale_ordinal([], {
	      t: "range",
	      a: [ [] ]
	    });
	  };
	  function d3_scale_ordinal(domain, ranger) {
	    var index, range, rangeBand;
	    function scale(x) {
	      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
	    }
	    function steps(start, step) {
	      return d3.range(domain.length).map(function(i) {
	        return start + step * i;
	      });
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = [];
	      index = new d3_Map();
	      var i = -1, n = x.length, xi;
	      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
	      return scale[ranger.t].apply(scale, ranger.a);
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      rangeBand = 0;
	      ranger = {
	        t: "range",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangePoints = function(x, padding) {
	      if (arguments.length < 2) padding = 0;
	      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
	      0) : (stop - start) / (domain.length - 1 + padding);
	      range = steps(start + step * padding / 2, step);
	      rangeBand = 0;
	      ranger = {
	        t: "rangePoints",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeRoundPoints = function(x, padding) {
	      if (arguments.length < 2) padding = 0;
	      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
	      0) : (stop - start) / (domain.length - 1 + padding) | 0;
	      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
	      rangeBand = 0;
	      ranger = {
	        t: "rangeRoundPoints",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
	      range = steps(start + step * outerPadding, step);
	      if (reverse) range.reverse();
	      rangeBand = step * (1 - padding);
	      ranger = {
	        t: "rangeBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeRoundBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
	      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
	      if (reverse) range.reverse();
	      rangeBand = Math.round(step * (1 - padding));
	      ranger = {
	        t: "rangeRoundBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBand = function() {
	      return rangeBand;
	    };
	    scale.rangeExtent = function() {
	      return d3_scaleExtent(ranger.a[0]);
	    };
	    scale.copy = function() {
	      return d3_scale_ordinal(domain, ranger);
	    };
	    return scale.domain(domain);
	  }
	  d3.scale.category10 = function() {
	    return d3.scale.ordinal().range(d3_category10);
	  };
	  d3.scale.category20 = function() {
	    return d3.scale.ordinal().range(d3_category20);
	  };
	  d3.scale.category20b = function() {
	    return d3.scale.ordinal().range(d3_category20b);
	  };
	  d3.scale.category20c = function() {
	    return d3.scale.ordinal().range(d3_category20c);
	  };
	  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
	  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
	  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
	  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
	  d3.scale.quantile = function() {
	    return d3_scale_quantile([], []);
	  };
	  function d3_scale_quantile(domain, range) {
	    var thresholds;
	    function rescale() {
	      var k = 0, q = range.length;
	      thresholds = [];
	      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
	      return scale;
	    }
	    function scale(x) {
	      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.quantiles = function() {
	      return thresholds;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantile(domain, range);
	    };
	    return rescale();
	  }
	  d3.scale.quantize = function() {
	    return d3_scale_quantize(0, 1, [ 0, 1 ]);
	  };
	  function d3_scale_quantize(x0, x1, range) {
	    var kx, i;
	    function scale(x) {
	      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
	    }
	    function rescale() {
	      kx = range.length / (x1 - x0);
	      i = range.length - 1;
	      return scale;
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return [ x0, x1 ];
	      x0 = +x[0];
	      x1 = +x[x.length - 1];
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      y = y < 0 ? NaN : y / kx + x0;
	      return [ y, y + 1 / kx ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantize(x0, x1, range);
	    };
	    return rescale();
	  }
	  d3.scale.threshold = function() {
	    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
	  };
	  function d3_scale_threshold(domain, range) {
	    function scale(x) {
	      if (x <= x) return range[d3.bisect(domain, x)];
	    }
	    scale.domain = function(_) {
	      if (!arguments.length) return domain;
	      domain = _;
	      return scale;
	    };
	    scale.range = function(_) {
	      if (!arguments.length) return range;
	      range = _;
	      return scale;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return [ domain[y - 1], domain[y] ];
	    };
	    scale.copy = function() {
	      return d3_scale_threshold(domain, range);
	    };
	    return scale;
	  }
	  d3.scale.identity = function() {
	    return d3_scale_identity([ 0, 1 ]);
	  };
	  function d3_scale_identity(domain) {
	    function identity(x) {
	      return +x;
	    }
	    identity.invert = identity;
	    identity.domain = identity.range = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(identity);
	      return identity;
	    };
	    identity.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    identity.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    identity.copy = function() {
	      return d3_scale_identity(domain);
	    };
	    return identity;
	  }
	  d3.svg = {};
	  function d3_zero() {
	    return 0;
	  }
	  d3.svg.arc = function() {
	    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
	    function arc() {
	      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
	      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
	      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
	      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
	      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
	        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
	        if (!cw) p1 *= -1;
	        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
	        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
	      }
	      if (r1) {
	        x0 = r1 * Math.cos(a0 + p1);
	        y0 = r1 * Math.sin(a0 + p1);
	        x1 = r1 * Math.cos(a1 - p1);
	        y1 = r1 * Math.sin(a1 - p1);
	        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
	        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
	          var h1 = (a0 + a1) / 2;
	          x0 = r1 * Math.cos(h1);
	          y0 = r1 * Math.sin(h1);
	          x1 = y1 = null;
	        }
	      } else {
	        x0 = y0 = 0;
	      }
	      if (r0) {
	        x2 = r0 * Math.cos(a1 - p0);
	        y2 = r0 * Math.sin(a1 - p0);
	        x3 = r0 * Math.cos(a0 + p0);
	        y3 = r0 * Math.sin(a0 + p0);
	        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
	        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
	          var h0 = (a0 + a1) / 2;
	          x2 = r0 * Math.cos(h0);
	          y2 = r0 * Math.sin(h0);
	          x3 = y3 = null;
	        }
	      } else {
	        x2 = y2 = 0;
	      }
	      if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
	        cr = r0 < r1 ^ cw ? 0 : 1;
	        var rc1 = rc, rc0 = rc;
	        if (da < π) {
	          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
	          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
	          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
	        }
	        if (x1 != null) {
	          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
	          if (rc === rc1) {
	            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
	          } else {
	            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
	          }
	        } else {
	          path.push("M", x0, ",", y0);
	        }
	        if (x3 != null) {
	          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
	          if (rc === rc0) {
	            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
	          } else {
	            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
	          }
	        } else {
	          path.push("L", x2, ",", y2);
	        }
	      } else {
	        path.push("M", x0, ",", y0);
	        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
	        path.push("L", x2, ",", y2);
	        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
	      }
	      path.push("Z");
	      return path.join("");
	    }
	    function circleSegment(r1, cw) {
	      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
	    }
	    arc.innerRadius = function(v) {
	      if (!arguments.length) return innerRadius;
	      innerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.outerRadius = function(v) {
	      if (!arguments.length) return outerRadius;
	      outerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.cornerRadius = function(v) {
	      if (!arguments.length) return cornerRadius;
	      cornerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.padRadius = function(v) {
	      if (!arguments.length) return padRadius;
	      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
	      return arc;
	    };
	    arc.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return arc;
	    };
	    arc.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return arc;
	    };
	    arc.padAngle = function(v) {
	      if (!arguments.length) return padAngle;
	      padAngle = d3_functor(v);
	      return arc;
	    };
	    arc.centroid = function() {
	      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
	      return [ Math.cos(a) * r, Math.sin(a) * r ];
	    };
	    return arc;
	  };
	  var d3_svg_arcAuto = "auto";
	  function d3_svg_arcInnerRadius(d) {
	    return d.innerRadius;
	  }
	  function d3_svg_arcOuterRadius(d) {
	    return d.outerRadius;
	  }
	  function d3_svg_arcStartAngle(d) {
	    return d.startAngle;
	  }
	  function d3_svg_arcEndAngle(d) {
	    return d.endAngle;
	  }
	  function d3_svg_arcPadAngle(d) {
	    return d && d.padAngle;
	  }
	  function d3_svg_arcSweep(x0, y0, x1, y1) {
	    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
	  }
	  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
	    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
	    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
	    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
	  }
	  function d3_svg_line(projection) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
	    function line(data) {
	      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
	      function segment() {
	        segments.push("M", interpolate(projection(points), tension));
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
	        } else if (points.length) {
	          segment();
	          points = [];
	        }
	      }
	      if (points.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    line.x = function(_) {
	      if (!arguments.length) return x;
	      x = _;
	      return line;
	    };
	    line.y = function(_) {
	      if (!arguments.length) return y;
	      y = _;
	      return line;
	    };
	    line.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return line;
	    };
	    line.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      return line;
	    };
	    line.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return line;
	    };
	    return line;
	  }
	  d3.svg.line = function() {
	    return d3_svg_line(d3_identity);
	  };
	  var d3_svg_lineInterpolators = d3.map({
	    linear: d3_svg_lineLinear,
	    "linear-closed": d3_svg_lineLinearClosed,
	    step: d3_svg_lineStep,
	    "step-before": d3_svg_lineStepBefore,
	    "step-after": d3_svg_lineStepAfter,
	    basis: d3_svg_lineBasis,
	    "basis-open": d3_svg_lineBasisOpen,
	    "basis-closed": d3_svg_lineBasisClosed,
	    bundle: d3_svg_lineBundle,
	    cardinal: d3_svg_lineCardinal,
	    "cardinal-open": d3_svg_lineCardinalOpen,
	    "cardinal-closed": d3_svg_lineCardinalClosed,
	    monotone: d3_svg_lineMonotone
	  });
	  d3_svg_lineInterpolators.forEach(function(key, value) {
	    value.key = key;
	    value.closed = /-closed$/.test(key);
	  });
	  function d3_svg_lineLinear(points) {
	    return points.length > 1 ? points.join("L") : points + "Z";
	  }
	  function d3_svg_lineLinearClosed(points) {
	    return points.join("L") + "Z";
	  }
	  function d3_svg_lineStep(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
	    if (n > 1) path.push("H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepBefore(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepAfter(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
	    return path.join("");
	  }
	  function d3_svg_lineCardinalOpen(points, tension) {
	    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineCardinalClosed(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
	    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
	  }
	  function d3_svg_lineCardinal(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineHermite(points, tangents) {
	    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
	      return d3_svg_lineLinear(points);
	    }
	    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
	    if (quad) {
	      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
	      p0 = points[1];
	      pi = 2;
	    }
	    if (tangents.length > 1) {
	      t = tangents[1];
	      p = points[pi];
	      pi++;
	      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      for (var i = 2; i < tangents.length; i++, pi++) {
	        p = points[pi];
	        t = tangents[i];
	        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      }
	    }
	    if (quad) {
	      var lp = points[pi];
	      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
	    }
	    return path;
	  }
	  function d3_svg_lineCardinalTangents(points, tension) {
	    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
	    while (++i < n) {
	      p0 = p1;
	      p1 = p2;
	      p2 = points[i];
	      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineBasis(points) {
	    if (points.length < 3) return d3_svg_lineLinear(points);
	    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    points.push(points[n - 1]);
	    while (++i <= n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    points.pop();
	    path.push("L", pi);
	    return path.join("");
	  }
	  function d3_svg_lineBasisOpen(points) {
	    if (points.length < 4) return d3_svg_lineLinear(points);
	    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
	    while (++i < 3) {
	      pi = points[i];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
	    --i;
	    while (++i < n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBasisClosed(points) {
	    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
	    while (++i < 4) {
	      pi = points[i % n];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    --i;
	    while (++i < m) {
	      pi = points[i % n];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBundle(points, tension) {
	    var n = points.length - 1;
	    if (n) {
	      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
	      while (++i <= n) {
	        p = points[i];
	        t = i / n;
	        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
	        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
	      }
	    }
	    return d3_svg_lineBasis(points);
	  }
	  function d3_svg_lineDot4(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
	  }
	  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
	  function d3_svg_lineBasisBezier(path, x, y) {
	    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
	  }
	  function d3_svg_lineSlope(p0, p1) {
	    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
	  }
	  function d3_svg_lineFiniteDifferences(points) {
	    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
	    while (++i < j) {
	      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
	    }
	    m[i] = d;
	    return m;
	  }
	  function d3_svg_lineMonotoneTangents(points) {
	    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
	    while (++i < j) {
	      d = d3_svg_lineSlope(points[i], points[i + 1]);
	      if (abs(d) < ε) {
	        m[i] = m[i + 1] = 0;
	      } else {
	        a = m[i] / d;
	        b = m[i + 1] / d;
	        s = a * a + b * b;
	        if (s > 9) {
	          s = d * 3 / Math.sqrt(s);
	          m[i] = s * a;
	          m[i + 1] = s * b;
	        }
	      }
	    }
	    i = -1;
	    while (++i <= j) {
	      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
	      tangents.push([ s || 0, m[i] * s || 0 ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineMonotone(points) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
	  }
	  d3.svg.line.radial = function() {
	    var line = d3_svg_line(d3_svg_lineRadial);
	    line.radius = line.x, delete line.x;
	    line.angle = line.y, delete line.y;
	    return line;
	  };
	  function d3_svg_lineRadial(points) {
	    var point, i = -1, n = points.length, r, a;
	    while (++i < n) {
	      point = points[i];
	      r = point[0];
	      a = point[1] - halfπ;
	      point[0] = r * Math.cos(a);
	      point[1] = r * Math.sin(a);
	    }
	    return points;
	  }
	  function d3_svg_area(projection) {
	    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
	    function area(data) {
	      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
	        return x;
	      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
	        return y;
	      } : d3_functor(y1), x, y;
	      function segment() {
	        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
	          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
	        } else if (points0.length) {
	          segment();
	          points0 = [];
	          points1 = [];
	        }
	      }
	      if (points0.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    area.x = function(_) {
	      if (!arguments.length) return x1;
	      x0 = x1 = _;
	      return area;
	    };
	    area.x0 = function(_) {
	      if (!arguments.length) return x0;
	      x0 = _;
	      return area;
	    };
	    area.x1 = function(_) {
	      if (!arguments.length) return x1;
	      x1 = _;
	      return area;
	    };
	    area.y = function(_) {
	      if (!arguments.length) return y1;
	      y0 = y1 = _;
	      return area;
	    };
	    area.y0 = function(_) {
	      if (!arguments.length) return y0;
	      y0 = _;
	      return area;
	    };
	    area.y1 = function(_) {
	      if (!arguments.length) return y1;
	      y1 = _;
	      return area;
	    };
	    area.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return area;
	    };
	    area.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      interpolateReverse = interpolate.reverse || interpolate;
	      L = interpolate.closed ? "M" : "L";
	      return area;
	    };
	    area.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return area;
	    };
	    return area;
	  }
	  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
	  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
	  d3.svg.area = function() {
	    return d3_svg_area(d3_identity);
	  };
	  d3.svg.area.radial = function() {
	    var area = d3_svg_area(d3_svg_lineRadial);
	    area.radius = area.x, delete area.x;
	    area.innerRadius = area.x0, delete area.x0;
	    area.outerRadius = area.x1, delete area.x1;
	    area.angle = area.y, delete area.y;
	    area.startAngle = area.y0, delete area.y0;
	    area.endAngle = area.y1, delete area.y1;
	    return area;
	  };
	  d3.svg.chord = function() {
	    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
	    function chord(d, i) {
	      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
	      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
	    }
	    function subgroup(self, f, d, i) {
	      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
	      return {
	        r: r,
	        a0: a0,
	        a1: a1,
	        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
	        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
	      };
	    }
	    function equals(a, b) {
	      return a.a0 == b.a0 && a.a1 == b.a1;
	    }
	    function arc(r, p, a) {
	      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
	    }
	    function curve(r0, p0, r1, p1) {
	      return "Q 0,0 " + p1;
	    }
	    chord.radius = function(v) {
	      if (!arguments.length) return radius;
	      radius = d3_functor(v);
	      return chord;
	    };
	    chord.source = function(v) {
	      if (!arguments.length) return source;
	      source = d3_functor(v);
	      return chord;
	    };
	    chord.target = function(v) {
	      if (!arguments.length) return target;
	      target = d3_functor(v);
	      return chord;
	    };
	    chord.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return chord;
	    };
	    chord.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return chord;
	    };
	    return chord;
	  };
	  function d3_svg_chordRadius(d) {
	    return d.radius;
	  }
	  d3.svg.diagonal = function() {
	    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
	    function diagonal(d, i) {
	      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
	        x: p0.x,
	        y: m
	      }, {
	        x: p3.x,
	        y: m
	      }, p3 ];
	      p = p.map(projection);
	      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
	    }
	    diagonal.source = function(x) {
	      if (!arguments.length) return source;
	      source = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.target = function(x) {
	      if (!arguments.length) return target;
	      target = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.projection = function(x) {
	      if (!arguments.length) return projection;
	      projection = x;
	      return diagonal;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalProjection(d) {
	    return [ d.x, d.y ];
	  }
	  d3.svg.diagonal.radial = function() {
	    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
	    diagonal.projection = function(x) {
	      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalRadialProjection(projection) {
	    return function() {
	      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
	      return [ r * Math.cos(a), r * Math.sin(a) ];
	    };
	  }
	  d3.svg.symbol = function() {
	    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
	    function symbol(d, i) {
	      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
	    }
	    symbol.type = function(x) {
	      if (!arguments.length) return type;
	      type = d3_functor(x);
	      return symbol;
	    };
	    symbol.size = function(x) {
	      if (!arguments.length) return size;
	      size = d3_functor(x);
	      return symbol;
	    };
	    return symbol;
	  };
	  function d3_svg_symbolSize() {
	    return 64;
	  }
	  function d3_svg_symbolType() {
	    return "circle";
	  }
	  function d3_svg_symbolCircle(size) {
	    var r = Math.sqrt(size / π);
	    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
	  }
	  var d3_svg_symbols = d3.map({
	    circle: d3_svg_symbolCircle,
	    cross: function(size) {
	      var r = Math.sqrt(size / 5) / 2;
	      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
	    },
	    diamond: function(size) {
	      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
	      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
	    },
	    square: function(size) {
	      var r = Math.sqrt(size) / 2;
	      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
	    },
	    "triangle-down": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
	    },
	    "triangle-up": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
	    }
	  });
	  d3.svg.symbolTypes = d3_svg_symbols.keys();
	  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
	  d3_selectionPrototype.transition = function(name) {
	    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
	      time: Date.now(),
	      ease: d3_ease_cubicInOut,
	      delay: 0,
	      duration: 250
	    };
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_selectionPrototype.interrupt = function(name) {
	    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
	  };
	  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
	  function d3_selection_interruptNS(ns) {
	    return function() {
	      var lock, activeId, active;
	      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
	        active.timer.c = null;
	        active.timer.t = NaN;
	        if (--lock.count) delete lock[activeId]; else delete this[ns];
	        lock.active += .5;
	        active.event && active.event.interrupt.call(this, this.__data__, active.index);
	      }
	    };
	  }
	  function d3_transition(groups, ns, id) {
	    d3_subclass(groups, d3_transitionPrototype);
	    groups.namespace = ns;
	    groups.id = id;
	    return groups;
	  }
	  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
	  d3_transitionPrototype.call = d3_selectionPrototype.call;
	  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
	  d3_transitionPrototype.node = d3_selectionPrototype.node;
	  d3_transitionPrototype.size = d3_selectionPrototype.size;
	  d3.transition = function(selection, name) {
	    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
	  };
	  d3.transition.prototype = d3_transitionPrototype;
	  d3_transitionPrototype.select = function(selector) {
	    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
	          if ("__data__" in node) subnode.__data__ = node.__data__;
	          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
	          subgroup.push(subnode);
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_transitionPrototype.selectAll = function(selector) {
	    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          transition = node[ns][id];
	          subnodes = selector.call(node, node.__data__, i, j);
	          subgroups.push(subgroup = []);
	          for (var k = -1, o = subnodes.length; ++k < o; ) {
	            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
	            subgroup.push(subnode);
	          }
	        }
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_transitionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_transition(subgroups, this.namespace, this.id);
	  };
	  d3_transitionPrototype.tween = function(name, tween) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
	    return d3_selection_each(this, tween == null ? function(node) {
	      node[ns][id].tween.remove(name);
	    } : function(node) {
	      node[ns][id].tween.set(name, tween);
	    });
	  };
	  function d3_transition_tween(groups, name, value, tween) {
	    var id = groups.id, ns = groups.namespace;
	    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
	    } : (value = tween(value), function(node) {
	      node[ns][id].tween.set(name, value);
	    }));
	  }
	  d3_transitionPrototype.attr = function(nameNS, value) {
	    if (arguments.length < 2) {
	      for (value in nameNS) this.attr(value, nameNS[value]);
	      return this;
	    }
	    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrTween(b) {
	      return b == null ? attrNull : (b += "", function() {
	        var a = this.getAttribute(name), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttribute(name, i(t));
	        });
	      });
	    }
	    function attrTweenNS(b) {
	      return b == null ? attrNullNS : (b += "", function() {
	        var a = this.getAttributeNS(name.space, name.local), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttributeNS(name.space, name.local, i(t));
	        });
	      });
	    }
	    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.attrTween = function(nameNS, tween) {
	    var name = d3.ns.qualify(nameNS);
	    function attrTween(d, i) {
	      var f = tween.call(this, d, i, this.getAttribute(name));
	      return f && function(t) {
	        this.setAttribute(name, f(t));
	      };
	    }
	    function attrTweenNS(d, i) {
	      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
	      return f && function(t) {
	        this.setAttributeNS(name.space, name.local, f(t));
	      };
	    }
	    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.style(priority, name[priority], value);
	        return this;
	      }
	      priority = "";
	    }
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleString(b) {
	      return b == null ? styleNull : (b += "", function() {
	        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
	        return a !== b && (i = d3_interpolate(a, b), function(t) {
	          this.style.setProperty(name, i(t), priority);
	        });
	      });
	    }
	    return d3_transition_tween(this, "style." + name, value, styleString);
	  };
	  d3_transitionPrototype.styleTween = function(name, tween, priority) {
	    if (arguments.length < 3) priority = "";
	    function styleTween(d, i) {
	      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
	      return f && function(t) {
	        this.style.setProperty(name, f(t), priority);
	      };
	    }
	    return this.tween("style." + name, styleTween);
	  };
	  d3_transitionPrototype.text = function(value) {
	    return d3_transition_tween(this, "text", value, d3_transition_text);
	  };
	  function d3_transition_text(b) {
	    if (b == null) b = "";
	    return function() {
	      this.textContent = b;
	    };
	  }
	  d3_transitionPrototype.remove = function() {
	    var ns = this.namespace;
	    return this.each("end.transition", function() {
	      var p;
	      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
	    });
	  };
	  d3_transitionPrototype.ease = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].ease;
	    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
	    return d3_selection_each(this, function(node) {
	      node[ns][id].ease = value;
	    });
	  };
	  d3_transitionPrototype.delay = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].delay;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].delay = +value.call(node, node.__data__, i, j);
	    } : (value = +value, function(node) {
	      node[ns][id].delay = value;
	    }));
	  };
	  d3_transitionPrototype.duration = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].duration;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
	    } : (value = Math.max(1, value), function(node) {
	      node[ns][id].duration = value;
	    }));
	  };
	  d3_transitionPrototype.each = function(type, listener) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 2) {
	      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
	      try {
	        d3_transitionInheritId = id;
	        d3_selection_each(this, function(node, i, j) {
	          d3_transitionInherit = node[ns][id];
	          type.call(node, node.__data__, i, j);
	        });
	      } finally {
	        d3_transitionInherit = inherit;
	        d3_transitionInheritId = inheritId;
	      }
	    } else {
	      d3_selection_each(this, function(node) {
	        var transition = node[ns][id];
	        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
	      });
	    }
	    return this;
	  };
	  d3_transitionPrototype.transition = function() {
	    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if (node = group[i]) {
	          transition = node[ns][id0];
	          d3_transitionNode(node, i, ns, id1, {
	            time: transition.time,
	            ease: transition.ease,
	            delay: transition.delay + transition.duration,
	            duration: transition.duration
	          });
	        }
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, ns, id1);
	  };
	  function d3_transitionNamespace(name) {
	    return name == null ? "__transition__" : "__transition_" + name + "__";
	  }
	  function d3_transitionNode(node, i, ns, id, inherit) {
	    var lock = node[ns] || (node[ns] = {
	      active: 0,
	      count: 0
	    }), transition = lock[id], time, timer, duration, ease, tweens;
	    function schedule(elapsed) {
	      var delay = transition.delay;
	      timer.t = delay + time;
	      if (delay <= elapsed) return start(elapsed - delay);
	      timer.c = start;
	    }
	    function start(elapsed) {
	      var activeId = lock.active, active = lock[activeId];
	      if (active) {
	        active.timer.c = null;
	        active.timer.t = NaN;
	        --lock.count;
	        delete lock[activeId];
	        active.event && active.event.interrupt.call(node, node.__data__, active.index);
	      }
	      for (var cancelId in lock) {
	        if (+cancelId < id) {
	          var cancel = lock[cancelId];
	          cancel.timer.c = null;
	          cancel.timer.t = NaN;
	          --lock.count;
	          delete lock[cancelId];
	        }
	      }
	      timer.c = tick;
	      d3_timer(function() {
	        if (timer.c && tick(elapsed || 1)) {
	          timer.c = null;
	          timer.t = NaN;
	        }
	        return 1;
	      }, 0, time);
	      lock.active = id;
	      transition.event && transition.event.start.call(node, node.__data__, i);
	      tweens = [];
	      transition.tween.forEach(function(key, value) {
	        if (value = value.call(node, node.__data__, i)) {
	          tweens.push(value);
	        }
	      });
	      ease = transition.ease;
	      duration = transition.duration;
	    }
	    function tick(elapsed) {
	      var t = elapsed / duration, e = ease(t), n = tweens.length;
	      while (n > 0) {
	        tweens[--n].call(node, e);
	      }
	      if (t >= 1) {
	        transition.event && transition.event.end.call(node, node.__data__, i);
	        if (--lock.count) delete lock[id]; else delete node[ns];
	        return 1;
	      }
	    }
	    if (!transition) {
	      time = inherit.time;
	      timer = d3_timer(schedule, 0, time);
	      transition = lock[id] = {
	        tween: new d3_Map(),
	        time: time,
	        timer: timer,
	        delay: inherit.delay,
	        duration: inherit.duration,
	        ease: inherit.ease,
	        index: i
	      };
	      inherit = null;
	      ++lock.count;
	    }
	  }
	  d3.svg.axis = function() {
	    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
	    function axis(g) {
	      g.each(function() {
	        var g = d3.select(this);
	        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
	        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
	        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
	        d3.transition(path));
	        tickEnter.append("line");
	        tickEnter.append("text");
	        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
	        if (orient === "bottom" || orient === "top") {
	          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
	          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
	          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
	        } else {
	          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
	          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
	          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
	        }
	        lineEnter.attr(y2, sign * innerTickSize);
	        textEnter.attr(y1, sign * tickSpacing);
	        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
	        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
	        if (scale1.rangeBand) {
	          var x = scale1, dx = x.rangeBand() / 2;
	          scale0 = scale1 = function(d) {
	            return x(d) + dx;
	          };
	        } else if (scale0.rangeBand) {
	          scale0 = scale1;
	        } else {
	          tickExit.call(tickTransform, scale1, scale0);
	        }
	        tickEnter.call(tickTransform, scale0, scale1);
	        tickUpdate.call(tickTransform, scale1, scale1);
	      });
	    }
	    axis.scale = function(x) {
	      if (!arguments.length) return scale;
	      scale = x;
	      return axis;
	    };
	    axis.orient = function(x) {
	      if (!arguments.length) return orient;
	      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
	      return axis;
	    };
	    axis.ticks = function() {
	      if (!arguments.length) return tickArguments_;
	      tickArguments_ = d3_array(arguments);
	      return axis;
	    };
	    axis.tickValues = function(x) {
	      if (!arguments.length) return tickValues;
	      tickValues = x;
	      return axis;
	    };
	    axis.tickFormat = function(x) {
	      if (!arguments.length) return tickFormat_;
	      tickFormat_ = x;
	      return axis;
	    };
	    axis.tickSize = function(x) {
	      var n = arguments.length;
	      if (!n) return innerTickSize;
	      innerTickSize = +x;
	      outerTickSize = +arguments[n - 1];
	      return axis;
	    };
	    axis.innerTickSize = function(x) {
	      if (!arguments.length) return innerTickSize;
	      innerTickSize = +x;
	      return axis;
	    };
	    axis.outerTickSize = function(x) {
	      if (!arguments.length) return outerTickSize;
	      outerTickSize = +x;
	      return axis;
	    };
	    axis.tickPadding = function(x) {
	      if (!arguments.length) return tickPadding;
	      tickPadding = +x;
	      return axis;
	    };
	    axis.tickSubdivide = function() {
	      return arguments.length && axis;
	    };
	    return axis;
	  };
	  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
	    top: 1,
	    right: 1,
	    bottom: 1,
	    left: 1
	  };
	  function d3_svg_axisX(selection, x0, x1) {
	    selection.attr("transform", function(d) {
	      var v0 = x0(d);
	      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
	    });
	  }
	  function d3_svg_axisY(selection, y0, y1) {
	    selection.attr("transform", function(d) {
	      var v0 = y0(d);
	      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
	    });
	  }
	  d3.svg.brush = function() {
	    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
	    function brush(g) {
	      g.each(function() {
	        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
	        var background = g.selectAll(".background").data([ 0 ]);
	        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
	        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
	        var resize = g.selectAll(".resize").data(resizes, d3_identity);
	        resize.exit().remove();
	        resize.enter().append("g").attr("class", function(d) {
	          return "resize " + d;
	        }).style("cursor", function(d) {
	          return d3_svg_brushCursor[d];
	        }).append("rect").attr("x", function(d) {
	          return /[ew]$/.test(d) ? -3 : null;
	        }).attr("y", function(d) {
	          return /^[ns]/.test(d) ? -3 : null;
	        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
	        resize.style("display", brush.empty() ? "none" : null);
	        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
	        if (x) {
	          range = d3_scaleRange(x);
	          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
	          redrawX(gUpdate);
	        }
	        if (y) {
	          range = d3_scaleRange(y);
	          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
	          redrawY(gUpdate);
	        }
	        redraw(gUpdate);
	      });
	    }
	    brush.event = function(g) {
	      g.each(function() {
	        var event_ = event.of(this, arguments), extent1 = {
	          x: xExtent,
	          y: yExtent,
	          i: xExtentDomain,
	          j: yExtentDomain
	        }, extent0 = this.__chart__ || extent1;
	        this.__chart__ = extent1;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.brush", function() {
	            xExtentDomain = extent0.i;
	            yExtentDomain = extent0.j;
	            xExtent = extent0.x;
	            yExtent = extent0.y;
	            event_({
	              type: "brushstart"
	            });
	          }).tween("brush:brush", function() {
	            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
	            xExtentDomain = yExtentDomain = null;
	            return function(t) {
	              xExtent = extent1.x = xi(t);
	              yExtent = extent1.y = yi(t);
	              event_({
	                type: "brush",
	                mode: "resize"
	              });
	            };
	          }).each("end.brush", function() {
	            xExtentDomain = extent1.i;
	            yExtentDomain = extent1.j;
	            event_({
	              type: "brush",
	              mode: "resize"
	            });
	            event_({
	              type: "brushend"
	            });
	          });
	        } else {
	          event_({
	            type: "brushstart"
	          });
	          event_({
	            type: "brush",
	            mode: "resize"
	          });
	          event_({
	            type: "brushend"
	          });
	        }
	      });
	    };
	    function redraw(g) {
	      g.selectAll(".resize").attr("transform", function(d) {
	        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
	      });
	    }
	    function redrawX(g) {
	      g.select(".extent").attr("x", xExtent[0]);
	      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
	    }
	    function redrawY(g) {
	      g.select(".extent").attr("y", yExtent[0]);
	      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
	    }
	    function brushstart() {
	      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
	      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
	      if (d3.event.changedTouches) {
	        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
	      } else {
	        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
	      }
	      g.interrupt().selectAll("*").interrupt();
	      if (dragging) {
	        origin[0] = xExtent[0] - origin[0];
	        origin[1] = yExtent[0] - origin[1];
	      } else if (resizing) {
	        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
	        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
	        origin[0] = xExtent[ex];
	        origin[1] = yExtent[ey];
	      } else if (d3.event.altKey) center = origin.slice();
	      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
	      d3.select("body").style("cursor", eventTarget.style("cursor"));
	      event_({
	        type: "brushstart"
	      });
	      brushmove();
	      function keydown() {
	        if (d3.event.keyCode == 32) {
	          if (!dragging) {
	            center = null;
	            origin[0] -= xExtent[1];
	            origin[1] -= yExtent[1];
	            dragging = 2;
	          }
	          d3_eventPreventDefault();
	        }
	      }
	      function keyup() {
	        if (d3.event.keyCode == 32 && dragging == 2) {
	          origin[0] += xExtent[1];
	          origin[1] += yExtent[1];
	          dragging = 0;
	          d3_eventPreventDefault();
	        }
	      }
	      function brushmove() {
	        var point = d3.mouse(target), moved = false;
	        if (offset) {
	          point[0] += offset[0];
	          point[1] += offset[1];
	        }
	        if (!dragging) {
	          if (d3.event.altKey) {
	            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
	            origin[0] = xExtent[+(point[0] < center[0])];
	            origin[1] = yExtent[+(point[1] < center[1])];
	          } else center = null;
	        }
	        if (resizingX && move1(point, x, 0)) {
	          redrawX(g);
	          moved = true;
	        }
	        if (resizingY && move1(point, y, 1)) {
	          redrawY(g);
	          moved = true;
	        }
	        if (moved) {
	          redraw(g);
	          event_({
	            type: "brush",
	            mode: dragging ? "move" : "resize"
	          });
	        }
	      }
	      function move1(point, scale, i) {
	        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
	        if (dragging) {
	          r0 -= position;
	          r1 -= size + position;
	        }
	        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
	        if (dragging) {
	          max = (min += position) + size;
	        } else {
	          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
	          if (position < min) {
	            max = min;
	            min = position;
	          } else {
	            max = position;
	          }
	        }
	        if (extent[0] != min || extent[1] != max) {
	          if (i) yExtentDomain = null; else xExtentDomain = null;
	          extent[0] = min;
	          extent[1] = max;
	          return true;
	        }
	      }
	      function brushend() {
	        brushmove();
	        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
	        d3.select("body").style("cursor", null);
	        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
	        dragRestore();
	        event_({
	          type: "brushend"
	        });
	      }
	    }
	    brush.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.clamp = function(z) {
	      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
	      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
	      return brush;
	    };
	    brush.extent = function(z) {
	      var x0, x1, y0, y1, t;
	      if (!arguments.length) {
	        if (x) {
	          if (xExtentDomain) {
	            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
	          } else {
	            x0 = xExtent[0], x1 = xExtent[1];
	            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
	            if (x1 < x0) t = x0, x0 = x1, x1 = t;
	          }
	        }
	        if (y) {
	          if (yExtentDomain) {
	            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
	          } else {
	            y0 = yExtent[0], y1 = yExtent[1];
	            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
	            if (y1 < y0) t = y0, y0 = y1, y1 = t;
	          }
	        }
	        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
	      }
	      if (x) {
	        x0 = z[0], x1 = z[1];
	        if (y) x0 = x0[0], x1 = x1[0];
	        xExtentDomain = [ x0, x1 ];
	        if (x.invert) x0 = x(x0), x1 = x(x1);
	        if (x1 < x0) t = x0, x0 = x1, x1 = t;
	        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
	      }
	      if (y) {
	        y0 = z[0], y1 = z[1];
	        if (x) y0 = y0[1], y1 = y1[1];
	        yExtentDomain = [ y0, y1 ];
	        if (y.invert) y0 = y(y0), y1 = y(y1);
	        if (y1 < y0) t = y0, y0 = y1, y1 = t;
	        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
	      }
	      return brush;
	    };
	    brush.clear = function() {
	      if (!brush.empty()) {
	        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
	        xExtentDomain = yExtentDomain = null;
	      }
	      return brush;
	    };
	    brush.empty = function() {
	      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
	    };
	    return d3.rebind(brush, event, "on");
	  };
	  var d3_svg_brushCursor = {
	    n: "ns-resize",
	    e: "ew-resize",
	    s: "ns-resize",
	    w: "ew-resize",
	    nw: "nwse-resize",
	    ne: "nesw-resize",
	    se: "nwse-resize",
	    sw: "nesw-resize"
	  };
	  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
	  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
	  var d3_time_formatUtc = d3_time_format.utc;
	  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
	  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
	  function d3_time_formatIsoNative(date) {
	    return date.toISOString();
	  }
	  d3_time_formatIsoNative.parse = function(string) {
	    var date = new Date(string);
	    return isNaN(date) ? null : date;
	  };
	  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
	  d3_time.second = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 1e3) * 1e3);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
	  }, function(date) {
	    return date.getSeconds();
	  });
	  d3_time.seconds = d3_time.second.range;
	  d3_time.seconds.utc = d3_time.second.utc.range;
	  d3_time.minute = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 6e4) * 6e4);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
	  }, function(date) {
	    return date.getMinutes();
	  });
	  d3_time.minutes = d3_time.minute.range;
	  d3_time.minutes.utc = d3_time.minute.utc.range;
	  d3_time.hour = d3_time_interval(function(date) {
	    var timezone = date.getTimezoneOffset() / 60;
	    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
	  }, function(date) {
	    return date.getHours();
	  });
	  d3_time.hours = d3_time.hour.range;
	  d3_time.hours.utc = d3_time.hour.utc.range;
	  d3_time.month = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setDate(1);
	    return date;
	  }, function(date, offset) {
	    date.setMonth(date.getMonth() + offset);
	  }, function(date) {
	    return date.getMonth();
	  });
	  d3_time.months = d3_time.month.range;
	  d3_time.months.utc = d3_time.month.utc.range;
	  function d3_time_scale(linear, methods, format) {
	    function scale(x) {
	      return linear(x);
	    }
	    scale.invert = function(x) {
	      return d3_time_scaleDate(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
	      linear.domain(x);
	      return scale;
	    };
	    function tickMethod(extent, count) {
	      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
	      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
	        return d / 31536e6;
	      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
	    }
	    scale.nice = function(interval, skip) {
	      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
	      if (method) interval = method[0], skip = method[1];
	      function skipped(date) {
	        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
	      }
	      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
	        floor: function(date) {
	          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
	          return date;
	        },
	        ceil: function(date) {
	          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
	          return date;
	        }
	      } : interval));
	    };
	    scale.ticks = function(interval, skip) {
	      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
	        range: interval
	      }, skip ];
	      if (method) interval = method[0], skip = method[1];
	      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
	    };
	    scale.tickFormat = function() {
	      return format;
	    };
	    scale.copy = function() {
	      return d3_time_scale(linear.copy(), methods, format);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_time_scaleDate(t) {
	    return new Date(t);
	  }
	  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
	  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
	  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
	    return d.getMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getHours();
	  } ], [ "%a %d", function(d) {
	    return d.getDay() && d.getDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getMonth();
	  } ], [ "%Y", d3_true ] ]);
	  var d3_time_scaleMilliseconds = {
	    range: function(start, stop, step) {
	      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
	    },
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  d3_time_scaleLocalMethods.year = d3_time.year;
	  d3_time.scale = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
	  };
	  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
	    return [ m[0].utc, m[1] ];
	  });
	  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
	    return d.getUTCMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getUTCSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getUTCMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getUTCHours();
	  } ], [ "%a %d", function(d) {
	    return d.getUTCDay() && d.getUTCDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getUTCDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getUTCMonth();
	  } ], [ "%Y", d3_true ] ]);
	  d3_time_scaleUtcMethods.year = d3_time.year.utc;
	  d3_time.scale.utc = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
	  };
	  d3.text = d3_xhrType(function(request) {
	    return request.responseText;
	  });
	  d3.json = function(url, callback) {
	    return d3_xhr(url, "application/json", d3_json, callback);
	  };
	  function d3_json(request) {
	    return JSON.parse(request.responseText);
	  }
	  d3.html = function(url, callback) {
	    return d3_xhr(url, "text/html", d3_html, callback);
	  };
	  function d3_html(request) {
	    var range = d3_document.createRange();
	    range.selectNode(d3_document.body);
	    return range.createContextualFragment(request.responseText);
	  }
	  d3.xml = d3_xhrType(function(request) {
	    return request.responseXML;
	  });
	  if (true) this.d3 = d3, !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else if (typeof module === "object" && module.exports) module.exports = d3; else this.d3 = d3;
	}();

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var d3 = __webpack_require__(1);

	d3.legend = __webpack_require__(3);

	module.exports = d3;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	  color: __webpack_require__(4),
	  size: __webpack_require__(6),
	  symbol: __webpack_require__(7)
	};


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var helper = __webpack_require__(5);

	module.exports = function(){

	  var scale = d3.scale.linear(),
	    shape = "rect",
	    shapeWidth = 15,
	    shapeHeight = 15,
	    shapeRadius = 10,
	    shapePadding = 2,
	    cells = [5],
	    labels = [],
	    classPrefix = "",
	    useClass = false,
	    title = "",
	    labelFormat = d3.format(".01f"),
	    labelOffset = 10,
	    labelAlign = "middle",
	    labelDelimiter = "to",
	    orient = "vertical",
	    ascending = false,
	    path,
	    legendDispatcher = d3.dispatch("cellover", "cellout", "cellclick");

	    function legend(svg){

	      var type = helper.d3_calcType(scale, ascending, cells, labels, labelFormat, labelDelimiter),
	        legendG = svg.selectAll('g').data([scale]);

	      legendG.enter().append('g').attr('class', classPrefix + 'legendCells');


	      var cell = legendG.selectAll("." + classPrefix + "cell").data(type.data),
	        cellEnter = cell.enter().append("g", ".cell").attr("class", classPrefix + "cell").style("opacity", 1e-6);
	        shapeEnter = cellEnter.append(shape).attr("class", classPrefix + "swatch"),
	        shapes = cell.select("g." + classPrefix + "cell " + shape);

	      //add event handlers
	      helper.d3_addEvents(cellEnter, legendDispatcher);

	      cell.exit().transition().style("opacity", 0).remove();

	      helper.d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, path);

	      helper.d3_addText(legendG, cellEnter, type.labels, classPrefix)

	      // sets placement
	      var text = cell.select("text"),
	        shapeSize = shapes[0].map( function(d){ return d.getBBox(); });

	      //sets scale
	      //everything is fill except for line which is stroke,
	      if (!useClass){
	        if (shape == "line"){
	          shapes.style("stroke", type.feature);
	        } else {
	          shapes.style("fill", type.feature);
	        }
	      } else {
	        shapes.attr("class", function(d){ return classPrefix + "swatch " + type.feature(d); });
	      }

	      var cellTrans,
	      textTrans,
	      textAlign = (labelAlign == "start") ? 0 : (labelAlign == "middle") ? 0.5 : 1;

	      //positions cells and text
	      if (orient === "vertical"){
	        cellTrans = function(d,i) { return "translate(0, " + (i * (shapeSize[i].height + shapePadding)) + ")"; };
	        textTrans = function(d,i) { return "translate(" + (shapeSize[i].width + shapeSize[i].x +
	          labelOffset) + "," + (shapeSize[i].y + shapeSize[i].height/2 + 5) + ")"; };

	      } else if (orient === "horizontal"){
	        cellTrans = function(d,i) { return "translate(" + (i * (shapeSize[i].width + shapePadding)) + ",0)"; }
	        textTrans = function(d,i) { return "translate(" + (shapeSize[i].width*textAlign  + shapeSize[i].x) +
	          "," + (shapeSize[i].height + shapeSize[i].y + labelOffset + 8) + ")"; };
	      }

	      helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
	      helper.d3_title(svg, legendG, title, classPrefix);

	      cell.transition().style("opacity", 1);

	    }



	  legend.scale = function(_) {
	    if (!arguments.length) return scale;
	    scale = _;
	    return legend;
	  };

	  legend.cells = function(_) {
	    if (!arguments.length) return cells;
	    if (_.length > 1 || _ >= 2 ){
	      cells = _;
	    }
	    return legend;
	  };

	  legend.shape = function(_, d) {
	    if (!arguments.length) return shape;
	    if (_ == "rect" || _ == "circle" || _ == "line" || (_ == "path" && (typeof d === 'string')) ){
	      shape = _;
	      path = d;
	    }
	    return legend;
	  };

	  legend.shapeWidth = function(_) {
	    if (!arguments.length) return shapeWidth;
	    shapeWidth = +_;
	    return legend;
	  };

	  legend.shapeHeight = function(_) {
	    if (!arguments.length) return shapeHeight;
	    shapeHeight = +_;
	    return legend;
	  };

	  legend.shapeRadius = function(_) {
	    if (!arguments.length) return shapeRadius;
	    shapeRadius = +_;
	    return legend;
	  };

	  legend.shapePadding = function(_) {
	    if (!arguments.length) return shapePadding;
	    shapePadding = +_;
	    return legend;
	  };

	  legend.labels = function(_) {
	    if (!arguments.length) return labels;
	    labels = _;
	    return legend;
	  };

	  legend.labelAlign = function(_) {
	    if (!arguments.length) return labelAlign;
	    if (_ == "start" || _ == "end" || _ == "middle") {
	      labelAlign = _;
	    }
	    return legend;
	  };

	  legend.labelFormat = function(_) {
	    if (!arguments.length) return labelFormat;
	    labelFormat = _;
	    return legend;
	  };

	  legend.labelOffset = function(_) {
	    if (!arguments.length) return labelOffset;
	    labelOffset = +_;
	    return legend;
	  };

	  legend.labelDelimiter = function(_) {
	    if (!arguments.length) return labelDelimiter;
	    labelDelimiter = _;
	    return legend;
	  };

	  legend.useClass = function(_) {
	    if (!arguments.length) return useClass;
	    if (_ === true || _ === false){
	      useClass = _;
	    }
	    return legend;
	  };

	  legend.orient = function(_){
	    if (!arguments.length) return orient;
	    _ = _.toLowerCase();
	    if (_ == "horizontal" || _ == "vertical") {
	      orient = _;
	    }
	    return legend;
	  };

	  legend.ascending = function(_) {
	    if (!arguments.length) return ascending;
	    ascending = !!_;
	    return legend;
	  };

	  legend.classPrefix = function(_) {
	    if (!arguments.length) return classPrefix;
	    classPrefix = _;
	    return legend;
	  };

	  legend.title = function(_) {
	    if (!arguments.length) return title;
	    title = _;
	    return legend;
	  };

	  d3.rebind(legend, legendDispatcher, "on");

	  return legend;

	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = {

	  d3_identity: function (d) {
	    return d;
	  },

	  d3_mergeLabels: function (gen, labels) {

	      if(labels.length === 0) return gen;

	      gen = (gen) ? gen : [];

	      var i = labels.length;
	      for (; i < gen.length; i++) {
	        labels.push(gen[i]);
	      }
	      return labels;
	    },

	  d3_linearLegend: function (scale, cells, labelFormat) {
	    var data = [];

	    if (cells.length > 1){
	      data = cells;

	    } else {
	      var domain = scale.domain(),
	      increment = (domain[domain.length - 1] - domain[0])/(cells - 1),
	      i = 0;

	      for (; i < cells; i++){
	        data.push(domain[0] + i*increment);
	      }
	    }

	    var labels = data.map(labelFormat);

	    return {data: data,
	            labels: labels,
	            feature: function(d){ return scale(d); }};
	  },

	  d3_quantLegend: function (scale, labelFormat, labelDelimiter) {
	    var labels = scale.range().map(function(d){
	      var invert = scale.invertExtent(d),
	      a = labelFormat(invert[0]),
	      b = labelFormat(invert[1]);

	      // if (( (a) && (a.isNan()) && b){
	      //   console.log("in initial statement")
	        return labelFormat(invert[0]) + " " + labelDelimiter + " " + labelFormat(invert[1]);
	      // } else if (a || b) {
	      //   console.log('in else statement')
	      //   return (a) ? a : b;
	      // }

	    });

	    return {data: scale.range(),
	            labels: labels,
	            feature: this.d3_identity
	          };
	  },

	  d3_ordinalLegend: function (scale) {
	    return {data: scale.domain(),
	            labels: scale.domain(),
	            feature: function(d){ return scale(d); }};
	  },

	  d3_drawShapes: function (shape, shapes, shapeHeight, shapeWidth, shapeRadius, path) {
	    if (shape === "rect"){
	        shapes.attr("height", shapeHeight).attr("width", shapeWidth);

	    } else if (shape === "circle") {
	        shapes.attr("r", shapeRadius)//.attr("cx", shapeRadius).attr("cy", shapeRadius);

	    } else if (shape === "line") {
	        shapes.attr("x1", 0).attr("x2", shapeWidth).attr("y1", 0).attr("y2", 0);

	    } else if (shape === "path") {
	      shapes.attr("d", path);
	    }
	  },

	  d3_addText: function (svg, enter, labels, classPrefix){
	    enter.append("text").attr("class", classPrefix + "label");
	    svg.selectAll("g." + classPrefix + "cell text").data(labels).text(this.d3_identity);
	  },

	  d3_calcType: function (scale, ascending, cells, labels, labelFormat, labelDelimiter){
	    var type = scale.ticks ?
	            this.d3_linearLegend(scale, cells, labelFormat) : scale.invertExtent ?
	            this.d3_quantLegend(scale, labelFormat, labelDelimiter) : this.d3_ordinalLegend(scale);

	    type.labels = this.d3_mergeLabels(type.labels, labels);

	    if (ascending) {
	      type.labels = this.d3_reverse(type.labels);
	      type.data = this.d3_reverse(type.data);
	    }

	    return type;
	  },

	  d3_reverse: function(arr) {
	    var mirror = [];
	    for (var i = 0, l = arr.length; i < l; i++) {
	      mirror[i] = arr[l-i-1];
	    }
	    return mirror;
	  },

	  d3_placement: function (orient, cell, cellTrans, text, textTrans, labelAlign) {
	    cell.attr("transform", cellTrans);
	    text.attr("transform", textTrans);
	    if (orient === "horizontal"){
	      text.style("text-anchor", labelAlign);
	    }
	  },

	  d3_addEvents: function(cells, dispatcher){
	    var _ = this;

	      cells.on("mouseover.legend", function (d) { _.d3_cellOver(dispatcher, d, this); })
	          .on("mouseout.legend", function (d) { _.d3_cellOut(dispatcher, d, this); })
	          .on("click.legend", function (d) { _.d3_cellClick(dispatcher, d, this); });
	  },

	  d3_cellOver: function(cellDispatcher, d, obj){
	    cellDispatcher.cellover.call(obj, d);
	  },

	  d3_cellOut: function(cellDispatcher, d, obj){
	    cellDispatcher.cellout.call(obj, d);
	  },

	  d3_cellClick: function(cellDispatcher, d, obj){
	    cellDispatcher.cellclick.call(obj, d);
	  },

	  d3_title: function(svg, cellsSvg, title, classPrefix){
	    if (title !== ""){

	      var titleText = svg.selectAll('text.' + classPrefix + 'legendTitle');

	      titleText.data([title])
	        .enter()
	        .append('text')
	        .attr('class', classPrefix + 'legendTitle');

	        svg.selectAll('text.' + classPrefix + 'legendTitle')
	            .text(title)

	      var yOffset = svg.select('.' + classPrefix + 'legendTitle')
	          .map(function(d) { return d[0].getBBox().height})[0],
	      xOffset = -cellsSvg.map(function(d) { return d[0].getBBox().x})[0];

	      cellsSvg.attr('transform', 'translate(' + xOffset + ',' + (yOffset + 10) + ')');

	    }
	  }
	}


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var helper = __webpack_require__(5);

	module.exports =  function(){

	  var scale = d3.scale.linear(),
	    shape = "rect",
	    shapeWidth = 15,
	    shapePadding = 2,
	    cells = [5],
	    labels = [],
	    useStroke = false,
	    classPrefix = "",
	    title = "",
	    labelFormat = d3.format(".01f"),
	    labelOffset = 10,
	    labelAlign = "middle",
	    labelDelimiter = "to",
	    orient = "vertical",
	    ascending = false,
	    path,
	    legendDispatcher = d3.dispatch("cellover", "cellout", "cellclick");

	    function legend(svg){

	      var type = helper.d3_calcType(scale, ascending, cells, labels, labelFormat, labelDelimiter),
	        legendG = svg.selectAll('g').data([scale]);

	      legendG.enter().append('g').attr('class', classPrefix + 'legendCells');


	      var cell = legendG.selectAll("." + classPrefix + "cell").data(type.data),
	        cellEnter = cell.enter().append("g", ".cell").attr("class", classPrefix + "cell").style("opacity", 1e-6);
	        shapeEnter = cellEnter.append(shape).attr("class", classPrefix + "swatch"),
	        shapes = cell.select("g." + classPrefix + "cell " + shape);

	      //add event handlers
	      helper.d3_addEvents(cellEnter, legendDispatcher);

	      cell.exit().transition().style("opacity", 0).remove();

	      //creates shape
	      if (shape === "line"){
	        helper.d3_drawShapes(shape, shapes, 0, shapeWidth);
	        shapes.attr("stroke-width", type.feature);
	      } else {
	        helper.d3_drawShapes(shape, shapes, type.feature, type.feature, type.feature, path);
	      }

	      helper.d3_addText(legendG, cellEnter, type.labels, classPrefix)

	      //sets placement
	      var text = cell.select("text"),
	        shapeSize = shapes[0].map(
	          function(d, i){
	            var bbox = d.getBBox()
	            var stroke = scale(type.data[i]);

	            if (shape === "line" && orient === "horizontal") {
	              bbox.height = bbox.height + stroke;
	            } else if (shape === "line" && orient === "vertical"){
	              bbox.width = bbox.width;
	            }

	            return bbox;
	        });

	      var maxH = d3.max(shapeSize, function(d){ return d.height + d.y; }),
	      maxW = d3.max(shapeSize, function(d){ return d.width + d.x; });

	      var cellTrans,
	      textTrans,
	      textAlign = (labelAlign == "start") ? 0 : (labelAlign == "middle") ? 0.5 : 1;

	      //positions cells and text
	      if (orient === "vertical"){

	        cellTrans = function(d,i) {
	            var height = d3.sum(shapeSize.slice(0, i + 1 ), function(d){ return d.height; });
	            return "translate(0, " + (height + i*shapePadding) + ")"; };

	        textTrans = function(d,i) { return "translate(" + (maxW + labelOffset) + "," +
	          (shapeSize[i].y + shapeSize[i].height/2 + 5) + ")"; };

	      } else if (orient === "horizontal"){
	        cellTrans = function(d,i) {
	            var width = d3.sum(shapeSize.slice(0, i + 1 ), function(d){ return d.width; });
	            return "translate(" + (width + i*shapePadding) + ",0)"; };

	        textTrans = function(d,i) { return "translate(" + (shapeSize[i].width*textAlign  + shapeSize[i].x) + "," +
	              (maxH + labelOffset ) + ")"; };
	      }

	      helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
	      helper.d3_title(svg, legendG, title, classPrefix);

	      cell.transition().style("opacity", 1);

	    }

	  legend.scale = function(_) {
	    if (!arguments.length) return scale;
	    scale = _;
	    return legend;
	  };

	  legend.cells = function(_) {
	    if (!arguments.length) return cells;
	    if (_.length > 1 || _ >= 2 ){
	      cells = _;
	    }
	    return legend;
	  };


	  legend.shape = function(_, d) {
	    if (!arguments.length) return shape;
	    if (_ == "rect" || _ == "circle" || _ == "line" ){
	      shape = _;
	      path = d;
	    }
	    return legend;
	  };

	  legend.shapeWidth = function(_) {
	    if (!arguments.length) return shapeWidth;
	    shapeWidth = +_;
	    return legend;
	  };

	  legend.shapePadding = function(_) {
	    if (!arguments.length) return shapePadding;
	    shapePadding = +_;
	    return legend;
	  };

	  legend.labels = function(_) {
	    if (!arguments.length) return labels;
	    labels = _;
	    return legend;
	  };

	  legend.labelAlign = function(_) {
	    if (!arguments.length) return labelAlign;
	    if (_ == "start" || _ == "end" || _ == "middle") {
	      labelAlign = _;
	    }
	    return legend;
	  };

	  legend.labelFormat = function(_) {
	    if (!arguments.length) return labelFormat;
	    labelFormat = _;
	    return legend;
	  };

	  legend.labelOffset = function(_) {
	    if (!arguments.length) return labelOffset;
	    labelOffset = +_;
	    return legend;
	  };

	  legend.labelDelimiter = function(_) {
	    if (!arguments.length) return labelDelimiter;
	    labelDelimiter = _;
	    return legend;
	  };

	  legend.orient = function(_){
	    if (!arguments.length) return orient;
	    _ = _.toLowerCase();
	    if (_ == "horizontal" || _ == "vertical") {
	      orient = _;
	    }
	    return legend;
	  };

	  legend.ascending = function(_) {
	    if (!arguments.length) return ascending;
	    ascending = !!_;
	    return legend;
	  };

	  legend.classPrefix = function(_) {
	    if (!arguments.length) return classPrefix;
	    classPrefix = _;
	    return legend;
	  };

	  legend.title = function(_) {
	    if (!arguments.length) return title;
	    title = _;
	    return legend;
	  };

	  d3.rebind(legend, legendDispatcher, "on");

	  return legend;

	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var helper = __webpack_require__(5);

	module.exports = function(){

	  var scale = d3.scale.linear(),
	    shape = "path",
	    shapeWidth = 15,
	    shapeHeight = 15,
	    shapeRadius = 10,
	    shapePadding = 5,
	    cells = [5],
	    labels = [],
	    classPrefix = "",
	    useClass = false,
	    title = "",
	    labelFormat = d3.format(".01f"),
	    labelAlign = "middle",
	    labelOffset = 10,
	    labelDelimiter = "to",
	    orient = "vertical",
	    ascending = false,
	    legendDispatcher = d3.dispatch("cellover", "cellout", "cellclick");

	    function legend(svg){

	      var type = helper.d3_calcType(scale, ascending, cells, labels, labelFormat, labelDelimiter),
	        legendG = svg.selectAll('g').data([scale]);

	      legendG.enter().append('g').attr('class', classPrefix + 'legendCells');

	      var cell = legendG.selectAll("." + classPrefix + "cell").data(type.data),
	        cellEnter = cell.enter().append("g", ".cell").attr("class", classPrefix + "cell").style("opacity", 1e-6);
	        shapeEnter = cellEnter.append(shape).attr("class", classPrefix + "swatch"),
	        shapes = cell.select("g." + classPrefix + "cell " + shape);

	      //add event handlers
	      helper.d3_addEvents(cellEnter, legendDispatcher);

	      //remove old shapes
	      cell.exit().transition().style("opacity", 0).remove();

	      helper.d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, type.feature);
	      helper.d3_addText(legendG, cellEnter, type.labels, classPrefix)

	      // sets placement
	      var text = cell.select("text"),
	        shapeSize = shapes[0].map( function(d){ return d.getBBox(); });

	      var maxH = d3.max(shapeSize, function(d){ return d.height; }),
	      maxW = d3.max(shapeSize, function(d){ return d.width; });

	      var cellTrans,
	      textTrans,
	      textAlign = (labelAlign == "start") ? 0 : (labelAlign == "middle") ? 0.5 : 1;

	      //positions cells and text
	      if (orient === "vertical"){
	        cellTrans = function(d,i) { return "translate(0, " + (i * (maxH + shapePadding)) + ")"; };
	        textTrans = function(d,i) { return "translate(" + (maxW + labelOffset) + "," +
	              (shapeSize[i].y + shapeSize[i].height/2 + 5) + ")"; };

	      } else if (orient === "horizontal"){
	        cellTrans = function(d,i) { return "translate(" + (i * (maxW + shapePadding)) + ",0)"; };
	        textTrans = function(d,i) { return "translate(" + (shapeSize[i].width*textAlign  + shapeSize[i].x) + "," +
	              (maxH + labelOffset ) + ")"; };
	      }

	      helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
	      helper.d3_title(svg, legendG, title, classPrefix);
	      cell.transition().style("opacity", 1);

	    }


	  legend.scale = function(_) {
	    if (!arguments.length) return scale;
	    scale = _;
	    return legend;
	  };

	  legend.cells = function(_) {
	    if (!arguments.length) return cells;
	    if (_.length > 1 || _ >= 2 ){
	      cells = _;
	    }
	    return legend;
	  };

	  legend.shapePadding = function(_) {
	    if (!arguments.length) return shapePadding;
	    shapePadding = +_;
	    return legend;
	  };

	  legend.labels = function(_) {
	    if (!arguments.length) return labels;
	    labels = _;
	    return legend;
	  };

	  legend.labelAlign = function(_) {
	    if (!arguments.length) return labelAlign;
	    if (_ == "start" || _ == "end" || _ == "middle") {
	      labelAlign = _;
	    }
	    return legend;
	  };

	  legend.labelFormat = function(_) {
	    if (!arguments.length) return labelFormat;
	    labelFormat = _;
	    return legend;
	  };

	  legend.labelOffset = function(_) {
	    if (!arguments.length) return labelOffset;
	    labelOffset = +_;
	    return legend;
	  };

	  legend.labelDelimiter = function(_) {
	    if (!arguments.length) return labelDelimiter;
	    labelDelimiter = _;
	    return legend;
	  };

	  legend.orient = function(_){
	    if (!arguments.length) return orient;
	    _ = _.toLowerCase();
	    if (_ == "horizontal" || _ == "vertical") {
	      orient = _;
	    }
	    return legend;
	  };

	  legend.ascending = function(_) {
	    if (!arguments.length) return ascending;
	    ascending = !!_;
	    return legend;
	  };

	  legend.classPrefix = function(_) {
	    if (!arguments.length) return classPrefix;
	    classPrefix = _;
	    return legend;
	  };

	  legend.title = function(_) {
	    if (!arguments.length) return title;
	    title = _;
	    return legend;
	  };

	  d3.rebind(legend, legendDispatcher, "on");

	  return legend;

	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v2.2.4
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-05-20T17:23Z
	 */

	(function( global, factory ) {

		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//"use strict";
	var arr = [];

	var document = window.document;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};



	var
		version = "2.2.4",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android<4.1
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?

				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :

				// Return all the elements in a clean array
				slice.call( this );
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},

		isArray: Array.isArray,

		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function( obj ) {

			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			var realStringObj = obj && obj.toString();
			return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
		},

		isPlainObject: function( obj ) {
			var key;

			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}

			// Not own constructor property must be Object
			if ( obj.constructor &&
					!hasOwn.call( obj, "constructor" ) &&
					!hasOwn.call( obj.constructor.prototype || {}, "isPrototypeOf" ) ) {
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own
			for ( key in obj ) {}

			return key === undefined || hasOwn.call( obj, key );
		},

		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},

		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}

			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			var script,
				indirect = eval;

			code = jQuery.trim( code );

			if ( code ) {

				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if ( code.indexOf( "use strict" ) === 1 ) {
					script = document.createElement( "script" );
					script.text = code;
					document.head.appendChild( script ).parentNode.removeChild( script );
				} else {

					// Otherwise, avoid the DOM node creation, insertion
					// and removal by using an indirect global eval

					indirect( code );
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android<4.1
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	// JSHint would error on this code due to the Symbol not being defined in ES5.
	// Defining this global in .jshintrc would create a danger of using the global
	// unguarded in another place, it seems safer to just disable JSHint for these
	// three lines.
	/* jshint ignore: start */
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	/* jshint ignore: end */

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );

		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.2.1
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2015-10-17
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,
		rescape = /'|\\/g,

		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		};

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, nidselect, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rescape, "\\$&" );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
						while ( i-- ) {
							groups[i] = nidselect + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");

		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, parent,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( (parent = document.defaultView) && parent.top !== parent ) {
			// Support: IE 11
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( document.createComment("") );
			return !div.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					return m ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];

			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibing-combinator selector` fails
				if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},

			"disabled": function( elem ) {
				return elem.disabled === true;
			},

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( (oldCache = uniqueCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ dir ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;



	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				/* jshint -W018 */
				return !!qualifier.call( elem, i, elem ) !== not;
			} );

		}

		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );

		}

		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}

			qualifier = jQuery.filter( qualifier, elements );
		}

		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i,
				len = this.length,
				ret = [],
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						// Support: Blackberry 4.6
						// gEBID returns nodes no longer in the document (#6963)
						if ( elem && elem.parentNode ) {

							// Inject the element directly into the jQuery object
							this.length = 1;
							this[ 0 ] = elem;
						}

						this.context = document;
						this.selector = selector;
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;

			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( pos ?
						pos.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnotwhite = ( /\S+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this === promise ? newDefer.promise() : this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Keep pipe for back-compat
			promise.pipe = promise.then;

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];

				// promise[ done | fail | progress ] = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add( function() {

						// state = [ resolved | rejected ]
						state = stateString;

					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}

				// deferred[ resolve | reject | notify ]
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = slice.call( arguments ),
				length = resolveValues.length,

				// the count of uncompleted subordinates
				remaining = length !== 1 ||
					( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

				// the master Deferred.
				// If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},

				progressValues, progressContexts, resolveContexts;

			// Add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.progress( updateFunc( i, progressContexts, progressValues ) )
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject );
					} else {
						--remaining;
					}
				}
			}

			// If we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}

			return deferred.promise();
		}
	} );


	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function( fn ) {

		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
				jQuery( document ).off( "ready" );
			}
		}
	} );

	/**
	 * The ready event handler and self cleanup method
	 */
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called
			// after the browser event has already occurred.
			// Support: IE9-10 only
			// Older IE sometimes signals "interactive" too soon
			if ( document.readyState === "complete" ||
				( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout( jQuery.ready );

			} else {

				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed );

				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed );
			}
		}
		return readyList.promise( obj );
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		register: function( owner, initial ) {
			var value = initial || {};

			// If it is a node unlikely to be stringify-ed or looped over
			// use plain assignment
			if ( owner.nodeType ) {
				owner[ this.expando ] = value;

			// Otherwise secure it in a non-enumerable, non-writable property
			// configurability must be true to allow the property to be
			// deleted with the delete operator
			} else {
				Object.defineProperty( owner, this.expando, {
					value: value,
					writable: true,
					configurable: true
				} );
			}
			return owner[ this.expando ];
		},
		cache: function( owner ) {

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( !acceptData( owner ) ) {
				return {};
			}

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			if ( typeof data === "string" ) {
				cache[ data ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
				owner[ this.expando ] && owner[ this.expando ][ key ];
		},
		access: function( owner, key, value ) {
			var stored;

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				stored = this.get( owner, key );

				return stored !== undefined ?
					stored : this.get( owner, jQuery.camelCase( key ) );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i, name, camel,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key === undefined ) {
				this.register( owner );

			} else {

				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {

					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat( key.map( jQuery.camelCase ) );
				} else {
					camel = jQuery.camelCase( key );

					// Try the string as a key before any manipulation
					if ( key in cache ) {
						name = [ key, camel ];
					} else {

						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ?
							[ name ] : ( name.match( rnotwhite ) || [] );
					}
				}

				i = name.length;

				while ( i-- ) {
					delete cache[ name[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <= 35-45+
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://code.google.com/p/chromium/issues/detail?id=378607
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :

						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data, camelKey;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// with the key as-is
					data = dataUser.get( elem, key ) ||

						// Try to find dashed key if it exists (gh-2779)
						// This is for 2.2.x only
						dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );

					if ( data !== undefined ) {
						return data;
					}

					camelKey = jQuery.camelCase( key );

					// Attempt to get data from the cache
					// with the key camelized
					data = dataUser.get( elem, camelKey );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, camelKey, undefined );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				camelKey = jQuery.camelCase( key );
				this.each( function() {

					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = dataUser.get( this, camelKey );

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					dataUser.set( this, camelKey, value );

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
						dataUser.set( this, key, value );
					}
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHidden = function( elem, el ) {

			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css( elem, "display" ) === "none" ||
				!jQuery.contains( elem.ownerDocument, elem );
		};



	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() { return tween.cur(); } :
				function() { return jQuery.css( elem, prop, "" ); },
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );

			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([\w:-]+)/ );

	var rscriptType = ( /^$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE9-11+
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ?
				context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== "undefined" ?
					context.querySelectorAll( tag || "*" ) :
				[];

		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0-4.3, Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();


	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE9
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( event ) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );

			var i, j, ret, matched, handleObj,
				handlerQueue = [],
				args = slice.call( arguments ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Support (at least): Chrome, IE9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox<=42+
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if ( delegateCount && cur.nodeType &&
				( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push( { elem: cur, handlers: matches } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
			"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split( " " ),
			filter: function( event, original ) {

				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
				"screenX screenY toElement" ).split( " " ),
			filter: function( event, original ) {
				var eventDoc, doc, body,
					button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX +
						( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
						( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY +
						( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
						( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}

				return event;
			}
		},

		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];

			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

			event = new jQuery.Event( originalEvent );

			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if ( !event.target ) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android<4.0
					src.returnValue === false ?
				returnTrue :
				returnFalse;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://code.google.com/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

		// Support: IE 10-11, Edge 10240+
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Manipulating tables requires a tbody
	function manipulationTarget( elem, content ) {
		return jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

			elem.getElementsByTagName( "tbody" )[ 0 ] ||
				elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
			elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );

		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android<4.1, PhantomJS<2
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {

		// Keep domManip exposed until 3.0 (gh-2225)
		domManip: domManip,

		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );


	var iframe,
		elemdisplay = {

			// Support: Firefox
			// We have to pre-define these values for FF (#10227)
			HTML: "block",
			BODY: "block"
		};

	/**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */

	// Called only from within defaultDisplay
	function actualDisplay( name, doc ) {
		var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

			display = jQuery.css( elem[ 0 ], "display" );

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */
	function defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];

		if ( !display ) {
			display = actualDisplay( nodeName, doc );

			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {

				// Use the already-created iframe if possible
				iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
					.appendTo( doc.documentElement );

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[ 0 ].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}

		return display;
	}
	var rmargin = ( /^margin/ );

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};


	var documentElement = document.documentElement;



	( function() {
		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
			div.style.cssText =

				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild( container );
		}

		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {

				// Support: Android 4.0-4.3
				// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
				// since that compresses better and they're computed together anyway.
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {

				// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return reliableMarginLeftVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =

					// Support: Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;box-sizing:content-box;" +
					"display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				documentElement.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );

				documentElement.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );
		ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

		// Support: Opera 12.1x only
		// Fall back to style even without computed
		// computed is undefined for elems on document fragments
		if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// http://dev.w3.org/csswg/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE9-11+
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,

		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?

			// If we already have the right measurement, avoid augmentation
			4 :

			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,

			val = 0;

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {

				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {

			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}

			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );

			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;

		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			values[ index ] = dataPriv.get( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {

				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = dataPriv.access(
						elem,
						"olddisplay",
						defaultDisplay( elem.nodeName )
					);
				}
			} else {
				hidden = isHidden( elem );

				if ( display !== "none" || !hidden ) {
					dataPriv.set(
						elem,
						"olddisplay",
						hidden ? display : jQuery.css( elem, "display" )
					);
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;

			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// Support: IE9-11+
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					style[ name ] = value;
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );

			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
						elem.offsetWidth === 0 ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
		function( elem, computed ) {
			if ( computed ) {
				return swap( elem, { "display": "inline-block" },
					curCSS, [ elem, "marginRight" ] );
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		/* jshint validthis: true */
		var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHidden( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css( elem, "display" );

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ?
				dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

			if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
				style.display = "inline-block";
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// show/hide pass
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// If there is dataShow left over from a stopped hide or show
					// and we are going to proceed with show, we should pretend to be hidden
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

			// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}

		if ( !jQuery.isEmptyObject( orig ) ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", {} );
			}

			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done( function() {
					jQuery( elem ).hide();
				} );
			}
			anim.done( function() {
				var prop;

				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
			for ( prop in orig ) {
				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

		// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
			style.display = display;
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length ; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}

	jQuery.Animation = jQuery.extend( Animation, {
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnotwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
			opt.duration : opt.duration in jQuery.fx.speeds ?
				jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};

	jQuery.fx.stop = function() {
		window.clearInterval( timerId );

		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( rnotwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					propName = jQuery.propFix[ name ] || name;

					// Boolean attributes get special treatment (#10870)
					if ( jQuery.expr.match.bool.test( name ) ) {

						// Set corresponding property to false
						elem[ propName ] = false;
					}

					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					return tabindex ?
						parseInt( tabindex, 10 ) :
						rfocusable.test( elem.nodeName ) ||
							rclickable.test( elem.nodeName ) && elem.href ?
								0 :
								-1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




	var rclass = /[\t\r\n\f]/g;

	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value;

			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( type === "string" ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnotwhite ) || [];

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + getClass( elem ) + " " ).replace( rclass, " " )
						.indexOf( className ) > -1
				) {
					return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g,
		rspaces = /[\x20\t\r\n\f]+/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?

						// Handle most common string cases
						ret.replace( rreturn, "" ) :

						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :

						// Support: IE10-11+
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								( support.optDisabled ?
									!option.disabled : option.getAttribute( "disabled" ) === null ) &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];
						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	support.focusin = "onfocusin" in window;


	// Support: Firefox
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome, Safari
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = ( /\?/ );



	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function( data ) {
		return JSON.parse( data + "" );
	};


	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE9
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

			if ( jQuery.isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

			// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// The jqXHR state
				state = 0,

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {

									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE8-11+
				// IE throws exception if url is malformed, e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE8-11+
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?

						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + nonce++ ) :

						// Otherwise add one to the end
						cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( state === 2 ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );

					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Called once
				if ( state === 2 ) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapAll( html.call( this, i ) );
				} );
			}

			if ( this[ 0 ] ) {

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function() {
			return this.parent().each( function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			} ).end();
		}
	} );


	jQuery.expr.filters.hidden = function( elem ) {
		return !jQuery.expr.filters.visible( elem );
	};
	jQuery.expr.filters.visible = function( elem ) {

		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		// Use OR instead of AND as the element is not visible if either is true
		// See tickets #10406 and #13132
		return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
	};




	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( jQuery.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {

				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} ) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE9
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE9
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );

					// Support: IE9
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}

		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {
		offset: function( options ) {
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var docElem, win,
				elem = this[ 0 ],
				box = { top: 0, left: 0 },
				doc = elem && elem.ownerDocument;

			if ( !doc ) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if ( !jQuery.contains( docElem, elem ) ) {
				return box;
			}

			box = elem.getBoundingClientRect();
			win = getWindow( doc );
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();

			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari<7-8+, Chrome<37-44+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {

						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		} );
	} );


	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		},
		size: function() {
			return this.length;
		}
	} );

	jQuery.fn.andSelf = jQuery.fn.addBack;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}



	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}

	return jQuery;
	}));


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_0__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(jQuery, $) {/*!
	 * Materialize v0.97.6 (http://materializecss.com)
	 * Copyright 2014-2015 Materialize
	 * MIT License (https://raw.githubusercontent.com/Dogfalo/materialize/master/LICENSE)
	 */
	// Check for jQuery.
	if (typeof(jQuery) === 'undefined') {
	  var jQuery;
	  // Check if require is a defined function.
	  if (true) {
	    jQuery = $ = __webpack_require__(8);
	  // Else use the dollar sign alias.
	  } else {
	    jQuery = $;
	  }
	}
	;/*
	 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
	 *
	 * Uses the built in easing capabilities added In jQuery 1.1
	 * to offer multiple easing options
	 *
	 * TERMS OF USE - jQuery Easing
	 *
	 * Open source under the BSD License.
	 *
	 * Copyright © 2008 George McGinley Smith
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without modification,
	 * are permitted provided that the following conditions are met:
	 *
	 * Redistributions of source code must retain the above copyright notice, this list of
	 * conditions and the following disclaimer.
	 * Redistributions in binary form must reproduce the above copyright notice, this list
	 * of conditions and the following disclaimer in the documentation and/or other materials
	 * provided with the distribution.
	 *
	 * Neither the name of the author nor the names of contributors may be used to endorse
	 * or promote products derived from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
	 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
	 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
	 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
	 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
	 * OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	*/

	// t: current time, b: begInnIng value, c: change In value, d: duration
	jQuery.easing['jswing'] = jQuery.easing['swing'];

	jQuery.extend( jQuery.easing,
	{
		def: 'easeOutQuad',
		swing: function (x, t, b, c, d) {
			//alert(jQuery.easing.default);
			return jQuery.easing[jQuery.easing.def](x, t, b, c, d);
		},
		easeInQuad: function (x, t, b, c, d) {
			return c*(t/=d)*t + b;
		},
		easeOutQuad: function (x, t, b, c, d) {
			return -c *(t/=d)*(t-2) + b;
		},
		easeInOutQuad: function (x, t, b, c, d) {
			if ((t/=d/2) < 1) return c/2*t*t + b;
			return -c/2 * ((--t)*(t-2) - 1) + b;
		},
		easeInCubic: function (x, t, b, c, d) {
			return c*(t/=d)*t*t + b;
		},
		easeOutCubic: function (x, t, b, c, d) {
			return c*((t=t/d-1)*t*t + 1) + b;
		},
		easeInOutCubic: function (x, t, b, c, d) {
			if ((t/=d/2) < 1) return c/2*t*t*t + b;
			return c/2*((t-=2)*t*t + 2) + b;
		},
		easeInQuart: function (x, t, b, c, d) {
			return c*(t/=d)*t*t*t + b;
		},
		easeOutQuart: function (x, t, b, c, d) {
			return -c * ((t=t/d-1)*t*t*t - 1) + b;
		},
		easeInOutQuart: function (x, t, b, c, d) {
			if ((t/=d/2) < 1) return c/2*t*t*t*t + b;
			return -c/2 * ((t-=2)*t*t*t - 2) + b;
		},
		easeInQuint: function (x, t, b, c, d) {
			return c*(t/=d)*t*t*t*t + b;
		},
		easeOutQuint: function (x, t, b, c, d) {
			return c*((t=t/d-1)*t*t*t*t + 1) + b;
		},
		easeInOutQuint: function (x, t, b, c, d) {
			if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;
			return c/2*((t-=2)*t*t*t*t + 2) + b;
		},
		easeInSine: function (x, t, b, c, d) {
			return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
		},
		easeOutSine: function (x, t, b, c, d) {
			return c * Math.sin(t/d * (Math.PI/2)) + b;
		},
		easeInOutSine: function (x, t, b, c, d) {
			return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
		},
		easeInExpo: function (x, t, b, c, d) {
			return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
		},
		easeOutExpo: function (x, t, b, c, d) {
			return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
		},
		easeInOutExpo: function (x, t, b, c, d) {
			if (t==0) return b;
			if (t==d) return b+c;
			if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
			return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
		},
		easeInCirc: function (x, t, b, c, d) {
			return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
		},
		easeOutCirc: function (x, t, b, c, d) {
			return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
		},
		easeInOutCirc: function (x, t, b, c, d) {
			if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
			return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
		},
		easeInElastic: function (x, t, b, c, d) {
			var s=1.70158;var p=0;var a=c;
			if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
			if (a < Math.abs(c)) { a=c; var s=p/4; }
			else var s = p/(2*Math.PI) * Math.asin (c/a);
			return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
		},
		easeOutElastic: function (x, t, b, c, d) {
			var s=1.70158;var p=0;var a=c;
			if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
			if (a < Math.abs(c)) { a=c; var s=p/4; }
			else var s = p/(2*Math.PI) * Math.asin (c/a);
			return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
		},
		easeInOutElastic: function (x, t, b, c, d) {
			var s=1.70158;var p=0;var a=c;
			if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);
			if (a < Math.abs(c)) { a=c; var s=p/4; }
			else var s = p/(2*Math.PI) * Math.asin (c/a);
			if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
			return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
		},
		easeInBack: function (x, t, b, c, d, s) {
			if (s == undefined) s = 1.70158;
			return c*(t/=d)*t*((s+1)*t - s) + b;
		},
		easeOutBack: function (x, t, b, c, d, s) {
			if (s == undefined) s = 1.70158;
			return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
		},
		easeInOutBack: function (x, t, b, c, d, s) {
			if (s == undefined) s = 1.70158;
			if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
			return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
		},
		easeInBounce: function (x, t, b, c, d) {
			return c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d) + b;
		},
		easeOutBounce: function (x, t, b, c, d) {
			if ((t/=d) < (1/2.75)) {
				return c*(7.5625*t*t) + b;
			} else if (t < (2/2.75)) {
				return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
			} else if (t < (2.5/2.75)) {
				return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
			} else {
				return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
			}
		},
		easeInOutBounce: function (x, t, b, c, d) {
			if (t < d/2) return jQuery.easing.easeInBounce (x, t*2, 0, c, d) * .5 + b;
			return jQuery.easing.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;
		}
	});

	/*
	 *
	 * TERMS OF USE - EASING EQUATIONS
	 *
	 * Open source under the BSD License.
	 *
	 * Copyright © 2001 Robert Penner
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without modification,
	 * are permitted provided that the following conditions are met:
	 *
	 * Redistributions of source code must retain the above copyright notice, this list of
	 * conditions and the following disclaimer.
	 * Redistributions in binary form must reproduce the above copyright notice, this list
	 * of conditions and the following disclaimer in the documentation and/or other materials
	 * provided with the distribution.
	 *
	 * Neither the name of the author nor the names of contributors may be used to endorse
	 * or promote products derived from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
	 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
	 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
	 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
	 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
	 * OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 */;    // Custom Easing
	    jQuery.extend( jQuery.easing,
	    {
	      easeInOutMaterial: function (x, t, b, c, d) {
	        if ((t/=d/2) < 1) return c/2*t*t + b;
	        return c/4*((t-=2)*t*t + 2) + b;
	      }
	    });

	;/*! VelocityJS.org (1.2.3). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */
	/*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */
	/*! Note that this has been modified by Materialize to confirm that Velocity is not already being imported. */
	jQuery.Velocity?console.log("Velocity is already loaded. You may be needlessly importing Velocity again; note that Materialize includes Velocity."):(!function(e){function t(e){var t=e.length,a=r.type(e);return"function"===a||r.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===a||0===t||"number"==typeof t&&t>0&&t-1 in e}if(!e.jQuery){var r=function(e,t){return new r.fn.init(e,t)};r.isWindow=function(e){return null!=e&&e==e.window},r.type=function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[i.call(e)]||"object":typeof e},r.isArray=Array.isArray||function(e){return"array"===r.type(e)},r.isPlainObject=function(e){var t;if(!e||"object"!==r.type(e)||e.nodeType||r.isWindow(e))return!1;try{if(e.constructor&&!o.call(e,"constructor")&&!o.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(a){return!1}for(t in e);return void 0===t||o.call(e,t)},r.each=function(e,r,a){var n,o=0,i=e.length,s=t(e);if(a){if(s)for(;i>o&&(n=r.apply(e[o],a),n!==!1);o++);else for(o in e)if(n=r.apply(e[o],a),n===!1)break}else if(s)for(;i>o&&(n=r.call(e[o],o,e[o]),n!==!1);o++);else for(o in e)if(n=r.call(e[o],o,e[o]),n===!1)break;return e},r.data=function(e,t,n){if(void 0===n){var o=e[r.expando],i=o&&a[o];if(void 0===t)return i;if(i&&t in i)return i[t]}else if(void 0!==t){var o=e[r.expando]||(e[r.expando]=++r.uuid);return a[o]=a[o]||{},a[o][t]=n,n}},r.removeData=function(e,t){var n=e[r.expando],o=n&&a[n];o&&r.each(t,function(e,t){delete o[t]})},r.extend=function(){var e,t,a,n,o,i,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[l]||{},l++),"object"!=typeof s&&"function"!==r.type(s)&&(s={}),l===u&&(s=this,l--);u>l;l++)if(null!=(o=arguments[l]))for(n in o)e=s[n],a=o[n],s!==a&&(c&&a&&(r.isPlainObject(a)||(t=r.isArray(a)))?(t?(t=!1,i=e&&r.isArray(e)?e:[]):i=e&&r.isPlainObject(e)?e:{},s[n]=r.extend(c,i,a)):void 0!==a&&(s[n]=a));return s},r.queue=function(e,a,n){function o(e,r){var a=r||[];return null!=e&&(t(Object(e))?!function(e,t){for(var r=+t.length,a=0,n=e.length;r>a;)e[n++]=t[a++];if(r!==r)for(;void 0!==t[a];)e[n++]=t[a++];return e.length=n,e}(a,"string"==typeof e?[e]:e):[].push.call(a,e)),a}if(e){a=(a||"fx")+"queue";var i=r.data(e,a);return n?(!i||r.isArray(n)?i=r.data(e,a,o(n)):i.push(n),i):i||[]}},r.dequeue=function(e,t){r.each(e.nodeType?[e]:e,function(e,a){t=t||"fx";var n=r.queue(a,t),o=n.shift();"inprogress"===o&&(o=n.shift()),o&&("fx"===t&&n.unshift("inprogress"),o.call(a,function(){r.dequeue(a,t)}))})},r.fn=r.prototype={init:function(e){if(e.nodeType)return this[0]=e,this;throw new Error("Not a DOM node.")},offset:function(){var t=this[0].getBoundingClientRect?this[0].getBoundingClientRect():{top:0,left:0};return{top:t.top+(e.pageYOffset||document.scrollTop||0)-(document.clientTop||0),left:t.left+(e.pageXOffset||document.scrollLeft||0)-(document.clientLeft||0)}},position:function(){function e(){for(var e=this.offsetParent||document;e&&"html"===!e.nodeType.toLowerCase&&"static"===e.style.position;)e=e.offsetParent;return e||document}var t=this[0],e=e.apply(t),a=this.offset(),n=/^(?:body|html)$/i.test(e.nodeName)?{top:0,left:0}:r(e).offset();return a.top-=parseFloat(t.style.marginTop)||0,a.left-=parseFloat(t.style.marginLeft)||0,e.style&&(n.top+=parseFloat(e.style.borderTopWidth)||0,n.left+=parseFloat(e.style.borderLeftWidth)||0),{top:a.top-n.top,left:a.left-n.left}}};var a={};r.expando="velocity"+(new Date).getTime(),r.uuid=0;for(var n={},o=n.hasOwnProperty,i=n.toString,s="Boolean Number String Function Array Date RegExp Object Error".split(" "),l=0;l<s.length;l++)n["[object "+s[l]+"]"]=s[l].toLowerCase();r.fn.init.prototype=r.fn,e.Velocity={Utilities:r}}}(window),function(e){"object"==typeof module&&"object"==typeof module.exports?module.exports=e(): true?!(__WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):e()}(function(){return function(e,t,r,a){function n(e){for(var t=-1,r=e?e.length:0,a=[];++t<r;){var n=e[t];n&&a.push(n)}return a}function o(e){return m.isWrapped(e)?e=[].slice.call(e):m.isNode(e)&&(e=[e]),e}function i(e){var t=f.data(e,"velocity");return null===t?a:t}function s(e){return function(t){return Math.round(t*e)*(1/e)}}function l(e,r,a,n){function o(e,t){return 1-3*t+3*e}function i(e,t){return 3*t-6*e}function s(e){return 3*e}function l(e,t,r){return((o(t,r)*e+i(t,r))*e+s(t))*e}function u(e,t,r){return 3*o(t,r)*e*e+2*i(t,r)*e+s(t)}function c(t,r){for(var n=0;m>n;++n){var o=u(r,e,a);if(0===o)return r;var i=l(r,e,a)-t;r-=i/o}return r}function p(){for(var t=0;b>t;++t)w[t]=l(t*x,e,a)}function f(t,r,n){var o,i,s=0;do i=r+(n-r)/2,o=l(i,e,a)-t,o>0?n=i:r=i;while(Math.abs(o)>h&&++s<v);return i}function d(t){for(var r=0,n=1,o=b-1;n!=o&&w[n]<=t;++n)r+=x;--n;var i=(t-w[n])/(w[n+1]-w[n]),s=r+i*x,l=u(s,e,a);return l>=y?c(t,s):0==l?s:f(t,r,r+x)}function g(){V=!0,(e!=r||a!=n)&&p()}var m=4,y=.001,h=1e-7,v=10,b=11,x=1/(b-1),S="Float32Array"in t;if(4!==arguments.length)return!1;for(var P=0;4>P;++P)if("number"!=typeof arguments[P]||isNaN(arguments[P])||!isFinite(arguments[P]))return!1;e=Math.min(e,1),a=Math.min(a,1),e=Math.max(e,0),a=Math.max(a,0);var w=S?new Float32Array(b):new Array(b),V=!1,C=function(t){return V||g(),e===r&&a===n?t:0===t?0:1===t?1:l(d(t),r,n)};C.getControlPoints=function(){return[{x:e,y:r},{x:a,y:n}]};var T="generateBezier("+[e,r,a,n]+")";return C.toString=function(){return T},C}function u(e,t){var r=e;return m.isString(e)?b.Easings[e]||(r=!1):r=m.isArray(e)&&1===e.length?s.apply(null,e):m.isArray(e)&&2===e.length?x.apply(null,e.concat([t])):m.isArray(e)&&4===e.length?l.apply(null,e):!1,r===!1&&(r=b.Easings[b.defaults.easing]?b.defaults.easing:v),r}function c(e){if(e){var t=(new Date).getTime(),r=b.State.calls.length;r>1e4&&(b.State.calls=n(b.State.calls));for(var o=0;r>o;o++)if(b.State.calls[o]){var s=b.State.calls[o],l=s[0],u=s[2],d=s[3],g=!!d,y=null;d||(d=b.State.calls[o][3]=t-16);for(var h=Math.min((t-d)/u.duration,1),v=0,x=l.length;x>v;v++){var P=l[v],V=P.element;if(i(V)){var C=!1;if(u.display!==a&&null!==u.display&&"none"!==u.display){if("flex"===u.display){var T=["-webkit-box","-moz-box","-ms-flexbox","-webkit-flex"];f.each(T,function(e,t){S.setPropertyValue(V,"display",t)})}S.setPropertyValue(V,"display",u.display)}u.visibility!==a&&"hidden"!==u.visibility&&S.setPropertyValue(V,"visibility",u.visibility);for(var k in P)if("element"!==k){var A,F=P[k],j=m.isString(F.easing)?b.Easings[F.easing]:F.easing;if(1===h)A=F.endValue;else{var E=F.endValue-F.startValue;if(A=F.startValue+E*j(h,u,E),!g&&A===F.currentValue)continue}if(F.currentValue=A,"tween"===k)y=A;else{if(S.Hooks.registered[k]){var H=S.Hooks.getRoot(k),N=i(V).rootPropertyValueCache[H];N&&(F.rootPropertyValue=N)}var L=S.setPropertyValue(V,k,F.currentValue+(0===parseFloat(A)?"":F.unitType),F.rootPropertyValue,F.scrollData);S.Hooks.registered[k]&&(i(V).rootPropertyValueCache[H]=S.Normalizations.registered[H]?S.Normalizations.registered[H]("extract",null,L[1]):L[1]),"transform"===L[0]&&(C=!0)}}u.mobileHA&&i(V).transformCache.translate3d===a&&(i(V).transformCache.translate3d="(0px, 0px, 0px)",C=!0),C&&S.flushTransformCache(V)}}u.display!==a&&"none"!==u.display&&(b.State.calls[o][2].display=!1),u.visibility!==a&&"hidden"!==u.visibility&&(b.State.calls[o][2].visibility=!1),u.progress&&u.progress.call(s[1],s[1],h,Math.max(0,d+u.duration-t),d,y),1===h&&p(o)}}b.State.isTicking&&w(c)}function p(e,t){if(!b.State.calls[e])return!1;for(var r=b.State.calls[e][0],n=b.State.calls[e][1],o=b.State.calls[e][2],s=b.State.calls[e][4],l=!1,u=0,c=r.length;c>u;u++){var p=r[u].element;if(t||o.loop||("none"===o.display&&S.setPropertyValue(p,"display",o.display),"hidden"===o.visibility&&S.setPropertyValue(p,"visibility",o.visibility)),o.loop!==!0&&(f.queue(p)[1]===a||!/\.velocityQueueEntryFlag/i.test(f.queue(p)[1]))&&i(p)){i(p).isAnimating=!1,i(p).rootPropertyValueCache={};var d=!1;f.each(S.Lists.transforms3D,function(e,t){var r=/^scale/.test(t)?1:0,n=i(p).transformCache[t];i(p).transformCache[t]!==a&&new RegExp("^\\("+r+"[^.]").test(n)&&(d=!0,delete i(p).transformCache[t])}),o.mobileHA&&(d=!0,delete i(p).transformCache.translate3d),d&&S.flushTransformCache(p),S.Values.removeClass(p,"velocity-animating")}if(!t&&o.complete&&!o.loop&&u===c-1)try{o.complete.call(n,n)}catch(g){setTimeout(function(){throw g},1)}s&&o.loop!==!0&&s(n),i(p)&&o.loop===!0&&!t&&(f.each(i(p).tweensContainer,function(e,t){/^rotate/.test(e)&&360===parseFloat(t.endValue)&&(t.endValue=0,t.startValue=360),/^backgroundPosition/.test(e)&&100===parseFloat(t.endValue)&&"%"===t.unitType&&(t.endValue=0,t.startValue=100)}),b(p,"reverse",{loop:!0,delay:o.delay})),o.queue!==!1&&f.dequeue(p,o.queue)}b.State.calls[e]=!1;for(var m=0,y=b.State.calls.length;y>m;m++)if(b.State.calls[m]!==!1){l=!0;break}l===!1&&(b.State.isTicking=!1,delete b.State.calls,b.State.calls=[])}var f,d=function(){if(r.documentMode)return r.documentMode;for(var e=7;e>4;e--){var t=r.createElement("div");if(t.innerHTML="<!--[if IE "+e+"]><span></span><![endif]-->",t.getElementsByTagName("span").length)return t=null,e}return a}(),g=function(){var e=0;return t.webkitRequestAnimationFrame||t.mozRequestAnimationFrame||function(t){var r,a=(new Date).getTime();return r=Math.max(0,16-(a-e)),e=a+r,setTimeout(function(){t(a+r)},r)}}(),m={isString:function(e){return"string"==typeof e},isArray:Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)},isFunction:function(e){return"[object Function]"===Object.prototype.toString.call(e)},isNode:function(e){return e&&e.nodeType},isNodeList:function(e){return"object"==typeof e&&/^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(e))&&e.length!==a&&(0===e.length||"object"==typeof e[0]&&e[0].nodeType>0)},isWrapped:function(e){return e&&(e.jquery||t.Zepto&&t.Zepto.zepto.isZ(e))},isSVG:function(e){return t.SVGElement&&e instanceof t.SVGElement},isEmptyObject:function(e){for(var t in e)return!1;return!0}},y=!1;if(e.fn&&e.fn.jquery?(f=e,y=!0):f=t.Velocity.Utilities,8>=d&&!y)throw new Error("Velocity: IE8 and below require jQuery to be loaded before Velocity.");if(7>=d)return void(jQuery.fn.velocity=jQuery.fn.animate);var h=400,v="swing",b={State:{isMobile:/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),isAndroid:/Android/i.test(navigator.userAgent),isGingerbread:/Android 2\.3\.[3-7]/i.test(navigator.userAgent),isChrome:t.chrome,isFirefox:/Firefox/i.test(navigator.userAgent),prefixElement:r.createElement("div"),prefixMatches:{},scrollAnchor:null,scrollPropertyLeft:null,scrollPropertyTop:null,isTicking:!1,calls:[]},CSS:{},Utilities:f,Redirects:{},Easings:{},Promise:t.Promise,defaults:{queue:"",duration:h,easing:v,begin:a,complete:a,progress:a,display:a,visibility:a,loop:!1,delay:!1,mobileHA:!0,_cacheValues:!0},init:function(e){f.data(e,"velocity",{isSVG:m.isSVG(e),isAnimating:!1,computedStyle:null,tweensContainer:null,rootPropertyValueCache:{},transformCache:{}})},hook:null,mock:!1,version:{major:1,minor:2,patch:2},debug:!1};t.pageYOffset!==a?(b.State.scrollAnchor=t,b.State.scrollPropertyLeft="pageXOffset",b.State.scrollPropertyTop="pageYOffset"):(b.State.scrollAnchor=r.documentElement||r.body.parentNode||r.body,b.State.scrollPropertyLeft="scrollLeft",b.State.scrollPropertyTop="scrollTop");var x=function(){function e(e){return-e.tension*e.x-e.friction*e.v}function t(t,r,a){var n={x:t.x+a.dx*r,v:t.v+a.dv*r,tension:t.tension,friction:t.friction};return{dx:n.v,dv:e(n)}}function r(r,a){var n={dx:r.v,dv:e(r)},o=t(r,.5*a,n),i=t(r,.5*a,o),s=t(r,a,i),l=1/6*(n.dx+2*(o.dx+i.dx)+s.dx),u=1/6*(n.dv+2*(o.dv+i.dv)+s.dv);return r.x=r.x+l*a,r.v=r.v+u*a,r}return function a(e,t,n){var o,i,s,l={x:-1,v:0,tension:null,friction:null},u=[0],c=0,p=1e-4,f=.016;for(e=parseFloat(e)||500,t=parseFloat(t)||20,n=n||null,l.tension=e,l.friction=t,o=null!==n,o?(c=a(e,t),i=c/n*f):i=f;s=r(s||l,i),u.push(1+s.x),c+=16,Math.abs(s.x)>p&&Math.abs(s.v)>p;);return o?function(e){return u[e*(u.length-1)|0]}:c}}();b.Easings={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},spring:function(e){return 1-Math.cos(4.5*e*Math.PI)*Math.exp(6*-e)}},f.each([["ease",[.25,.1,.25,1]],["ease-in",[.42,0,1,1]],["ease-out",[0,0,.58,1]],["ease-in-out",[.42,0,.58,1]],["easeInSine",[.47,0,.745,.715]],["easeOutSine",[.39,.575,.565,1]],["easeInOutSine",[.445,.05,.55,.95]],["easeInQuad",[.55,.085,.68,.53]],["easeOutQuad",[.25,.46,.45,.94]],["easeInOutQuad",[.455,.03,.515,.955]],["easeInCubic",[.55,.055,.675,.19]],["easeOutCubic",[.215,.61,.355,1]],["easeInOutCubic",[.645,.045,.355,1]],["easeInQuart",[.895,.03,.685,.22]],["easeOutQuart",[.165,.84,.44,1]],["easeInOutQuart",[.77,0,.175,1]],["easeInQuint",[.755,.05,.855,.06]],["easeOutQuint",[.23,1,.32,1]],["easeInOutQuint",[.86,0,.07,1]],["easeInExpo",[.95,.05,.795,.035]],["easeOutExpo",[.19,1,.22,1]],["easeInOutExpo",[1,0,0,1]],["easeInCirc",[.6,.04,.98,.335]],["easeOutCirc",[.075,.82,.165,1]],["easeInOutCirc",[.785,.135,.15,.86]]],function(e,t){b.Easings[t[0]]=l.apply(null,t[1])});var S=b.CSS={RegEx:{isHex:/^#([A-f\d]{3}){1,2}$/i,valueUnwrap:/^[A-z]+\((.*)\)$/i,wrappedValueAlreadyExtracted:/[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,valueSplit:/([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/gi},Lists:{colors:["fill","stroke","stopColor","color","backgroundColor","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","outlineColor"],transformsBase:["translateX","translateY","scale","scaleX","scaleY","skewX","skewY","rotateZ"],transforms3D:["transformPerspective","translateZ","scaleZ","rotateX","rotateY"]},Hooks:{templates:{textShadow:["Color X Y Blur","black 0px 0px 0px"],boxShadow:["Color X Y Blur Spread","black 0px 0px 0px 0px"],clip:["Top Right Bottom Left","0px 0px 0px 0px"],backgroundPosition:["X Y","0% 0%"],transformOrigin:["X Y Z","50% 50% 0px"],perspectiveOrigin:["X Y","50% 50%"]},registered:{},register:function(){for(var e=0;e<S.Lists.colors.length;e++){var t="color"===S.Lists.colors[e]?"0 0 0 1":"255 255 255 1";S.Hooks.templates[S.Lists.colors[e]]=["Red Green Blue Alpha",t]}var r,a,n;if(d)for(r in S.Hooks.templates){a=S.Hooks.templates[r],n=a[0].split(" ");var o=a[1].match(S.RegEx.valueSplit);"Color"===n[0]&&(n.push(n.shift()),o.push(o.shift()),S.Hooks.templates[r]=[n.join(" "),o.join(" ")])}for(r in S.Hooks.templates){a=S.Hooks.templates[r],n=a[0].split(" ");for(var e in n){var i=r+n[e],s=e;S.Hooks.registered[i]=[r,s]}}},getRoot:function(e){var t=S.Hooks.registered[e];return t?t[0]:e},cleanRootPropertyValue:function(e,t){return S.RegEx.valueUnwrap.test(t)&&(t=t.match(S.RegEx.valueUnwrap)[1]),S.Values.isCSSNullValue(t)&&(t=S.Hooks.templates[e][1]),t},extractValue:function(e,t){var r=S.Hooks.registered[e];if(r){var a=r[0],n=r[1];return t=S.Hooks.cleanRootPropertyValue(a,t),t.toString().match(S.RegEx.valueSplit)[n]}return t},injectValue:function(e,t,r){var a=S.Hooks.registered[e];if(a){var n,o,i=a[0],s=a[1];return r=S.Hooks.cleanRootPropertyValue(i,r),n=r.toString().match(S.RegEx.valueSplit),n[s]=t,o=n.join(" ")}return r}},Normalizations:{registered:{clip:function(e,t,r){switch(e){case"name":return"clip";case"extract":var a;return S.RegEx.wrappedValueAlreadyExtracted.test(r)?a=r:(a=r.toString().match(S.RegEx.valueUnwrap),a=a?a[1].replace(/,(\s+)?/g," "):r),a;case"inject":return"rect("+r+")"}},blur:function(e,t,r){switch(e){case"name":return b.State.isFirefox?"filter":"-webkit-filter";case"extract":var a=parseFloat(r);if(!a&&0!==a){var n=r.toString().match(/blur\(([0-9]+[A-z]+)\)/i);a=n?n[1]:0}return a;case"inject":return parseFloat(r)?"blur("+r+")":"none"}},opacity:function(e,t,r){if(8>=d)switch(e){case"name":return"filter";case"extract":var a=r.toString().match(/alpha\(opacity=(.*)\)/i);return r=a?a[1]/100:1;case"inject":return t.style.zoom=1,parseFloat(r)>=1?"":"alpha(opacity="+parseInt(100*parseFloat(r),10)+")"}else switch(e){case"name":return"opacity";case"extract":return r;case"inject":return r}}},register:function(){9>=d||b.State.isGingerbread||(S.Lists.transformsBase=S.Lists.transformsBase.concat(S.Lists.transforms3D));for(var e=0;e<S.Lists.transformsBase.length;e++)!function(){var t=S.Lists.transformsBase[e];S.Normalizations.registered[t]=function(e,r,n){switch(e){case"name":return"transform";case"extract":return i(r)===a||i(r).transformCache[t]===a?/^scale/i.test(t)?1:0:i(r).transformCache[t].replace(/[()]/g,"");case"inject":var o=!1;switch(t.substr(0,t.length-1)){case"translate":o=!/(%|px|em|rem|vw|vh|\d)$/i.test(n);break;case"scal":case"scale":b.State.isAndroid&&i(r).transformCache[t]===a&&1>n&&(n=1),o=!/(\d)$/i.test(n);break;case"skew":o=!/(deg|\d)$/i.test(n);break;case"rotate":o=!/(deg|\d)$/i.test(n)}return o||(i(r).transformCache[t]="("+n+")"),i(r).transformCache[t]}}}();for(var e=0;e<S.Lists.colors.length;e++)!function(){var t=S.Lists.colors[e];S.Normalizations.registered[t]=function(e,r,n){switch(e){case"name":return t;case"extract":var o;if(S.RegEx.wrappedValueAlreadyExtracted.test(n))o=n;else{var i,s={black:"rgb(0, 0, 0)",blue:"rgb(0, 0, 255)",gray:"rgb(128, 128, 128)",green:"rgb(0, 128, 0)",red:"rgb(255, 0, 0)",white:"rgb(255, 255, 255)"};/^[A-z]+$/i.test(n)?i=s[n]!==a?s[n]:s.black:S.RegEx.isHex.test(n)?i="rgb("+S.Values.hexToRgb(n).join(" ")+")":/^rgba?\(/i.test(n)||(i=s.black),o=(i||n).toString().match(S.RegEx.valueUnwrap)[1].replace(/,(\s+)?/g," ")}return 8>=d||3!==o.split(" ").length||(o+=" 1"),o;case"inject":return 8>=d?4===n.split(" ").length&&(n=n.split(/\s+/).slice(0,3).join(" ")):3===n.split(" ").length&&(n+=" 1"),(8>=d?"rgb":"rgba")+"("+n.replace(/\s+/g,",").replace(/\.(\d)+(?=,)/g,"")+")"}}}()}},Names:{camelCase:function(e){return e.replace(/-(\w)/g,function(e,t){return t.toUpperCase()})},SVGAttribute:function(e){var t="width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2";return(d||b.State.isAndroid&&!b.State.isChrome)&&(t+="|transform"),new RegExp("^("+t+")$","i").test(e)},prefixCheck:function(e){if(b.State.prefixMatches[e])return[b.State.prefixMatches[e],!0];for(var t=["","Webkit","Moz","ms","O"],r=0,a=t.length;a>r;r++){var n;if(n=0===r?e:t[r]+e.replace(/^\w/,function(e){return e.toUpperCase()}),m.isString(b.State.prefixElement.style[n]))return b.State.prefixMatches[e]=n,[n,!0]}return[e,!1]}},Values:{hexToRgb:function(e){var t,r=/^#?([a-f\d])([a-f\d])([a-f\d])$/i,a=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;return e=e.replace(r,function(e,t,r,a){return t+t+r+r+a+a}),t=a.exec(e),t?[parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16)]:[0,0,0]},isCSSNullValue:function(e){return 0==e||/^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(e)},getUnitType:function(e){return/^(rotate|skew)/i.test(e)?"deg":/(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(e)?"":"px"},getDisplayType:function(e){var t=e&&e.tagName.toString().toLowerCase();return/^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(t)?"inline":/^(li)$/i.test(t)?"list-item":/^(tr)$/i.test(t)?"table-row":/^(table)$/i.test(t)?"table":/^(tbody)$/i.test(t)?"table-row-group":"block"},addClass:function(e,t){e.classList?e.classList.add(t):e.className+=(e.className.length?" ":"")+t},removeClass:function(e,t){e.classList?e.classList.remove(t):e.className=e.className.toString().replace(new RegExp("(^|\\s)"+t.split(" ").join("|")+"(\\s|$)","gi")," ")}},getPropertyValue:function(e,r,n,o){function s(e,r){function n(){u&&S.setPropertyValue(e,"display","none")}var l=0;if(8>=d)l=f.css(e,r);else{var u=!1;if(/^(width|height)$/.test(r)&&0===S.getPropertyValue(e,"display")&&(u=!0,S.setPropertyValue(e,"display",S.Values.getDisplayType(e))),!o){if("height"===r&&"border-box"!==S.getPropertyValue(e,"boxSizing").toString().toLowerCase()){var c=e.offsetHeight-(parseFloat(S.getPropertyValue(e,"borderTopWidth"))||0)-(parseFloat(S.getPropertyValue(e,"borderBottomWidth"))||0)-(parseFloat(S.getPropertyValue(e,"paddingTop"))||0)-(parseFloat(S.getPropertyValue(e,"paddingBottom"))||0);return n(),c}if("width"===r&&"border-box"!==S.getPropertyValue(e,"boxSizing").toString().toLowerCase()){var p=e.offsetWidth-(parseFloat(S.getPropertyValue(e,"borderLeftWidth"))||0)-(parseFloat(S.getPropertyValue(e,"borderRightWidth"))||0)-(parseFloat(S.getPropertyValue(e,"paddingLeft"))||0)-(parseFloat(S.getPropertyValue(e,"paddingRight"))||0);return n(),p}}var g;g=i(e)===a?t.getComputedStyle(e,null):i(e).computedStyle?i(e).computedStyle:i(e).computedStyle=t.getComputedStyle(e,null),"borderColor"===r&&(r="borderTopColor"),l=9===d&&"filter"===r?g.getPropertyValue(r):g[r],(""===l||null===l)&&(l=e.style[r]),n()}if("auto"===l&&/^(top|right|bottom|left)$/i.test(r)){var m=s(e,"position");("fixed"===m||"absolute"===m&&/top|left/i.test(r))&&(l=f(e).position()[r]+"px")}return l}var l;if(S.Hooks.registered[r]){var u=r,c=S.Hooks.getRoot(u);n===a&&(n=S.getPropertyValue(e,S.Names.prefixCheck(c)[0])),S.Normalizations.registered[c]&&(n=S.Normalizations.registered[c]("extract",e,n)),l=S.Hooks.extractValue(u,n)}else if(S.Normalizations.registered[r]){var p,g;p=S.Normalizations.registered[r]("name",e),"transform"!==p&&(g=s(e,S.Names.prefixCheck(p)[0]),S.Values.isCSSNullValue(g)&&S.Hooks.templates[r]&&(g=S.Hooks.templates[r][1])),l=S.Normalizations.registered[r]("extract",e,g)}if(!/^[\d-]/.test(l))if(i(e)&&i(e).isSVG&&S.Names.SVGAttribute(r))if(/^(height|width)$/i.test(r))try{l=e.getBBox()[r]}catch(m){l=0}else l=e.getAttribute(r);else l=s(e,S.Names.prefixCheck(r)[0]);return S.Values.isCSSNullValue(l)&&(l=0),b.debug>=2&&console.log("Get "+r+": "+l),l},setPropertyValue:function(e,r,a,n,o){var s=r;if("scroll"===r)o.container?o.container["scroll"+o.direction]=a:"Left"===o.direction?t.scrollTo(a,o.alternateValue):t.scrollTo(o.alternateValue,a);else if(S.Normalizations.registered[r]&&"transform"===S.Normalizations.registered[r]("name",e))S.Normalizations.registered[r]("inject",e,a),s="transform",a=i(e).transformCache[r];else{if(S.Hooks.registered[r]){var l=r,u=S.Hooks.getRoot(r);n=n||S.getPropertyValue(e,u),a=S.Hooks.injectValue(l,a,n),r=u}if(S.Normalizations.registered[r]&&(a=S.Normalizations.registered[r]("inject",e,a),r=S.Normalizations.registered[r]("name",e)),s=S.Names.prefixCheck(r)[0],8>=d)try{e.style[s]=a}catch(c){b.debug&&console.log("Browser does not support ["+a+"] for ["+s+"]")}else i(e)&&i(e).isSVG&&S.Names.SVGAttribute(r)?e.setAttribute(r,a):e.style[s]=a;b.debug>=2&&console.log("Set "+r+" ("+s+"): "+a)}return[s,a]},flushTransformCache:function(e){function t(t){return parseFloat(S.getPropertyValue(e,t))}var r="";if((d||b.State.isAndroid&&!b.State.isChrome)&&i(e).isSVG){var a={translate:[t("translateX"),t("translateY")],skewX:[t("skewX")],skewY:[t("skewY")],scale:1!==t("scale")?[t("scale"),t("scale")]:[t("scaleX"),t("scaleY")],rotate:[t("rotateZ"),0,0]};f.each(i(e).transformCache,function(e){/^translate/i.test(e)?e="translate":/^scale/i.test(e)?e="scale":/^rotate/i.test(e)&&(e="rotate"),a[e]&&(r+=e+"("+a[e].join(" ")+") ",delete a[e])})}else{var n,o;f.each(i(e).transformCache,function(t){return n=i(e).transformCache[t],"transformPerspective"===t?(o=n,!0):(9===d&&"rotateZ"===t&&(t="rotate"),void(r+=t+n+" "))}),o&&(r="perspective"+o+" "+r)}S.setPropertyValue(e,"transform",r)}};S.Hooks.register(),S.Normalizations.register(),b.hook=function(e,t,r){var n=a;return e=o(e),f.each(e,function(e,o){if(i(o)===a&&b.init(o),r===a)n===a&&(n=b.CSS.getPropertyValue(o,t));else{var s=b.CSS.setPropertyValue(o,t,r);"transform"===s[0]&&b.CSS.flushTransformCache(o),n=s}}),n};var P=function(){function e(){return s?k.promise||null:l}function n(){function e(e){function p(e,t){var r=a,n=a,i=a;return m.isArray(e)?(r=e[0],!m.isArray(e[1])&&/^[\d-]/.test(e[1])||m.isFunction(e[1])||S.RegEx.isHex.test(e[1])?i=e[1]:(m.isString(e[1])&&!S.RegEx.isHex.test(e[1])||m.isArray(e[1]))&&(n=t?e[1]:u(e[1],s.duration),e[2]!==a&&(i=e[2]))):r=e,t||(n=n||s.easing),m.isFunction(r)&&(r=r.call(o,V,w)),m.isFunction(i)&&(i=i.call(o,V,w)),[r||0,n,i]}function d(e,t){var r,a;return a=(t||"0").toString().toLowerCase().replace(/[%A-z]+$/,function(e){return r=e,""}),r||(r=S.Values.getUnitType(e)),[a,r]}function h(){var e={myParent:o.parentNode||r.body,position:S.getPropertyValue(o,"position"),fontSize:S.getPropertyValue(o,"fontSize")},a=e.position===L.lastPosition&&e.myParent===L.lastParent,n=e.fontSize===L.lastFontSize;L.lastParent=e.myParent,L.lastPosition=e.position,L.lastFontSize=e.fontSize;var s=100,l={};if(n&&a)l.emToPx=L.lastEmToPx,l.percentToPxWidth=L.lastPercentToPxWidth,l.percentToPxHeight=L.lastPercentToPxHeight;else{var u=i(o).isSVG?r.createElementNS("http://www.w3.org/2000/svg","rect"):r.createElement("div");b.init(u),e.myParent.appendChild(u),f.each(["overflow","overflowX","overflowY"],function(e,t){b.CSS.setPropertyValue(u,t,"hidden")}),b.CSS.setPropertyValue(u,"position",e.position),b.CSS.setPropertyValue(u,"fontSize",e.fontSize),b.CSS.setPropertyValue(u,"boxSizing","content-box"),f.each(["minWidth","maxWidth","width","minHeight","maxHeight","height"],function(e,t){b.CSS.setPropertyValue(u,t,s+"%")}),b.CSS.setPropertyValue(u,"paddingLeft",s+"em"),l.percentToPxWidth=L.lastPercentToPxWidth=(parseFloat(S.getPropertyValue(u,"width",null,!0))||1)/s,l.percentToPxHeight=L.lastPercentToPxHeight=(parseFloat(S.getPropertyValue(u,"height",null,!0))||1)/s,l.emToPx=L.lastEmToPx=(parseFloat(S.getPropertyValue(u,"paddingLeft"))||1)/s,e.myParent.removeChild(u)}return null===L.remToPx&&(L.remToPx=parseFloat(S.getPropertyValue(r.body,"fontSize"))||16),null===L.vwToPx&&(L.vwToPx=parseFloat(t.innerWidth)/100,L.vhToPx=parseFloat(t.innerHeight)/100),l.remToPx=L.remToPx,l.vwToPx=L.vwToPx,l.vhToPx=L.vhToPx,b.debug>=1&&console.log("Unit ratios: "+JSON.stringify(l),o),l}if(s.begin&&0===V)try{s.begin.call(g,g)}catch(x){setTimeout(function(){throw x},1)}if("scroll"===A){var P,C,T,F=/^x$/i.test(s.axis)?"Left":"Top",j=parseFloat(s.offset)||0;s.container?m.isWrapped(s.container)||m.isNode(s.container)?(s.container=s.container[0]||s.container,P=s.container["scroll"+F],T=P+f(o).position()[F.toLowerCase()]+j):s.container=null:(P=b.State.scrollAnchor[b.State["scrollProperty"+F]],C=b.State.scrollAnchor[b.State["scrollProperty"+("Left"===F?"Top":"Left")]],T=f(o).offset()[F.toLowerCase()]+j),l={scroll:{rootPropertyValue:!1,startValue:P,currentValue:P,endValue:T,unitType:"",easing:s.easing,scrollData:{container:s.container,direction:F,alternateValue:C}},element:o},b.debug&&console.log("tweensContainer (scroll): ",l.scroll,o)}else if("reverse"===A){if(!i(o).tweensContainer)return void f.dequeue(o,s.queue);"none"===i(o).opts.display&&(i(o).opts.display="auto"),"hidden"===i(o).opts.visibility&&(i(o).opts.visibility="visible"),i(o).opts.loop=!1,i(o).opts.begin=null,i(o).opts.complete=null,v.easing||delete s.easing,v.duration||delete s.duration,s=f.extend({},i(o).opts,s);var E=f.extend(!0,{},i(o).tweensContainer);for(var H in E)if("element"!==H){var N=E[H].startValue;E[H].startValue=E[H].currentValue=E[H].endValue,E[H].endValue=N,m.isEmptyObject(v)||(E[H].easing=s.easing),b.debug&&console.log("reverse tweensContainer ("+H+"): "+JSON.stringify(E[H]),o)}l=E}else if("start"===A){var E;i(o).tweensContainer&&i(o).isAnimating===!0&&(E=i(o).tweensContainer),f.each(y,function(e,t){if(RegExp("^"+S.Lists.colors.join("$|^")+"$").test(e)){var r=p(t,!0),n=r[0],o=r[1],i=r[2];if(S.RegEx.isHex.test(n)){for(var s=["Red","Green","Blue"],l=S.Values.hexToRgb(n),u=i?S.Values.hexToRgb(i):a,c=0;c<s.length;c++){var f=[l[c]];o&&f.push(o),u!==a&&f.push(u[c]),y[e+s[c]]=f}delete y[e]}}});for(var z in y){var O=p(y[z]),q=O[0],$=O[1],M=O[2];z=S.Names.camelCase(z);var I=S.Hooks.getRoot(z),B=!1;if(i(o).isSVG||"tween"===I||S.Names.prefixCheck(I)[1]!==!1||S.Normalizations.registered[I]!==a){(s.display!==a&&null!==s.display&&"none"!==s.display||s.visibility!==a&&"hidden"!==s.visibility)&&/opacity|filter/.test(z)&&!M&&0!==q&&(M=0),s._cacheValues&&E&&E[z]?(M===a&&(M=E[z].endValue+E[z].unitType),B=i(o).rootPropertyValueCache[I]):S.Hooks.registered[z]?M===a?(B=S.getPropertyValue(o,I),M=S.getPropertyValue(o,z,B)):B=S.Hooks.templates[I][1]:M===a&&(M=S.getPropertyValue(o,z));var W,G,Y,D=!1;if(W=d(z,M),M=W[0],Y=W[1],W=d(z,q),q=W[0].replace(/^([+-\/*])=/,function(e,t){return D=t,""}),G=W[1],M=parseFloat(M)||0,q=parseFloat(q)||0,"%"===G&&(/^(fontSize|lineHeight)$/.test(z)?(q/=100,G="em"):/^scale/.test(z)?(q/=100,G=""):/(Red|Green|Blue)$/i.test(z)&&(q=q/100*255,G="")),/[\/*]/.test(D))G=Y;else if(Y!==G&&0!==M)if(0===q)G=Y;else{n=n||h();var Q=/margin|padding|left|right|width|text|word|letter/i.test(z)||/X$/.test(z)||"x"===z?"x":"y";switch(Y){case"%":M*="x"===Q?n.percentToPxWidth:n.percentToPxHeight;break;case"px":break;default:M*=n[Y+"ToPx"]}switch(G){case"%":M*=1/("x"===Q?n.percentToPxWidth:n.percentToPxHeight);break;case"px":break;default:M*=1/n[G+"ToPx"]}}switch(D){case"+":q=M+q;break;case"-":q=M-q;break;case"*":q=M*q;break;case"/":q=M/q}l[z]={rootPropertyValue:B,startValue:M,currentValue:M,endValue:q,unitType:G,easing:$},b.debug&&console.log("tweensContainer ("+z+"): "+JSON.stringify(l[z]),o)}else b.debug&&console.log("Skipping ["+I+"] due to a lack of browser support.")}l.element=o}l.element&&(S.Values.addClass(o,"velocity-animating"),R.push(l),""===s.queue&&(i(o).tweensContainer=l,i(o).opts=s),i(o).isAnimating=!0,V===w-1?(b.State.calls.push([R,g,s,null,k.resolver]),b.State.isTicking===!1&&(b.State.isTicking=!0,c())):V++)}var n,o=this,s=f.extend({},b.defaults,v),l={};switch(i(o)===a&&b.init(o),parseFloat(s.delay)&&s.queue!==!1&&f.queue(o,s.queue,function(e){b.velocityQueueEntryFlag=!0,i(o).delayTimer={setTimeout:setTimeout(e,parseFloat(s.delay)),next:e}}),s.duration.toString().toLowerCase()){case"fast":s.duration=200;break;case"normal":s.duration=h;break;case"slow":s.duration=600;break;default:s.duration=parseFloat(s.duration)||1}b.mock!==!1&&(b.mock===!0?s.duration=s.delay=1:(s.duration*=parseFloat(b.mock)||1,s.delay*=parseFloat(b.mock)||1)),s.easing=u(s.easing,s.duration),s.begin&&!m.isFunction(s.begin)&&(s.begin=null),s.progress&&!m.isFunction(s.progress)&&(s.progress=null),s.complete&&!m.isFunction(s.complete)&&(s.complete=null),s.display!==a&&null!==s.display&&(s.display=s.display.toString().toLowerCase(),"auto"===s.display&&(s.display=b.CSS.Values.getDisplayType(o))),s.visibility!==a&&null!==s.visibility&&(s.visibility=s.visibility.toString().toLowerCase()),s.mobileHA=s.mobileHA&&b.State.isMobile&&!b.State.isGingerbread,s.queue===!1?s.delay?setTimeout(e,s.delay):e():f.queue(o,s.queue,function(t,r){return r===!0?(k.promise&&k.resolver(g),!0):(b.velocityQueueEntryFlag=!0,void e(t))}),""!==s.queue&&"fx"!==s.queue||"inprogress"===f.queue(o)[0]||f.dequeue(o)}var s,l,d,g,y,v,x=arguments[0]&&(arguments[0].p||f.isPlainObject(arguments[0].properties)&&!arguments[0].properties.names||m.isString(arguments[0].properties));if(m.isWrapped(this)?(s=!1,d=0,g=this,l=this):(s=!0,d=1,g=x?arguments[0].elements||arguments[0].e:arguments[0]),g=o(g)){x?(y=arguments[0].properties||arguments[0].p,v=arguments[0].options||arguments[0].o):(y=arguments[d],v=arguments[d+1]);var w=g.length,V=0;if(!/^(stop|finish)$/i.test(y)&&!f.isPlainObject(v)){var C=d+1;v={};for(var T=C;T<arguments.length;T++)m.isArray(arguments[T])||!/^(fast|normal|slow)$/i.test(arguments[T])&&!/^\d/.test(arguments[T])?m.isString(arguments[T])||m.isArray(arguments[T])?v.easing=arguments[T]:m.isFunction(arguments[T])&&(v.complete=arguments[T]):v.duration=arguments[T]}var k={promise:null,resolver:null,rejecter:null};s&&b.Promise&&(k.promise=new b.Promise(function(e,t){k.resolver=e,k.rejecter=t}));var A;switch(y){case"scroll":A="scroll";break;case"reverse":A="reverse";break;case"finish":case"stop":f.each(g,function(e,t){i(t)&&i(t).delayTimer&&(clearTimeout(i(t).delayTimer.setTimeout),i(t).delayTimer.next&&i(t).delayTimer.next(),delete i(t).delayTimer)});var F=[];return f.each(b.State.calls,function(e,t){t&&f.each(t[1],function(r,n){var o=v===a?"":v;return o===!0||t[2].queue===o||v===a&&t[2].queue===!1?void f.each(g,function(r,a){a===n&&((v===!0||m.isString(v))&&(f.each(f.queue(a,m.isString(v)?v:""),function(e,t){
	m.isFunction(t)&&t(null,!0)}),f.queue(a,m.isString(v)?v:"",[])),"stop"===y?(i(a)&&i(a).tweensContainer&&o!==!1&&f.each(i(a).tweensContainer,function(e,t){t.endValue=t.currentValue}),F.push(e)):"finish"===y&&(t[2].duration=1))}):!0})}),"stop"===y&&(f.each(F,function(e,t){p(t,!0)}),k.promise&&k.resolver(g)),e();default:if(!f.isPlainObject(y)||m.isEmptyObject(y)){if(m.isString(y)&&b.Redirects[y]){var j=f.extend({},v),E=j.duration,H=j.delay||0;return j.backwards===!0&&(g=f.extend(!0,[],g).reverse()),f.each(g,function(e,t){parseFloat(j.stagger)?j.delay=H+parseFloat(j.stagger)*e:m.isFunction(j.stagger)&&(j.delay=H+j.stagger.call(t,e,w)),j.drag&&(j.duration=parseFloat(E)||(/^(callout|transition)/.test(y)?1e3:h),j.duration=Math.max(j.duration*(j.backwards?1-e/w:(e+1)/w),.75*j.duration,200)),b.Redirects[y].call(t,t,j||{},e,w,g,k.promise?k:a)}),e()}var N="Velocity: First argument ("+y+") was not a property map, a known action, or a registered redirect. Aborting.";return k.promise?k.rejecter(new Error(N)):console.log(N),e()}A="start"}var L={lastParent:null,lastPosition:null,lastFontSize:null,lastPercentToPxWidth:null,lastPercentToPxHeight:null,lastEmToPx:null,remToPx:null,vwToPx:null,vhToPx:null},R=[];f.each(g,function(e,t){m.isNode(t)&&n.call(t)});var z,j=f.extend({},b.defaults,v);if(j.loop=parseInt(j.loop),z=2*j.loop-1,j.loop)for(var O=0;z>O;O++){var q={delay:j.delay,progress:j.progress};O===z-1&&(q.display=j.display,q.visibility=j.visibility,q.complete=j.complete),P(g,"reverse",q)}return e()}};b=f.extend(P,b),b.animate=P;var w=t.requestAnimationFrame||g;return b.State.isMobile||r.hidden===a||r.addEventListener("visibilitychange",function(){r.hidden?(w=function(e){return setTimeout(function(){e(!0)},16)},c()):w=t.requestAnimationFrame||g}),e.Velocity=b,e!==t&&(e.fn.velocity=P,e.fn.velocity.defaults=b.defaults),f.each(["Down","Up"],function(e,t){b.Redirects["slide"+t]=function(e,r,n,o,i,s){var l=f.extend({},r),u=l.begin,c=l.complete,p={height:"",marginTop:"",marginBottom:"",paddingTop:"",paddingBottom:""},d={};l.display===a&&(l.display="Down"===t?"inline"===b.CSS.Values.getDisplayType(e)?"inline-block":"block":"none"),l.begin=function(){u&&u.call(i,i);for(var r in p){d[r]=e.style[r];var a=b.CSS.getPropertyValue(e,r);p[r]="Down"===t?[a,0]:[0,a]}d.overflow=e.style.overflow,e.style.overflow="hidden"},l.complete=function(){for(var t in d)e.style[t]=d[t];c&&c.call(i,i),s&&s.resolver(i)},b(e,p,l)}}),f.each(["In","Out"],function(e,t){b.Redirects["fade"+t]=function(e,r,n,o,i,s){var l=f.extend({},r),u={opacity:"In"===t?1:0},c=l.complete;l.complete=n!==o-1?l.begin=null:function(){c&&c.call(i,i),s&&s.resolver(i)},l.display===a&&(l.display="In"===t?"auto":"none"),b(this,u,l)}}),b}(window.jQuery||window.Zepto||window,window,document)}));
	;!function(a,b,c,d){"use strict";function k(a,b,c){return setTimeout(q(a,c),b)}function l(a,b,c){return Array.isArray(a)?(m(a,c[b],c),!0):!1}function m(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e<a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&&b.call(c,a[e],e,a)}function n(a,b,c){for(var e=Object.keys(b),f=0;f<e.length;)(!c||c&&a[e[f]]===d)&&(a[e[f]]=b[e[f]]),f++;return a}function o(a,b){return n(a,b,!0)}function p(a,b,c){var e,d=b.prototype;e=a.prototype=Object.create(d),e.constructor=a,e._super=d,c&&n(e,c)}function q(a,b){return function(){return a.apply(b,arguments)}}function r(a,b){return typeof a==g?a.apply(b?b[0]||d:d,b):a}function s(a,b){return a===d?b:a}function t(a,b,c){m(x(b),function(b){a.addEventListener(b,c,!1)})}function u(a,b,c){m(x(b),function(b){a.removeEventListener(b,c,!1)})}function v(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function w(a,b){return a.indexOf(b)>-1}function x(a){return a.trim().split(/\s+/g)}function y(a,b,c){if(a.indexOf&&!c)return a.indexOf(b);for(var d=0;d<a.length;){if(c&&a[d][c]==b||!c&&a[d]===b)return d;d++}return-1}function z(a){return Array.prototype.slice.call(a,0)}function A(a,b,c){for(var d=[],e=[],f=0;f<a.length;){var g=b?a[f][b]:a[f];y(e,g)<0&&d.push(a[f]),e[f]=g,f++}return c&&(d=b?d.sort(function(a,c){return a[b]>c[b]}):d.sort()),d}function B(a,b){for(var c,f,g=b[0].toUpperCase()+b.slice(1),h=0;h<e.length;){if(c=e[h],f=c?c+g:b,f in a)return f;h++}return d}function D(){return C++}function E(a){var b=a.ownerDocument;return b.defaultView||b.parentWindow}function ab(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){r(a.options.enable,[a])&&c.handler(b)},this.init()}function bb(a){var b,c=a.options.inputClass;return b=c?c:H?wb:I?Eb:G?Gb:rb,new b(a,cb)}function cb(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&O&&0===d-e,g=b&(Q|R)&&0===d-e;c.isFirst=!!f,c.isFinal=!!g,f&&(a.session={}),c.eventType=b,db(a,c),a.emit("hammer.input",c),a.recognize(c),a.session.prevInput=c}function db(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=gb(b)),e>1&&!c.firstMultiple?c.firstMultiple=gb(b):1===e&&(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=hb(d);b.timeStamp=j(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=lb(h,i),b.distance=kb(h,i),eb(c,b),b.offsetDirection=jb(b.deltaX,b.deltaY),b.scale=g?nb(g.pointers,d):1,b.rotation=g?mb(g.pointers,d):0,fb(c,b);var k=a.element;v(b.srcEvent.target,k)&&(k=b.srcEvent.target),b.target=k}function eb(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};(b.eventType===O||f.eventType===Q)&&(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function fb(a,b){var f,g,h,j,c=a.lastInterval||b,e=b.timeStamp-c.timeStamp;if(b.eventType!=R&&(e>N||c.velocity===d)){var k=c.deltaX-b.deltaX,l=c.deltaY-b.deltaY,m=ib(e,k,l);g=m.x,h=m.y,f=i(m.x)>i(m.y)?m.x:m.y,j=jb(k,l),a.lastInterval=b}else f=c.velocity,g=c.velocityX,h=c.velocityY,j=c.direction;b.velocity=f,b.velocityX=g,b.velocityY=h,b.direction=j}function gb(a){for(var b=[],c=0;c<a.pointers.length;)b[c]={clientX:h(a.pointers[c].clientX),clientY:h(a.pointers[c].clientY)},c++;return{timeStamp:j(),pointers:b,center:hb(b),deltaX:a.deltaX,deltaY:a.deltaY}}function hb(a){var b=a.length;if(1===b)return{x:h(a[0].clientX),y:h(a[0].clientY)};for(var c=0,d=0,e=0;b>e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:h(c/b),y:h(d/b)}}function ib(a,b,c){return{x:b/a||0,y:c/a||0}}function jb(a,b){return a===b?S:i(a)>=i(b)?a>0?T:U:b>0?V:W}function kb(a,b,c){c||(c=$);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function lb(a,b,c){c||(c=$);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function mb(a,b){return lb(b[1],b[0],_)-lb(a[1],a[0],_)}function nb(a,b){return kb(b[0],b[1],_)/kb(a[0],a[1],_)}function rb(){this.evEl=pb,this.evWin=qb,this.allow=!0,this.pressed=!1,ab.apply(this,arguments)}function wb(){this.evEl=ub,this.evWin=vb,ab.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function Ab(){this.evTarget=yb,this.evWin=zb,this.started=!1,ab.apply(this,arguments)}function Bb(a,b){var c=z(a.touches),d=z(a.changedTouches);return b&(Q|R)&&(c=A(c.concat(d),"identifier",!0)),[c,d]}function Eb(){this.evTarget=Db,this.targetIds={},ab.apply(this,arguments)}function Fb(a,b){var c=z(a.touches),d=this.targetIds;if(b&(O|P)&&1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=z(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return v(a.target,i)}),b===O)for(e=0;e<f.length;)d[f[e].identifier]=!0,e++;for(e=0;e<g.length;)d[g[e].identifier]&&h.push(g[e]),b&(Q|R)&&delete d[g[e].identifier],e++;return h.length?[A(f.concat(h),"identifier",!0),h]:void 0}function Gb(){ab.apply(this,arguments);var a=q(this.handler,this);this.touch=new Eb(this.manager,a),this.mouse=new rb(this.manager,a)}function Pb(a,b){this.manager=a,this.set(b)}function Qb(a){if(w(a,Mb))return Mb;var b=w(a,Nb),c=w(a,Ob);return b&&c?Nb+" "+Ob:b||c?b?Nb:Ob:w(a,Lb)?Lb:Kb}function Yb(a){this.id=D(),this.manager=null,this.options=o(a||{},this.defaults),this.options.enable=s(this.options.enable,!0),this.state=Rb,this.simultaneous={},this.requireFail=[]}function Zb(a){return a&Wb?"cancel":a&Ub?"end":a&Tb?"move":a&Sb?"start":""}function $b(a){return a==W?"down":a==V?"up":a==T?"left":a==U?"right":""}function _b(a,b){var c=b.manager;return c?c.get(a):a}function ac(){Yb.apply(this,arguments)}function bc(){ac.apply(this,arguments),this.pX=null,this.pY=null}function cc(){ac.apply(this,arguments)}function dc(){Yb.apply(this,arguments),this._timer=null,this._input=null}function ec(){ac.apply(this,arguments)}function fc(){ac.apply(this,arguments)}function gc(){Yb.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function hc(a,b){return b=b||{},b.recognizers=s(b.recognizers,hc.defaults.preset),new kc(a,b)}function kc(a,b){b=b||{},this.options=o(b,hc.defaults),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.element=a,this.input=bb(this),this.touchAction=new Pb(this,this.options.touchAction),lc(this,!0),m(b.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&&b.recognizeWith(a[2]),a[3]&&b.requireFailure(a[3])},this)}function lc(a,b){var c=a.element;m(a.options.cssProps,function(a,d){c.style[B(c.style,d)]=b?a:""})}function mc(a,c){var d=b.createEvent("Event");d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var e=["","webkit","moz","MS","ms","o"],f=b.createElement("div"),g="function",h=Math.round,i=Math.abs,j=Date.now,C=1,F=/mobile|tablet|ip(ad|hone|od)|android/i,G="ontouchstart"in a,H=B(a,"PointerEvent")!==d,I=G&&F.test(navigator.userAgent),J="touch",K="pen",L="mouse",M="kinect",N=25,O=1,P=2,Q=4,R=8,S=1,T=2,U=4,V=8,W=16,X=T|U,Y=V|W,Z=X|Y,$=["x","y"],_=["clientX","clientY"];ab.prototype={handler:function(){},init:function(){this.evEl&&t(this.element,this.evEl,this.domHandler),this.evTarget&&t(this.target,this.evTarget,this.domHandler),this.evWin&&t(E(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&u(this.element,this.evEl,this.domHandler),this.evTarget&&u(this.target,this.evTarget,this.domHandler),this.evWin&&u(E(this.element),this.evWin,this.domHandler)}};var ob={mousedown:O,mousemove:P,mouseup:Q},pb="mousedown",qb="mousemove mouseup";p(rb,ab,{handler:function(a){var b=ob[a.type];b&O&&0===a.button&&(this.pressed=!0),b&P&&1!==a.which&&(b=Q),this.pressed&&this.allow&&(b&Q&&(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:L,srcEvent:a}))}});var sb={pointerdown:O,pointermove:P,pointerup:Q,pointercancel:R,pointerout:R},tb={2:J,3:K,4:L,5:M},ub="pointerdown",vb="pointermove pointerup pointercancel";a.MSPointerEvent&&(ub="MSPointerDown",vb="MSPointerMove MSPointerUp MSPointerCancel"),p(wb,ab,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace("ms",""),e=sb[d],f=tb[a.pointerType]||a.pointerType,g=f==J,h=y(b,a.pointerId,"pointerId");e&O&&(0===a.button||g)?0>h&&(b.push(a),h=b.length-1):e&(Q|R)&&(c=!0),0>h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&&b.splice(h,1))}});var xb={touchstart:O,touchmove:P,touchend:Q,touchcancel:R},yb="touchstart",zb="touchstart touchmove touchend touchcancel";p(Ab,ab,{handler:function(a){var b=xb[a.type];if(b===O&&(this.started=!0),this.started){var c=Bb.call(this,a,b);b&(Q|R)&&0===c[0].length-c[1].length&&(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:J,srcEvent:a})}}});var Cb={touchstart:O,touchmove:P,touchend:Q,touchcancel:R},Db="touchstart touchmove touchend touchcancel";p(Eb,ab,{handler:function(a){var b=Cb[a.type],c=Fb.call(this,a,b);c&&this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:J,srcEvent:a})}}),p(Gb,ab,{handler:function(a,b,c){var d=c.pointerType==J,e=c.pointerType==L;if(d)this.mouse.allow=!1;else if(e&&!this.mouse.allow)return;b&(Q|R)&&(this.mouse.allow=!0),this.callback(a,b,c)},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var Hb=B(f.style,"touchAction"),Ib=Hb!==d,Jb="compute",Kb="auto",Lb="manipulation",Mb="none",Nb="pan-x",Ob="pan-y";Pb.prototype={set:function(a){a==Jb&&(a=this.compute()),Ib&&(this.manager.element.style[Hb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return m(this.manager.recognizers,function(b){r(b.options.enable,[b])&&(a=a.concat(b.getTouchAction()))}),Qb(a.join(" "))},preventDefaults:function(a){if(!Ib){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return b.preventDefault(),void 0;var d=this.actions,e=w(d,Mb),f=w(d,Ob),g=w(d,Nb);return e||f&&c&X||g&&c&Y?this.preventSrc(b):void 0}},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var Rb=1,Sb=2,Tb=4,Ub=8,Vb=Ub,Wb=16,Xb=32;Yb.prototype={defaults:{},set:function(a){return n(this.options,a),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(a){if(l(a,"recognizeWith",this))return this;var b=this.simultaneous;return a=_b(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return l(a,"dropRecognizeWith",this)?this:(a=_b(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(l(a,"requireFailure",this))return this;var b=this.requireFail;return a=_b(a,this),-1===y(b,a)&&(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(l(a,"dropRequireFailure",this))return this;a=_b(a,this);var b=y(this.requireFail,a);return b>-1&&this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function d(d){b.manager.emit(b.options.event+(d?Zb(c):""),a)}var b=this,c=this.state;Ub>c&&d(!0),d(),c>=Ub&&d(!0)},tryEmit:function(a){return this.canEmit()?this.emit(a):(this.state=Xb,void 0)},canEmit:function(){for(var a=0;a<this.requireFail.length;){if(!(this.requireFail[a].state&(Xb|Rb)))return!1;a++}return!0},recognize:function(a){var b=n({},a);return r(this.options.enable,[this,b])?(this.state&(Vb|Wb|Xb)&&(this.state=Rb),this.state=this.process(b),this.state&(Sb|Tb|Ub|Wb)&&this.tryEmit(b),void 0):(this.reset(),this.state=Xb,void 0)},process:function(){},getTouchAction:function(){},reset:function(){}},p(ac,Yb,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&(Sb|Tb),e=this.attrTest(a);return d&&(c&R||!e)?b|Wb:d||e?c&Q?b|Ub:b&Sb?b|Tb:Sb:Xb}}),p(bc,ac,{defaults:{event:"pan",threshold:10,pointers:1,direction:Z},getTouchAction:function(){var a=this.options.direction,b=[];return a&X&&b.push(Ob),a&Y&&b.push(Nb),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&b.direction||(b.direction&X?(e=0===f?S:0>f?T:U,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?S:0>g?V:W,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&&d>b.threshold&&e&b.direction},attrTest:function(a){return ac.prototype.attrTest.call(this,a)&&(this.state&Sb||!(this.state&Sb)&&this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=$b(a.direction);b&&this.manager.emit(this.options.event+b,a),this._super.emit.call(this,a)}}),p(cc,ac,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[Mb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.scale-1)>this.options.threshold||this.state&Sb)},emit:function(a){if(this._super.emit.call(this,a),1!==a.scale){var b=a.scale<1?"in":"out";this.manager.emit(this.options.event+b,a)}}}),p(dc,Yb,{defaults:{event:"press",pointers:1,time:500,threshold:5},getTouchAction:function(){return[Kb]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,e=a.deltaTime>b.time;if(this._input=a,!d||!c||a.eventType&(Q|R)&&!e)this.reset();else if(a.eventType&O)this.reset(),this._timer=k(function(){this.state=Vb,this.tryEmit()},b.time,this);else if(a.eventType&Q)return Vb;return Xb},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===Vb&&(a&&a.eventType&Q?this.manager.emit(this.options.event+"up",a):(this._input.timeStamp=j(),this.manager.emit(this.options.event,this._input)))}}),p(ec,ac,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[Mb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.rotation)>this.options.threshold||this.state&Sb)}}),p(fc,ac,{defaults:{event:"swipe",threshold:10,velocity:.65,direction:X|Y,pointers:1},getTouchAction:function(){return bc.prototype.getTouchAction.call(this)},attrTest:function(a){var c,b=this.options.direction;return b&(X|Y)?c=a.velocity:b&X?c=a.velocityX:b&Y&&(c=a.velocityY),this._super.attrTest.call(this,a)&&b&a.direction&&a.distance>this.options.threshold&&i(c)>this.options.velocity&&a.eventType&Q},emit:function(a){var b=$b(a.direction);b&&this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),p(gc,Yb,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:2,posThreshold:10},getTouchAction:function(){return[Lb]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,e=a.deltaTime<b.time;if(this.reset(),a.eventType&O&&0===this.count)return this.failTimeout();if(d&&e&&c){if(a.eventType!=Q)return this.failTimeout();var f=this.pTime?a.timeStamp-this.pTime<b.interval:!0,g=!this.pCenter||kb(this.pCenter,a.center)<b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,g&&f?this.count+=1:this.count=1,this._input=a;var h=this.count%b.taps;if(0===h)return this.hasRequireFailures()?(this._timer=k(function(){this.state=Vb,this.tryEmit()},b.interval,this),Sb):Vb}return Xb},failTimeout:function(){return this._timer=k(function(){this.state=Xb},this.options.interval,this),Xb},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==Vb&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),hc.VERSION="2.0.4",hc.defaults={domEvents:!1,touchAction:Jb,enable:!0,inputTarget:null,inputClass:null,preset:[[ec,{enable:!1}],[cc,{enable:!1},["rotate"]],[fc,{direction:X}],[bc,{direction:X},["swipe"]],[gc],[gc,{event:"doubletap",taps:2},["tap"]],[dc]],cssProps:{userSelect:"default",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var ic=1,jc=2;kc.prototype={set:function(a){return n(this.options,a),a.touchAction&&this.touchAction.update(),a.inputTarget&&(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?jc:ic},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&&e.state&Vb)&&(e=b.curRecognizer=null);for(var f=0;f<d.length;)c=d[f],b.stopped===jc||e&&c!=e&&!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&&c.state&(Sb|Tb|Ub)&&(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof Yb)return a;for(var b=this.recognizers,c=0;c<b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(l(a,"add",this))return this;var b=this.get(a.options.event);return b&&this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(l(a,"remove",this))return this;var b=this.recognizers;return a=this.get(a),b.splice(y(b,a),1),this.touchAction.update(),this},on:function(a,b){var c=this.handlers;return m(x(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this},off:function(a,b){var c=this.handlers;return m(x(a),function(a){b?c[a].splice(y(c[a],b),1):delete c[a]}),this},emit:function(a,b){this.options.domEvents&&mc(a,b);var c=this.handlers[a]&&this.handlers[a].slice();if(c&&c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d<c.length;)c[d](b),d++}},destroy:function(){this.element&&lc(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},n(hc,{INPUT_START:O,INPUT_MOVE:P,INPUT_END:Q,INPUT_CANCEL:R,STATE_POSSIBLE:Rb,STATE_BEGAN:Sb,STATE_CHANGED:Tb,STATE_ENDED:Ub,STATE_RECOGNIZED:Vb,STATE_CANCELLED:Wb,STATE_FAILED:Xb,DIRECTION_NONE:S,DIRECTION_LEFT:T,DIRECTION_RIGHT:U,DIRECTION_UP:V,DIRECTION_DOWN:W,DIRECTION_HORIZONTAL:X,DIRECTION_VERTICAL:Y,DIRECTION_ALL:Z,Manager:kc,Input:ab,TouchAction:Pb,TouchInput:Eb,MouseInput:rb,PointerEventInput:wb,TouchMouseInput:Gb,SingleTouchInput:Ab,Recognizer:Yb,AttrRecognizer:ac,Tap:gc,Pan:bc,Swipe:fc,Pinch:cc,Rotate:ec,Press:dc,on:t,off:u,each:m,merge:o,extend:n,inherit:p,bindFn:q,prefixed:B}),"function"==g&&__webpack_require__(10)?!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return hc}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):"undefined"!=typeof module&&module.exports?module.exports=hc:a[c]=hc}(window,document,"Hammer");;(function(factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8), __webpack_require__(11)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        factory(require('jquery'), require('hammerjs'));
	    } else {
	        factory(jQuery, Hammer);
	    }
	}(function($, Hammer) {
	    function hammerify(el, options) {
	        var $el = $(el);
	        if(!$el.data("hammer")) {
	            $el.data("hammer", new Hammer($el[0], options));
	        }
	    }

	    $.fn.hammer = function(options) {
	        return this.each(function() {
	            hammerify(this, options);
	        });
	    };

	    // extend the emit method to also trigger jQuery events
	    Hammer.Manager.prototype.emit = (function(originalEmit) {
	        return function(type, data) {
	            originalEmit.call(this, type, data);
	            $(this.element).trigger({
	                type: type,
	                gesture: data
	            });
	        };
	    })(Hammer.Manager.prototype.emit);
	}));
	;// Required for Meteor package, the use of window prevents export by Meteor
	(function(window){
	  if(window.Package){
	    Materialize = {};
	  } else {
	    window.Materialize = {};
	  }
	})(window);


	// Unique ID
	Materialize.guid = (function() {
	  function s4() {
	    return Math.floor((1 + Math.random()) * 0x10000)
	      .toString(16)
	      .substring(1);
	  }
	  return function() {
	    return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
	           s4() + '-' + s4() + s4() + s4();
	  };
	})();

	Materialize.elementOrParentIsFixed = function(element) {
	    var $element = $(element);
	    var $checkElements = $element.add($element.parents());
	    var isFixed = false;
	    $checkElements.each(function(){
	        if ($(this).css("position") === "fixed") {
	            isFixed = true;
	            return false;
	        }
	    });
	    return isFixed;
	};

	// Velocity has conflicts when loaded with jQuery, this will check for it
	var Vel;
	if ($) {
	  Vel = $.Velocity;
	} else if (jQuery) {
	  Vel = jQuery.Velocity;
	} else {
	  Vel = Velocity;
	}
	;(function ($) {
	  $.fn.collapsible = function(options) {
	    var defaults = {
	        accordion: undefined
	    };

	    options = $.extend(defaults, options);


	    return this.each(function() {

	      var $this = $(this);

	      var $panel_headers = $(this).find('> li > .collapsible-header');

	      var collapsible_type = $this.data("collapsible");

	      // Turn off any existing event handlers
	       $this.off('click.collapse', '> li > .collapsible-header');
	       $panel_headers.off('click.collapse');


	       /****************
	       Helper Functions
	       ****************/

	      // Accordion Open
	      function accordionOpen(object) {
	        $panel_headers = $this.find('> li > .collapsible-header');
	        if (object.hasClass('active')) {
	            object.parent().addClass('active');
	        }
	        else {
	            object.parent().removeClass('active');
	        }
	        if (object.parent().hasClass('active')){
	          object.siblings('.collapsible-body').stop(true,false).slideDown({ duration: 350, easing: "easeOutQuart", queue: false, complete: function() {$(this).css('height', '');}});
	        }
	        else{
	          object.siblings('.collapsible-body').stop(true,false).slideUp({ duration: 350, easing: "easeOutQuart", queue: false, complete: function() {$(this).css('height', '');}});
	        }

	        $panel_headers.not(object).removeClass('active').parent().removeClass('active');
	        $panel_headers.not(object).parent().children('.collapsible-body').stop(true,false).slideUp(
	          {
	            duration: 350,
	            easing: "easeOutQuart",
	            queue: false,
	            complete:
	              function() {
	                $(this).css('height', '');
	              }
	          });
	      }

	      // Expandable Open
	      function expandableOpen(object) {
	        if (object.hasClass('active')) {
	            object.parent().addClass('active');
	        }
	        else {
	            object.parent().removeClass('active');
	        }
	        if (object.parent().hasClass('active')){
	          object.siblings('.collapsible-body').stop(true,false).slideDown({ duration: 350, easing: "easeOutQuart", queue: false, complete: function() {$(this).css('height', '');}});
	        }
	        else{
	          object.siblings('.collapsible-body').stop(true,false).slideUp({ duration: 350, easing: "easeOutQuart", queue: false, complete: function() {$(this).css('height', '');}});
	        }
	      }

	      /**
	       * Check if object is children of panel header
	       * @param  {Object}  object Jquery object
	       * @return {Boolean} true if it is children
	       */
	      function isChildrenOfPanelHeader(object) {

	        var panelHeader = getPanelHeader(object);

	        return panelHeader.length > 0;
	      }

	      /**
	       * Get panel header from a children element
	       * @param  {Object} object Jquery object
	       * @return {Object} panel header object
	       */
	      function getPanelHeader(object) {

	        return object.closest('li > .collapsible-header');
	      }

	      /*****  End Helper Functions  *****/



	      // Add click handler to only direct collapsible header children
	      $this.on('click.collapse', '> li > .collapsible-header', function(e) {
	        var $header = $(this),
	            element = $(e.target);

	        if (isChildrenOfPanelHeader(element)) {
	          element = getPanelHeader(element);
	        }

	        element.toggleClass('active');

	        if (options.accordion || collapsible_type === "accordion" || collapsible_type === undefined) { // Handle Accordion
	          accordionOpen(element);
	        } else { // Handle Expandables
	          expandableOpen(element);

	          if ($header.hasClass('active')) {
	            expandableOpen($header);
	          }
	        }
	      });

	      // Open first active
	      var $panel_headers = $this.find('> li > .collapsible-header');
	      if (options.accordion || collapsible_type === "accordion" || collapsible_type === undefined) { // Handle Accordion
	        accordionOpen($panel_headers.filter('.active').first());
	      }
	      else { // Handle Expandables
	        $panel_headers.filter('.active').each(function() {
	          expandableOpen($(this));
	        });
	      }

	    });
	  };

	  $(document).ready(function(){
	    $('.collapsible').collapsible();
	  });
	}( jQuery ));;(function ($) {

	  // Add posibility to scroll to selected option
	  // usefull for select for example
	  $.fn.scrollTo = function(elem) {
	    $(this).scrollTop($(this).scrollTop() - $(this).offset().top + $(elem).offset().top);
	    return this;
	  };

	  $.fn.dropdown = function (option) {
	    var defaults = {
	      inDuration: 300,
	      outDuration: 225,
	      constrain_width: true, // Constrains width of dropdown to the activator
	      hover: false,
	      gutter: 0, // Spacing from edge
	      belowOrigin: false,
	      alignment: 'left'
	    };

	    this.each(function(){
	    var origin = $(this);
	    var options = $.extend({}, defaults, option);
	    var isFocused = false;

	    // Dropdown menu
	    var activates = $("#"+ origin.attr('data-activates'));

	    function updateOptions() {
	      if (origin.data('induration') !== undefined)
	        options.inDuration = origin.data('inDuration');
	      if (origin.data('outduration') !== undefined)
	        options.outDuration = origin.data('outDuration');
	      if (origin.data('constrainwidth') !== undefined)
	        options.constrain_width = origin.data('constrainwidth');
	      if (origin.data('hover') !== undefined)
	        options.hover = origin.data('hover');
	      if (origin.data('gutter') !== undefined)
	        options.gutter = origin.data('gutter');
	      if (origin.data('beloworigin') !== undefined)
	        options.belowOrigin = origin.data('beloworigin');
	      if (origin.data('alignment') !== undefined)
	        options.alignment = origin.data('alignment');
	    }

	    updateOptions();

	    // Attach dropdown to its activator
	    origin.after(activates);

	    /*
	      Helper function to position and resize dropdown.
	      Used in hover and click handler.
	    */
	    function placeDropdown(eventType) {
	      // Check for simultaneous focus and click events.
	      if (eventType === 'focus') {
	        isFocused = true;
	      }

	      // Check html data attributes
	      updateOptions();

	      // Set Dropdown state
	      activates.addClass('active');
	      origin.addClass('active');

	      // Constrain width
	      if (options.constrain_width === true) {
	        activates.css('width', origin.outerWidth());

	      } else {
	        activates.css('white-space', 'nowrap');
	      }

	      // Offscreen detection
	      var windowHeight = window.innerHeight;
	      var originHeight = origin.innerHeight();
	      var offsetLeft = origin.offset().left;
	      var offsetTop = origin.offset().top - $(window).scrollTop();
	      var currAlignment = options.alignment;
	      var gutterSpacing = 0;
	      var leftPosition = 0;

	      // Below Origin
	      var verticalOffset = 0;
	      if (options.belowOrigin === true) {
	        verticalOffset = originHeight;
	      }

	      // Check for scrolling positioned container.
	      var scrollOffset = 0;
	      var wrapper = origin.parent();
	      if (!wrapper.is('body') && wrapper[0].scrollHeight > wrapper[0].clientHeight) {
	        scrollOffset = wrapper[0].scrollTop;
	      }


	      if (offsetLeft + activates.innerWidth() > $(window).width()) {
	        // Dropdown goes past screen on right, force right alignment
	        currAlignment = 'right';

	      } else if (offsetLeft - activates.innerWidth() + origin.innerWidth() < 0) {
	        // Dropdown goes past screen on left, force left alignment
	        currAlignment = 'left';
	      }
	      // Vertical bottom offscreen detection
	      if (offsetTop + activates.innerHeight() > windowHeight) {
	        // If going upwards still goes offscreen, just crop height of dropdown.
	        if (offsetTop + originHeight - activates.innerHeight() < 0) {
	          var adjustedHeight = windowHeight - offsetTop - verticalOffset;
	          activates.css('max-height', adjustedHeight);
	        } else {
	          // Flow upwards.
	          if (!verticalOffset) {
	            verticalOffset += originHeight;
	          }
	          verticalOffset -= activates.innerHeight();
	        }
	      }

	      // Handle edge alignment
	      if (currAlignment === 'left') {
	        gutterSpacing = options.gutter;
	        leftPosition = origin.position().left + gutterSpacing;
	      }
	      else if (currAlignment === 'right') {
	        var offsetRight = origin.position().left + origin.outerWidth() - activates.outerWidth();
	        gutterSpacing = -options.gutter;
	        leftPosition =  offsetRight + gutterSpacing;
	      }

	      // Position dropdown
	      activates.css({
	        position: 'absolute',
	        top: origin.position().top + verticalOffset + scrollOffset,
	        left: leftPosition
	      });


	      // Show dropdown
	      activates.stop(true, true).css('opacity', 0)
	        .slideDown({
	        queue: false,
	        duration: options.inDuration,
	        easing: 'easeOutCubic',
	        complete: function() {
	          $(this).css('height', '');
	        }
	      })
	        .animate( {opacity: 1}, {queue: false, duration: options.inDuration, easing: 'easeOutSine'});
	    }

	    function hideDropdown() {
	      // Check for simultaneous focus and click events.
	      isFocused = false;
	      activates.fadeOut(options.outDuration);
	      activates.removeClass('active');
	      origin.removeClass('active');
	      setTimeout(function() { activates.css('max-height', ''); }, options.outDuration);
	    }

	    // Hover
	    if (options.hover) {
	      var open = false;
	      origin.unbind('click.' + origin.attr('id'));
	      // Hover handler to show dropdown
	      origin.on('mouseenter', function(e){ // Mouse over
	        if (open === false) {
	          placeDropdown();
	          open = true;
	        }
	      });
	      origin.on('mouseleave', function(e){
	        // If hover on origin then to something other than dropdown content, then close
	        var toEl = e.toElement || e.relatedTarget; // added browser compatibility for target element
	        if(!$(toEl).closest('.dropdown-content').is(activates)) {
	          activates.stop(true, true);
	          hideDropdown();
	          open = false;
	        }
	      });

	      activates.on('mouseleave', function(e){ // Mouse out
	        var toEl = e.toElement || e.relatedTarget;
	        if(!$(toEl).closest('.dropdown-button').is(origin)) {
	          activates.stop(true, true);
	          hideDropdown();
	          open = false;
	        }
	      });

	    // Click
	    } else {
	      // Click handler to show dropdown
	      origin.unbind('click.' + origin.attr('id'));
	      origin.bind('click.'+origin.attr('id'), function(e){
	        if (!isFocused) {
	          if ( origin[0] == e.currentTarget &&
	               !origin.hasClass('active') &&
	               ($(e.target).closest('.dropdown-content').length === 0)) {
	            e.preventDefault(); // Prevents button click from moving window
	            placeDropdown('click');
	          }
	          // If origin is clicked and menu is open, close menu
	          else if (origin.hasClass('active')) {
	            hideDropdown();
	            $(document).unbind('click.'+ activates.attr('id') + ' touchstart.' + activates.attr('id'));
	          }
	          // If menu open, add click close handler to document
	          if (activates.hasClass('active')) {
	            $(document).bind('click.'+ activates.attr('id') + ' touchstart.' + activates.attr('id'), function (e) {
	              if (!activates.is(e.target) && !origin.is(e.target) && (!origin.find(e.target).length) ) {
	                hideDropdown();
	                $(document).unbind('click.'+ activates.attr('id') + ' touchstart.' + activates.attr('id'));
	              }
	            });
	          }
	        }
	      });

	    } // End else

	    // Listen to open and close event - useful for select component
	    origin.on('open', function(e, eventType) {
	      placeDropdown(eventType);
	    });
	    origin.on('close', hideDropdown);


	   });
	  }; // End dropdown plugin

	  $(document).ready(function(){
	    $('.dropdown-button').dropdown();
	  });
	}( jQuery ));
	;(function($) {
	    var _stack = 0,
	    _lastID = 0,
	    _generateID = function() {
	      _lastID++;
	      return 'materialize-lean-overlay-' + _lastID;
	    };

	  $.fn.extend({
	    openModal: function(options) {

	      var $body = $('body');
	      var oldWidth = $body.innerWidth();
	      $body.css('overflow', 'hidden');
	      $body.width(oldWidth);

	      var defaults = {
	        opacity: 0.5,
	        in_duration: 350,
	        out_duration: 250,
	        ready: undefined,
	        complete: undefined,
	        dismissible: true,
	        starting_top: '4%'
	      },
	      $modal = $(this);

	      if ($modal.hasClass('open')) {
	        return;
	      }

	      overlayID = _generateID();
	      $overlay = $('<div class="lean-overlay"></div>');
	      lStack = (++_stack);

	      // Store a reference of the overlay
	      $overlay.attr('id', overlayID).css('z-index', 1000 + lStack * 2);
	      $modal.data('overlay-id', overlayID).css('z-index', 1000 + lStack * 2 + 1);
	      $modal.addClass('open');

	      $("body").append($overlay);

	      // Override defaults
	      options = $.extend(defaults, options);

	      if (options.dismissible) {
	        $overlay.click(function() {
	          $modal.closeModal(options);
	        });
	        // Return on ESC
	        $(document).on('keyup.leanModal' + overlayID, function(e) {
	          if (e.keyCode === 27) {   // ESC key
	            $modal.closeModal(options);
	          }
	        });
	      }

	      $modal.find(".modal-close").on('click.close', function(e) {
	        $modal.closeModal(options);
	      });

	      $overlay.css({ display : "block", opacity : 0 });

	      $modal.css({
	        display : "block",
	        opacity: 0
	      });

	      $overlay.velocity({opacity: options.opacity}, {duration: options.in_duration, queue: false, ease: "easeOutCubic"});
	      $modal.data('associated-overlay', $overlay[0]);

	      // Define Bottom Sheet animation
	      if ($modal.hasClass('bottom-sheet')) {
	        $modal.velocity({bottom: "0", opacity: 1}, {
	          duration: options.in_duration,
	          queue: false,
	          ease: "easeOutCubic",
	          // Handle modal ready callback
	          complete: function() {
	            if (typeof(options.ready) === "function") {
	              options.ready();
	            }
	          }
	        });
	      }
	      else {
	        $.Velocity.hook($modal, "scaleX", 0.7);
	        $modal.css({ top: options.starting_top });
	        $modal.velocity({top: "10%", opacity: 1, scaleX: '1'}, {
	          duration: options.in_duration,
	          queue: false,
	          ease: "easeOutCubic",
	          // Handle modal ready callback
	          complete: function() {
	            if (typeof(options.ready) === "function") {
	              options.ready();
	            }
	          }
	        });
	      }


	    }
	  });

	  $.fn.extend({
	    closeModal: function(options) {
	      var defaults = {
	        out_duration: 250,
	        complete: undefined
	      },
	      $modal = $(this),
	      overlayID = $modal.data('overlay-id'),
	      $overlay = $('#' + overlayID);
	      $modal.removeClass('open');

	      options = $.extend(defaults, options);

	      // Enable scrolling
	      $('body').css({
	        overflow: '',
	        width: ''
	      });

	      $modal.find('.modal-close').off('click.close');
	      $(document).off('keyup.leanModal' + overlayID);

	      $overlay.velocity( { opacity: 0}, {duration: options.out_duration, queue: false, ease: "easeOutQuart"});


	      // Define Bottom Sheet animation
	      if ($modal.hasClass('bottom-sheet')) {
	        $modal.velocity({bottom: "-100%", opacity: 0}, {
	          duration: options.out_duration,
	          queue: false,
	          ease: "easeOutCubic",
	          // Handle modal ready callback
	          complete: function() {
	            $overlay.css({display:"none"});

	            // Call complete callback
	            if (typeof(options.complete) === "function") {
	              options.complete();
	            }
	            $overlay.remove();
	            _stack--;
	          }
	        });
	      }
	      else {
	        $modal.velocity(
	          { top: options.starting_top, opacity: 0, scaleX: 0.7}, {
	          duration: options.out_duration,
	          complete:
	            function() {

	              $(this).css('display', 'none');
	              // Call complete callback
	              if (typeof(options.complete) === "function") {
	                options.complete();
	              }
	              $overlay.remove();
	              _stack--;
	            }
	          }
	        );
	      }
	    }
	  });

	  $.fn.extend({
	    leanModal: function(option) {
	      return this.each(function() {

	        var defaults = {
	          starting_top: '4%'
	        },
	        // Override defaults
	        options = $.extend(defaults, option);

	        // Close Handlers
	        $(this).click(function(e) {
	          options.starting_top = ($(this).offset().top - $(window).scrollTop()) /1.15;
	          var modal_id = $(this).attr("href") || '#' + $(this).data('target');
	          $(modal_id).openModal(options);
	          e.preventDefault();
	        }); // done set on click
	      }); // done return
	    }
	  });
	})(jQuery);
	;(function ($) {

	  $.fn.materialbox = function () {

	    return this.each(function() {

	      if ($(this).hasClass('initialized')) {
	        return;
	      }

	      $(this).addClass('initialized');

	      var overlayActive = false;
	      var doneAnimating = true;
	      var inDuration = 275;
	      var outDuration = 200;
	      var origin = $(this);
	      var placeholder = $('<div></div>').addClass('material-placeholder');
	      var originalWidth = 0;
	      var originalHeight = 0;
	      var ancestorsChanged;
	      var ancestor;
	      origin.wrap(placeholder);


	      origin.on('click', function(){
	        var placeholder = origin.parent('.material-placeholder');
	        var windowWidth = window.innerWidth;
	        var windowHeight = window.innerHeight;
	        var originalWidth = origin.width();
	        var originalHeight = origin.height();


	        // If already modal, return to original
	        if (doneAnimating === false) {
	          returnToOriginal();
	          return false;
	        }
	        else if (overlayActive && doneAnimating===true) {
	          returnToOriginal();
	          return false;
	        }


	        // Set states
	        doneAnimating = false;
	        origin.addClass('active');
	        overlayActive = true;

	        // Set positioning for placeholder
	        placeholder.css({
	          width: placeholder[0].getBoundingClientRect().width,
	          height: placeholder[0].getBoundingClientRect().height,
	          position: 'relative',
	          top: 0,
	          left: 0
	        });

	        // Find ancestor with overflow: hidden; and remove it
	        ancestorsChanged = undefined;
	        ancestor = placeholder[0].parentNode;
	        var count = 0;
	        while (ancestor !== null && !$(ancestor).is(document)) {
	          var curr = $(ancestor);
	          if (curr.css('overflow') !== 'visible') {
	            curr.css('overflow', 'visible');
	            if (ancestorsChanged === undefined) {
	              ancestorsChanged = curr;
	            }
	            else {
	              ancestorsChanged = ancestorsChanged.add(curr);
	            }
	          }
	          ancestor = ancestor.parentNode;
	        }

	        // Set css on origin
	        origin.css({position: 'absolute', 'z-index': 1000})
	        .data('width', originalWidth)
	        .data('height', originalHeight);

	        // Add overlay
	        var overlay = $('<div id="materialbox-overlay"></div>')
	          .css({
	            opacity: 0
	          })
	          .click(function(){
	            if (doneAnimating === true)
	            returnToOriginal();
	          });
	          // Animate Overlay
	          // Put before in origin image to preserve z-index layering.
	          origin.before(overlay);
	          overlay.velocity({opacity: 1},
	                           {duration: inDuration, queue: false, easing: 'easeOutQuad'} );

	        // Add and animate caption if it exists
	        if (origin.data('caption') !== "") {
	          var $photo_caption = $('<div class="materialbox-caption"></div>');
	          $photo_caption.text(origin.data('caption'));
	          $('body').append($photo_caption);
	          $photo_caption.css({ "display": "inline" });
	          $photo_caption.velocity({opacity: 1}, {duration: inDuration, queue: false, easing: 'easeOutQuad'});
	        }

	        // Resize Image
	        var ratio = 0;
	        var widthPercent = originalWidth / windowWidth;
	        var heightPercent = originalHeight / windowHeight;
	        var newWidth = 0;
	        var newHeight = 0;

	        if (widthPercent > heightPercent) {
	          ratio = originalHeight / originalWidth;
	          newWidth = windowWidth * 0.9;
	          newHeight = windowWidth * 0.9 * ratio;
	        }
	        else {
	          ratio = originalWidth / originalHeight;
	          newWidth = (windowHeight * 0.9) * ratio;
	          newHeight = windowHeight * 0.9;
	        }

	        // Animate image + set z-index
	        if(origin.hasClass('responsive-img')) {
	          origin.velocity({'max-width': newWidth, 'width': originalWidth}, {duration: 0, queue: false,
	            complete: function(){
	              origin.css({left: 0, top: 0})
	              .velocity(
	                {
	                  height: newHeight,
	                  width: newWidth,
	                  left: $(document).scrollLeft() + windowWidth/2 - origin.parent('.material-placeholder').offset().left - newWidth/2,
	                  top: $(document).scrollTop() + windowHeight/2 - origin.parent('.material-placeholder').offset().top - newHeight/ 2
	                },
	                {
	                  duration: inDuration,
	                  queue: false,
	                  easing: 'easeOutQuad',
	                  complete: function(){doneAnimating = true;}
	                }
	              );
	            } // End Complete
	          }); // End Velocity
	        }
	        else {
	          origin.css('left', 0)
	          .css('top', 0)
	          .velocity(
	            {
	              height: newHeight,
	              width: newWidth,
	              left: $(document).scrollLeft() + windowWidth/2 - origin.parent('.material-placeholder').offset().left - newWidth/2,
	              top: $(document).scrollTop() + windowHeight/2 - origin.parent('.material-placeholder').offset().top - newHeight/ 2
	            },
	            {
	              duration: inDuration,
	              queue: false,
	              easing: 'easeOutQuad',
	              complete: function(){doneAnimating = true;}
	            }
	            ); // End Velocity
	        }

	    }); // End origin on click


	      // Return on scroll
	      $(window).scroll(function() {
	        if (overlayActive) {
	          returnToOriginal();
	        }
	      });

	      // Return on ESC
	      $(document).keyup(function(e) {

	        if (e.keyCode === 27 && doneAnimating === true) {   // ESC key
	          if (overlayActive) {
	            returnToOriginal();
	          }
	        }
	      });


	      // This function returns the modaled image to the original spot
	      function returnToOriginal() {

	          doneAnimating = false;

	          var placeholder = origin.parent('.material-placeholder');
	          var windowWidth = window.innerWidth;
	          var windowHeight = window.innerHeight;
	          var originalWidth = origin.data('width');
	          var originalHeight = origin.data('height');

	          origin.velocity("stop", true);
	          $('#materialbox-overlay').velocity("stop", true);
	          $('.materialbox-caption').velocity("stop", true);


	          $('#materialbox-overlay').velocity({opacity: 0}, {
	            duration: outDuration, // Delay prevents animation overlapping
	            queue: false, easing: 'easeOutQuad',
	            complete: function(){
	              // Remove Overlay
	              overlayActive = false;
	              $(this).remove();
	            }
	          });

	          // Resize Image
	          origin.velocity(
	            {
	              width: originalWidth,
	              height: originalHeight,
	              left: 0,
	              top: 0
	            },
	            {
	              duration: outDuration,
	              queue: false, easing: 'easeOutQuad'
	            }
	          );

	          // Remove Caption + reset css settings on image
	          $('.materialbox-caption').velocity({opacity: 0}, {
	            duration: outDuration, // Delay prevents animation overlapping
	            queue: false, easing: 'easeOutQuad',
	            complete: function(){
	              placeholder.css({
	                height: '',
	                width: '',
	                position: '',
	                top: '',
	                left: ''
	              });

	              origin.css({
	                height: '',
	                top: '',
	                left: '',
	                width: '',
	                'max-width': '',
	                position: '',
	                'z-index': ''
	              });

	              // Remove class
	              origin.removeClass('active');
	              doneAnimating = true;
	              $(this).remove();

	              // Remove overflow overrides on ancestors
	              if (ancestorsChanged) {
	                ancestorsChanged.css('overflow', '');
	              }
	            }
	          });

	        }
	        });
	};

	$(document).ready(function(){
	  $('.materialboxed').materialbox();
	});

	}( jQuery ));
	;(function ($) {

	    $.fn.parallax = function () {
	      var window_width = $(window).width();
	      // Parallax Scripts
	      return this.each(function(i) {
	        var $this = $(this);
	        $this.addClass('parallax');

	        function updateParallax(initial) {
	          var container_height;
	          if (window_width < 601) {
	            container_height = ($this.height() > 0) ? $this.height() : $this.children("img").height();
	          }
	          else {
	            container_height = ($this.height() > 0) ? $this.height() : 500;
	          }
	          var $img = $this.children("img").first();
	          var img_height = $img.height();
	          var parallax_dist = img_height - container_height;
	          var bottom = $this.offset().top + container_height;
	          var top = $this.offset().top;
	          var scrollTop = $(window).scrollTop();
	          var windowHeight = window.innerHeight;
	          var windowBottom = scrollTop + windowHeight;
	          var percentScrolled = (windowBottom - top) / (container_height + windowHeight);
	          var parallax = Math.round((parallax_dist * percentScrolled));

	          if (initial) {
	            $img.css('display', 'block');
	          }
	          if ((bottom > scrollTop) && (top < (scrollTop + windowHeight))) {
	            $img.css('transform', "translate3D(-50%," + parallax + "px, 0)");
	          }

	        }

	        // Wait for image load
	        $this.children("img").one("load", function() {
	          updateParallax(true);
	        }).each(function() {
	          if(this.complete) $(this).load();
	        });

	        $(window).scroll(function() {
	          window_width = $(window).width();
	          updateParallax(false);
	        });

	        $(window).resize(function() {
	          window_width = $(window).width();
	          updateParallax(false);
	        });

	      });

	    };
	}( jQuery ));;(function ($) {

	  var methods = {
	    init : function() {
	      return this.each(function() {

	      // For each set of tabs, we want to keep track of
	      // which tab is active and its associated content
	      var $this = $(this),
	          window_width = $(window).width();

	      $this.width('100%');
	      var $active, $content, $links = $this.find('li.tab a'),
	          $tabs_width = $this.width(),
	          $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length,
	          $index = 0;

	      // If the location.hash matches one of the links, use that as the active tab.
	      $active = $($links.filter('[href="'+location.hash+'"]'));

	      // If no match is found, use the first link or any with class 'active' as the initial active tab.
	      if ($active.length === 0) {
	          $active = $(this).find('li.tab a.active').first();
	      }
	      if ($active.length === 0) {
	        $active = $(this).find('li.tab a').first();
	      }

	      $active.addClass('active');
	      $index = $links.index($active);
	      if ($index < 0) {
	        $index = 0;
	      }

	      if ($active[0] !== undefined) {
	        $content = $($active[0].hash);
	      }

	      // append indicator then set indicator width to tab width
	      $this.append('<div class="indicator"></div>');
	      var $indicator = $this.find('.indicator');
	      if ($this.is(":visible")) {
	        $indicator.css({"right": $tabs_width - (($index + 1) * $tab_width)});
	        $indicator.css({"left": $index * $tab_width});
	      }
	      $(window).resize(function () {
	        $tabs_width = $this.width();
	        $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length;
	        if ($index < 0) {
	          $index = 0;
	        }
	        if ($tab_width !== 0 && $tabs_width !== 0) {
	          $indicator.css({"right": $tabs_width - (($index + 1) * $tab_width)});
	          $indicator.css({"left": $index * $tab_width});
	        }
	      });

	      // Hide the remaining content
	      $links.not($active).each(function () {
	        $(this.hash).hide();
	      });


	      // Bind the click event handler
	      $this.on('click', 'a', function(e) {
	        if ($(this).parent().hasClass('disabled')) {
	          e.preventDefault();
	          return;
	        }

	        $tabs_width = $this.width();
	        $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length;

	        // Make the old tab inactive.
	        $active.removeClass('active');
	        if ($content !== undefined) {
	          $content.hide();
	        }

	        // Update the variables with the new link and content
	        $active = $(this);
	        $content = $(this.hash);
	        $links = $this.find('li.tab a');

	        // Make the tab active.
	        $active.addClass('active');
	        var $prev_index = $index;
	        $index = $links.index($(this));
	        if ($index < 0) {
	          $index = 0;
	        }
	        // Change url to current tab
	        // window.location.hash = $active.attr('href');

	        if ($content !== undefined) {
	          $content.show();
	        }

	        // Update indicator
	        if (($index - $prev_index) >= 0) {
	          $indicator.velocity({"right": $tabs_width - (($index + 1) * $tab_width)}, { duration: 300, queue: false, easing: 'easeOutQuad'});
	          $indicator.velocity({"left": $index * $tab_width}, {duration: 300, queue: false, easing: 'easeOutQuad', delay: 90});

	        }
	        else {
	          $indicator.velocity({"left": $index * $tab_width}, { duration: 300, queue: false, easing: 'easeOutQuad'});
	          $indicator.velocity({"right": $tabs_width - (($index + 1) * $tab_width)}, {duration: 300, queue: false, easing: 'easeOutQuad', delay: 90});
	        }

	        // Prevent the anchor's default click action
	        e.preventDefault();
	      });
	    });

	    },
	    select_tab : function( id ) {
	      this.find('a[href="#' + id + '"]').trigger('click');
	    }
	  };

	  $.fn.tabs = function(methodOrOptions) {
	    if ( methods[methodOrOptions] ) {
	      return methods[ methodOrOptions ].apply( this, Array.prototype.slice.call( arguments, 1 ));
	    } else if ( typeof methodOrOptions === 'object' || ! methodOrOptions ) {
	      // Default to "init"
	      return methods.init.apply( this, arguments );
	    } else {
	      $.error( 'Method ' +  methodOrOptions + ' does not exist on jQuery.tooltip' );
	    }
	  };

	  $(document).ready(function(){
	    $('ul.tabs').tabs();
	  });
	}( jQuery ));
	;(function ($) {
	    $.fn.tooltip = function (options) {
	        var timeout = null,
	        margin = 5;

	      // Defaults
	      var defaults = {
	        delay: 350
	      };

	      // Remove tooltip from the activator
	      if (options === "remove") {
	        this.each(function(){
	          $('#' + $(this).attr('data-tooltip-id')).remove();
	          $(this).off('mouseenter.tooltip mouseleave.tooltip');
	        });
	        return false;
	      }

	      options = $.extend(defaults, options);


	      return this.each(function(){
	        var tooltipId = Materialize.guid();
	        var origin = $(this);
	        origin.attr('data-tooltip-id', tooltipId);

	        // Create Text span
	        var tooltip_text = $('<span></span>').text(origin.attr('data-tooltip'));

	        // Create tooltip
	        var newTooltip = $('<div></div>');
	        newTooltip.addClass('material-tooltip').append(tooltip_text)
	          .appendTo($('body'))
	          .attr('id', tooltipId);

	        var backdrop = $('<div></div>').addClass('backdrop');
	        backdrop.appendTo(newTooltip);
	        backdrop.css({ top: 0, left:0 });


	      //Destroy previously binded events
	      origin.off('mouseenter.tooltip mouseleave.tooltip');
	      // Mouse In
	      var started = false, timeoutRef;
	      origin.on({
	        'mouseenter.tooltip': function(e) {
	          var tooltip_delay = origin.attr('data-delay');
	          tooltip_delay = (tooltip_delay === undefined || tooltip_delay === '') ?
	              options.delay : tooltip_delay;
	          timeoutRef = setTimeout(function(){
	            started = true;
	            newTooltip.velocity('stop');
	            backdrop.velocity('stop');
	            newTooltip.css({ display: 'block', left: '0px', top: '0px' });

	            // Set Tooltip text
	            newTooltip.children('span').text(origin.attr('data-tooltip'));

	            // Tooltip positioning
	            var originWidth = origin.outerWidth();
	            var originHeight = origin.outerHeight();
	            var tooltipPosition =  origin.attr('data-position');
	            var tooltipHeight = newTooltip.outerHeight();
	            var tooltipWidth = newTooltip.outerWidth();
	            var tooltipVerticalMovement = '0px';
	            var tooltipHorizontalMovement = '0px';
	            var scale_factor = 8;
	            var targetTop, targetLeft, newCoordinates;

	            if (tooltipPosition === "top") {
	              // Top Position
	              targetTop = origin.offset().top - tooltipHeight - margin;
	              targetLeft = origin.offset().left + originWidth/2 - tooltipWidth/2;
	              newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);

	              tooltipVerticalMovement = '-10px';
	              backdrop.css({
	                borderRadius: '14px 14px 0 0',
	                transformOrigin: '50% 90%',
	                marginTop: tooltipHeight,
	                marginLeft: (tooltipWidth/2) - (backdrop.width()/2)
	              });
	            }
	            // Left Position
	            else if (tooltipPosition === "left") {
	              targetTop = origin.offset().top + originHeight/2 - tooltipHeight/2;
	              targetLeft =  origin.offset().left - tooltipWidth - margin;
	              newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);

	              tooltipHorizontalMovement = '-10px';
	              backdrop.css({
	                width: '14px',
	                height: '14px',
	                borderRadius: '14px 0 0 14px',
	                transformOrigin: '95% 50%',
	                marginTop: tooltipHeight/2,
	                marginLeft: tooltipWidth
	              });
	            }
	            // Right Position
	            else if (tooltipPosition === "right") {
	              targetTop = origin.offset().top + originHeight/2 - tooltipHeight/2;
	              targetLeft = origin.offset().left + originWidth + margin;
	              newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);

	              tooltipHorizontalMovement = '+10px';
	              backdrop.css({
	                width: '14px',
	                height: '14px',
	                borderRadius: '0 14px 14px 0',
	                transformOrigin: '5% 50%',
	                marginTop: tooltipHeight/2,
	                marginLeft: '0px'
	              });
	            }
	            else {
	              // Bottom Position
	              targetTop = origin.offset().top + origin.outerHeight() + margin;
	              targetLeft = origin.offset().left + originWidth/2 - tooltipWidth/2;
	              newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);
	              tooltipVerticalMovement = '+10px';
	              backdrop.css({
	                marginLeft: (tooltipWidth/2) - (backdrop.width()/2)
	              });
	            }

	            // Set tooptip css placement
	            newTooltip.css({
	              top: newCoordinates.y,
	              left: newCoordinates.x
	            });

	            // Calculate Scale to fill
	            scale_factor = tooltipWidth / 8;
	            if (scale_factor < 8) {
	              scale_factor = 8;
	            }
	            if (tooltipPosition === "right" || tooltipPosition === "left") {
	              scale_factor = tooltipWidth / 10;
	              if (scale_factor < 6)
	                scale_factor = 6;
	            }

	            newTooltip.velocity({ marginTop: tooltipVerticalMovement, marginLeft: tooltipHorizontalMovement}, { duration: 350, queue: false })
	              .velocity({opacity: 1}, {duration: 300, delay: 50, queue: false});
	            backdrop.css({ display: 'block' })
	              .velocity({opacity:1},{duration: 55, delay: 0, queue: false})
	              .velocity({scale: scale_factor}, {duration: 300, delay: 0, queue: false, easing: 'easeInOutQuad'});


	          }, tooltip_delay); // End Interval

	        // Mouse Out
	        },
	        'mouseleave.tooltip': function(){
	          // Reset State
	          started = false;
	          clearTimeout(timeoutRef);

	          // Animate back
	          setTimeout(function() {
	            if (started != true) {
	              newTooltip.velocity({
	                opacity: 0, marginTop: 0, marginLeft: 0}, { duration: 225, queue: false});
	              backdrop.velocity({opacity: 0, scale: 1}, {
	                duration:225,
	                queue: false,
	                complete: function(){
	                  backdrop.css('display', 'none');
	                  newTooltip.css('display', 'none');
	                  started = false;}
	              });
	            }
	          },225);
	        }
	        });
	    });
	  };

	  var repositionWithinScreen = function(x, y, width, height) {
	    var newX = x
	    var newY = y;

	    if (newX < 0) {
	      newX = 4;
	    } else if (newX + width > window.innerWidth) {
	      newX -= newX + width - window.innerWidth;
	    }

	    if (newY < 0) {
	      newY = 4;
	    } else if (newY + height > window.innerHeight + $(window).scrollTop) {
	      newY -= newY + height - window.innerHeight;
	    }

	    return {x: newX, y: newY};
	  };

	  $(document).ready(function(){
	     $('.tooltipped').tooltip();
	   });
	}( jQuery ));
	;/*!
	 * Waves v0.6.4
	 * http://fian.my.id/Waves
	 *
	 * Copyright 2014 Alfiana E. Sibuea and other contributors
	 * Released under the MIT license
	 * https://github.com/fians/Waves/blob/master/LICENSE
	 */

	;(function(window) {
	    'use strict';

	    var Waves = Waves || {};
	    var $$ = document.querySelectorAll.bind(document);

	    // Find exact position of element
	    function isWindow(obj) {
	        return obj !== null && obj === obj.window;
	    }

	    function getWindow(elem) {
	        return isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
	    }

	    function offset(elem) {
	        var docElem, win,
	            box = {top: 0, left: 0},
	            doc = elem && elem.ownerDocument;

	        docElem = doc.documentElement;

	        if (typeof elem.getBoundingClientRect !== typeof undefined) {
	            box = elem.getBoundingClientRect();
	        }
	        win = getWindow(doc);
	        return {
	            top: box.top + win.pageYOffset - docElem.clientTop,
	            left: box.left + win.pageXOffset - docElem.clientLeft
	        };
	    }

	    function convertStyle(obj) {
	        var style = '';

	        for (var a in obj) {
	            if (obj.hasOwnProperty(a)) {
	                style += (a + ':' + obj[a] + ';');
	            }
	        }

	        return style;
	    }

	    var Effect = {

	        // Effect delay
	        duration: 750,

	        show: function(e, element) {

	            // Disable right click
	            if (e.button === 2) {
	                return false;
	            }

	            var el = element || this;

	            // Create ripple
	            var ripple = document.createElement('div');
	            ripple.className = 'waves-ripple';
	            el.appendChild(ripple);

	            // Get click coordinate and element witdh
	            var pos         = offset(el);
	            var relativeY   = (e.pageY - pos.top);
	            var relativeX   = (e.pageX - pos.left);
	            var scale       = 'scale('+((el.clientWidth / 100) * 10)+')';

	            // Support for touch devices
	            if ('touches' in e) {
	              relativeY   = (e.touches[0].pageY - pos.top);
	              relativeX   = (e.touches[0].pageX - pos.left);
	            }

	            // Attach data to element
	            ripple.setAttribute('data-hold', Date.now());
	            ripple.setAttribute('data-scale', scale);
	            ripple.setAttribute('data-x', relativeX);
	            ripple.setAttribute('data-y', relativeY);

	            // Set ripple position
	            var rippleStyle = {
	                'top': relativeY+'px',
	                'left': relativeX+'px'
	            };

	            ripple.className = ripple.className + ' waves-notransition';
	            ripple.setAttribute('style', convertStyle(rippleStyle));
	            ripple.className = ripple.className.replace('waves-notransition', '');

	            // Scale the ripple
	            rippleStyle['-webkit-transform'] = scale;
	            rippleStyle['-moz-transform'] = scale;
	            rippleStyle['-ms-transform'] = scale;
	            rippleStyle['-o-transform'] = scale;
	            rippleStyle.transform = scale;
	            rippleStyle.opacity   = '1';

	            rippleStyle['-webkit-transition-duration'] = Effect.duration + 'ms';
	            rippleStyle['-moz-transition-duration']    = Effect.duration + 'ms';
	            rippleStyle['-o-transition-duration']      = Effect.duration + 'ms';
	            rippleStyle['transition-duration']         = Effect.duration + 'ms';

	            rippleStyle['-webkit-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
	            rippleStyle['-moz-transition-timing-function']    = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
	            rippleStyle['-o-transition-timing-function']      = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
	            rippleStyle['transition-timing-function']         = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';

	            ripple.setAttribute('style', convertStyle(rippleStyle));
	        },

	        hide: function(e) {
	            TouchHandler.touchup(e);

	            var el = this;
	            var width = el.clientWidth * 1.4;

	            // Get first ripple
	            var ripple = null;
	            var ripples = el.getElementsByClassName('waves-ripple');
	            if (ripples.length > 0) {
	                ripple = ripples[ripples.length - 1];
	            } else {
	                return false;
	            }

	            var relativeX   = ripple.getAttribute('data-x');
	            var relativeY   = ripple.getAttribute('data-y');
	            var scale       = ripple.getAttribute('data-scale');

	            // Get delay beetween mousedown and mouse leave
	            var diff = Date.now() - Number(ripple.getAttribute('data-hold'));
	            var delay = 350 - diff;

	            if (delay < 0) {
	                delay = 0;
	            }

	            // Fade out ripple after delay
	            setTimeout(function() {
	                var style = {
	                    'top': relativeY+'px',
	                    'left': relativeX+'px',
	                    'opacity': '0',

	                    // Duration
	                    '-webkit-transition-duration': Effect.duration + 'ms',
	                    '-moz-transition-duration': Effect.duration + 'ms',
	                    '-o-transition-duration': Effect.duration + 'ms',
	                    'transition-duration': Effect.duration + 'ms',
	                    '-webkit-transform': scale,
	                    '-moz-transform': scale,
	                    '-ms-transform': scale,
	                    '-o-transform': scale,
	                    'transform': scale,
	                };

	                ripple.setAttribute('style', convertStyle(style));

	                setTimeout(function() {
	                    try {
	                        el.removeChild(ripple);
	                    } catch(e) {
	                        return false;
	                    }
	                }, Effect.duration);
	            }, delay);
	        },

	        // Little hack to make <input> can perform waves effect
	        wrapInput: function(elements) {
	            for (var a = 0; a < elements.length; a++) {
	                var el = elements[a];

	                if (el.tagName.toLowerCase() === 'input') {
	                    var parent = el.parentNode;

	                    // If input already have parent just pass through
	                    if (parent.tagName.toLowerCase() === 'i' && parent.className.indexOf('waves-effect') !== -1) {
	                        continue;
	                    }

	                    // Put element class and style to the specified parent
	                    var wrapper = document.createElement('i');
	                    wrapper.className = el.className + ' waves-input-wrapper';

	                    var elementStyle = el.getAttribute('style');

	                    if (!elementStyle) {
	                        elementStyle = '';
	                    }

	                    wrapper.setAttribute('style', elementStyle);

	                    el.className = 'waves-button-input';
	                    el.removeAttribute('style');

	                    // Put element as child
	                    parent.replaceChild(wrapper, el);
	                    wrapper.appendChild(el);
	                }
	            }
	        }
	    };


	    /**
	     * Disable mousedown event for 500ms during and after touch
	     */
	    var TouchHandler = {
	        /* uses an integer rather than bool so there's no issues with
	         * needing to clear timeouts if another touch event occurred
	         * within the 500ms. Cannot mouseup between touchstart and
	         * touchend, nor in the 500ms after touchend. */
	        touches: 0,
	        allowEvent: function(e) {
	            var allow = true;

	            if (e.type === 'touchstart') {
	                TouchHandler.touches += 1; //push
	            } else if (e.type === 'touchend' || e.type === 'touchcancel') {
	                setTimeout(function() {
	                    if (TouchHandler.touches > 0) {
	                        TouchHandler.touches -= 1; //pop after 500ms
	                    }
	                }, 500);
	            } else if (e.type === 'mousedown' && TouchHandler.touches > 0) {
	                allow = false;
	            }

	            return allow;
	        },
	        touchup: function(e) {
	            TouchHandler.allowEvent(e);
	        }
	    };


	    /**
	     * Delegated click handler for .waves-effect element.
	     * returns null when .waves-effect element not in "click tree"
	     */
	    function getWavesEffectElement(e) {
	        if (TouchHandler.allowEvent(e) === false) {
	            return null;
	        }

	        var element = null;
	        var target = e.target || e.srcElement;

	        while (target.parentElement !== null) {
	            if (!(target instanceof SVGElement) && target.className.indexOf('waves-effect') !== -1) {
	                element = target;
	                break;
	            } else if (target.classList.contains('waves-effect')) {
	                element = target;
	                break;
	            }
	            target = target.parentElement;
	        }

	        return element;
	    }

	    /**
	     * Bubble the click and show effect if .waves-effect elem was found
	     */
	    function showEffect(e) {
	        var element = getWavesEffectElement(e);

	        if (element !== null) {
	            Effect.show(e, element);

	            if ('ontouchstart' in window) {
	                element.addEventListener('touchend', Effect.hide, false);
	                element.addEventListener('touchcancel', Effect.hide, false);
	            }

	            element.addEventListener('mouseup', Effect.hide, false);
	            element.addEventListener('mouseleave', Effect.hide, false);
	        }
	    }

	    Waves.displayEffect = function(options) {
	        options = options || {};

	        if ('duration' in options) {
	            Effect.duration = options.duration;
	        }

	        //Wrap input inside <i> tag
	        Effect.wrapInput($$('.waves-effect'));

	        if ('ontouchstart' in window) {
	            document.body.addEventListener('touchstart', showEffect, false);
	        }

	        document.body.addEventListener('mousedown', showEffect, false);
	    };

	    /**
	     * Attach Waves to an input element (or any element which doesn't
	     * bubble mouseup/mousedown events).
	     *   Intended to be used with dynamically loaded forms/inputs, or
	     * where the user doesn't want a delegated click handler.
	     */
	    Waves.attach = function(element) {
	        //FUTURE: automatically add waves classes and allow users
	        // to specify them with an options param? Eg. light/classic/button
	        if (element.tagName.toLowerCase() === 'input') {
	            Effect.wrapInput([element]);
	            element = element.parentElement;
	        }

	        if ('ontouchstart' in window) {
	            element.addEventListener('touchstart', showEffect, false);
	        }

	        element.addEventListener('mousedown', showEffect, false);
	    };

	    window.Waves = Waves;

	    document.addEventListener('DOMContentLoaded', function() {
	        Waves.displayEffect();
	    }, false);

	})(window);
	;Materialize.toast = function (message, displayLength, className, completeCallback) {
	    className = className || "";

	    var container = document.getElementById('toast-container');

	    // Create toast container if it does not exist
	    if (container === null) {
	        // create notification container
	        container = document.createElement('div');
	        container.id = 'toast-container';
	        document.body.appendChild(container);
	    }

	    // Select and append toast
	    var newToast = createToast(message);

	    // only append toast if message is not undefined
	    if(message){
	        container.appendChild(newToast);
	    }

	    newToast.style.top = '35px';
	    newToast.style.opacity = 0;

	    // Animate toast in
	    Vel(newToast, { "top" : "0px", opacity: 1 }, {duration: 300,
	      easing: 'easeOutCubic',
	      queue: false});

	    // Allows timer to be pause while being panned
	    var timeLeft = displayLength;
	    var counterInterval = setInterval (function(){


	      if (newToast.parentNode === null)
	        window.clearInterval(counterInterval);

	      // If toast is not being dragged, decrease its time remaining
	      if (!newToast.classList.contains('panning')) {
	        timeLeft -= 20;
	      }

	      if (timeLeft <= 0) {
	        // Animate toast out
	        Vel(newToast, {"opacity": 0, marginTop: '-40px'}, { duration: 375,
	            easing: 'easeOutExpo',
	            queue: false,
	            complete: function(){
	              // Call the optional callback
	              if(typeof(completeCallback) === "function")
	                completeCallback();
	              // Remove toast after it times out
	              this[0].parentNode.removeChild(this[0]);
	            }
	          });
	        window.clearInterval(counterInterval);
	      }
	    }, 20);



	    function createToast(html) {

	        // Create toast
	        var toast = document.createElement('div');
	        toast.classList.add('toast');
	        if (className) {
	            var classes = className.split(' ');

	            for (var i = 0, count = classes.length; i < count; i++) {
	                toast.classList.add(classes[i]);
	            }
	        }
	        // If type of parameter is HTML Element
	        if ( typeof HTMLElement === "object" ? html instanceof HTMLElement : html && typeof html === "object" && html !== null && html.nodeType === 1 && typeof html.nodeName==="string"
	) {
	          toast.appendChild(html);
	        }
	        else if (html instanceof jQuery) {
	          // Check if it is jQuery object
	          toast.appendChild(html[0]);
	        }
	        else {
	          // Insert as text;
	          toast.innerHTML = html; 
	        }
	        // Bind hammer
	        var hammerHandler = new Hammer(toast, {prevent_default: false});
	        hammerHandler.on('pan', function(e) {
	          var deltaX = e.deltaX;
	          var activationDistance = 80;

	          // Change toast state
	          if (!toast.classList.contains('panning')){
	            toast.classList.add('panning');
	          }

	          var opacityPercent = 1-Math.abs(deltaX / activationDistance);
	          if (opacityPercent < 0)
	            opacityPercent = 0;

	          Vel(toast, {left: deltaX, opacity: opacityPercent }, {duration: 50, queue: false, easing: 'easeOutQuad'});

	        });

	        hammerHandler.on('panend', function(e) {
	          var deltaX = e.deltaX;
	          var activationDistance = 80;

	          // If toast dragged past activation point
	          if (Math.abs(deltaX) > activationDistance) {
	            Vel(toast, {marginTop: '-40px'}, { duration: 375,
	                easing: 'easeOutExpo',
	                queue: false,
	                complete: function(){
	                  if(typeof(completeCallback) === "function") {
	                    completeCallback();
	                  }
	                  toast.parentNode.removeChild(toast);
	                }
	            });

	          } else {
	            toast.classList.remove('panning');
	            // Put toast back into original position
	            Vel(toast, { left: 0, opacity: 1 }, { duration: 300,
	              easing: 'easeOutExpo',
	              queue: false
	            });

	          }
	        });

	        return toast;
	    }
	};
	;(function ($) {

	  var methods = {
	    init : function(options) {
	      var defaults = {
	        menuWidth: 240,
	        edge: 'left',
	        closeOnClick: false
	      };
	      options = $.extend(defaults, options);

	      $(this).each(function(){
	        var $this = $(this);
	        var menu_id = $("#"+ $this.attr('data-activates'));

	        // Set to width
	        if (options.menuWidth != 240) {
	          menu_id.css('width', options.menuWidth);
	        }

	        // Add Touch Area
	        var dragTarget = $('<div class="drag-target"></div>');
	        $('body').append(dragTarget);

	        if (options.edge == 'left') {
	          menu_id.css('transform', 'translateX(-100%)');
	          dragTarget.css({'left': 0}); // Add Touch Area
	        }
	        else {
	          menu_id.addClass('right-aligned') // Change text-alignment to right
	            .css('transform', 'translateX(100%)');
	          dragTarget.css({'right': 0}); // Add Touch Area
	        }

	        // If fixed sidenav, bring menu out
	        if (menu_id.hasClass('fixed')) {
	            if (window.innerWidth > 992) {
	              menu_id.css('transform', 'translateX(0)');
	            }
	          }

	        // Window resize to reset on large screens fixed
	        if (menu_id.hasClass('fixed')) {
	          $(window).resize( function() {
	            if (window.innerWidth > 992) {
	              // Close menu if window is resized bigger than 992 and user has fixed sidenav
	              if ($('#sidenav-overlay').length != 0 && menuOut) {
	                removeMenu(true);
	              }
	              else {
	                // menu_id.removeAttr('style');
	                menu_id.css('transform', 'translateX(0%)');
	                // menu_id.css('width', options.menuWidth);
	              }
	            }
	            else if (menuOut === false){
	              if (options.edge === 'left') {
	                menu_id.css('transform', 'translateX(-100%)');
	              } else {
	                menu_id.css('transform', 'translateX(100%)');
	              }

	            }

	          });
	        }

	        // if closeOnClick, then add close event for all a tags in side sideNav
	        if (options.closeOnClick === true) {
	          menu_id.on("click.itemclick", "a:not(.collapsible-header)", function(){
	            removeMenu();
	          });
	        }

	        function removeMenu(restoreNav) {
	          panning = false;
	          menuOut = false;
	          // Reenable scrolling
	          $('body').css({
	            overflow: '',
	            width: ''
	          });

	          $('#sidenav-overlay').velocity({opacity: 0}, {duration: 200,
	              queue: false, easing: 'easeOutQuad',
	            complete: function() {
	              $(this).remove();
	            } });
	          if (options.edge === 'left') {
	            // Reset phantom div
	            dragTarget.css({width: '', right: '', left: '0'});
	            menu_id.velocity(
	              {'translateX': '-100%'},
	              { duration: 200,
	                queue: false,
	                easing: 'easeOutCubic',
	                complete: function() {
	                  if (restoreNav === true) {
	                    // Restore Fixed sidenav
	                    menu_id.removeAttr('style');
	                    menu_id.css('width', options.menuWidth);
	                  }
	                }

	            });
	          }
	          else {
	            // Reset phantom div
	            dragTarget.css({width: '', right: '0', left: ''});
	            menu_id.velocity(
	              {'translateX': '100%'},
	              { duration: 200,
	                queue: false,
	                easing: 'easeOutCubic',
	                complete: function() {
	                  if (restoreNav === true) {
	                    // Restore Fixed sidenav
	                    menu_id.removeAttr('style');
	                    menu_id.css('width', options.menuWidth);
	                  }
	                }
	              });
	          }
	        }



	        // Touch Event
	        var panning = false;
	        var menuOut = false;

	        dragTarget.on('click', function(){
	          removeMenu();
	        });

	        dragTarget.hammer({
	          prevent_default: false
	        }).bind('pan', function(e) {

	          if (e.gesture.pointerType == "touch") {

	            var direction = e.gesture.direction;
	            var x = e.gesture.center.x;
	            var y = e.gesture.center.y;
	            var velocityX = e.gesture.velocityX;

	            // Disable Scrolling
	            var $body = $('body');
	            var oldWidth = $body.innerWidth();
	            $body.css('overflow', 'hidden');
	            $body.width(oldWidth);

	            // If overlay does not exist, create one and if it is clicked, close menu
	            if ($('#sidenav-overlay').length === 0) {
	              var overlay = $('<div id="sidenav-overlay"></div>');
	              overlay.css('opacity', 0).click( function(){
	                removeMenu();
	              });
	              $('body').append(overlay);
	            }

	            // Keep within boundaries
	            if (options.edge === 'left') {
	              if (x > options.menuWidth) { x = options.menuWidth; }
	              else if (x < 0) { x = 0; }
	            }

	            if (options.edge === 'left') {
	              // Left Direction
	              if (x < (options.menuWidth / 2)) { menuOut = false; }
	              // Right Direction
	              else if (x >= (options.menuWidth / 2)) { menuOut = true; }
	              menu_id.css('transform', 'translateX(' + (x - options.menuWidth) + 'px)');
	            }
	            else {
	              // Left Direction
	              if (x < (window.innerWidth - options.menuWidth / 2)) {
	                menuOut = true;
	              }
	              // Right Direction
	              else if (x >= (window.innerWidth - options.menuWidth / 2)) {
	               menuOut = false;
	             }
	              var rightPos = (x - options.menuWidth / 2);
	              if (rightPos < 0) {
	                rightPos = 0;
	              }

	              menu_id.css('transform', 'translateX(' + rightPos + 'px)');
	            }


	            // Percentage overlay
	            var overlayPerc;
	            if (options.edge === 'left') {
	              overlayPerc = x / options.menuWidth;
	              $('#sidenav-overlay').velocity({opacity: overlayPerc }, {duration: 10, queue: false, easing: 'easeOutQuad'});
	            }
	            else {
	              overlayPerc = Math.abs((x - window.innerWidth) / options.menuWidth);
	              $('#sidenav-overlay').velocity({opacity: overlayPerc }, {duration: 10, queue: false, easing: 'easeOutQuad'});
	            }
	          }

	        }).bind('panend', function(e) {

	          if (e.gesture.pointerType == "touch") {
	            var velocityX = e.gesture.velocityX;
	            var x = e.gesture.center.x;
	            var leftPos = x - options.menuWidth;
	            var rightPos = x - options.menuWidth / 2;
	            if (leftPos > 0 ) {
	              leftPos = 0;
	            }
	            if (rightPos < 0) {
	              rightPos = 0;
	            }
	            panning = false;

	            if (options.edge === 'left') {
	              // If velocityX <= 0.3 then the user is flinging the menu closed so ignore menuOut
	              if ((menuOut && velocityX <= 0.3) || velocityX < -0.5) {
	                if (leftPos != 0) {
	                  menu_id.velocity({'translateX': [0, leftPos]}, {duration: 300, queue: false, easing: 'easeOutQuad'});
	                }

	                // menu_id.css({'translateX': 0});
	                $('#sidenav-overlay').velocity({opacity: 1 }, {duration: 50, queue: false, easing: 'easeOutQuad'});
	                dragTarget.css({width: '50%', right: 0, left: ''});
	              }
	              else if (!menuOut || velocityX > 0.3) {
	                // Enable Scrolling
	                $('body').css({
	                  overflow: '',
	                  width: ''
	                });
	                // Slide menu closed
	                menu_id.velocity({'translateX': [-1 * options.menuWidth - 10, leftPos]}, {duration: 200, queue: false, easing: 'easeOutQuad'});
	                $('#sidenav-overlay').velocity({opacity: 0 }, {duration: 200, queue: false, easing: 'easeOutQuad',
	                  complete: function () {
	                    $(this).remove();
	                  }});
	                dragTarget.css({width: '10px', right: '', left: 0});
	              }
	            }
	            else {
	              if ((menuOut && velocityX >= -0.3) || velocityX > 0.5) {
	                menu_id.velocity({'translateX': [0, rightPos]}, {duration: 300, queue: false, easing: 'easeOutQuad'});
	                $('#sidenav-overlay').velocity({opacity: 1 }, {duration: 50, queue: false, easing: 'easeOutQuad'});
	                dragTarget.css({width: '50%', right: '', left: 0});
	              }
	              else if (!menuOut || velocityX < -0.3) {
	                // Enable Scrolling
	                $('body').css({
	                  overflow: '',
	                  width: ''
	                });

	                // Slide menu closed
	                menu_id.velocity({'translateX': [options.menuWidth + 10, rightPos]}, {duration: 200, queue: false, easing: 'easeOutQuad'});
	                $('#sidenav-overlay').velocity({opacity: 0 }, {duration: 200, queue: false, easing: 'easeOutQuad',
	                  complete: function () {
	                    $(this).remove();
	                  }});
	                dragTarget.css({width: '10px', right: 0, left: ''});
	              }
	            }

	          }
	        });

	          $this.click(function() {
	            if (menuOut === true) {
	              menuOut = false;
	              panning = false;
	              removeMenu();
	            }
	            else {

	              // Disable Scrolling
	              var $body = $('body');
	              var oldWidth = $body.innerWidth();
	              $body.css('overflow', 'hidden');
	              $body.width(oldWidth);

	              // Push current drag target on top of DOM tree
	              $('body').append(dragTarget);

	              if (options.edge === 'left') {
	                dragTarget.css({width: '50%', right: 0, left: ''});
	                menu_id.velocity({'translateX': [0, -1 * options.menuWidth]}, {duration: 300, queue: false, easing: 'easeOutQuad'});
	              }
	              else {
	                dragTarget.css({width: '50%', right: '', left: 0});
	                menu_id.velocity({'translateX': [0, options.menuWidth]}, {duration: 300, queue: false, easing: 'easeOutQuad'});
	              }

	              var overlay = $('<div id="sidenav-overlay"></div>');
	              overlay.css('opacity', 0)
	              .click(function(){
	                menuOut = false;
	                panning = false;
	                removeMenu();
	                overlay.velocity({opacity: 0}, {duration: 300, queue: false, easing: 'easeOutQuad',
	                  complete: function() {
	                    $(this).remove();
	                  } });

	              });
	              $('body').append(overlay);
	              overlay.velocity({opacity: 1}, {duration: 300, queue: false, easing: 'easeOutQuad',
	                complete: function () {
	                  menuOut = true;
	                  panning = false;
	                }
	              });
	            }

	            return false;
	          });
	      });


	    },
	    show : function() {
	      this.trigger('click');
	    },
	    hide : function() {
	      $('#sidenav-overlay').trigger('click');
	    }
	  };


	    $.fn.sideNav = function(methodOrOptions) {
	      if ( methods[methodOrOptions] ) {
	        return methods[ methodOrOptions ].apply( this, Array.prototype.slice.call( arguments, 1 ));
	      } else if ( typeof methodOrOptions === 'object' || ! methodOrOptions ) {
	        // Default to "init"
	        return methods.init.apply( this, arguments );
	      } else {
	        $.error( 'Method ' +  methodOrOptions + ' does not exist on jQuery.sideNav' );
	      }
	    }; // Plugin end
	}( jQuery ));
	;/**
	 * Extend jquery with a scrollspy plugin.
	 * This watches the window scroll and fires events when elements are scrolled into viewport.
	 *
	 * throttle() and getTime() taken from Underscore.js
	 * https://github.com/jashkenas/underscore
	 *
	 * @author Copyright 2013 John Smart
	 * @license https://raw.github.com/thesmart/jquery-scrollspy/master/LICENSE
	 * @see https://github.com/thesmart
	 * @version 0.1.2
	 */
	(function($) {

		var jWindow = $(window);
		var elements = [];
		var elementsInView = [];
		var isSpying = false;
		var ticks = 0;
		var unique_id = 1;
		var offset = {
			top : 0,
			right : 0,
			bottom : 0,
			left : 0,
		}

		/**
		 * Find elements that are within the boundary
		 * @param {number} top
		 * @param {number} right
		 * @param {number} bottom
		 * @param {number} left
		 * @return {jQuery}		A collection of elements
		 */
		function findElements(top, right, bottom, left) {
			var hits = $();
			$.each(elements, function(i, element) {
				if (element.height() > 0) {
					var elTop = element.offset().top,
						elLeft = element.offset().left,
						elRight = elLeft + element.width(),
						elBottom = elTop + element.height();

					var isIntersect = !(elLeft > right ||
						elRight < left ||
						elTop > bottom ||
						elBottom < top);

					if (isIntersect) {
						hits.push(element);
					}
				}
			});

			return hits;
		}


		/**
		 * Called when the user scrolls the window
		 */
		function onScroll() {
			// unique tick id
			++ticks;

			// viewport rectangle
			var top = jWindow.scrollTop(),
				left = jWindow.scrollLeft(),
				right = left + jWindow.width(),
				bottom = top + jWindow.height();

			// determine which elements are in view
	//        + 60 accounts for fixed nav
			var intersections = findElements(top+offset.top + 200, right+offset.right, bottom+offset.bottom, left+offset.left);
			$.each(intersections, function(i, element) {

				var lastTick = element.data('scrollSpy:ticks');
				if (typeof lastTick != 'number') {
					// entered into view
					element.triggerHandler('scrollSpy:enter');
				}

				// update tick id
				element.data('scrollSpy:ticks', ticks);
			});

			// determine which elements are no longer in view
			$.each(elementsInView, function(i, element) {
				var lastTick = element.data('scrollSpy:ticks');
				if (typeof lastTick == 'number' && lastTick !== ticks) {
					// exited from view
					element.triggerHandler('scrollSpy:exit');
					element.data('scrollSpy:ticks', null);
				}
			});

			// remember elements in view for next tick
			elementsInView = intersections;
		}

		/**
		 * Called when window is resized
		*/
		function onWinSize() {
			jWindow.trigger('scrollSpy:winSize');
		}

		/**
		 * Get time in ms
	   * @license https://raw.github.com/jashkenas/underscore/master/LICENSE
		 * @type {function}
		 * @return {number}
		 */
		var getTime = (Date.now || function () {
			return new Date().getTime();
		});

		/**
		 * Returns a function, that, when invoked, will only be triggered at most once
		 * during a given window of time. Normally, the throttled function will run
		 * as much as it can, without ever going more than once per `wait` duration;
		 * but if you'd like to disable the execution on the leading edge, pass
		 * `{leading: false}`. To disable execution on the trailing edge, ditto.
		 * @license https://raw.github.com/jashkenas/underscore/master/LICENSE
		 * @param {function} func
		 * @param {number} wait
		 * @param {Object=} options
		 * @returns {Function}
		 */
		function throttle(func, wait, options) {
			var context, args, result;
			var timeout = null;
			var previous = 0;
			options || (options = {});
			var later = function () {
				previous = options.leading === false ? 0 : getTime();
				timeout = null;
				result = func.apply(context, args);
				context = args = null;
			};
			return function () {
				var now = getTime();
				if (!previous && options.leading === false) previous = now;
				var remaining = wait - (now - previous);
				context = this;
				args = arguments;
				if (remaining <= 0) {
					clearTimeout(timeout);
					timeout = null;
					previous = now;
					result = func.apply(context, args);
					context = args = null;
				} else if (!timeout && options.trailing !== false) {
					timeout = setTimeout(later, remaining);
				}
				return result;
			};
		};

		/**
		 * Enables ScrollSpy using a selector
		 * @param {jQuery|string} selector  The elements collection, or a selector
		 * @param {Object=} options	Optional.
	        throttle : number -> scrollspy throttling. Default: 100 ms
	        offsetTop : number -> offset from top. Default: 0
	        offsetRight : number -> offset from right. Default: 0
	        offsetBottom : number -> offset from bottom. Default: 0
	        offsetLeft : number -> offset from left. Default: 0
		 * @returns {jQuery}
		 */
		$.scrollSpy = function(selector, options) {
			var visible = [];
			selector = $(selector);
			selector.each(function(i, element) {
				elements.push($(element));
				$(element).data("scrollSpy:id", i);
				// Smooth scroll to section
			  $('a[href="#' + $(element).attr('id') + '"]').click(function(e) {
			    e.preventDefault();
			    var offset = $(this.hash).offset().top + 1;

	//          offset - 200 allows elements near bottom of page to scroll
				
		    	$('html, body').animate({ scrollTop: offset - 200 }, {duration: 400, queue: false, easing: 'easeOutCubic'});
				
			  });
			});
			options = options || {
				throttle: 100
			};

			offset.top = options.offsetTop || 0;
			offset.right = options.offsetRight || 0;
			offset.bottom = options.offsetBottom || 0;
			offset.left = options.offsetLeft || 0;

			var throttledScroll = throttle(onScroll, options.throttle || 100);
			var readyScroll = function(){
				$(document).ready(throttledScroll);
			};

			if (!isSpying) {
				jWindow.on('scroll', readyScroll);
				jWindow.on('resize', readyScroll);
				isSpying = true;
			}

			// perform a scan once, after current execution context, and after dom is ready
			setTimeout(readyScroll, 0);


			selector.on('scrollSpy:enter', function() {
				visible = $.grep(visible, function(value) {
		      return value.height() != 0;
		    });

				var $this = $(this);

				if (visible[0]) {
					$('a[href="#' + visible[0].attr('id') + '"]').removeClass('active');
					if ($this.data('scrollSpy:id') < visible[0].data('scrollSpy:id')) {
						visible.unshift($(this));
					}
					else {
						visible.push($(this));
					}
				}
				else {
					visible.push($(this));
				}


				$('a[href="#' + visible[0].attr('id') + '"]').addClass('active');
			});
			selector.on('scrollSpy:exit', function() {
				visible = $.grep(visible, function(value) {
		      return value.height() != 0;
		    });

				if (visible[0]) {
					$('a[href="#' + visible[0].attr('id') + '"]').removeClass('active');
					var $this = $(this);
					visible = $.grep(visible, function(value) {
		        return value.attr('id') != $this.attr('id');
		      });
		      if (visible[0]) { // Check if empty
						$('a[href="#' + visible[0].attr('id') + '"]').addClass('active');
		      }
				}
			});

			return selector;
		};

		/**
		 * Listen for window resize events
		 * @param {Object=} options						Optional. Set { throttle: number } to change throttling. Default: 100 ms
		 * @returns {jQuery}		$(window)
		 */
		$.winSizeSpy = function(options) {
			$.winSizeSpy = function() { return jWindow; }; // lock from multiple calls
			options = options || {
				throttle: 100
			};
			return jWindow.on('resize', throttle(onWinSize, options.throttle || 100));
		};

		/**
		 * Enables ScrollSpy on a collection of elements
		 * e.g. $('.scrollSpy').scrollSpy()
		 * @param {Object=} options	Optional.
												throttle : number -> scrollspy throttling. Default: 100 ms
												offsetTop : number -> offset from top. Default: 0
												offsetRight : number -> offset from right. Default: 0
												offsetBottom : number -> offset from bottom. Default: 0
												offsetLeft : number -> offset from left. Default: 0
		 * @returns {jQuery}
		 */
		$.fn.scrollSpy = function(options) {
			return $.scrollSpy($(this), options);
		};

	})(jQuery);
	;(function ($) {
	  $(document).ready(function() {

	    // Function to update labels of text fields
	    Materialize.updateTextFields = function() {
	      var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], textarea';
	      $(input_selector).each(function(index, element) {
	        if ($(element).val().length > 0 || element.autofocus ||$(this).attr('placeholder') !== undefined || $(element)[0].validity.badInput === true) {
	          $(this).siblings('label, i').addClass('active');
	        }
	        else {
	          $(this).siblings('label, i').removeClass('active');
	        }
	      });
	    };

	    // Text based inputs
	    var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], textarea';

	    // Add active if form auto complete
	    $(document).on('change', input_selector, function () {
	      if($(this).val().length !== 0 || $(this).attr('placeholder') !== undefined) {
	        $(this).siblings('label').addClass('active');
	      }
	      validate_field($(this));
	    });

	    // Add active if input element has been pre-populated on document ready
	    $(document).ready(function() {
	      Materialize.updateTextFields();
	    });

	    // HTML DOM FORM RESET handling
	    $(document).on('reset', function(e) {
	      var formReset = $(e.target);
	      if (formReset.is('form')) {
	        formReset.find(input_selector).removeClass('valid').removeClass('invalid');
	        formReset.find(input_selector).each(function () {
	          if ($(this).attr('value') === '') {
	            $(this).siblings('label, i').removeClass('active');
	          }
	        });

	        // Reset select
	        formReset.find('select.initialized').each(function () {
	          var reset_text = formReset.find('option[selected]').text();
	          formReset.siblings('input.select-dropdown').val(reset_text);
	        });
	      }
	    });

	    // Add active when element has focus
	    $(document).on('focus', input_selector, function () {
	      $(this).siblings('label, i').addClass('active');
	    });

	    $(document).on('blur', input_selector, function () {
	      var $inputElement = $(this);
	      if ($inputElement.val().length === 0 && $inputElement[0].validity.badInput !== true && $inputElement.attr('placeholder') === undefined) {
	        $inputElement.siblings('label, i').removeClass('active');
	      }

	      if ($inputElement.val().length === 0 && $inputElement[0].validity.badInput !== true && $inputElement.attr('placeholder') !== undefined) {
	        $inputElement.siblings('i').removeClass('active');
	      }
	      validate_field($inputElement);
	    });

	    window.validate_field = function(object) {
	      var hasLength = object.attr('length') !== undefined;
	      var lenAttr = parseInt(object.attr('length'));
	      var len = object.val().length;

	      if (object.val().length === 0 && object[0].validity.badInput === false) {
	        if (object.hasClass('validate')) {
	          object.removeClass('valid');
	          object.removeClass('invalid');
	        }
	      }
	      else {
	        if (object.hasClass('validate')) {
	          // Check for character counter attributes
	          if ((object.is(':valid') && hasLength && (len <= lenAttr)) || (object.is(':valid') && !hasLength)) {
	            object.removeClass('invalid');
	            object.addClass('valid');
	          }
	          else {
	            object.removeClass('valid');
	            object.addClass('invalid');
	          }
	        }
	      }
	    };

	    // Radio and Checkbox focus class
	    var radio_checkbox = 'input[type=radio], input[type=checkbox]';
	    $(document).on('keyup.radio', radio_checkbox, function(e) {
	      // TAB, check if tabbing to radio or checkbox.
	      if (e.which === 9) {
	        $(this).addClass('tabbed');
	        var $this = $(this);
	        $this.one('blur', function(e) {
	          
	          $(this).removeClass('tabbed');
	        });
	        return;
	      }
	    });

	    // Textarea Auto Resize
	    var hiddenDiv = $('.hiddendiv').first();
	    if (!hiddenDiv.length) {
	      hiddenDiv = $('<div class="hiddendiv common"></div>');
	      $('body').append(hiddenDiv);
	    }
	    var text_area_selector = '.materialize-textarea';

	    function textareaAutoResize($textarea) {
	      // Set font properties of hiddenDiv

	      var fontFamily = $textarea.css('font-family');
	      var fontSize = $textarea.css('font-size');

	      if (fontSize) { hiddenDiv.css('font-size', fontSize); }
	      if (fontFamily) { hiddenDiv.css('font-family', fontFamily); }

	      if ($textarea.attr('wrap') === "off") {
	        hiddenDiv.css('overflow-wrap', "normal")
	                 .css('white-space', "pre");
	      }

	      hiddenDiv.text($textarea.val() + '\n');
	      var content = hiddenDiv.html().replace(/\n/g, '<br>');
	      hiddenDiv.html(content);


	      // When textarea is hidden, width goes crazy.
	      // Approximate with half of window size

	      if ($textarea.is(':visible')) {
	        hiddenDiv.css('width', $textarea.width());
	      }
	      else {
	        hiddenDiv.css('width', $(window).width()/2);
	      }

	      $textarea.css('height', hiddenDiv.height());
	    }

	    $(text_area_selector).each(function () {
	      var $textarea = $(this);
	      if ($textarea.val().length) {
	        textareaAutoResize($textarea);
	      }
	    });

	    $('body').on('keyup keydown autoresize', text_area_selector, function () {
	      textareaAutoResize($(this));
	    });

	    // File Input Path
	    $(document).on('change', '.file-field input[type="file"]', function () {
	      var file_field = $(this).closest('.file-field');
	      var path_input = file_field.find('input.file-path');
	      var files      = $(this)[0].files;
	      var file_names = [];
	      for (var i = 0; i < files.length; i++) {
	        file_names.push(files[i].name);
	      }
	      path_input.val(file_names.join(", "));
	      path_input.trigger('change');
	    });

	    /****************
	    *  Range Input  *
	    ****************/

	    var range_type = 'input[type=range]';
	    var range_mousedown = false;
	    var left;

	    $(range_type).each(function () {
	      var thumb = $('<span class="thumb"><span class="value"></span></span>');
	      $(this).after(thumb);
	    });

	    var range_wrapper = '.range-field';
	    $(document).on('change', range_type, function(e) {
	      var thumb = $(this).siblings('.thumb');
	      thumb.find('.value').html($(this).val());
	    });

	    $(document).on('input mousedown touchstart', range_type, function(e) {
	      var thumb = $(this).siblings('.thumb');
	      var width = $(this).outerWidth();

	      // If thumb indicator does not exist yet, create it
	      if (thumb.length <= 0) {
	        thumb = $('<span class="thumb"><span class="value"></span></span>');
	        $(this).after(thumb);
	      }

	      // Set indicator value
	      thumb.find('.value').html($(this).val());

	      range_mousedown = true;
	      $(this).addClass('active');

	      if (!thumb.hasClass('active')) {
	        thumb.velocity({ height: "30px", width: "30px", top: "-20px", marginLeft: "-15px"}, { duration: 300, easing: 'easeOutExpo' });
	      }

	      if (e.type !== 'input') {
	        if(e.pageX === undefined || e.pageX === null){//mobile
	           left = e.originalEvent.touches[0].pageX - $(this).offset().left;
	        }
	        else{ // desktop
	           left = e.pageX - $(this).offset().left;
	        }
	        if (left < 0) {
	          left = 0;
	        }
	        else if (left > width) {
	          left = width;
	        }
	        thumb.addClass('active').css('left', left);
	      }

	      thumb.find('.value').html($(this).val());
	    });

	    $(document).on('mouseup touchend', range_wrapper, function() {
	      range_mousedown = false;
	      $(this).removeClass('active');
	    });

	    $(document).on('mousemove touchmove', range_wrapper, function(e) {
	      var thumb = $(this).children('.thumb');
	      var left;
	      if (range_mousedown) {
	        if (!thumb.hasClass('active')) {
	          thumb.velocity({ height: '30px', width: '30px', top: '-20px', marginLeft: '-15px'}, { duration: 300, easing: 'easeOutExpo' });
	        }
	        if (e.pageX === undefined || e.pageX === null) { //mobile
	          left = e.originalEvent.touches[0].pageX - $(this).offset().left;
	        }
	        else{ // desktop
	          left = e.pageX - $(this).offset().left;
	        }
	        var width = $(this).outerWidth();

	        if (left < 0) {
	          left = 0;
	        }
	        else if (left > width) {
	          left = width;
	        }
	        thumb.addClass('active').css('left', left);
	        thumb.find('.value').html(thumb.siblings(range_type).val());
	      }
	    });

	    $(document).on('mouseout touchleave', range_wrapper, function() {
	      if (!range_mousedown) {

	        var thumb = $(this).children('.thumb');

	        if (thumb.hasClass('active')) {
	          thumb.velocity({ height: '0', width: '0', top: '10px', marginLeft: '-6px'}, { duration: 100 });
	        }
	        thumb.removeClass('active');
	      }
	    });
	  }); // End of $(document).ready

	  /*******************
	   *  Select Plugin  *
	   ******************/
	  $.fn.material_select = function (callback) {
	    $(this).each(function(){
	      var $select = $(this);

	      if ($select.hasClass('browser-default')) {
	        return; // Continue to next (return false breaks out of entire loop)
	      }

	      var multiple = $select.attr('multiple') ? true : false,
	          lastID = $select.data('select-id'); // Tear down structure if Select needs to be rebuilt

	      if (lastID) {
	        $select.parent().find('span.caret').remove();
	        $select.parent().find('input').remove();

	        $select.unwrap();
	        $('ul#select-options-'+lastID).remove();
	      }

	      // If destroying the select, remove the selelct-id and reset it to it's uninitialized state.
	      if(callback === 'destroy') {
	        $select.data('select-id', null).removeClass('initialized');
	        return;
	      }

	      var uniqueID = Materialize.guid();
	      $select.data('select-id', uniqueID);
	      var wrapper = $('<div class="select-wrapper"></div>');
	      wrapper.addClass($select.attr('class'));
	      var options = $('<ul id="select-options-' + uniqueID +'" class="dropdown-content select-dropdown ' + (multiple ? 'multiple-select-dropdown' : '') + '"></ul>'),
	          selectChildren = $select.children('option, optgroup'),
	          valuesSelected = [],
	          optionsHover = false;

	      var label = $select.find('option:selected').html() || $select.find('option:first').html() || "";

	      // Function that renders and appends the option taking into
	      // account type and possible image icon.
	      var appendOptionWithIcon = function(select, option, type) {
	        // Add disabled attr if disabled
	        var disabledClass = (option.is(':disabled')) ? 'disabled ' : '';
	        var optgroupClass = (type === 'optgroup-option') ? 'optgroup-option ' : '';

	        // add icons
	        var icon_url = option.data('icon');
	        var classes = option.attr('class');
	        if (!!icon_url) {
	          var classString = '';
	          if (!!classes) classString = ' class="' + classes + '"';

	          // Check for multiple type.
	          if (type === 'multiple') {
	            options.append($('<li class="' + disabledClass + '"><img src="' + icon_url + '"' + classString + '><span><input type="checkbox"' + disabledClass + '/><label></label>' + option.html() + '</span></li>'));
	          } else {
	            options.append($('<li class="' + disabledClass + optgroupClass + '"><img src="' + icon_url + '"' + classString + '><span>' + option.html() + '</span></li>'));
	          }
	          return true;
	        }

	        // Check for multiple type.
	        if (type === 'multiple') {
	          options.append($('<li class="' + disabledClass + '"><span><input type="checkbox"' + disabledClass + '/><label></label>' + option.html() + '</span></li>'));
	        } else {
	          options.append($('<li class="' + disabledClass + optgroupClass + '"><span>' + option.html() + '</span></li>'));
	        }
	      };

	      /* Create dropdown structure. */
	      if (selectChildren.length) {
	        selectChildren.each(function() {
	          if ($(this).is('option')) {
	            // Direct descendant option.
	            if (multiple) {
	              appendOptionWithIcon($select, $(this), 'multiple');

	            } else {
	              appendOptionWithIcon($select, $(this));
	            }
	          } else if ($(this).is('optgroup')) {
	            // Optgroup.
	            var selectOptions = $(this).children('option');
	            options.append($('<li class="optgroup"><span>' + $(this).attr('label') + '</span></li>'));

	            selectOptions.each(function() {
	              appendOptionWithIcon($select, $(this), 'optgroup-option');
	            });
	          }
	        });
	      }

	      options.find('li:not(.optgroup)').each(function (i) {
	        $(this).click(function (e) {
	          // Check if option element is disabled
	          if (!$(this).hasClass('disabled') && !$(this).hasClass('optgroup')) {
	            var selected = true;

	            if (multiple) {
	              $('input[type="checkbox"]', this).prop('checked', function(i, v) { return !v; });
	              selected = toggleEntryFromArray(valuesSelected, $(this).index(), $select);
	              $newSelect.trigger('focus');
	            } else {
	              options.find('li').removeClass('active');
	              $(this).toggleClass('active');
	              $newSelect.val($(this).text());
	            }

	            activateOption(options, $(this));
	            $select.find('option').eq(i).prop('selected', selected);
	            // Trigger onchange() event
	            $select.trigger('change');
	            if (typeof callback !== 'undefined') callback();
	          }

	          e.stopPropagation();
	        });
	      });

	      // Wrap Elements
	      $select.wrap(wrapper);
	      // Add Select Display Element
	      var dropdownIcon = $('<span class="caret">&#9660;</span>');
	      if ($select.is(':disabled'))
	        dropdownIcon.addClass('disabled');

	      // escape double quotes
	      var sanitizedLabelHtml = label.replace(/"/g, '&quot;');

	      var $newSelect = $('<input type="text" class="select-dropdown" readonly="true" ' + (($select.is(':disabled')) ? 'disabled' : '') + ' data-activates="select-options-' + uniqueID +'" value="'+ sanitizedLabelHtml +'"/>');
	      $select.before($newSelect);
	      $newSelect.before(dropdownIcon);

	      $newSelect.after(options);
	      // Check if section element is disabled
	      if (!$select.is(':disabled')) {
	        $newSelect.dropdown({'hover': false, 'closeOnClick': false});
	      }

	      // Copy tabindex
	      if ($select.attr('tabindex')) {
	        $($newSelect[0]).attr('tabindex', $select.attr('tabindex'));
	      }

	      $select.addClass('initialized');

	      $newSelect.on({
	        'focus': function (){
	          if ($('ul.select-dropdown').not(options[0]).is(':visible')) {
	            $('input.select-dropdown').trigger('close');
	          }
	          if (!options.is(':visible')) {
	            $(this).trigger('open', ['focus']);
	            var label = $(this).val();
	            var selectedOption = options.find('li').filter(function() {
	              return $(this).text().toLowerCase() === label.toLowerCase();
	            })[0];
	            activateOption(options, selectedOption);
	          }
	        },
	        'click': function (e){
	          e.stopPropagation();
	        }
	      });

	      $newSelect.on('blur', function() {
	        if (!multiple) {
	          $(this).trigger('close');
	        }
	        options.find('li.selected').removeClass('selected');
	      });

	      options.hover(function() {
	        optionsHover = true;
	      }, function () {
	        optionsHover = false;
	      });

	      $(window).on({
	        'click': function () {
	          multiple && (optionsHover || $newSelect.trigger('close'));
	        }
	      });

	      // Add initial multiple selections.
	      if (multiple) {
	        $select.find("option:selected:not(:disabled)").each(function () {
	          var index = $(this).index();

	          toggleEntryFromArray(valuesSelected, index, $select);
	          options.find("li").eq(index).find(":checkbox").prop("checked", true);
	        });
	      }

	      // Make option as selected and scroll to selected position
	      var activateOption = function(collection, newOption) {
	        if (newOption) {
	          collection.find('li.selected').removeClass('selected');
	          var option = $(newOption);
	          option.addClass('selected');
	          options.scrollTo(option);
	        }
	      };

	      // Allow user to search by typing
	      // this array is cleared after 1 second
	      var filterQuery = [],
	          onKeyDown = function(e){
	            // TAB - switch to another input
	            if(e.which == 9){
	              $newSelect.trigger('close');
	              return;
	            }

	            // ARROW DOWN WHEN SELECT IS CLOSED - open select options
	            if(e.which == 40 && !options.is(':visible')){
	              $newSelect.trigger('open');
	              return;
	            }

	            // ENTER WHEN SELECT IS CLOSED - submit form
	            if(e.which == 13 && !options.is(':visible')){
	              return;
	            }

	            e.preventDefault();

	            // CASE WHEN USER TYPE LETTERS
	            var letter = String.fromCharCode(e.which).toLowerCase(),
	                nonLetters = [9,13,27,38,40];
	            if (letter && (nonLetters.indexOf(e.which) === -1)) {
	              filterQuery.push(letter);

	              var string = filterQuery.join(''),
	                  newOption = options.find('li').filter(function() {
	                    return $(this).text().toLowerCase().indexOf(string) === 0;
	                  })[0];

	              if (newOption) {
	                activateOption(options, newOption);
	              }
	            }

	            // ENTER - select option and close when select options are opened
	            if (e.which == 13) {
	              var activeOption = options.find('li.selected:not(.disabled)')[0];
	              if(activeOption){
	                $(activeOption).trigger('click');
	                if (!multiple) {
	                  $newSelect.trigger('close');
	                }
	              }
	            }

	            // ARROW DOWN - move to next not disabled option
	            if (e.which == 40) {
	              if (options.find('li.selected').length) {
	                newOption = options.find('li.selected').next('li:not(.disabled)')[0];
	              } else {
	                newOption = options.find('li:not(.disabled)')[0];
	              }
	              activateOption(options, newOption);
	            }

	            // ESC - close options
	            if (e.which == 27) {
	              $newSelect.trigger('close');
	            }

	            // ARROW UP - move to previous not disabled option
	            if (e.which == 38) {
	              newOption = options.find('li.selected').prev('li:not(.disabled)')[0];
	              if(newOption)
	                activateOption(options, newOption);
	            }

	            // Automaticaly clean filter query so user can search again by starting letters
	            setTimeout(function(){ filterQuery = []; }, 1000);
	          };

	      $newSelect.on('keydown', onKeyDown);
	    });

	    function toggleEntryFromArray(entriesArray, entryIndex, select) {
	      var index = entriesArray.indexOf(entryIndex),
	          notAdded = index === -1;

	      if (notAdded) {
	        entriesArray.push(entryIndex);
	      } else {
	        entriesArray.splice(index, 1);
	      }

	      select.siblings('ul.dropdown-content').find('li').eq(entryIndex).toggleClass('active');

	      // use notAdded instead of true (to detect if the option is selected or not)
	      select.find('option').eq(entryIndex).prop('selected', notAdded);
	      setValueToInput(entriesArray, select);

	      return notAdded;
	    }

	    function setValueToInput(entriesArray, select) {
	      var value = '';

	      for (var i = 0, count = entriesArray.length; i < count; i++) {
	        var text = select.find('option').eq(entriesArray[i]).text();

	        i === 0 ? value += text : value += ', ' + text;
	      }

	      if (value === '') {
	        value = select.find('option:disabled').eq(0).text();
	      }

	      select.siblings('input.select-dropdown').val(value);
	    }
	  };

	}( jQuery ));
	;(function ($) {

	  var methods = {

	    init : function(options) {
	      var defaults = {
	        indicators: true,
	        height: 400,
	        transition: 500,
	        interval: 6000
	      };
	      options = $.extend(defaults, options);

	      return this.each(function() {

	        // For each slider, we want to keep track of
	        // which slide is active and its associated content
	        var $this = $(this);
	        var $slider = $this.find('ul.slides').first();
	        var $slides = $slider.find('li');
	        var $active_index = $slider.find('.active').index();
	        var $active, $indicators, $interval;
	        if ($active_index != -1) { $active = $slides.eq($active_index); }

	        // Transitions the caption depending on alignment
	        function captionTransition(caption, duration) {
	          if (caption.hasClass("center-align")) {
	            caption.velocity({opacity: 0, translateY: -100}, {duration: duration, queue: false});
	          }
	          else if (caption.hasClass("right-align")) {
	            caption.velocity({opacity: 0, translateX: 100}, {duration: duration, queue: false});
	          }
	          else if (caption.hasClass("left-align")) {
	            caption.velocity({opacity: 0, translateX: -100}, {duration: duration, queue: false});
	          }
	        }

	        // This function will transition the slide to any index of the next slide
	        function moveToSlide(index) {
	          // Wrap around indices.
	          if (index >= $slides.length) index = 0;
	          else if (index < 0) index = $slides.length -1;

	          $active_index = $slider.find('.active').index();

	          // Only do if index changes
	          if ($active_index != index) {
	            $active = $slides.eq($active_index);
	            $caption = $active.find('.caption');

	            $active.removeClass('active');
	            $active.velocity({opacity: 0}, {duration: options.transition, queue: false, easing: 'easeOutQuad',
	                              complete: function() {
	                                $slides.not('.active').velocity({opacity: 0, translateX: 0, translateY: 0}, {duration: 0, queue: false});
	                              } });
	            captionTransition($caption, options.transition);


	            // Update indicators
	            if (options.indicators) {
	              $indicators.eq($active_index).removeClass('active');
	            }

	            $slides.eq(index).velocity({opacity: 1}, {duration: options.transition, queue: false, easing: 'easeOutQuad'});
	            $slides.eq(index).find('.caption').velocity({opacity: 1, translateX: 0, translateY: 0}, {duration: options.transition, delay: options.transition, queue: false, easing: 'easeOutQuad'});
	            $slides.eq(index).addClass('active');


	            // Update indicators
	            if (options.indicators) {
	              $indicators.eq(index).addClass('active');
	            }
	          }
	        }

	        // Set height of slider
	        // If fullscreen, do nothing
	        if (!$this.hasClass('fullscreen')) {
	          if (options.indicators) {
	            // Add height if indicators are present
	            $this.height(options.height + 40);
	          }
	          else {
	            $this.height(options.height);
	          }
	          $slider.height(options.height);
	        }


	        // Set initial positions of captions
	        $slides.find('.caption').each(function () {
	          captionTransition($(this), 0);
	        });

	        // Move img src into background-image
	        $slides.find('img').each(function () {
	          var placeholderBase64 = 'data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
	          if ($(this).attr('src') !== placeholderBase64) {
	            $(this).css('background-image', 'url(' + $(this).attr('src') + ')' );
	            $(this).attr('src', placeholderBase64);
	          }
	        });

	        // dynamically add indicators
	        if (options.indicators) {
	          $indicators = $('<ul class="indicators"></ul>');
	          $slides.each(function( index ) {
	            var $indicator = $('<li class="indicator-item"></li>');

	            // Handle clicks on indicators
	            $indicator.click(function () {
	              var $parent = $slider.parent();
	              var curr_index = $parent.find($(this)).index();
	              moveToSlide(curr_index);

	              // reset interval
	              clearInterval($interval);
	              $interval = setInterval(
	                function(){
	                  $active_index = $slider.find('.active').index();
	                  if ($slides.length == $active_index + 1) $active_index = 0; // loop to start
	                  else $active_index += 1;

	                  moveToSlide($active_index);

	                }, options.transition + options.interval
	              );
	            });
	            $indicators.append($indicator);
	          });
	          $this.append($indicators);
	          $indicators = $this.find('ul.indicators').find('li.indicator-item');
	        }

	        if ($active) {
	          $active.show();
	        }
	        else {
	          $slides.first().addClass('active').velocity({opacity: 1}, {duration: options.transition, queue: false, easing: 'easeOutQuad'});

	          $active_index = 0;
	          $active = $slides.eq($active_index);

	          // Update indicators
	          if (options.indicators) {
	            $indicators.eq($active_index).addClass('active');
	          }
	        }

	        // Adjust height to current slide
	        $active.find('img').each(function() {
	          $active.find('.caption').velocity({opacity: 1, translateX: 0, translateY: 0}, {duration: options.transition, queue: false, easing: 'easeOutQuad'});
	        });

	        // auto scroll
	        $interval = setInterval(
	          function(){
	            $active_index = $slider.find('.active').index();
	            moveToSlide($active_index + 1);

	          }, options.transition + options.interval
	        );


	        // HammerJS, Swipe navigation

	        // Touch Event
	        var panning = false;
	        var swipeLeft = false;
	        var swipeRight = false;

	        $this.hammer({
	            prevent_default: false
	        }).bind('pan', function(e) {
	          if (e.gesture.pointerType === "touch") {

	            // reset interval
	            clearInterval($interval);

	            var direction = e.gesture.direction;
	            var x = e.gesture.deltaX;
	            var velocityX = e.gesture.velocityX;

	            $curr_slide = $slider.find('.active');
	            $curr_slide.velocity({ translateX: x
	                }, {duration: 50, queue: false, easing: 'easeOutQuad'});

	            // Swipe Left
	            if (direction === 4 && (x > ($this.innerWidth() / 2) || velocityX < -0.65)) {
	              swipeRight = true;
	            }
	            // Swipe Right
	            else if (direction === 2 && (x < (-1 * $this.innerWidth() / 2) || velocityX > 0.65)) {
	              swipeLeft = true;
	            }

	            // Make Slide Behind active slide visible
	            var next_slide;
	            if (swipeLeft) {
	              next_slide = $curr_slide.next();
	              if (next_slide.length === 0) {
	                next_slide = $slides.first();
	              }
	              next_slide.velocity({ opacity: 1
	                  }, {duration: 300, queue: false, easing: 'easeOutQuad'});
	            }
	            if (swipeRight) {
	              next_slide = $curr_slide.prev();
	              if (next_slide.length === 0) {
	                next_slide = $slides.last();
	              }
	              next_slide.velocity({ opacity: 1
	                  }, {duration: 300, queue: false, easing: 'easeOutQuad'});
	            }


	          }

	        }).bind('panend', function(e) {
	          if (e.gesture.pointerType === "touch") {

	            $curr_slide = $slider.find('.active');
	            panning = false;
	            curr_index = $slider.find('.active').index();

	            if (!swipeRight && !swipeLeft || $slides.length <=1) {
	              // Return to original spot
	              $curr_slide.velocity({ translateX: 0
	                  }, {duration: 300, queue: false, easing: 'easeOutQuad'});
	            }
	            else if (swipeLeft) {
	              moveToSlide(curr_index + 1);
	              $curr_slide.velocity({translateX: -1 * $this.innerWidth() }, {duration: 300, queue: false, easing: 'easeOutQuad',
	                                    complete: function() {
	                                      $curr_slide.velocity({opacity: 0, translateX: 0}, {duration: 0, queue: false});
	                                    } });
	            }
	            else if (swipeRight) {
	              moveToSlide(curr_index - 1);
	              $curr_slide.velocity({translateX: $this.innerWidth() }, {duration: 300, queue: false, easing: 'easeOutQuad',
	                                    complete: function() {
	                                      $curr_slide.velocity({opacity: 0, translateX: 0}, {duration: 0, queue: false});
	                                    } });
	            }
	            swipeLeft = false;
	            swipeRight = false;

	            // Restart interval
	            clearInterval($interval);
	            $interval = setInterval(
	              function(){
	                $active_index = $slider.find('.active').index();
	                if ($slides.length == $active_index + 1) $active_index = 0; // loop to start
	                else $active_index += 1;

	                moveToSlide($active_index);

	              }, options.transition + options.interval
	            );
	          }
	        });

	        $this.on('sliderPause', function() {
	          clearInterval($interval);
	        });

	        $this.on('sliderStart', function() {
	          clearInterval($interval);
	          $interval = setInterval(
	            function(){
	              $active_index = $slider.find('.active').index();
	              if ($slides.length == $active_index + 1) $active_index = 0; // loop to start
	              else $active_index += 1;

	              moveToSlide($active_index);

	            }, options.transition + options.interval
	          );
	        });

	        $this.on('sliderNext', function() {
	          $active_index = $slider.find('.active').index();
	          moveToSlide($active_index + 1);
	        });

	        $this.on('sliderPrev', function() {
	          $active_index = $slider.find('.active').index();
	          moveToSlide($active_index - 1);
	        });

	      });



	    },
	    pause : function() {
	      $(this).trigger('sliderPause');
	    },
	    start : function() {
	      $(this).trigger('sliderStart');
	    },
	    next : function() {
	      $(this).trigger('sliderNext');
	    },
	    prev : function() {
	      $(this).trigger('sliderPrev');
	    }
	  };


	    $.fn.slider = function(methodOrOptions) {
	      if ( methods[methodOrOptions] ) {
	        return methods[ methodOrOptions ].apply( this, Array.prototype.slice.call( arguments, 1 ));
	      } else if ( typeof methodOrOptions === 'object' || ! methodOrOptions ) {
	        // Default to "init"
	        return methods.init.apply( this, arguments );
	      } else {
	        $.error( 'Method ' +  methodOrOptions + ' does not exist on jQuery.tooltip' );
	      }
	    }; // Plugin end
	}( jQuery ));
	;(function ($) {
	  $(document).ready(function() {

	    $(document).on('click.card', '.card', function (e) {
	      if ($(this).find('> .card-reveal').length) {
	        if ($(e.target).is($('.card-reveal .card-title')) || $(e.target).is($('.card-reveal .card-title i'))) {
	          // Make Reveal animate down and display none
	          $(this).find('.card-reveal').velocity(
	            {translateY: 0}, {
	              duration: 225,
	              queue: false,
	              easing: 'easeInOutQuad',
	              complete: function() { $(this).css({ display: 'none'}); }
	            }
	          );
	        }
	        else if ($(e.target).is($('.card .activator')) ||
	                 $(e.target).is($('.card .activator i')) ) {
	          $(e.target).closest('.card').css('overflow', 'hidden');
	          $(this).find('.card-reveal').css({ display: 'block'}).velocity("stop", false).velocity({translateY: '-100%'}, {duration: 300, queue: false, easing: 'easeInOutQuad'});
	        }
	      }

	      $('.card-reveal').closest('.card').css('overflow', 'hidden');

	    });

	  });
	}( jQuery ));;(function ($) {
	  $(document).ready(function() {

	    $(document).on('click.chip', '.chip .material-icons', function (e) {
	      $(this).parent().remove();
	    });

	  });
	}( jQuery ));;(function ($) {
	  $.fn.pushpin = function (options) {

	    var defaults = {
	      top: 0,
	      bottom: Infinity,
	      offset: 0
	    };
	    options = $.extend(defaults, options);

	    $index = 0;
	    return this.each(function() {
	      var $uniqueId = Materialize.guid(),
	          $this = $(this),
	          $original_offset = $(this).offset().top;

	      function removePinClasses(object) {
	        object.removeClass('pin-top');
	        object.removeClass('pinned');
	        object.removeClass('pin-bottom');
	      }

	      function updateElements(objects, scrolled) {
	        objects.each(function () {
	          // Add position fixed (because its between top and bottom)
	          if (options.top <= scrolled && options.bottom >= scrolled && !$(this).hasClass('pinned')) {
	            removePinClasses($(this));
	            $(this).css('top', options.offset);
	            $(this).addClass('pinned');
	          }

	          // Add pin-top (when scrolled position is above top)
	          if (scrolled < options.top && !$(this).hasClass('pin-top')) {
	            removePinClasses($(this));
	            $(this).css('top', 0);
	            $(this).addClass('pin-top');
	          }

	          // Add pin-bottom (when scrolled position is below bottom)
	          if (scrolled > options.bottom && !$(this).hasClass('pin-bottom')) {
	            removePinClasses($(this));
	            $(this).addClass('pin-bottom');
	            $(this).css('top', options.bottom - $original_offset);
	          }
	        });
	      }

	      updateElements($this, $(window).scrollTop());
	      $(window).on('scroll.' + $uniqueId, function () {
	        var $scrolled = $(window).scrollTop() + options.offset;
	        updateElements($this, $scrolled);
	      });

	    });

	  };
	}( jQuery ));;(function ($) {
	  $(document).ready(function() {

	    // jQuery reverse
	    $.fn.reverse = [].reverse;

	    // Hover behaviour: make sure this doesn't work on .click-to-toggle FABs!
	    $(document).on('mouseenter.fixedActionBtn', '.fixed-action-btn:not(.click-to-toggle)', function(e) {
	      var $this = $(this);
	      openFABMenu($this);
	    });
	    $(document).on('mouseleave.fixedActionBtn', '.fixed-action-btn:not(.click-to-toggle)', function(e) {
	      var $this = $(this);
	      closeFABMenu($this);
	    });

	    // Toggle-on-click behaviour.
	    $(document).on('click.fixedActionBtn', '.fixed-action-btn.click-to-toggle > a', function(e) {
	      var $this = $(this);
	      var $menu = $this.parent();
	      if ($menu.hasClass('active')) {
	        closeFABMenu($menu);
	      } else {
	        openFABMenu($menu);
	      }
	    });

	  });

	  $.fn.extend({
	    openFAB: function() {
	      openFABMenu($(this));
	    },
	    closeFAB: function() {
	      closeFABMenu($(this));
	    }
	  });


	  var openFABMenu = function (btn) {
	    $this = btn;
	    if ($this.hasClass('active') === false) {

	      // Get direction option
	      var horizontal = $this.hasClass('horizontal');
	      var offsetY, offsetX;

	      if (horizontal === true) {
	        offsetX = 40;
	      } else {
	        offsetY = 40;
	      }

	      $this.addClass('active');
	      $this.find('ul .btn-floating').velocity(
	        { scaleY: ".4", scaleX: ".4", translateY: offsetY + 'px', translateX: offsetX + 'px'},
	        { duration: 0 });

	      var time = 0;
	      $this.find('ul .btn-floating').reverse().each( function () {
	        $(this).velocity(
	          { opacity: "1", scaleX: "1", scaleY: "1", translateY: "0", translateX: '0'},
	          { duration: 80, delay: time });
	        time += 40;
	      });
	    }
	  };

	  var closeFABMenu = function (btn) {
	    $this = btn;
	    // Get direction option
	    var horizontal = $this.hasClass('horizontal');
	    var offsetY, offsetX;

	    if (horizontal === true) {
	      offsetX = 40;
	    } else {
	      offsetY = 40;
	    }

	    $this.removeClass('active');
	    var time = 0;
	    $this.find('ul .btn-floating').velocity("stop", true);
	    $this.find('ul .btn-floating').velocity(
	      { opacity: "0", scaleX: ".4", scaleY: ".4", translateY: offsetY + 'px', translateX: offsetX + 'px'},
	      { duration: 80 }
	    );
	  };


	}( jQuery ));
	;(function ($) {
	  // Image transition function
	  Materialize.fadeInImage =  function(selector){
	    var element = $(selector);
	    element.css({opacity: 0});
	    $(element).velocity({opacity: 1}, {
	        duration: 650,
	        queue: false,
	        easing: 'easeOutSine'
	      });
	    $(element).velocity({opacity: 1}, {
	          duration: 1300,
	          queue: false,
	          easing: 'swing',
	          step: function(now, fx) {
	              fx.start = 100;
	              var grayscale_setting = now/100;
	              var brightness_setting = 150 - (100 - now)/1.75;

	              if (brightness_setting < 100) {
	                brightness_setting = 100;
	              }
	              if (now >= 0) {
	                $(this).css({
	                    "-webkit-filter": "grayscale("+grayscale_setting+")" + "brightness("+brightness_setting+"%)",
	                    "filter": "grayscale("+grayscale_setting+")" + "brightness("+brightness_setting+"%)"
	                });
	              }
	          }
	      });
	  };

	  // Horizontal staggered list
	  Materialize.showStaggeredList = function(selector) {
	    var time = 0;
	    $(selector).find('li').velocity(
	        { translateX: "-100px"},
	        { duration: 0 });

	    $(selector).find('li').each(function() {
	      $(this).velocity(
	        { opacity: "1", translateX: "0"},
	        { duration: 800, delay: time, easing: [60, 10] });
	      time += 120;
	    });
	  };


	  $(document).ready(function() {
	    // Hardcoded .staggered-list scrollFire
	    // var staggeredListOptions = [];
	    // $('ul.staggered-list').each(function (i) {

	    //   var label = 'scrollFire-' + i;
	    //   $(this).addClass(label);
	    //   staggeredListOptions.push(
	    //     {selector: 'ul.staggered-list.' + label,
	    //      offset: 200,
	    //      callback: 'showStaggeredList("ul.staggered-list.' + label + '")'});
	    // });
	    // scrollFire(staggeredListOptions);

	    // HammerJS, Swipe navigation

	    // Touch Event
	    var swipeLeft = false;
	    var swipeRight = false;


	    // Dismissible Collections
	    $('.dismissable').each(function() {
	      $(this).hammer({
	        prevent_default: false
	      }).bind('pan', function(e) {
	        if (e.gesture.pointerType === "touch") {
	          var $this = $(this);
	          var direction = e.gesture.direction;
	          var x = e.gesture.deltaX;
	          var velocityX = e.gesture.velocityX;

	          $this.velocity({ translateX: x
	              }, {duration: 50, queue: false, easing: 'easeOutQuad'});

	          // Swipe Left
	          if (direction === 4 && (x > ($this.innerWidth() / 2) || velocityX < -0.75)) {
	            swipeLeft = true;
	          }

	          // Swipe Right
	          if (direction === 2 && (x < (-1 * $this.innerWidth() / 2) || velocityX > 0.75)) {
	            swipeRight = true;
	          }
	        }
	      }).bind('panend', function(e) {
	        // Reset if collection is moved back into original position
	        if (Math.abs(e.gesture.deltaX) < ($(this).innerWidth() / 2)) {
	          swipeRight = false;
	          swipeLeft = false;
	        }

	        if (e.gesture.pointerType === "touch") {
	          var $this = $(this);
	          if (swipeLeft || swipeRight) {
	            var fullWidth;
	            if (swipeLeft) { fullWidth = $this.innerWidth(); }
	            else { fullWidth = -1 * $this.innerWidth(); }

	            $this.velocity({ translateX: fullWidth,
	              }, {duration: 100, queue: false, easing: 'easeOutQuad', complete:
	              function() {
	                $this.css('border', 'none');
	                $this.velocity({ height: 0, padding: 0,
	                  }, {duration: 200, queue: false, easing: 'easeOutQuad', complete:
	                    function() { $this.remove(); }
	                  });
	              }
	            });
	          }
	          else {
	            $this.velocity({ translateX: 0,
	              }, {duration: 100, queue: false, easing: 'easeOutQuad'});
	          }
	          swipeLeft = false;
	          swipeRight = false;
	        }
	      });

	    });


	    // time = 0
	    // // Vertical Staggered list
	    // $('ul.staggered-list.vertical li').velocity(
	    //     { translateY: "100px"},
	    //     { duration: 0 });

	    // $('ul.staggered-list.vertical li').each(function() {
	    //   $(this).velocity(
	    //     { opacity: "1", translateY: "0"},
	    //     { duration: 800, delay: time, easing: [60, 25] });
	    //   time += 120;
	    // });

	    // // Fade in and Scale
	    // $('.fade-in.scale').velocity(
	    //     { scaleX: .4, scaleY: .4, translateX: -600},
	    //     { duration: 0});
	    // $('.fade-in').each(function() {
	    //   $(this).velocity(
	    //     { opacity: "1", scaleX: 1, scaleY: 1, translateX: 0},
	    //     { duration: 800, easing: [60, 10] });
	    // });
	  });
	}( jQuery ));
	;(function($) {

	  // Input: Array of JSON objects {selector, offset, callback}

	  Materialize.scrollFire = function(options) {

	    var didScroll = false;

	    window.addEventListener("scroll", function() {
	      didScroll = true;
	    });

	    // Rate limit to 100ms
	    setInterval(function() {
	      if(didScroll) {
	          didScroll = false;

	          var windowScroll = window.pageYOffset + window.innerHeight;

	          for (var i = 0 ; i < options.length; i++) {
	            // Get options from each line
	            var value = options[i];
	            var selector = value.selector,
	                offset = value.offset,
	                callback = value.callback;

	            var currentElement = document.querySelector(selector);
	            if ( currentElement !== null) {
	              var elementOffset = currentElement.getBoundingClientRect().top + window.pageYOffset;

	              if (windowScroll > (elementOffset + offset)) {
	                if (value.done !== true) {
	                  if (typeof(callback) === 'function') {
	                    callback.call(this);
	                  } else if (typeof(callback) === 'string') {
	                    var callbackFunc = new Function(callback);
	                    callbackFunc();
	                  }
	                  value.done = true;
	                }
	              }
	            }
	          }
	      }
	    }, 100);
	  };

	})(jQuery);
	;/*!
	 * pickadate.js v3.5.0, 2014/04/13
	 * By Amsul, http://amsul.ca
	 * Hosted on http://amsul.github.io/pickadate.js
	 * Licensed under MIT
	 */

	(function ( factory ) {

	    // AMD.
	    if ( true )
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_LOCAL_MODULE_0__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__))

	    // Node.js/browserify.
	    else if ( typeof exports == 'object' )
	        module.exports = factory( require('jquery') )

	    // Browser globals.
	    else this.Picker = factory( jQuery )

	}(function( $ ) {

	var $window = $( window )
	var $document = $( document )
	var $html = $( document.documentElement )


	/**
	 * The picker constructor that creates a blank picker.
	 */
	function PickerConstructor( ELEMENT, NAME, COMPONENT, OPTIONS ) {

	    // If there’s no element, return the picker constructor.
	    if ( !ELEMENT ) return PickerConstructor


	    var
	        IS_DEFAULT_THEME = false,


	        // The state of the picker.
	        STATE = {
	            id: ELEMENT.id || 'P' + Math.abs( ~~(Math.random() * new Date()) )
	        },


	        // Merge the defaults and options passed.
	        SETTINGS = COMPONENT ? $.extend( true, {}, COMPONENT.defaults, OPTIONS ) : OPTIONS || {},


	        // Merge the default classes with the settings classes.
	        CLASSES = $.extend( {}, PickerConstructor.klasses(), SETTINGS.klass ),


	        // The element node wrapper into a jQuery object.
	        $ELEMENT = $( ELEMENT ),


	        // Pseudo picker constructor.
	        PickerInstance = function() {
	            return this.start()
	        },


	        // The picker prototype.
	        P = PickerInstance.prototype = {

	            constructor: PickerInstance,

	            $node: $ELEMENT,


	            /**
	             * Initialize everything
	             */
	            start: function() {

	                // If it’s already started, do nothing.
	                if ( STATE && STATE.start ) return P


	                // Update the picker states.
	                STATE.methods = {}
	                STATE.start = true
	                STATE.open = false
	                STATE.type = ELEMENT.type


	                // Confirm focus state, convert into text input to remove UA stylings,
	                // and set as readonly to prevent keyboard popup.
	                ELEMENT.autofocus = ELEMENT == getActiveElement()
	                ELEMENT.readOnly = !SETTINGS.editable
	                ELEMENT.id = ELEMENT.id || STATE.id
	                if ( ELEMENT.type != 'text' ) {
	                    ELEMENT.type = 'text'
	                }


	                // Create a new picker component with the settings.
	                P.component = new COMPONENT(P, SETTINGS)


	                // Create the picker root with a holder and then prepare it.
	                P.$root = $( PickerConstructor._.node('div', createWrappedComponent(), CLASSES.picker, 'id="' + ELEMENT.id + '_root" tabindex="0"') )
	                prepareElementRoot()


	                // If there’s a format for the hidden input element, create the element.
	                if ( SETTINGS.formatSubmit ) {
	                    prepareElementHidden()
	                }


	                // Prepare the input element.
	                prepareElement()


	                // Insert the root as specified in the settings.
	                if ( SETTINGS.container ) $( SETTINGS.container ).append( P.$root )
	                else $ELEMENT.after( P.$root )


	                // Bind the default component and settings events.
	                P.on({
	                    start: P.component.onStart,
	                    render: P.component.onRender,
	                    stop: P.component.onStop,
	                    open: P.component.onOpen,
	                    close: P.component.onClose,
	                    set: P.component.onSet
	                }).on({
	                    start: SETTINGS.onStart,
	                    render: SETTINGS.onRender,
	                    stop: SETTINGS.onStop,
	                    open: SETTINGS.onOpen,
	                    close: SETTINGS.onClose,
	                    set: SETTINGS.onSet
	                })


	                // Once we’re all set, check the theme in use.
	                IS_DEFAULT_THEME = isUsingDefaultTheme( P.$root.children()[ 0 ] )


	                // If the element has autofocus, open the picker.
	                if ( ELEMENT.autofocus ) {
	                    P.open()
	                }


	                // Trigger queued the “start” and “render” events.
	                return P.trigger( 'start' ).trigger( 'render' )
	            }, //start


	            /**
	             * Render a new picker
	             */
	            render: function( entireComponent ) {

	                // Insert a new component holder in the root or box.
	                if ( entireComponent ) P.$root.html( createWrappedComponent() )
	                else P.$root.find( '.' + CLASSES.box ).html( P.component.nodes( STATE.open ) )

	                // Trigger the queued “render” events.
	                return P.trigger( 'render' )
	            }, //render


	            /**
	             * Destroy everything
	             */
	            stop: function() {

	                // If it’s already stopped, do nothing.
	                if ( !STATE.start ) return P

	                // Then close the picker.
	                P.close()

	                // Remove the hidden field.
	                if ( P._hidden ) {
	                    P._hidden.parentNode.removeChild( P._hidden )
	                }

	                // Remove the root.
	                P.$root.remove()

	                // Remove the input class, remove the stored data, and unbind
	                // the events (after a tick for IE - see `P.close`).
	                $ELEMENT.removeClass( CLASSES.input ).removeData( NAME )
	                setTimeout( function() {
	                    $ELEMENT.off( '.' + STATE.id )
	                }, 0)

	                // Restore the element state
	                ELEMENT.type = STATE.type
	                ELEMENT.readOnly = false

	                // Trigger the queued “stop” events.
	                P.trigger( 'stop' )

	                // Reset the picker states.
	                STATE.methods = {}
	                STATE.start = false

	                return P
	            }, //stop


	            /**
	             * Open up the picker
	             */
	            open: function( dontGiveFocus ) {

	                // If it’s already open, do nothing.
	                if ( STATE.open ) return P

	                // Add the “active” class.
	                $ELEMENT.addClass( CLASSES.active )
	                aria( ELEMENT, 'expanded', true )

	                // * A Firefox bug, when `html` has `overflow:hidden`, results in
	                //   killing transitions :(. So add the “opened” state on the next tick.
	                //   Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=625289
	                setTimeout( function() {

	                    // Add the “opened” class to the picker root.
	                    P.$root.addClass( CLASSES.opened )
	                    aria( P.$root[0], 'hidden', false )

	                }, 0 )

	                // If we have to give focus, bind the element and doc events.
	                if ( dontGiveFocus !== false ) {

	                    // Set it as open.
	                    STATE.open = true

	                    // Prevent the page from scrolling.
	                    if ( IS_DEFAULT_THEME ) {
	                        $html.
	                            css( 'overflow', 'hidden' ).
	                            css( 'padding-right', '+=' + getScrollbarWidth() )
	                    }

	                    // Pass focus to the root element’s jQuery object.
	                    // * Workaround for iOS8 to bring the picker’s root into view.
	                    P.$root.eq(0).focus()

	                    // Bind the document events.
	                    $document.on( 'click.' + STATE.id + ' focusin.' + STATE.id, function( event ) {

	                        var target = event.target

	                        // If the target of the event is not the element, close the picker picker.
	                        // * Don’t worry about clicks or focusins on the root because those don’t bubble up.
	                        //   Also, for Firefox, a click on an `option` element bubbles up directly
	                        //   to the doc. So make sure the target wasn't the doc.
	                        // * In Firefox stopPropagation() doesn’t prevent right-click events from bubbling,
	                        //   which causes the picker to unexpectedly close when right-clicking it. So make
	                        //   sure the event wasn’t a right-click.
	                        if ( target != ELEMENT && target != document && event.which != 3 ) {

	                            // If the target was the holder that covers the screen,
	                            // keep the element focused to maintain tabindex.
	                            P.close( target === P.$root.children()[0] )
	                        }

	                    }).on( 'keydown.' + STATE.id, function( event ) {

	                        var
	                            // Get the keycode.
	                            keycode = event.keyCode,

	                            // Translate that to a selection change.
	                            keycodeToMove = P.component.key[ keycode ],

	                            // Grab the target.
	                            target = event.target


	                        // On escape, close the picker and give focus.
	                        if ( keycode == 27 ) {
	                            P.close( true )
	                        }


	                        // Check if there is a key movement or “enter” keypress on the element.
	                        else if ( target == P.$root[0] && ( keycodeToMove || keycode == 13 ) ) {

	                            // Prevent the default action to stop page movement.
	                            event.preventDefault()

	                            // Trigger the key movement action.
	                            if ( keycodeToMove ) {
	                                PickerConstructor._.trigger( P.component.key.go, P, [ PickerConstructor._.trigger( keycodeToMove ) ] )
	                            }

	                            // On “enter”, if the highlighted item isn’t disabled, set the value and close.
	                            else if ( !P.$root.find( '.' + CLASSES.highlighted ).hasClass( CLASSES.disabled ) ) {
	                                P.set( 'select', P.component.item.highlight ).close()
	                            }
	                        }


	                        // If the target is within the root and “enter” is pressed,
	                        // prevent the default action and trigger a click on the target instead.
	                        else if ( $.contains( P.$root[0], target ) && keycode == 13 ) {
	                            event.preventDefault()
	                            target.click()
	                        }
	                    })
	                }

	                // Trigger the queued “open” events.
	                return P.trigger( 'open' )
	            }, //open


	            /**
	             * Close the picker
	             */
	            close: function( giveFocus ) {

	                // If we need to give focus, do it before changing states.
	                if ( giveFocus ) {
	                    // ....ah yes! It would’ve been incomplete without a crazy workaround for IE :|
	                    // The focus is triggered *after* the close has completed - causing it
	                    // to open again. So unbind and rebind the event at the next tick.
	                    P.$root.off( 'focus.toOpen' ).eq(0).focus()
	                    setTimeout( function() {
	                        P.$root.on( 'focus.toOpen', handleFocusToOpenEvent )
	                    }, 0 )
	                }

	                // Remove the “active” class.
	                $ELEMENT.removeClass( CLASSES.active )
	                aria( ELEMENT, 'expanded', false )

	                // * A Firefox bug, when `html` has `overflow:hidden`, results in
	                //   killing transitions :(. So remove the “opened” state on the next tick.
	                //   Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=625289
	                setTimeout( function() {

	                    // Remove the “opened” and “focused” class from the picker root.
	                    P.$root.removeClass( CLASSES.opened + ' ' + CLASSES.focused )
	                    aria( P.$root[0], 'hidden', true )

	                }, 0 )

	                // If it’s already closed, do nothing more.
	                if ( !STATE.open ) return P

	                // Set it as closed.
	                STATE.open = false

	                // Allow the page to scroll.
	                if ( IS_DEFAULT_THEME ) {
	                    $html.
	                        css( 'overflow', '' ).
	                        css( 'padding-right', '-=' + getScrollbarWidth() )
	                }

	                // Unbind the document events.
	                $document.off( '.' + STATE.id )

	                // Trigger the queued “close” events.
	                return P.trigger( 'close' )
	            }, //close


	            /**
	             * Clear the values
	             */
	            clear: function( options ) {
	                return P.set( 'clear', null, options )
	            }, //clear


	            /**
	             * Set something
	             */
	            set: function( thing, value, options ) {

	                var thingItem, thingValue,
	                    thingIsObject = $.isPlainObject( thing ),
	                    thingObject = thingIsObject ? thing : {}

	                // Make sure we have usable options.
	                options = thingIsObject && $.isPlainObject( value ) ? value : options || {}

	                if ( thing ) {

	                    // If the thing isn’t an object, make it one.
	                    if ( !thingIsObject ) {
	                        thingObject[ thing ] = value
	                    }

	                    // Go through the things of items to set.
	                    for ( thingItem in thingObject ) {

	                        // Grab the value of the thing.
	                        thingValue = thingObject[ thingItem ]

	                        // First, if the item exists and there’s a value, set it.
	                        if ( thingItem in P.component.item ) {
	                            if ( thingValue === undefined ) thingValue = null
	                            P.component.set( thingItem, thingValue, options )
	                        }

	                        // Then, check to update the element value and broadcast a change.
	                        if ( thingItem == 'select' || thingItem == 'clear' ) {
	                            $ELEMENT.
	                                val( thingItem == 'clear' ? '' : P.get( thingItem, SETTINGS.format ) ).
	                                trigger( 'change' )
	                        }
	                    }

	                    // Render a new picker.
	                    P.render()
	                }

	                // When the method isn’t muted, trigger queued “set” events and pass the `thingObject`.
	                return options.muted ? P : P.trigger( 'set', thingObject )
	            }, //set


	            /**
	             * Get something
	             */
	            get: function( thing, format ) {

	                // Make sure there’s something to get.
	                thing = thing || 'value'

	                // If a picker state exists, return that.
	                if ( STATE[ thing ] != null ) {
	                    return STATE[ thing ]
	                }

	                // Return the submission value, if that.
	                if ( thing == 'valueSubmit' ) {
	                    if ( P._hidden ) {
	                        return P._hidden.value
	                    }
	                    thing = 'value'
	                }

	                // Return the value, if that.
	                if ( thing == 'value' ) {
	                    return ELEMENT.value
	                }

	                // Check if a component item exists, return that.
	                if ( thing in P.component.item ) {
	                    if ( typeof format == 'string' ) {
	                        var thingValue = P.component.get( thing )
	                        return thingValue ?
	                            PickerConstructor._.trigger(
	                                P.component.formats.toString,
	                                P.component,
	                                [ format, thingValue ]
	                            ) : ''
	                    }
	                    return P.component.get( thing )
	                }
	            }, //get



	            /**
	             * Bind events on the things.
	             */
	            on: function( thing, method, internal ) {

	                var thingName, thingMethod,
	                    thingIsObject = $.isPlainObject( thing ),
	                    thingObject = thingIsObject ? thing : {}

	                if ( thing ) {

	                    // If the thing isn’t an object, make it one.
	                    if ( !thingIsObject ) {
	                        thingObject[ thing ] = method
	                    }

	                    // Go through the things to bind to.
	                    for ( thingName in thingObject ) {

	                        // Grab the method of the thing.
	                        thingMethod = thingObject[ thingName ]

	                        // If it was an internal binding, prefix it.
	                        if ( internal ) {
	                            thingName = '_' + thingName
	                        }

	                        // Make sure the thing methods collection exists.
	                        STATE.methods[ thingName ] = STATE.methods[ thingName ] || []

	                        // Add the method to the relative method collection.
	                        STATE.methods[ thingName ].push( thingMethod )
	                    }
	                }

	                return P
	            }, //on



	            /**
	             * Unbind events on the things.
	             */
	            off: function() {
	                var i, thingName,
	                    names = arguments;
	                for ( i = 0, namesCount = names.length; i < namesCount; i += 1 ) {
	                    thingName = names[i]
	                    if ( thingName in STATE.methods ) {
	                        delete STATE.methods[thingName]
	                    }
	                }
	                return P
	            },


	            /**
	             * Fire off method events.
	             */
	            trigger: function( name, data ) {
	                var _trigger = function( name ) {
	                    var methodList = STATE.methods[ name ]
	                    if ( methodList ) {
	                        methodList.map( function( method ) {
	                            PickerConstructor._.trigger( method, P, [ data ] )
	                        })
	                    }
	                }
	                _trigger( '_' + name )
	                _trigger( name )
	                return P
	            } //trigger
	        } //PickerInstance.prototype


	    /**
	     * Wrap the picker holder components together.
	     */
	    function createWrappedComponent() {

	        // Create a picker wrapper holder
	        return PickerConstructor._.node( 'div',

	            // Create a picker wrapper node
	            PickerConstructor._.node( 'div',

	                // Create a picker frame
	                PickerConstructor._.node( 'div',

	                    // Create a picker box node
	                    PickerConstructor._.node( 'div',

	                        // Create the components nodes.
	                        P.component.nodes( STATE.open ),

	                        // The picker box class
	                        CLASSES.box
	                    ),

	                    // Picker wrap class
	                    CLASSES.wrap
	                ),

	                // Picker frame class
	                CLASSES.frame
	            ),

	            // Picker holder class
	            CLASSES.holder
	        ) //endreturn
	    } //createWrappedComponent



	    /**
	     * Prepare the input element with all bindings.
	     */
	    function prepareElement() {

	        $ELEMENT.

	            // Store the picker data by component name.
	            data(NAME, P).

	            // Add the “input” class name.
	            addClass(CLASSES.input).

	            // Remove the tabindex.
	            attr('tabindex', -1).

	            // If there’s a `data-value`, update the value of the element.
	            val( $ELEMENT.data('value') ?
	                P.get('select', SETTINGS.format) :
	                ELEMENT.value
	            )


	        // Only bind keydown events if the element isn’t editable.
	        if ( !SETTINGS.editable ) {

	            $ELEMENT.

	                // On focus/click, focus onto the root to open it up.
	                on( 'focus.' + STATE.id + ' click.' + STATE.id, function( event ) {
	                    event.preventDefault()
	                    P.$root.eq(0).focus()
	                }).

	                // Handle keyboard event based on the picker being opened or not.
	                on( 'keydown.' + STATE.id, handleKeydownEvent )
	        }


	        // Update the aria attributes.
	        aria(ELEMENT, {
	            haspopup: true,
	            expanded: false,
	            readonly: false,
	            owns: ELEMENT.id + '_root'
	        })
	    }


	    /**
	     * Prepare the root picker element with all bindings.
	     */
	    function prepareElementRoot() {

	        P.$root.

	            on({

	                // For iOS8.
	                keydown: handleKeydownEvent,

	                // When something within the root is focused, stop from bubbling
	                // to the doc and remove the “focused” state from the root.
	                focusin: function( event ) {
	                    P.$root.removeClass( CLASSES.focused )
	                    event.stopPropagation()
	                },

	                // When something within the root holder is clicked, stop it
	                // from bubbling to the doc.
	                'mousedown click': function( event ) {

	                    var target = event.target

	                    // Make sure the target isn’t the root holder so it can bubble up.
	                    if ( target != P.$root.children()[ 0 ] ) {

	                        event.stopPropagation()

	                        // * For mousedown events, cancel the default action in order to
	                        //   prevent cases where focus is shifted onto external elements
	                        //   when using things like jQuery mobile or MagnificPopup (ref: #249 & #120).
	                        //   Also, for Firefox, don’t prevent action on the `option` element.
	                        if ( event.type == 'mousedown' && !$( target ).is( 'input, select, textarea, button, option' )) {

	                            event.preventDefault()

	                            // Re-focus onto the root so that users can click away
	                            // from elements focused within the picker.
	                            P.$root.eq(0).focus()
	                        }
	                    }
	                }
	            }).

	            // Add/remove the “target” class on focus and blur.
	            on({
	                focus: function() {
	                    $ELEMENT.addClass( CLASSES.target )
	                },
	                blur: function() {
	                    $ELEMENT.removeClass( CLASSES.target )
	                }
	            }).

	            // Open the picker and adjust the root “focused” state
	            on( 'focus.toOpen', handleFocusToOpenEvent ).

	            // If there’s a click on an actionable element, carry out the actions.
	            on( 'click', '[data-pick], [data-nav], [data-clear], [data-close]', function() {

	                var $target = $( this ),
	                    targetData = $target.data(),
	                    targetDisabled = $target.hasClass( CLASSES.navDisabled ) || $target.hasClass( CLASSES.disabled ),

	                    // * For IE, non-focusable elements can be active elements as well
	                    //   (http://stackoverflow.com/a/2684561).
	                    activeElement = getActiveElement()
	                    activeElement = activeElement && ( activeElement.type || activeElement.href )

	                // If it’s disabled or nothing inside is actively focused, re-focus the element.
	                if ( targetDisabled || activeElement && !$.contains( P.$root[0], activeElement ) ) {
	                    P.$root.eq(0).focus()
	                }

	                // If something is superficially changed, update the `highlight` based on the `nav`.
	                if ( !targetDisabled && targetData.nav ) {
	                    P.set( 'highlight', P.component.item.highlight, { nav: targetData.nav } )
	                }

	                // If something is picked, set `select` then close with focus.
	                else if ( !targetDisabled && 'pick' in targetData ) {
	                    P.set( 'select', targetData.pick )
	                }

	                // If a “clear” button is pressed, empty the values and close with focus.
	                else if ( targetData.clear ) {
	                    P.clear().close( true )
	                }

	                else if ( targetData.close ) {
	                    P.close( true )
	                }

	            }) //P.$root

	        aria( P.$root[0], 'hidden', true )
	    }


	     /**
	      * Prepare the hidden input element along with all bindings.
	      */
	    function prepareElementHidden() {

	        var name

	        if ( SETTINGS.hiddenName === true ) {
	            name = ELEMENT.name
	            ELEMENT.name = ''
	        }
	        else {
	            name = [
	                typeof SETTINGS.hiddenPrefix == 'string' ? SETTINGS.hiddenPrefix : '',
	                typeof SETTINGS.hiddenSuffix == 'string' ? SETTINGS.hiddenSuffix : '_submit'
	            ]
	            name = name[0] + ELEMENT.name + name[1]
	        }

	        P._hidden = $(
	            '<input ' +
	            'type=hidden ' +

	            // Create the name using the original input’s with a prefix and suffix.
	            'name="' + name + '"' +

	            // If the element has a value, set the hidden value as well.
	            (
	                $ELEMENT.data('value') || ELEMENT.value ?
	                    ' value="' + P.get('select', SETTINGS.formatSubmit) + '"' :
	                    ''
	            ) +
	            '>'
	        )[0]

	        $ELEMENT.

	            // If the value changes, update the hidden input with the correct format.
	            on('change.' + STATE.id, function() {
	                P._hidden.value = ELEMENT.value ?
	                    P.get('select', SETTINGS.formatSubmit) :
	                    ''
	            })


	        // Insert the hidden input as specified in the settings.
	        if ( SETTINGS.container ) $( SETTINGS.container ).append( P._hidden )
	        else $ELEMENT.after( P._hidden )
	    }


	    // For iOS8.
	    function handleKeydownEvent( event ) {

	        var keycode = event.keyCode,

	            // Check if one of the delete keys was pressed.
	            isKeycodeDelete = /^(8|46)$/.test(keycode)

	        // For some reason IE clears the input value on “escape”.
	        if ( keycode == 27 ) {
	            P.close()
	            return false
	        }

	        // Check if `space` or `delete` was pressed or the picker is closed with a key movement.
	        if ( keycode == 32 || isKeycodeDelete || !STATE.open && P.component.key[keycode] ) {

	            // Prevent it from moving the page and bubbling to doc.
	            event.preventDefault()
	            event.stopPropagation()

	            // If `delete` was pressed, clear the values and close the picker.
	            // Otherwise open the picker.
	            if ( isKeycodeDelete ) { P.clear().close() }
	            else { P.open() }
	        }
	    }


	    // Separated for IE
	    function handleFocusToOpenEvent( event ) {

	        // Stop the event from propagating to the doc.
	        event.stopPropagation()

	        // If it’s a focus event, add the “focused” class to the root.
	        if ( event.type == 'focus' ) {
	            P.$root.addClass( CLASSES.focused )
	        }

	        // And then finally open the picker.
	        P.open()
	    }


	    // Return a new picker instance.
	    return new PickerInstance()
	} //PickerConstructor



	/**
	 * The default classes and prefix to use for the HTML classes.
	 */
	PickerConstructor.klasses = function( prefix ) {
	    prefix = prefix || 'picker'
	    return {

	        picker: prefix,
	        opened: prefix + '--opened',
	        focused: prefix + '--focused',

	        input: prefix + '__input',
	        active: prefix + '__input--active',
	        target: prefix + '__input--target',

	        holder: prefix + '__holder',

	        frame: prefix + '__frame',
	        wrap: prefix + '__wrap',

	        box: prefix + '__box'
	    }
	} //PickerConstructor.klasses



	/**
	 * Check if the default theme is being used.
	 */
	function isUsingDefaultTheme( element ) {

	    var theme,
	        prop = 'position'

	    // For IE.
	    if ( element.currentStyle ) {
	        theme = element.currentStyle[prop]
	    }

	    // For normal browsers.
	    else if ( window.getComputedStyle ) {
	        theme = getComputedStyle( element )[prop]
	    }

	    return theme == 'fixed'
	}



	/**
	 * Get the width of the browser’s scrollbar.
	 * Taken from: https://github.com/VodkaBears/Remodal/blob/master/src/jquery.remodal.js
	 */
	function getScrollbarWidth() {

	    if ( $html.height() <= $window.height() ) {
	        return 0
	    }

	    var $outer = $( '<div style="visibility:hidden;width:100px" />' ).
	        appendTo( 'body' )

	    // Get the width without scrollbars.
	    var widthWithoutScroll = $outer[0].offsetWidth

	    // Force adding scrollbars.
	    $outer.css( 'overflow', 'scroll' )

	    // Add the inner div.
	    var $inner = $( '<div style="width:100%" />' ).appendTo( $outer )

	    // Get the width with scrollbars.
	    var widthWithScroll = $inner[0].offsetWidth

	    // Remove the divs.
	    $outer.remove()

	    // Return the difference between the widths.
	    return widthWithoutScroll - widthWithScroll
	}



	/**
	 * PickerConstructor helper methods.
	 */
	PickerConstructor._ = {

	    /**
	     * Create a group of nodes. Expects:
	     * `
	        {
	            min:    {Integer},
	            max:    {Integer},
	            i:      {Integer},
	            node:   {String},
	            item:   {Function}
	        }
	     * `
	     */
	    group: function( groupObject ) {

	        var
	            // Scope for the looped object
	            loopObjectScope,

	            // Create the nodes list
	            nodesList = '',

	            // The counter starts from the `min`
	            counter = PickerConstructor._.trigger( groupObject.min, groupObject )


	        // Loop from the `min` to `max`, incrementing by `i`
	        for ( ; counter <= PickerConstructor._.trigger( groupObject.max, groupObject, [ counter ] ); counter += groupObject.i ) {

	            // Trigger the `item` function within scope of the object
	            loopObjectScope = PickerConstructor._.trigger( groupObject.item, groupObject, [ counter ] )

	            // Splice the subgroup and create nodes out of the sub nodes
	            nodesList += PickerConstructor._.node(
	                groupObject.node,
	                loopObjectScope[ 0 ],   // the node
	                loopObjectScope[ 1 ],   // the classes
	                loopObjectScope[ 2 ]    // the attributes
	            )
	        }

	        // Return the list of nodes
	        return nodesList
	    }, //group


	    /**
	     * Create a dom node string
	     */
	    node: function( wrapper, item, klass, attribute ) {

	        // If the item is false-y, just return an empty string
	        if ( !item ) return ''

	        // If the item is an array, do a join
	        item = $.isArray( item ) ? item.join( '' ) : item

	        // Check for the class
	        klass = klass ? ' class="' + klass + '"' : ''

	        // Check for any attributes
	        attribute = attribute ? ' ' + attribute : ''

	        // Return the wrapped item
	        return '<' + wrapper + klass + attribute + '>' + item + '</' + wrapper + '>'
	    }, //node


	    /**
	     * Lead numbers below 10 with a zero.
	     */
	    lead: function( number ) {
	        return ( number < 10 ? '0': '' ) + number
	    },


	    /**
	     * Trigger a function otherwise return the value.
	     */
	    trigger: function( callback, scope, args ) {
	        return typeof callback == 'function' ? callback.apply( scope, args || [] ) : callback
	    },


	    /**
	     * If the second character is a digit, length is 2 otherwise 1.
	     */
	    digits: function( string ) {
	        return ( /\d/ ).test( string[ 1 ] ) ? 2 : 1
	    },


	    /**
	     * Tell if something is a date object.
	     */
	    isDate: function( value ) {
	        return {}.toString.call( value ).indexOf( 'Date' ) > -1 && this.isInteger( value.getDate() )
	    },


	    /**
	     * Tell if something is an integer.
	     */
	    isInteger: function( value ) {
	        return {}.toString.call( value ).indexOf( 'Number' ) > -1 && value % 1 === 0
	    },


	    /**
	     * Create ARIA attribute strings.
	     */
	    ariaAttr: ariaAttr
	} //PickerConstructor._



	/**
	 * Extend the picker with a component and defaults.
	 */
	PickerConstructor.extend = function( name, Component ) {

	    // Extend jQuery.
	    $.fn[ name ] = function( options, action ) {

	        // Grab the component data.
	        var componentData = this.data( name )

	        // If the picker is requested, return the data object.
	        if ( options == 'picker' ) {
	            return componentData
	        }

	        // If the component data exists and `options` is a string, carry out the action.
	        if ( componentData && typeof options == 'string' ) {
	            return PickerConstructor._.trigger( componentData[ options ], componentData, [ action ] )
	        }

	        // Otherwise go through each matched element and if the component
	        // doesn’t exist, create a new picker using `this` element
	        // and merging the defaults and options with a deep copy.
	        return this.each( function() {
	            var $this = $( this )
	            if ( !$this.data( name ) ) {
	                new PickerConstructor( this, name, Component, options )
	            }
	        })
	    }

	    // Set the defaults.
	    $.fn[ name ].defaults = Component.defaults
	} //PickerConstructor.extend



	function aria(element, attribute, value) {
	    if ( $.isPlainObject(attribute) ) {
	        for ( var key in attribute ) {
	            ariaSet(element, key, attribute[key])
	        }
	    }
	    else {
	        ariaSet(element, attribute, value)
	    }
	}
	function ariaSet(element, attribute, value) {
	    element.setAttribute(
	        (attribute == 'role' ? '' : 'aria-') + attribute,
	        value
	    )
	}
	function ariaAttr(attribute, data) {
	    if ( !$.isPlainObject(attribute) ) {
	        attribute = { attribute: data }
	    }
	    data = ''
	    for ( var key in attribute ) {
	        var attr = (key == 'role' ? '' : 'aria-') + key,
	            attrVal = attribute[key]
	        data += attrVal == null ? '' : attr + '="' + attribute[key] + '"'
	    }
	    return data
	}

	// IE8 bug throws an error for activeElements within iframes.
	function getActiveElement() {
	    try {
	        return document.activeElement
	    } catch ( err ) { }
	}



	// Expose the picker constructor.
	return PickerConstructor


	}));


	;/*!
	 * Date picker for pickadate.js v3.5.0
	 * http://amsul.github.io/pickadate.js/date.htm
	 */

	(function ( factory ) {

	    // AMD.
	    if ( true )
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_0__, __webpack_require__(8)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))

	    // Node.js/browserify.
	    else if ( typeof exports == 'object' )
	        module.exports = factory( require('./picker.js'), require('jquery') )

	    // Browser globals.
	    else factory( Picker, jQuery )

	}(function( Picker, $ ) {


	/**
	 * Globals and constants
	 */
	var DAYS_IN_WEEK = 7,
	    WEEKS_IN_CALENDAR = 6,
	    _ = Picker._



	/**
	 * The date picker constructor
	 */
	function DatePicker( picker, settings ) {

	    var calendar = this,
	        element = picker.$node[ 0 ],
	        elementValue = element.value,
	        elementDataValue = picker.$node.data( 'value' ),
	        valueString = elementDataValue || elementValue,
	        formatString = elementDataValue ? settings.formatSubmit : settings.format,
	        isRTL = function() {

	            return element.currentStyle ?

	                // For IE.
	                element.currentStyle.direction == 'rtl' :

	                // For normal browsers.
	                getComputedStyle( picker.$root[0] ).direction == 'rtl'
	        }

	    calendar.settings = settings
	    calendar.$node = picker.$node

	    // The queue of methods that will be used to build item objects.
	    calendar.queue = {
	        min: 'measure create',
	        max: 'measure create',
	        now: 'now create',
	        select: 'parse create validate',
	        highlight: 'parse navigate create validate',
	        view: 'parse create validate viewset',
	        disable: 'deactivate',
	        enable: 'activate'
	    }

	    // The component's item object.
	    calendar.item = {}

	    calendar.item.clear = null
	    calendar.item.disable = ( settings.disable || [] ).slice( 0 )
	    calendar.item.enable = -(function( collectionDisabled ) {
	        return collectionDisabled[ 0 ] === true ? collectionDisabled.shift() : -1
	    })( calendar.item.disable )

	    calendar.
	        set( 'min', settings.min ).
	        set( 'max', settings.max ).
	        set( 'now' )

	    // When there’s a value, set the `select`, which in turn
	    // also sets the `highlight` and `view`.
	    if ( valueString ) {
	        calendar.set( 'select', valueString, { format: formatString })
	    }

	    // If there’s no value, default to highlighting “today”.
	    else {
	        calendar.
	            set( 'select', null ).
	            set( 'highlight', calendar.item.now )
	    }


	    // The keycode to movement mapping.
	    calendar.key = {
	        40: 7, // Down
	        38: -7, // Up
	        39: function() { return isRTL() ? -1 : 1 }, // Right
	        37: function() { return isRTL() ? 1 : -1 }, // Left
	        go: function( timeChange ) {
	            var highlightedObject = calendar.item.highlight,
	                targetDate = new Date( highlightedObject.year, highlightedObject.month, highlightedObject.date + timeChange )
	            calendar.set(
	                'highlight',
	                targetDate,
	                { interval: timeChange }
	            )
	            this.render()
	        }
	    }


	    // Bind some picker events.
	    picker.
	        on( 'render', function() {
	            picker.$root.find( '.' + settings.klass.selectMonth ).on( 'change', function() {
	                var value = this.value
	                if ( value ) {
	                    picker.set( 'highlight', [ picker.get( 'view' ).year, value, picker.get( 'highlight' ).date ] )
	                    picker.$root.find( '.' + settings.klass.selectMonth ).trigger( 'focus' )
	                }
	            })
	            picker.$root.find( '.' + settings.klass.selectYear ).on( 'change', function() {
	                var value = this.value
	                if ( value ) {
	                    picker.set( 'highlight', [ value, picker.get( 'view' ).month, picker.get( 'highlight' ).date ] )
	                    picker.$root.find( '.' + settings.klass.selectYear ).trigger( 'focus' )
	                }
	            })
	        }, 1 ).
	        on( 'open', function() {
	            var includeToday = ''
	            if ( calendar.disabled( calendar.get('now') ) ) {
	                includeToday = ':not(.' + settings.klass.buttonToday + ')'
	            }
	            picker.$root.find( 'button' + includeToday + ', select' ).attr( 'disabled', false )
	        }, 1 ).
	        on( 'close', function() {
	            picker.$root.find( 'button, select' ).attr( 'disabled', true )
	        }, 1 )

	} //DatePicker


	/**
	 * Set a datepicker item object.
	 */
	DatePicker.prototype.set = function( type, value, options ) {

	    var calendar = this,
	        calendarItem = calendar.item

	    // If the value is `null` just set it immediately.
	    if ( value === null ) {
	        if ( type == 'clear' ) type = 'select'
	        calendarItem[ type ] = value
	        return calendar
	    }

	    // Otherwise go through the queue of methods, and invoke the functions.
	    // Update this as the time unit, and set the final value as this item.
	    // * In the case of `enable`, keep the queue but set `disable` instead.
	    //   And in the case of `flip`, keep the queue but set `enable` instead.
	    calendarItem[ ( type == 'enable' ? 'disable' : type == 'flip' ? 'enable' : type ) ] = calendar.queue[ type ].split( ' ' ).map( function( method ) {
	        value = calendar[ method ]( type, value, options )
	        return value
	    }).pop()

	    // Check if we need to cascade through more updates.
	    if ( type == 'select' ) {
	        calendar.set( 'highlight', calendarItem.select, options )
	    }
	    else if ( type == 'highlight' ) {
	        calendar.set( 'view', calendarItem.highlight, options )
	    }
	    else if ( type.match( /^(flip|min|max|disable|enable)$/ ) ) {
	        if ( calendarItem.select && calendar.disabled( calendarItem.select ) ) {
	            calendar.set( 'select', calendarItem.select, options )
	        }
	        if ( calendarItem.highlight && calendar.disabled( calendarItem.highlight ) ) {
	            calendar.set( 'highlight', calendarItem.highlight, options )
	        }
	    }

	    return calendar
	} //DatePicker.prototype.set


	/**
	 * Get a datepicker item object.
	 */
	DatePicker.prototype.get = function( type ) {
	    return this.item[ type ]
	} //DatePicker.prototype.get


	/**
	 * Create a picker date object.
	 */
	DatePicker.prototype.create = function( type, value, options ) {

	    var isInfiniteValue,
	        calendar = this

	    // If there’s no value, use the type as the value.
	    value = value === undefined ? type : value


	    // If it’s infinity, update the value.
	    if ( value == -Infinity || value == Infinity ) {
	        isInfiniteValue = value
	    }

	    // If it’s an object, use the native date object.
	    else if ( $.isPlainObject( value ) && _.isInteger( value.pick ) ) {
	        value = value.obj
	    }

	    // If it’s an array, convert it into a date and make sure
	    // that it’s a valid date – otherwise default to today.
	    else if ( $.isArray( value ) ) {
	        value = new Date( value[ 0 ], value[ 1 ], value[ 2 ] )
	        value = _.isDate( value ) ? value : calendar.create().obj
	    }

	    // If it’s a number or date object, make a normalized date.
	    else if ( _.isInteger( value ) || _.isDate( value ) ) {
	        value = calendar.normalize( new Date( value ), options )
	    }

	    // If it’s a literal true or any other case, set it to now.
	    else /*if ( value === true )*/ {
	        value = calendar.now( type, value, options )
	    }

	    // Return the compiled object.
	    return {
	        year: isInfiniteValue || value.getFullYear(),
	        month: isInfiniteValue || value.getMonth(),
	        date: isInfiniteValue || value.getDate(),
	        day: isInfiniteValue || value.getDay(),
	        obj: isInfiniteValue || value,
	        pick: isInfiniteValue || value.getTime()
	    }
	} //DatePicker.prototype.create


	/**
	 * Create a range limit object using an array, date object,
	 * literal “true”, or integer relative to another time.
	 */
	DatePicker.prototype.createRange = function( from, to ) {

	    var calendar = this,
	        createDate = function( date ) {
	            if ( date === true || $.isArray( date ) || _.isDate( date ) ) {
	                return calendar.create( date )
	            }
	            return date
	        }

	    // Create objects if possible.
	    if ( !_.isInteger( from ) ) {
	        from = createDate( from )
	    }
	    if ( !_.isInteger( to ) ) {
	        to = createDate( to )
	    }

	    // Create relative dates.
	    if ( _.isInteger( from ) && $.isPlainObject( to ) ) {
	        from = [ to.year, to.month, to.date + from ];
	    }
	    else if ( _.isInteger( to ) && $.isPlainObject( from ) ) {
	        to = [ from.year, from.month, from.date + to ];
	    }

	    return {
	        from: createDate( from ),
	        to: createDate( to )
	    }
	} //DatePicker.prototype.createRange


	/**
	 * Check if a date unit falls within a date range object.
	 */
	DatePicker.prototype.withinRange = function( range, dateUnit ) {
	    range = this.createRange(range.from, range.to)
	    return dateUnit.pick >= range.from.pick && dateUnit.pick <= range.to.pick
	}


	/**
	 * Check if two date range objects overlap.
	 */
	DatePicker.prototype.overlapRanges = function( one, two ) {

	    var calendar = this

	    // Convert the ranges into comparable dates.
	    one = calendar.createRange( one.from, one.to )
	    two = calendar.createRange( two.from, two.to )

	    return calendar.withinRange( one, two.from ) || calendar.withinRange( one, two.to ) ||
	        calendar.withinRange( two, one.from ) || calendar.withinRange( two, one.to )
	}


	/**
	 * Get the date today.
	 */
	DatePicker.prototype.now = function( type, value, options ) {
	    value = new Date()
	    if ( options && options.rel ) {
	        value.setDate( value.getDate() + options.rel )
	    }
	    return this.normalize( value, options )
	}


	/**
	 * Navigate to next/prev month.
	 */
	DatePicker.prototype.navigate = function( type, value, options ) {

	    var targetDateObject,
	        targetYear,
	        targetMonth,
	        targetDate,
	        isTargetArray = $.isArray( value ),
	        isTargetObject = $.isPlainObject( value ),
	        viewsetObject = this.item.view/*,
	        safety = 100*/


	    if ( isTargetArray || isTargetObject ) {

	        if ( isTargetObject ) {
	            targetYear = value.year
	            targetMonth = value.month
	            targetDate = value.date
	        }
	        else {
	            targetYear = +value[0]
	            targetMonth = +value[1]
	            targetDate = +value[2]
	        }

	        // If we’re navigating months but the view is in a different
	        // month, navigate to the view’s year and month.
	        if ( options && options.nav && viewsetObject && viewsetObject.month !== targetMonth ) {
	            targetYear = viewsetObject.year
	            targetMonth = viewsetObject.month
	        }

	        // Figure out the expected target year and month.
	        targetDateObject = new Date( targetYear, targetMonth + ( options && options.nav ? options.nav : 0 ), 1 )
	        targetYear = targetDateObject.getFullYear()
	        targetMonth = targetDateObject.getMonth()

	        // If the month we’re going to doesn’t have enough days,
	        // keep decreasing the date until we reach the month’s last date.
	        while ( /*safety &&*/ new Date( targetYear, targetMonth, targetDate ).getMonth() !== targetMonth ) {
	            targetDate -= 1
	            /*safety -= 1
	            if ( !safety ) {
	                throw 'Fell into an infinite loop while navigating to ' + new Date( targetYear, targetMonth, targetDate ) + '.'
	            }*/
	        }

	        value = [ targetYear, targetMonth, targetDate ]
	    }

	    return value
	} //DatePicker.prototype.navigate


	/**
	 * Normalize a date by setting the hours to midnight.
	 */
	DatePicker.prototype.normalize = function( value/*, options*/ ) {
	    value.setHours( 0, 0, 0, 0 )
	    return value
	}


	/**
	 * Measure the range of dates.
	 */
	DatePicker.prototype.measure = function( type, value/*, options*/ ) {

	    var calendar = this

	    // If it’s anything false-y, remove the limits.
	    if ( !value ) {
	        value = type == 'min' ? -Infinity : Infinity
	    }

	    // If it’s a string, parse it.
	    else if ( typeof value == 'string' ) {
	        value = calendar.parse( type, value )
	    }

	    // If it's an integer, get a date relative to today.
	    else if ( _.isInteger( value ) ) {
	        value = calendar.now( type, value, { rel: value } )
	    }

	    return value
	} ///DatePicker.prototype.measure


	/**
	 * Create a viewset object based on navigation.
	 */
	DatePicker.prototype.viewset = function( type, dateObject/*, options*/ ) {
	    return this.create([ dateObject.year, dateObject.month, 1 ])
	}


	/**
	 * Validate a date as enabled and shift if needed.
	 */
	DatePicker.prototype.validate = function( type, dateObject, options ) {

	    var calendar = this,

	        // Keep a reference to the original date.
	        originalDateObject = dateObject,

	        // Make sure we have an interval.
	        interval = options && options.interval ? options.interval : 1,

	        // Check if the calendar enabled dates are inverted.
	        isFlippedBase = calendar.item.enable === -1,

	        // Check if we have any enabled dates after/before now.
	        hasEnabledBeforeTarget, hasEnabledAfterTarget,

	        // The min & max limits.
	        minLimitObject = calendar.item.min,
	        maxLimitObject = calendar.item.max,

	        // Check if we’ve reached the limit during shifting.
	        reachedMin, reachedMax,

	        // Check if the calendar is inverted and at least one weekday is enabled.
	        hasEnabledWeekdays = isFlippedBase && calendar.item.disable.filter( function( value ) {

	            // If there’s a date, check where it is relative to the target.
	            if ( $.isArray( value ) ) {
	                var dateTime = calendar.create( value ).pick
	                if ( dateTime < dateObject.pick ) hasEnabledBeforeTarget = true
	                else if ( dateTime > dateObject.pick ) hasEnabledAfterTarget = true
	            }

	            // Return only integers for enabled weekdays.
	            return _.isInteger( value )
	        }).length/*,

	        safety = 100*/



	    // Cases to validate for:
	    // [1] Not inverted and date disabled.
	    // [2] Inverted and some dates enabled.
	    // [3] Not inverted and out of range.
	    //
	    // Cases to **not** validate for:
	    // • Navigating months.
	    // • Not inverted and date enabled.
	    // • Inverted and all dates disabled.
	    // • ..and anything else.
	    if ( !options || !options.nav ) if (
	        /* 1 */ ( !isFlippedBase && calendar.disabled( dateObject ) ) ||
	        /* 2 */ ( isFlippedBase && calendar.disabled( dateObject ) && ( hasEnabledWeekdays || hasEnabledBeforeTarget || hasEnabledAfterTarget ) ) ||
	        /* 3 */ ( !isFlippedBase && (dateObject.pick <= minLimitObject.pick || dateObject.pick >= maxLimitObject.pick) )
	    ) {


	        // When inverted, flip the direction if there aren’t any enabled weekdays
	        // and there are no enabled dates in the direction of the interval.
	        if ( isFlippedBase && !hasEnabledWeekdays && ( ( !hasEnabledAfterTarget && interval > 0 ) || ( !hasEnabledBeforeTarget && interval < 0 ) ) ) {
	            interval *= -1
	        }


	        // Keep looping until we reach an enabled date.
	        while ( /*safety &&*/ calendar.disabled( dateObject ) ) {

	            /*safety -= 1
	            if ( !safety ) {
	                throw 'Fell into an infinite loop while validating ' + dateObject.obj + '.'
	            }*/


	            // If we’ve looped into the next/prev month with a large interval, return to the original date and flatten the interval.
	            if ( Math.abs( interval ) > 1 && ( dateObject.month < originalDateObject.month || dateObject.month > originalDateObject.month ) ) {
	                dateObject = originalDateObject
	                interval = interval > 0 ? 1 : -1
	            }


	            // If we’ve reached the min/max limit, reverse the direction, flatten the interval and set it to the limit.
	            if ( dateObject.pick <= minLimitObject.pick ) {
	                reachedMin = true
	                interval = 1
	                dateObject = calendar.create([
	                    minLimitObject.year,
	                    minLimitObject.month,
	                    minLimitObject.date + (dateObject.pick === minLimitObject.pick ? 0 : -1)
	                ])
	            }
	            else if ( dateObject.pick >= maxLimitObject.pick ) {
	                reachedMax = true
	                interval = -1
	                dateObject = calendar.create([
	                    maxLimitObject.year,
	                    maxLimitObject.month,
	                    maxLimitObject.date + (dateObject.pick === maxLimitObject.pick ? 0 : 1)
	                ])
	            }


	            // If we’ve reached both limits, just break out of the loop.
	            if ( reachedMin && reachedMax ) {
	                break
	            }


	            // Finally, create the shifted date using the interval and keep looping.
	            dateObject = calendar.create([ dateObject.year, dateObject.month, dateObject.date + interval ])
	        }

	    } //endif


	    // Return the date object settled on.
	    return dateObject
	} //DatePicker.prototype.validate


	/**
	 * Check if a date is disabled.
	 */
	DatePicker.prototype.disabled = function( dateToVerify ) {

	    var
	        calendar = this,

	        // Filter through the disabled dates to check if this is one.
	        isDisabledMatch = calendar.item.disable.filter( function( dateToDisable ) {

	            // If the date is a number, match the weekday with 0index and `firstDay` check.
	            if ( _.isInteger( dateToDisable ) ) {
	                return dateToVerify.day === ( calendar.settings.firstDay ? dateToDisable : dateToDisable - 1 ) % 7
	            }

	            // If it’s an array or a native JS date, create and match the exact date.
	            if ( $.isArray( dateToDisable ) || _.isDate( dateToDisable ) ) {
	                return dateToVerify.pick === calendar.create( dateToDisable ).pick
	            }

	            // If it’s an object, match a date within the “from” and “to” range.
	            if ( $.isPlainObject( dateToDisable ) ) {
	                return calendar.withinRange( dateToDisable, dateToVerify )
	            }
	        })

	    // If this date matches a disabled date, confirm it’s not inverted.
	    isDisabledMatch = isDisabledMatch.length && !isDisabledMatch.filter(function( dateToDisable ) {
	        return $.isArray( dateToDisable ) && dateToDisable[3] == 'inverted' ||
	            $.isPlainObject( dateToDisable ) && dateToDisable.inverted
	    }).length

	    // Check the calendar “enabled” flag and respectively flip the
	    // disabled state. Then also check if it’s beyond the min/max limits.
	    return calendar.item.enable === -1 ? !isDisabledMatch : isDisabledMatch ||
	        dateToVerify.pick < calendar.item.min.pick ||
	        dateToVerify.pick > calendar.item.max.pick

	} //DatePicker.prototype.disabled


	/**
	 * Parse a string into a usable type.
	 */
	DatePicker.prototype.parse = function( type, value, options ) {

	    var calendar = this,
	        parsingObject = {}

	    // If it’s already parsed, we’re good.
	    if ( !value || typeof value != 'string' ) {
	        return value
	    }

	    // We need a `.format` to parse the value with.
	    if ( !( options && options.format ) ) {
	        options = options || {}
	        options.format = calendar.settings.format
	    }

	    // Convert the format into an array and then map through it.
	    calendar.formats.toArray( options.format ).map( function( label ) {

	        var
	            // Grab the formatting label.
	            formattingLabel = calendar.formats[ label ],

	            // The format length is from the formatting label function or the
	            // label length without the escaping exclamation (!) mark.
	            formatLength = formattingLabel ? _.trigger( formattingLabel, calendar, [ value, parsingObject ] ) : label.replace( /^!/, '' ).length

	        // If there's a format label, split the value up to the format length.
	        // Then add it to the parsing object with appropriate label.
	        if ( formattingLabel ) {
	            parsingObject[ label ] = value.substr( 0, formatLength )
	        }

	        // Update the value as the substring from format length to end.
	        value = value.substr( formatLength )
	    })

	    // Compensate for month 0index.
	    return [
	        parsingObject.yyyy || parsingObject.yy,
	        +( parsingObject.mm || parsingObject.m ) - 1,
	        parsingObject.dd || parsingObject.d
	    ]
	} //DatePicker.prototype.parse


	/**
	 * Various formats to display the object in.
	 */
	DatePicker.prototype.formats = (function() {

	    // Return the length of the first word in a collection.
	    function getWordLengthFromCollection( string, collection, dateObject ) {

	        // Grab the first word from the string.
	        var word = string.match( /\w+/ )[ 0 ]

	        // If there's no month index, add it to the date object
	        if ( !dateObject.mm && !dateObject.m ) {
	            dateObject.m = collection.indexOf( word ) + 1
	        }

	        // Return the length of the word.
	        return word.length
	    }

	    // Get the length of the first word in a string.
	    function getFirstWordLength( string ) {
	        return string.match( /\w+/ )[ 0 ].length
	    }

	    return {

	        d: function( string, dateObject ) {

	            // If there's string, then get the digits length.
	            // Otherwise return the selected date.
	            return string ? _.digits( string ) : dateObject.date
	        },
	        dd: function( string, dateObject ) {

	            // If there's a string, then the length is always 2.
	            // Otherwise return the selected date with a leading zero.
	            return string ? 2 : _.lead( dateObject.date )
	        },
	        ddd: function( string, dateObject ) {

	            // If there's a string, then get the length of the first word.
	            // Otherwise return the short selected weekday.
	            return string ? getFirstWordLength( string ) : this.settings.weekdaysShort[ dateObject.day ]
	        },
	        dddd: function( string, dateObject ) {

	            // If there's a string, then get the length of the first word.
	            // Otherwise return the full selected weekday.
	            return string ? getFirstWordLength( string ) : this.settings.weekdaysFull[ dateObject.day ]
	        },
	        m: function( string, dateObject ) {

	            // If there's a string, then get the length of the digits
	            // Otherwise return the selected month with 0index compensation.
	            return string ? _.digits( string ) : dateObject.month + 1
	        },
	        mm: function( string, dateObject ) {

	            // If there's a string, then the length is always 2.
	            // Otherwise return the selected month with 0index and leading zero.
	            return string ? 2 : _.lead( dateObject.month + 1 )
	        },
	        mmm: function( string, dateObject ) {

	            var collection = this.settings.monthsShort

	            // If there's a string, get length of the relevant month from the short
	            // months collection. Otherwise return the selected month from that collection.
	            return string ? getWordLengthFromCollection( string, collection, dateObject ) : collection[ dateObject.month ]
	        },
	        mmmm: function( string, dateObject ) {

	            var collection = this.settings.monthsFull

	            // If there's a string, get length of the relevant month from the full
	            // months collection. Otherwise return the selected month from that collection.
	            return string ? getWordLengthFromCollection( string, collection, dateObject ) : collection[ dateObject.month ]
	        },
	        yy: function( string, dateObject ) {

	            // If there's a string, then the length is always 2.
	            // Otherwise return the selected year by slicing out the first 2 digits.
	            return string ? 2 : ( '' + dateObject.year ).slice( 2 )
	        },
	        yyyy: function( string, dateObject ) {

	            // If there's a string, then the length is always 4.
	            // Otherwise return the selected year.
	            return string ? 4 : dateObject.year
	        },

	        // Create an array by splitting the formatting string passed.
	        toArray: function( formatString ) { return formatString.split( /(d{1,4}|m{1,4}|y{4}|yy|!.)/g ) },

	        // Format an object into a string using the formatting options.
	        toString: function ( formatString, itemObject ) {
	            var calendar = this
	            return calendar.formats.toArray( formatString ).map( function( label ) {
	                return _.trigger( calendar.formats[ label ], calendar, [ 0, itemObject ] ) || label.replace( /^!/, '' )
	            }).join( '' )
	        }
	    }
	})() //DatePicker.prototype.formats




	/**
	 * Check if two date units are the exact.
	 */
	DatePicker.prototype.isDateExact = function( one, two ) {

	    var calendar = this

	    // When we’re working with weekdays, do a direct comparison.
	    if (
	        ( _.isInteger( one ) && _.isInteger( two ) ) ||
	        ( typeof one == 'boolean' && typeof two == 'boolean' )
	     ) {
	        return one === two
	    }

	    // When we’re working with date representations, compare the “pick” value.
	    if (
	        ( _.isDate( one ) || $.isArray( one ) ) &&
	        ( _.isDate( two ) || $.isArray( two ) )
	    ) {
	        return calendar.create( one ).pick === calendar.create( two ).pick
	    }

	    // When we’re working with range objects, compare the “from” and “to”.
	    if ( $.isPlainObject( one ) && $.isPlainObject( two ) ) {
	        return calendar.isDateExact( one.from, two.from ) && calendar.isDateExact( one.to, two.to )
	    }

	    return false
	}


	/**
	 * Check if two date units overlap.
	 */
	DatePicker.prototype.isDateOverlap = function( one, two ) {

	    var calendar = this,
	        firstDay = calendar.settings.firstDay ? 1 : 0

	    // When we’re working with a weekday index, compare the days.
	    if ( _.isInteger( one ) && ( _.isDate( two ) || $.isArray( two ) ) ) {
	        one = one % 7 + firstDay
	        return one === calendar.create( two ).day + 1
	    }
	    if ( _.isInteger( two ) && ( _.isDate( one ) || $.isArray( one ) ) ) {
	        two = two % 7 + firstDay
	        return two === calendar.create( one ).day + 1
	    }

	    // When we’re working with range objects, check if the ranges overlap.
	    if ( $.isPlainObject( one ) && $.isPlainObject( two ) ) {
	        return calendar.overlapRanges( one, two )
	    }

	    return false
	}


	/**
	 * Flip the “enabled” state.
	 */
	DatePicker.prototype.flipEnable = function(val) {
	    var itemObject = this.item
	    itemObject.enable = val || (itemObject.enable == -1 ? 1 : -1)
	}


	/**
	 * Mark a collection of dates as “disabled”.
	 */
	DatePicker.prototype.deactivate = function( type, datesToDisable ) {

	    var calendar = this,
	        disabledItems = calendar.item.disable.slice(0)


	    // If we’re flipping, that’s all we need to do.
	    if ( datesToDisable == 'flip' ) {
	        calendar.flipEnable()
	    }

	    else if ( datesToDisable === false ) {
	        calendar.flipEnable(1)
	        disabledItems = []
	    }

	    else if ( datesToDisable === true ) {
	        calendar.flipEnable(-1)
	        disabledItems = []
	    }

	    // Otherwise go through the dates to disable.
	    else {

	        datesToDisable.map(function( unitToDisable ) {

	            var matchFound

	            // When we have disabled items, check for matches.
	            // If something is matched, immediately break out.
	            for ( var index = 0; index < disabledItems.length; index += 1 ) {
	                if ( calendar.isDateExact( unitToDisable, disabledItems[index] ) ) {
	                    matchFound = true
	                    break
	                }
	            }

	            // If nothing was found, add the validated unit to the collection.
	            if ( !matchFound ) {
	                if (
	                    _.isInteger( unitToDisable ) ||
	                    _.isDate( unitToDisable ) ||
	                    $.isArray( unitToDisable ) ||
	                    ( $.isPlainObject( unitToDisable ) && unitToDisable.from && unitToDisable.to )
	                ) {
	                    disabledItems.push( unitToDisable )
	                }
	            }
	        })
	    }

	    // Return the updated collection.
	    return disabledItems
	} //DatePicker.prototype.deactivate


	/**
	 * Mark a collection of dates as “enabled”.
	 */
	DatePicker.prototype.activate = function( type, datesToEnable ) {

	    var calendar = this,
	        disabledItems = calendar.item.disable,
	        disabledItemsCount = disabledItems.length

	    // If we’re flipping, that’s all we need to do.
	    if ( datesToEnable == 'flip' ) {
	        calendar.flipEnable()
	    }

	    else if ( datesToEnable === true ) {
	        calendar.flipEnable(1)
	        disabledItems = []
	    }

	    else if ( datesToEnable === false ) {
	        calendar.flipEnable(-1)
	        disabledItems = []
	    }

	    // Otherwise go through the disabled dates.
	    else {

	        datesToEnable.map(function( unitToEnable ) {

	            var matchFound,
	                disabledUnit,
	                index,
	                isExactRange

	            // Go through the disabled items and try to find a match.
	            for ( index = 0; index < disabledItemsCount; index += 1 ) {

	                disabledUnit = disabledItems[index]

	                // When an exact match is found, remove it from the collection.
	                if ( calendar.isDateExact( disabledUnit, unitToEnable ) ) {
	                    matchFound = disabledItems[index] = null
	                    isExactRange = true
	                    break
	                }

	                // When an overlapped match is found, add the “inverted” state to it.
	                else if ( calendar.isDateOverlap( disabledUnit, unitToEnable ) ) {
	                    if ( $.isPlainObject( unitToEnable ) ) {
	                        unitToEnable.inverted = true
	                        matchFound = unitToEnable
	                    }
	                    else if ( $.isArray( unitToEnable ) ) {
	                        matchFound = unitToEnable
	                        if ( !matchFound[3] ) matchFound.push( 'inverted' )
	                    }
	                    else if ( _.isDate( unitToEnable ) ) {
	                        matchFound = [ unitToEnable.getFullYear(), unitToEnable.getMonth(), unitToEnable.getDate(), 'inverted' ]
	                    }
	                    break
	                }
	            }

	            // If a match was found, remove a previous duplicate entry.
	            if ( matchFound ) for ( index = 0; index < disabledItemsCount; index += 1 ) {
	                if ( calendar.isDateExact( disabledItems[index], unitToEnable ) ) {
	                    disabledItems[index] = null
	                    break
	                }
	            }

	            // In the event that we’re dealing with an exact range of dates,
	            // make sure there are no “inverted” dates because of it.
	            if ( isExactRange ) for ( index = 0; index < disabledItemsCount; index += 1 ) {
	                if ( calendar.isDateOverlap( disabledItems[index], unitToEnable ) ) {
	                    disabledItems[index] = null
	                    break
	                }
	            }

	            // If something is still matched, add it into the collection.
	            if ( matchFound ) {
	                disabledItems.push( matchFound )
	            }
	        })
	    }

	    // Return the updated collection.
	    return disabledItems.filter(function( val ) { return val != null })
	} //DatePicker.prototype.activate


	/**
	 * Create a string for the nodes in the picker.
	 */
	DatePicker.prototype.nodes = function( isOpen ) {

	    var
	        calendar = this,
	        settings = calendar.settings,
	        calendarItem = calendar.item,
	        nowObject = calendarItem.now,
	        selectedObject = calendarItem.select,
	        highlightedObject = calendarItem.highlight,
	        viewsetObject = calendarItem.view,
	        disabledCollection = calendarItem.disable,
	        minLimitObject = calendarItem.min,
	        maxLimitObject = calendarItem.max,


	        // Create the calendar table head using a copy of weekday labels collection.
	        // * We do a copy so we don't mutate the original array.
	        tableHead = (function( collection, fullCollection ) {

	            // If the first day should be Monday, move Sunday to the end.
	            if ( settings.firstDay ) {
	                collection.push( collection.shift() )
	                fullCollection.push( fullCollection.shift() )
	            }

	            // Create and return the table head group.
	            return _.node(
	                'thead',
	                _.node(
	                    'tr',
	                    _.group({
	                        min: 0,
	                        max: DAYS_IN_WEEK - 1,
	                        i: 1,
	                        node: 'th',
	                        item: function( counter ) {
	                            return [
	                                collection[ counter ],
	                                settings.klass.weekdays,
	                                'scope=col title="' + fullCollection[ counter ] + '"'
	                            ]
	                        }
	                    })
	                )
	            ) //endreturn

	        // Materialize modified
	        })( ( settings.showWeekdaysFull ? settings.weekdaysFull : settings.weekdaysLetter ).slice( 0 ), settings.weekdaysFull.slice( 0 ) ), //tableHead


	        // Create the nav for next/prev month.
	        createMonthNav = function( next ) {

	            // Otherwise, return the created month tag.
	            return _.node(
	                'div',
	                ' ',
	                settings.klass[ 'nav' + ( next ? 'Next' : 'Prev' ) ] + (

	                    // If the focused month is outside the range, disabled the button.
	                    ( next && viewsetObject.year >= maxLimitObject.year && viewsetObject.month >= maxLimitObject.month ) ||
	                    ( !next && viewsetObject.year <= minLimitObject.year && viewsetObject.month <= minLimitObject.month ) ?
	                    ' ' + settings.klass.navDisabled : ''
	                ),
	                'data-nav=' + ( next || -1 ) + ' ' +
	                _.ariaAttr({
	                    role: 'button',
	                    controls: calendar.$node[0].id + '_table'
	                }) + ' ' +
	                'title="' + (next ? settings.labelMonthNext : settings.labelMonthPrev ) + '"'
	            ) //endreturn
	        }, //createMonthNav


	        // Create the month label.
	        //Materialize modified
	        createMonthLabel = function(override) {

	            var monthsCollection = settings.showMonthsShort ? settings.monthsShort : settings.monthsFull

	             // Materialize modified
	            if (override == "short_months") {
	              monthsCollection = settings.monthsShort;
	            }

	            // If there are months to select, add a dropdown menu.
	            if ( settings.selectMonths  && override == undefined) {

	                return _.node( 'select',
	                    _.group({
	                        min: 0,
	                        max: 11,
	                        i: 1,
	                        node: 'option',
	                        item: function( loopedMonth ) {

	                            return [

	                                // The looped month and no classes.
	                                monthsCollection[ loopedMonth ], 0,

	                                // Set the value and selected index.
	                                'value=' + loopedMonth +
	                                ( viewsetObject.month == loopedMonth ? ' selected' : '' ) +
	                                (
	                                    (
	                                        ( viewsetObject.year == minLimitObject.year && loopedMonth < minLimitObject.month ) ||
	                                        ( viewsetObject.year == maxLimitObject.year && loopedMonth > maxLimitObject.month )
	                                    ) ?
	                                    ' disabled' : ''
	                                )
	                            ]
	                        }
	                    }),
	                    settings.klass.selectMonth + ' browser-default',
	                    ( isOpen ? '' : 'disabled' ) + ' ' +
	                    _.ariaAttr({ controls: calendar.$node[0].id + '_table' }) + ' ' +
	                    'title="' + settings.labelMonthSelect + '"'
	                )
	            }

	            // Materialize modified
	            if (override == "short_months")
	                if (selectedObject != null)
	                return _.node( 'div', monthsCollection[ selectedObject.month ] );
	                else return _.node( 'div', monthsCollection[ viewsetObject.month ] );

	            // If there's a need for a month selector
	            return _.node( 'div', monthsCollection[ viewsetObject.month ], settings.klass.month )
	        }, //createMonthLabel


	        // Create the year label.
	        // Materialize modified
	        createYearLabel = function(override) {

	            var focusedYear = viewsetObject.year,

	            // If years selector is set to a literal "true", set it to 5. Otherwise
	            // divide in half to get half before and half after focused year.
	            numberYears = settings.selectYears === true ? 5 : ~~( settings.selectYears / 2 )

	            // If there are years to select, add a dropdown menu.
	            if ( numberYears ) {

	                var
	                    minYear = minLimitObject.year,
	                    maxYear = maxLimitObject.year,
	                    lowestYear = focusedYear - numberYears,
	                    highestYear = focusedYear + numberYears

	                // If the min year is greater than the lowest year, increase the highest year
	                // by the difference and set the lowest year to the min year.
	                if ( minYear > lowestYear ) {
	                    highestYear += minYear - lowestYear
	                    lowestYear = minYear
	                }

	                // If the max year is less than the highest year, decrease the lowest year
	                // by the lower of the two: available and needed years. Then set the
	                // highest year to the max year.
	                if ( maxYear < highestYear ) {

	                    var availableYears = lowestYear - minYear,
	                        neededYears = highestYear - maxYear

	                    lowestYear -= availableYears > neededYears ? neededYears : availableYears
	                    highestYear = maxYear
	                }

	                if ( settings.selectYears  && override == undefined ) {
	                    return _.node( 'select',
	                        _.group({
	                            min: lowestYear,
	                            max: highestYear,
	                            i: 1,
	                            node: 'option',
	                            item: function( loopedYear ) {
	                                return [

	                                    // The looped year and no classes.
	                                    loopedYear, 0,

	                                    // Set the value and selected index.
	                                    'value=' + loopedYear + ( focusedYear == loopedYear ? ' selected' : '' )
	                                ]
	                            }
	                        }),
	                        settings.klass.selectYear + ' browser-default',
	                        ( isOpen ? '' : 'disabled' ) + ' ' + _.ariaAttr({ controls: calendar.$node[0].id + '_table' }) + ' ' +
	                        'title="' + settings.labelYearSelect + '"'
	                    )
	                }
	            }

	            // Materialize modified
	            if (override == "raw")
	                return _.node( 'div', focusedYear )

	            // Otherwise just return the year focused
	            return _.node( 'div', focusedYear, settings.klass.year )
	        } //createYearLabel


	        // Materialize modified
	        createDayLabel = function() {
	                if (selectedObject != null)
	                    return _.node( 'div', selectedObject.date)
	                else return _.node( 'div', nowObject.date)
	            }
	        createWeekdayLabel = function() {
	            var display_day;

	            if (selectedObject != null)
	                display_day = selectedObject.day;
	            else
	                display_day = nowObject.day;
	            var weekday = settings.weekdaysFull[ display_day ]
	            return weekday
	        }


	    // Create and return the entire calendar.
	return _.node(
	        // Date presentation View
	        'div',
	            _.node(
	                'div',
	                createWeekdayLabel(),
	                "picker__weekday-display"
	            )+
	            _.node(
	                // Div for short Month
	                'div',
	                createMonthLabel("short_months"),
	                settings.klass.month_display
	            )+
	            _.node(
	                // Div for Day
	                'div',
	                createDayLabel() ,
	                settings.klass.day_display
	            )+
	            _.node(
	                // Div for Year
	                'div',
	                createYearLabel("raw") ,
	                settings.klass.year_display
	            ),
	        settings.klass.date_display
	    )+
	    // Calendar container
	    _.node('div',
	        _.node('div',
	        ( settings.selectYears ?  createMonthLabel() + createYearLabel() : createMonthLabel() + createYearLabel() ) +
	        createMonthNav() + createMonthNav( 1 ),
	        settings.klass.header
	    ) + _.node(
	        'table',
	        tableHead +
	        _.node(
	            'tbody',
	            _.group({
	                min: 0,
	                max: WEEKS_IN_CALENDAR - 1,
	                i: 1,
	                node: 'tr',
	                item: function( rowCounter ) {

	                    // If Monday is the first day and the month starts on Sunday, shift the date back a week.
	                    var shiftDateBy = settings.firstDay && calendar.create([ viewsetObject.year, viewsetObject.month, 1 ]).day === 0 ? -7 : 0

	                    return [
	                        _.group({
	                            min: DAYS_IN_WEEK * rowCounter - viewsetObject.day + shiftDateBy + 1, // Add 1 for weekday 0index
	                            max: function() {
	                                return this.min + DAYS_IN_WEEK - 1
	                            },
	                            i: 1,
	                            node: 'td',
	                            item: function( targetDate ) {

	                                // Convert the time date from a relative date to a target date.
	                                targetDate = calendar.create([ viewsetObject.year, viewsetObject.month, targetDate + ( settings.firstDay ? 1 : 0 ) ])

	                                var isSelected = selectedObject && selectedObject.pick == targetDate.pick,
	                                    isHighlighted = highlightedObject && highlightedObject.pick == targetDate.pick,
	                                    isDisabled = disabledCollection && calendar.disabled( targetDate ) || targetDate.pick < minLimitObject.pick || targetDate.pick > maxLimitObject.pick,
	                                    formattedDate = _.trigger( calendar.formats.toString, calendar, [ settings.format, targetDate ] )

	                                return [
	                                    _.node(
	                                        'div',
	                                        targetDate.date,
	                                        (function( klasses ) {

	                                            // Add the `infocus` or `outfocus` classes based on month in view.
	                                            klasses.push( viewsetObject.month == targetDate.month ? settings.klass.infocus : settings.klass.outfocus )

	                                            // Add the `today` class if needed.
	                                            if ( nowObject.pick == targetDate.pick ) {
	                                                klasses.push( settings.klass.now )
	                                            }

	                                            // Add the `selected` class if something's selected and the time matches.
	                                            if ( isSelected ) {
	                                                klasses.push( settings.klass.selected )
	                                            }

	                                            // Add the `highlighted` class if something's highlighted and the time matches.
	                                            if ( isHighlighted ) {
	                                                klasses.push( settings.klass.highlighted )
	                                            }

	                                            // Add the `disabled` class if something's disabled and the object matches.
	                                            if ( isDisabled ) {
	                                                klasses.push( settings.klass.disabled )
	                                            }

	                                            return klasses.join( ' ' )
	                                        })([ settings.klass.day ]),
	                                        'data-pick=' + targetDate.pick + ' ' + _.ariaAttr({
	                                            role: 'gridcell',
	                                            label: formattedDate,
	                                            selected: isSelected && calendar.$node.val() === formattedDate ? true : null,
	                                            activedescendant: isHighlighted ? true : null,
	                                            disabled: isDisabled ? true : null
	                                        })
	                                    ),
	                                    '',
	                                    _.ariaAttr({ role: 'presentation' })
	                                ] //endreturn
	                            }
	                        })
	                    ] //endreturn
	                }
	            })
	        ),
	        settings.klass.table,
	        'id="' + calendar.$node[0].id + '_table' + '" ' + _.ariaAttr({
	            role: 'grid',
	            controls: calendar.$node[0].id,
	            readonly: true
	        })
	    )
	    , settings.klass.calendar_container) // end calendar

	     +

	    // * For Firefox forms to submit, make sure to set the buttons’ `type` attributes as “button”.
	    _.node(
	        'div',
	        _.node( 'button', settings.today, "btn-flat picker__today",
	            'type=button data-pick=' + nowObject.pick +
	            ( isOpen && !calendar.disabled(nowObject) ? '' : ' disabled' ) + ' ' +
	            _.ariaAttr({ controls: calendar.$node[0].id }) ) +
	        _.node( 'button', settings.clear, "btn-flat picker__clear",
	            'type=button data-clear=1' +
	            ( isOpen ? '' : ' disabled' ) + ' ' +
	            _.ariaAttr({ controls: calendar.$node[0].id }) ) +
	        _.node('button', settings.close, "btn-flat picker__close",
	            'type=button data-close=true ' +
	            ( isOpen ? '' : ' disabled' ) + ' ' +
	            _.ariaAttr({ controls: calendar.$node[0].id }) ),
	        settings.klass.footer
	    ) //endreturn
	} //DatePicker.prototype.nodes




	/**
	 * The date picker defaults.
	 */
	DatePicker.defaults = (function( prefix ) {

	    return {

	        // The title label to use for the month nav buttons
	        labelMonthNext: 'Next month',
	        labelMonthPrev: 'Previous month',

	        // The title label to use for the dropdown selectors
	        labelMonthSelect: 'Select a month',
	        labelYearSelect: 'Select a year',

	        // Months and weekdays
	        monthsFull: [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December' ],
	        monthsShort: [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ],
	        weekdaysFull: [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ],
	        weekdaysShort: [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ],

	        // Materialize modified
	        weekdaysLetter: [ 'S', 'M', 'T', 'W', 'T', 'F', 'S' ],

	        // Today and clear
	        today: 'Today',
	        clear: 'Clear',
	        close: 'Close',

	        // The format to show on the `input` element
	        format: 'd mmmm, yyyy',

	        // Classes
	        klass: {

	            table: prefix + 'table',

	            header: prefix + 'header',


	            // Materialize Added klasses
	            date_display: prefix + 'date-display',
	            day_display: prefix + 'day-display',
	            month_display: prefix + 'month-display',
	            year_display: prefix + 'year-display',
	            calendar_container: prefix + 'calendar-container',
	            // end



	            navPrev: prefix + 'nav--prev',
	            navNext: prefix + 'nav--next',
	            navDisabled: prefix + 'nav--disabled',

	            month: prefix + 'month',
	            year: prefix + 'year',

	            selectMonth: prefix + 'select--month',
	            selectYear: prefix + 'select--year',

	            weekdays: prefix + 'weekday',

	            day: prefix + 'day',
	            disabled: prefix + 'day--disabled',
	            selected: prefix + 'day--selected',
	            highlighted: prefix + 'day--highlighted',
	            now: prefix + 'day--today',
	            infocus: prefix + 'day--infocus',
	            outfocus: prefix + 'day--outfocus',

	            footer: prefix + 'footer',

	            buttonClear: prefix + 'button--clear',
	            buttonToday: prefix + 'button--today',
	            buttonClose: prefix + 'button--close'
	        }
	    }
	})( Picker.klasses().picker + '__' )





	/**
	 * Extend the picker to add the date picker.
	 */
	Picker.extend( 'pickadate', DatePicker )


	}));


	;(function ($) {

	  $.fn.characterCounter = function(){
	    return this.each(function(){
	      var $input = $(this);
	      var $counterElement = $input.parent().find('span[class="character-counter"]');

	      // character counter has already been added appended to the parent container
	      if ($counterElement.length) {
	        return;
	      }

	      var itHasLengthAttribute = $input.attr('length') !== undefined;

	      if(itHasLengthAttribute){
	        $input.on('input', updateCounter);
	        $input.on('focus', updateCounter);
	        $input.on('blur', removeCounterElement);

	        addCounterElement($input);
	      }

	    });
	  };

	  function updateCounter(){
	    var maxLength     = +$(this).attr('length'),
	    actualLength      = +$(this).val().length,
	    isValidLength     = actualLength <= maxLength;

	    $(this).parent().find('span[class="character-counter"]')
	                    .html( actualLength + '/' + maxLength);

	    addInputStyle(isValidLength, $(this));
	  }

	  function addCounterElement($input) {
	    var $counterElement = $input.parent().find('span[class="character-counter"]');

	    if ($counterElement.length) {
	      return;
	    }

	    $counterElement = $('<span/>')
	                        .addClass('character-counter')
	                        .css('float','right')
	                        .css('font-size','12px')
	                        .css('height', 1);

	    $input.parent().append($counterElement);
	  }

	  function removeCounterElement(){
	    $(this).parent().find('span[class="character-counter"]').html('');
	  }

	  function addInputStyle(isValidLength, $input){
	    var inputHasInvalidClass = $input.hasClass('invalid');
	    if (isValidLength && inputHasInvalidClass) {
	      $input.removeClass('invalid');
	    }
	    else if(!isValidLength && !inputHasInvalidClass){
	      $input.removeClass('valid');
	      $input.addClass('invalid');
	    }
	  }

	  $(document).ready(function(){
	    $('input, textarea').characterCounter();
	  });

	}( jQuery ));
	;(function ($) {

	  var methods = {

	    init : function(options) {
	      var defaults = {
	        time_constant: 200, // ms
	        dist: -100, // zoom scale TODO: make this more intuitive as an option
	        shift: 0, // spacing for center image
	        padding: 0, // Padding between non center items
	        full_width: false // Change to full width styles
	      };
	      options = $.extend(defaults, options);

	      return this.each(function() {

	        var images, offset, center, pressed, dim, count,
	            reference, referenceY, amplitude, target, velocity,
	            xform, frame, timestamp, ticker, dragged, vertical_dragged;

	        // Initialize
	        var view = $(this);
	        // Don't double initialize.
	        if (view.hasClass('initialized')) {
	          return true;
	        }

	        // Options
	        if (options.full_width) {
	          options.dist = 0;
	          imageHeight = view.find('.carousel-item img').first().load(function(){
	            view.css('height', $(this).height());
	          });
	        }

	        view.addClass('initialized');
	        pressed = false;
	        offset = target = 0;
	        images = [];
	        item_width = view.find('.carousel-item').first().innerWidth();
	        dim = item_width * 2 + options.padding;

	        view.find('.carousel-item').each(function () {
	          images.push($(this)[0]);
	        });

	        count = images.length;


	        function setupEvents() {
	          if (typeof window.ontouchstart !== 'undefined') {
	            view[0].addEventListener('touchstart', tap);
	            view[0].addEventListener('touchmove', drag);
	            view[0].addEventListener('touchend', release);
	          }
	          view[0].addEventListener('mousedown', tap);
	          view[0].addEventListener('mousemove', drag);
	          view[0].addEventListener('mouseup', release);
	          view[0].addEventListener('click', click);
	        }

	        function xpos(e) {
	          // touch event
	          if (e.targetTouches && (e.targetTouches.length >= 1)) {
	            return e.targetTouches[0].clientX;
	          }

	          // mouse event
	          return e.clientX;
	        }

	        function ypos(e) {
	          // touch event
	          if (e.targetTouches && (e.targetTouches.length >= 1)) {
	            return e.targetTouches[0].clientY;
	          }

	          // mouse event
	          return e.clientY;
	        }

	        function wrap(x) {
	          return (x >= count) ? (x % count) : (x < 0) ? wrap(count + (x % count)) : x;
	        }

	        function scroll(x) {
	          var i, half, delta, dir, tween, el, alignment, xTranslation;

	          offset = (typeof x === 'number') ? x : offset;
	          center = Math.floor((offset + dim / 2) / dim);
	          delta = offset - center * dim;
	          dir = (delta < 0) ? 1 : -1;
	          tween = -dir * delta * 2 / dim;

	          if (!options.full_width) {
	            alignment = 'translateX(' + (view[0].clientWidth - item_width) / 2 + 'px) ';
	            alignment += 'translateY(' + (view[0].clientHeight - item_width) / 2 + 'px)';
	          } else {
	            alignment = 'translateX(0)';
	          }

	          // center
	          el = images[wrap(center)];
	          el.style[xform] = alignment +
	            ' translateX(' + (-delta / 2) + 'px)' +
	            ' translateX(' + (dir * options.shift * tween * i) + 'px)' +
	            ' translateZ(' + (options.dist * tween) + 'px)';
	          el.style.zIndex = 0;
	          if (options.full_width) { tweenedOpacity = 1; }
	          else { tweenedOpacity = 1 - 0.2 * tween; }
	          el.style.opacity = tweenedOpacity;
	          half = count >> 1;

	          for (i = 1; i <= half; ++i) {
	            // right side
	            if (options.full_width) {
	              zTranslation = options.dist;
	              tweenedOpacity = (i === half && delta < 0) ? 1 - tween : 1;
	            } else {
	              zTranslation = options.dist * (i * 2 + tween * dir);
	              tweenedOpacity = 1 - 0.2 * (i * 2 + tween * dir);
	            }
	            el = images[wrap(center + i)];
	            el.style[xform] = alignment +
	              ' translateX(' + (options.shift + (dim * i - delta) / 2) + 'px)' +
	              ' translateZ(' + zTranslation + 'px)';
	            el.style.zIndex = -i;
	            el.style.opacity = tweenedOpacity;


	            // left side
	            if (options.full_width) {
	              zTranslation = options.dist;
	              tweenedOpacity = (i === half && delta > 0) ? 1 - tween : 1;
	            } else {
	              zTranslation = options.dist * (i * 2 - tween * dir);
	              tweenedOpacity = 1 - 0.2 * (i * 2 - tween * dir);
	            }
	            el = images[wrap(center - i)];
	            el.style[xform] = alignment +
	              ' translateX(' + (-options.shift + (-dim * i - delta) / 2) + 'px)' +
	              ' translateZ(' + zTranslation + 'px)';
	            el.style.zIndex = -i;
	            el.style.opacity = tweenedOpacity;
	          }

	          // center
	          el = images[wrap(center)];
	          el.style[xform] = alignment +
	            ' translateX(' + (-delta / 2) + 'px)' +
	            ' translateX(' + (dir * options.shift * tween) + 'px)' +
	            ' translateZ(' + (options.dist * tween) + 'px)';
	          el.style.zIndex = 0;
	          if (options.full_width) { tweenedOpacity = 1; }
	          else { tweenedOpacity = 1 - 0.2 * tween; }
	          el.style.opacity = tweenedOpacity;
	        }

	        function track() {
	          var now, elapsed, delta, v;

	          now = Date.now();
	          elapsed = now - timestamp;
	          timestamp = now;
	          delta = offset - frame;
	          frame = offset;

	          v = 1000 * delta / (1 + elapsed);
	          velocity = 0.8 * v + 0.2 * velocity;
	        }

	        function autoScroll() {
	          var elapsed, delta;

	          if (amplitude) {
	            elapsed = Date.now() - timestamp;
	            delta = amplitude * Math.exp(-elapsed / options.time_constant);
	            if (delta > 2 || delta < -2) {
	                scroll(target - delta);
	                requestAnimationFrame(autoScroll);
	            } else {
	                scroll(target);
	            }
	          }
	        }

	        function click(e) {
	          // Disable clicks if carousel was dragged.
	          if (dragged) {
	            e.preventDefault();
	            e.stopPropagation();
	            return false;

	          } else if (!options.full_width) {
	            var clickedIndex = $(e.target).closest('.carousel-item').index();
	            var diff = (center % count) - clickedIndex;

	            // Account for wraparound.
	            if (diff < 0) {
	              if (Math.abs(diff + count) < Math.abs(diff)) { diff += count; }

	            } else if (diff > 0) {
	              if (Math.abs(diff - count) < diff) { diff -= count; }
	            }

	            // Call prev or next accordingly.
	            if (diff < 0) {
	              $(this).trigger('carouselNext', [Math.abs(diff)]);

	            } else if (diff > 0) {
	              $(this).trigger('carouselPrev', [diff]);
	            }
	          }
	        }

	        function tap(e) {
	          pressed = true;
	          dragged = false;
	          vertical_dragged = false;
	          reference = xpos(e);
	          referenceY = ypos(e);

	          velocity = amplitude = 0;
	          frame = offset;
	          timestamp = Date.now();
	          clearInterval(ticker);
	          ticker = setInterval(track, 100);

	        }

	        function drag(e) {
	          var x, delta, deltaY;
	          if (pressed) {
	            x = xpos(e);
	            y = ypos(e);
	            delta = reference - x;
	            deltaY = Math.abs(referenceY - y);
	            if (deltaY < 30 && !vertical_dragged) {
	              // If vertical scrolling don't allow dragging.
	              if (delta > 2 || delta < -2) {
	                dragged = true;
	                reference = x;
	                scroll(offset + delta);
	              }

	            } else if (dragged) {
	              // If dragging don't allow vertical scroll.
	              e.preventDefault();
	              e.stopPropagation();
	              return false;

	            } else {
	              // Vertical scrolling.
	              vertical_dragged = true;
	            }
	          }

	          if (dragged) {
	            // If dragging don't allow vertical scroll.
	            e.preventDefault();
	            e.stopPropagation();
	            return false;
	          }
	        }

	        function release(e) {
	          pressed = false;

	          clearInterval(ticker);
	          target = offset;
	          if (velocity > 10 || velocity < -10) {
	            amplitude = 0.9 * velocity;
	            target = offset + amplitude;
	          }
	          target = Math.round(target / dim) * dim;
	          amplitude = target - offset;
	          timestamp = Date.now();
	          requestAnimationFrame(autoScroll);

	          e.preventDefault();
	          e.stopPropagation();
	          return false;
	        }

	        xform = 'transform';
	        ['webkit', 'Moz', 'O', 'ms'].every(function (prefix) {
	          var e = prefix + 'Transform';
	          if (typeof document.body.style[e] !== 'undefined') {
	            xform = e;
	            return false;
	          }
	          return true;
	        });



	        window.onresize = scroll;

	        setupEvents();
	        scroll(offset);

	        $(this).on('carouselNext', function(e, n) {
	          if (n === undefined) {
	            n = 1;
	          }
	          target = offset + dim * n;
	          if (offset !== target) {
	            amplitude = target - offset;
	            timestamp = Date.now();
	            requestAnimationFrame(autoScroll);
	          }
	        });

	        $(this).on('carouselPrev', function(e, n) {
	          if (n === undefined) {
	            n = 1;
	          }
	          target = offset - dim * n;
	          if (offset !== target) {
	            amplitude = target - offset;
	            timestamp = Date.now();
	            requestAnimationFrame(autoScroll);
	          }
	        });

	      });



	    },
	    next : function(n) {
	      $(this).trigger('carouselNext', [n]);
	    },
	    prev : function(n) {
	      $(this).trigger('carouselPrev', [n]);
	    },
	  };


	    $.fn.carousel = function(methodOrOptions) {
	      if ( methods[methodOrOptions] ) {
	        return methods[ methodOrOptions ].apply( this, Array.prototype.slice.call( arguments, 1 ));
	      } else if ( typeof methodOrOptions === 'object' || ! methodOrOptions ) {
	        // Default to "init"
	        return methods.init.apply( this, arguments );
	      } else {
	        $.error( 'Method ' +  methodOrOptions + ' does not exist on jQuery.carousel' );
	      }
	    }; // Plugin end
	}( jQuery ));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8), __webpack_require__(8)))

/***/ },
/* 10 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
	 * http://hammerjs.github.io/
	 *
	 * Copyright (c) 2016 Jorik Tangelder;
	 * Licensed under the MIT license */
	(function(window, document, exportName, undefined) {
	  'use strict';

	var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
	var TEST_ELEMENT = document.createElement('div');

	var TYPE_FUNCTION = 'function';

	var round = Math.round;
	var abs = Math.abs;
	var now = Date.now;

	/**
	 * set a timeout with a given scope
	 * @param {Function} fn
	 * @param {Number} timeout
	 * @param {Object} context
	 * @returns {number}
	 */
	function setTimeoutContext(fn, timeout, context) {
	    return setTimeout(bindFn(fn, context), timeout);
	}

	/**
	 * if the argument is an array, we want to execute the fn on each entry
	 * if it aint an array we don't want to do a thing.
	 * this is used by all the methods that accept a single and array argument.
	 * @param {*|Array} arg
	 * @param {String} fn
	 * @param {Object} [context]
	 * @returns {Boolean}
	 */
	function invokeArrayArg(arg, fn, context) {
	    if (Array.isArray(arg)) {
	        each(arg, context[fn], context);
	        return true;
	    }
	    return false;
	}

	/**
	 * walk objects and arrays
	 * @param {Object} obj
	 * @param {Function} iterator
	 * @param {Object} context
	 */
	function each(obj, iterator, context) {
	    var i;

	    if (!obj) {
	        return;
	    }

	    if (obj.forEach) {
	        obj.forEach(iterator, context);
	    } else if (obj.length !== undefined) {
	        i = 0;
	        while (i < obj.length) {
	            iterator.call(context, obj[i], i, obj);
	            i++;
	        }
	    } else {
	        for (i in obj) {
	            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
	        }
	    }
	}

	/**
	 * wrap a method with a deprecation warning and stack trace
	 * @param {Function} method
	 * @param {String} name
	 * @param {String} message
	 * @returns {Function} A new function wrapping the supplied method.
	 */
	function deprecate(method, name, message) {
	    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
	    return function() {
	        var e = new Error('get-stack-trace');
	        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
	            .replace(/^\s+at\s+/gm, '')
	            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

	        var log = window.console && (window.console.warn || window.console.log);
	        if (log) {
	            log.call(window.console, deprecationMessage, stack);
	        }
	        return method.apply(this, arguments);
	    };
	}

	/**
	 * extend object.
	 * means that properties in dest will be overwritten by the ones in src.
	 * @param {Object} target
	 * @param {...Object} objects_to_assign
	 * @returns {Object} target
	 */
	var assign;
	if (typeof Object.assign !== 'function') {
	    assign = function assign(target) {
	        if (target === undefined || target === null) {
	            throw new TypeError('Cannot convert undefined or null to object');
	        }

	        var output = Object(target);
	        for (var index = 1; index < arguments.length; index++) {
	            var source = arguments[index];
	            if (source !== undefined && source !== null) {
	                for (var nextKey in source) {
	                    if (source.hasOwnProperty(nextKey)) {
	                        output[nextKey] = source[nextKey];
	                    }
	                }
	            }
	        }
	        return output;
	    };
	} else {
	    assign = Object.assign;
	}

	/**
	 * extend object.
	 * means that properties in dest will be overwritten by the ones in src.
	 * @param {Object} dest
	 * @param {Object} src
	 * @param {Boolean} [merge=false]
	 * @returns {Object} dest
	 */
	var extend = deprecate(function extend(dest, src, merge) {
	    var keys = Object.keys(src);
	    var i = 0;
	    while (i < keys.length) {
	        if (!merge || (merge && dest[keys[i]] === undefined)) {
	            dest[keys[i]] = src[keys[i]];
	        }
	        i++;
	    }
	    return dest;
	}, 'extend', 'Use `assign`.');

	/**
	 * merge the values from src in the dest.
	 * means that properties that exist in dest will not be overwritten by src
	 * @param {Object} dest
	 * @param {Object} src
	 * @returns {Object} dest
	 */
	var merge = deprecate(function merge(dest, src) {
	    return extend(dest, src, true);
	}, 'merge', 'Use `assign`.');

	/**
	 * simple class inheritance
	 * @param {Function} child
	 * @param {Function} base
	 * @param {Object} [properties]
	 */
	function inherit(child, base, properties) {
	    var baseP = base.prototype,
	        childP;

	    childP = child.prototype = Object.create(baseP);
	    childP.constructor = child;
	    childP._super = baseP;

	    if (properties) {
	        assign(childP, properties);
	    }
	}

	/**
	 * simple function bind
	 * @param {Function} fn
	 * @param {Object} context
	 * @returns {Function}
	 */
	function bindFn(fn, context) {
	    return function boundFn() {
	        return fn.apply(context, arguments);
	    };
	}

	/**
	 * let a boolean value also be a function that must return a boolean
	 * this first item in args will be used as the context
	 * @param {Boolean|Function} val
	 * @param {Array} [args]
	 * @returns {Boolean}
	 */
	function boolOrFn(val, args) {
	    if (typeof val == TYPE_FUNCTION) {
	        return val.apply(args ? args[0] || undefined : undefined, args);
	    }
	    return val;
	}

	/**
	 * use the val2 when val1 is undefined
	 * @param {*} val1
	 * @param {*} val2
	 * @returns {*}
	 */
	function ifUndefined(val1, val2) {
	    return (val1 === undefined) ? val2 : val1;
	}

	/**
	 * addEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function addEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.addEventListener(type, handler, false);
	    });
	}

	/**
	 * removeEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function removeEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.removeEventListener(type, handler, false);
	    });
	}

	/**
	 * find if a node is in the given parent
	 * @method hasParent
	 * @param {HTMLElement} node
	 * @param {HTMLElement} parent
	 * @return {Boolean} found
	 */
	function hasParent(node, parent) {
	    while (node) {
	        if (node == parent) {
	            return true;
	        }
	        node = node.parentNode;
	    }
	    return false;
	}

	/**
	 * small indexOf wrapper
	 * @param {String} str
	 * @param {String} find
	 * @returns {Boolean} found
	 */
	function inStr(str, find) {
	    return str.indexOf(find) > -1;
	}

	/**
	 * split string on whitespace
	 * @param {String} str
	 * @returns {Array} words
	 */
	function splitStr(str) {
	    return str.trim().split(/\s+/g);
	}

	/**
	 * find if a array contains the object using indexOf or a simple polyFill
	 * @param {Array} src
	 * @param {String} find
	 * @param {String} [findByKey]
	 * @return {Boolean|Number} false when not found, or the index
	 */
	function inArray(src, find, findByKey) {
	    if (src.indexOf && !findByKey) {
	        return src.indexOf(find);
	    } else {
	        var i = 0;
	        while (i < src.length) {
	            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
	                return i;
	            }
	            i++;
	        }
	        return -1;
	    }
	}

	/**
	 * convert array-like objects to real arrays
	 * @param {Object} obj
	 * @returns {Array}
	 */
	function toArray(obj) {
	    return Array.prototype.slice.call(obj, 0);
	}

	/**
	 * unique array with objects based on a key (like 'id') or just by the array's value
	 * @param {Array} src [{id:1},{id:2},{id:1}]
	 * @param {String} [key]
	 * @param {Boolean} [sort=False]
	 * @returns {Array} [{id:1},{id:2}]
	 */
	function uniqueArray(src, key, sort) {
	    var results = [];
	    var values = [];
	    var i = 0;

	    while (i < src.length) {
	        var val = key ? src[i][key] : src[i];
	        if (inArray(values, val) < 0) {
	            results.push(src[i]);
	        }
	        values[i] = val;
	        i++;
	    }

	    if (sort) {
	        if (!key) {
	            results = results.sort();
	        } else {
	            results = results.sort(function sortUniqueArray(a, b) {
	                return a[key] > b[key];
	            });
	        }
	    }

	    return results;
	}

	/**
	 * get the prefixed property
	 * @param {Object} obj
	 * @param {String} property
	 * @returns {String|Undefined} prefixed
	 */
	function prefixed(obj, property) {
	    var prefix, prop;
	    var camelProp = property[0].toUpperCase() + property.slice(1);

	    var i = 0;
	    while (i < VENDOR_PREFIXES.length) {
	        prefix = VENDOR_PREFIXES[i];
	        prop = (prefix) ? prefix + camelProp : property;

	        if (prop in obj) {
	            return prop;
	        }
	        i++;
	    }
	    return undefined;
	}

	/**
	 * get a unique id
	 * @returns {number} uniqueId
	 */
	var _uniqueId = 1;
	function uniqueId() {
	    return _uniqueId++;
	}

	/**
	 * get the window object of an element
	 * @param {HTMLElement} element
	 * @returns {DocumentView|Window}
	 */
	function getWindowForElement(element) {
	    var doc = element.ownerDocument || element;
	    return (doc.defaultView || doc.parentWindow || window);
	}

	var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

	var SUPPORT_TOUCH = ('ontouchstart' in window);
	var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
	var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

	var INPUT_TYPE_TOUCH = 'touch';
	var INPUT_TYPE_PEN = 'pen';
	var INPUT_TYPE_MOUSE = 'mouse';
	var INPUT_TYPE_KINECT = 'kinect';

	var COMPUTE_INTERVAL = 25;

	var INPUT_START = 1;
	var INPUT_MOVE = 2;
	var INPUT_END = 4;
	var INPUT_CANCEL = 8;

	var DIRECTION_NONE = 1;
	var DIRECTION_LEFT = 2;
	var DIRECTION_RIGHT = 4;
	var DIRECTION_UP = 8;
	var DIRECTION_DOWN = 16;

	var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
	var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
	var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

	var PROPS_XY = ['x', 'y'];
	var PROPS_CLIENT_XY = ['clientX', 'clientY'];

	/**
	 * create new input type manager
	 * @param {Manager} manager
	 * @param {Function} callback
	 * @returns {Input}
	 * @constructor
	 */
	function Input(manager, callback) {
	    var self = this;
	    this.manager = manager;
	    this.callback = callback;
	    this.element = manager.element;
	    this.target = manager.options.inputTarget;

	    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
	    // so when disabled the input events are completely bypassed.
	    this.domHandler = function(ev) {
	        if (boolOrFn(manager.options.enable, [manager])) {
	            self.handler(ev);
	        }
	    };

	    this.init();

	}

	Input.prototype = {
	    /**
	     * should handle the inputEvent data and trigger the callback
	     * @virtual
	     */
	    handler: function() { },

	    /**
	     * bind the events
	     */
	    init: function() {
	        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    },

	    /**
	     * unbind the events
	     */
	    destroy: function() {
	        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    }
	};

	/**
	 * create new input type manager
	 * called by the Manager constructor
	 * @param {Hammer} manager
	 * @returns {Input}
	 */
	function createInputInstance(manager) {
	    var Type;
	    var inputClass = manager.options.inputClass;

	    if (inputClass) {
	        Type = inputClass;
	    } else if (SUPPORT_POINTER_EVENTS) {
	        Type = PointerEventInput;
	    } else if (SUPPORT_ONLY_TOUCH) {
	        Type = TouchInput;
	    } else if (!SUPPORT_TOUCH) {
	        Type = MouseInput;
	    } else {
	        Type = TouchMouseInput;
	    }
	    return new (Type)(manager, inputHandler);
	}

	/**
	 * handle input events
	 * @param {Manager} manager
	 * @param {String} eventType
	 * @param {Object} input
	 */
	function inputHandler(manager, eventType, input) {
	    var pointersLen = input.pointers.length;
	    var changedPointersLen = input.changedPointers.length;
	    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
	    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

	    input.isFirst = !!isFirst;
	    input.isFinal = !!isFinal;

	    if (isFirst) {
	        manager.session = {};
	    }

	    // source event is the normalized value of the domEvents
	    // like 'touchstart, mouseup, pointerdown'
	    input.eventType = eventType;

	    // compute scale, rotation etc
	    computeInputData(manager, input);

	    // emit secret event
	    manager.emit('hammer.input', input);

	    manager.recognize(input);
	    manager.session.prevInput = input;
	}

	/**
	 * extend the data with some usable properties like scale, rotate, velocity etc
	 * @param {Object} manager
	 * @param {Object} input
	 */
	function computeInputData(manager, input) {
	    var session = manager.session;
	    var pointers = input.pointers;
	    var pointersLength = pointers.length;

	    // store the first input to calculate the distance and direction
	    if (!session.firstInput) {
	        session.firstInput = simpleCloneInputData(input);
	    }

	    // to compute scale and rotation we need to store the multiple touches
	    if (pointersLength > 1 && !session.firstMultiple) {
	        session.firstMultiple = simpleCloneInputData(input);
	    } else if (pointersLength === 1) {
	        session.firstMultiple = false;
	    }

	    var firstInput = session.firstInput;
	    var firstMultiple = session.firstMultiple;
	    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

	    var center = input.center = getCenter(pointers);
	    input.timeStamp = now();
	    input.deltaTime = input.timeStamp - firstInput.timeStamp;

	    input.angle = getAngle(offsetCenter, center);
	    input.distance = getDistance(offsetCenter, center);

	    computeDeltaXY(session, input);
	    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

	    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
	    input.overallVelocityX = overallVelocity.x;
	    input.overallVelocityY = overallVelocity.y;
	    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

	    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
	    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

	    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
	        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

	    computeIntervalInputData(session, input);

	    // find the correct target
	    var target = manager.element;
	    if (hasParent(input.srcEvent.target, target)) {
	        target = input.srcEvent.target;
	    }
	    input.target = target;
	}

	function computeDeltaXY(session, input) {
	    var center = input.center;
	    var offset = session.offsetDelta || {};
	    var prevDelta = session.prevDelta || {};
	    var prevInput = session.prevInput || {};

	    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
	        prevDelta = session.prevDelta = {
	            x: prevInput.deltaX || 0,
	            y: prevInput.deltaY || 0
	        };

	        offset = session.offsetDelta = {
	            x: center.x,
	            y: center.y
	        };
	    }

	    input.deltaX = prevDelta.x + (center.x - offset.x);
	    input.deltaY = prevDelta.y + (center.y - offset.y);
	}

	/**
	 * velocity is calculated every x ms
	 * @param {Object} session
	 * @param {Object} input
	 */
	function computeIntervalInputData(session, input) {
	    var last = session.lastInterval || input,
	        deltaTime = input.timeStamp - last.timeStamp,
	        velocity, velocityX, velocityY, direction;

	    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
	        var deltaX = input.deltaX - last.deltaX;
	        var deltaY = input.deltaY - last.deltaY;

	        var v = getVelocity(deltaTime, deltaX, deltaY);
	        velocityX = v.x;
	        velocityY = v.y;
	        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
	        direction = getDirection(deltaX, deltaY);

	        session.lastInterval = input;
	    } else {
	        // use latest velocity info if it doesn't overtake a minimum period
	        velocity = last.velocity;
	        velocityX = last.velocityX;
	        velocityY = last.velocityY;
	        direction = last.direction;
	    }

	    input.velocity = velocity;
	    input.velocityX = velocityX;
	    input.velocityY = velocityY;
	    input.direction = direction;
	}

	/**
	 * create a simple clone from the input used for storage of firstInput and firstMultiple
	 * @param {Object} input
	 * @returns {Object} clonedInputData
	 */
	function simpleCloneInputData(input) {
	    // make a simple copy of the pointers because we will get a reference if we don't
	    // we only need clientXY for the calculations
	    var pointers = [];
	    var i = 0;
	    while (i < input.pointers.length) {
	        pointers[i] = {
	            clientX: round(input.pointers[i].clientX),
	            clientY: round(input.pointers[i].clientY)
	        };
	        i++;
	    }

	    return {
	        timeStamp: now(),
	        pointers: pointers,
	        center: getCenter(pointers),
	        deltaX: input.deltaX,
	        deltaY: input.deltaY
	    };
	}

	/**
	 * get the center of all the pointers
	 * @param {Array} pointers
	 * @return {Object} center contains `x` and `y` properties
	 */
	function getCenter(pointers) {
	    var pointersLength = pointers.length;

	    // no need to loop when only one touch
	    if (pointersLength === 1) {
	        return {
	            x: round(pointers[0].clientX),
	            y: round(pointers[0].clientY)
	        };
	    }

	    var x = 0, y = 0, i = 0;
	    while (i < pointersLength) {
	        x += pointers[i].clientX;
	        y += pointers[i].clientY;
	        i++;
	    }

	    return {
	        x: round(x / pointersLength),
	        y: round(y / pointersLength)
	    };
	}

	/**
	 * calculate the velocity between two points. unit is in px per ms.
	 * @param {Number} deltaTime
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Object} velocity `x` and `y`
	 */
	function getVelocity(deltaTime, x, y) {
	    return {
	        x: x / deltaTime || 0,
	        y: y / deltaTime || 0
	    };
	}

	/**
	 * get the direction between two points
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Number} direction
	 */
	function getDirection(x, y) {
	    if (x === y) {
	        return DIRECTION_NONE;
	    }

	    if (abs(x) >= abs(y)) {
	        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
	    }
	    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
	}

	/**
	 * calculate the absolute distance between two points
	 * @param {Object} p1 {x, y}
	 * @param {Object} p2 {x, y}
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} distance
	 */
	function getDistance(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];

	    return Math.sqrt((x * x) + (y * y));
	}

	/**
	 * calculate the angle between two coordinates
	 * @param {Object} p1
	 * @param {Object} p2
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} angle
	 */
	function getAngle(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];
	    return Math.atan2(y, x) * 180 / Math.PI;
	}

	/**
	 * calculate the rotation degrees between two pointersets
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} rotation
	 */
	function getRotation(start, end) {
	    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
	}

	/**
	 * calculate the scale factor between two pointersets
	 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} scale
	 */
	function getScale(start, end) {
	    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
	}

	var MOUSE_INPUT_MAP = {
	    mousedown: INPUT_START,
	    mousemove: INPUT_MOVE,
	    mouseup: INPUT_END
	};

	var MOUSE_ELEMENT_EVENTS = 'mousedown';
	var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

	/**
	 * Mouse events input
	 * @constructor
	 * @extends Input
	 */
	function MouseInput() {
	    this.evEl = MOUSE_ELEMENT_EVENTS;
	    this.evWin = MOUSE_WINDOW_EVENTS;

	    this.pressed = false; // mousedown state

	    Input.apply(this, arguments);
	}

	inherit(MouseInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function MEhandler(ev) {
	        var eventType = MOUSE_INPUT_MAP[ev.type];

	        // on start we want to have the left mouse button down
	        if (eventType & INPUT_START && ev.button === 0) {
	            this.pressed = true;
	        }

	        if (eventType & INPUT_MOVE && ev.which !== 1) {
	            eventType = INPUT_END;
	        }

	        // mouse must be down
	        if (!this.pressed) {
	            return;
	        }

	        if (eventType & INPUT_END) {
	            this.pressed = false;
	        }

	        this.callback(this.manager, eventType, {
	            pointers: [ev],
	            changedPointers: [ev],
	            pointerType: INPUT_TYPE_MOUSE,
	            srcEvent: ev
	        });
	    }
	});

	var POINTER_INPUT_MAP = {
	    pointerdown: INPUT_START,
	    pointermove: INPUT_MOVE,
	    pointerup: INPUT_END,
	    pointercancel: INPUT_CANCEL,
	    pointerout: INPUT_CANCEL
	};

	// in IE10 the pointer types is defined as an enum
	var IE10_POINTER_TYPE_ENUM = {
	    2: INPUT_TYPE_TOUCH,
	    3: INPUT_TYPE_PEN,
	    4: INPUT_TYPE_MOUSE,
	    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
	};

	var POINTER_ELEMENT_EVENTS = 'pointerdown';
	var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

	// IE10 has prefixed support, and case-sensitive
	if (window.MSPointerEvent && !window.PointerEvent) {
	    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
	    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
	}

	/**
	 * Pointer events input
	 * @constructor
	 * @extends Input
	 */
	function PointerEventInput() {
	    this.evEl = POINTER_ELEMENT_EVENTS;
	    this.evWin = POINTER_WINDOW_EVENTS;

	    Input.apply(this, arguments);

	    this.store = (this.manager.session.pointerEvents = []);
	}

	inherit(PointerEventInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function PEhandler(ev) {
	        var store = this.store;
	        var removePointer = false;

	        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
	        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
	        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

	        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

	        // get index of the event in the store
	        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

	        // start and mouse must be down
	        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
	            if (storeIndex < 0) {
	                store.push(ev);
	                storeIndex = store.length - 1;
	            }
	        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	            removePointer = true;
	        }

	        // it not found, so the pointer hasn't been down (so it's probably a hover)
	        if (storeIndex < 0) {
	            return;
	        }

	        // update the event in the store
	        store[storeIndex] = ev;

	        this.callback(this.manager, eventType, {
	            pointers: store,
	            changedPointers: [ev],
	            pointerType: pointerType,
	            srcEvent: ev
	        });

	        if (removePointer) {
	            // remove from the store
	            store.splice(storeIndex, 1);
	        }
	    }
	});

	var SINGLE_TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};

	var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
	var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

	/**
	 * Touch events input
	 * @constructor
	 * @extends Input
	 */
	function SingleTouchInput() {
	    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
	    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
	    this.started = false;

	    Input.apply(this, arguments);
	}

	inherit(SingleTouchInput, Input, {
	    handler: function TEhandler(ev) {
	        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

	        // should we handle the touch events?
	        if (type === INPUT_START) {
	            this.started = true;
	        }

	        if (!this.started) {
	            return;
	        }

	        var touches = normalizeSingleTouches.call(this, ev, type);

	        // when done, reset the started state
	        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
	            this.started = false;
	        }

	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});

	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function normalizeSingleTouches(ev, type) {
	    var all = toArray(ev.touches);
	    var changed = toArray(ev.changedTouches);

	    if (type & (INPUT_END | INPUT_CANCEL)) {
	        all = uniqueArray(all.concat(changed), 'identifier', true);
	    }

	    return [all, changed];
	}

	var TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};

	var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

	/**
	 * Multi-user touch events input
	 * @constructor
	 * @extends Input
	 */
	function TouchInput() {
	    this.evTarget = TOUCH_TARGET_EVENTS;
	    this.targetIds = {};

	    Input.apply(this, arguments);
	}

	inherit(TouchInput, Input, {
	    handler: function MTEhandler(ev) {
	        var type = TOUCH_INPUT_MAP[ev.type];
	        var touches = getTouches.call(this, ev, type);
	        if (!touches) {
	            return;
	        }

	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});

	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function getTouches(ev, type) {
	    var allTouches = toArray(ev.touches);
	    var targetIds = this.targetIds;

	    // when there is only one touch, the process can be simplified
	    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
	        targetIds[allTouches[0].identifier] = true;
	        return [allTouches, allTouches];
	    }

	    var i,
	        targetTouches,
	        changedTouches = toArray(ev.changedTouches),
	        changedTargetTouches = [],
	        target = this.target;

	    // get target touches from touches
	    targetTouches = allTouches.filter(function(touch) {
	        return hasParent(touch.target, target);
	    });

	    // collect touches
	    if (type === INPUT_START) {
	        i = 0;
	        while (i < targetTouches.length) {
	            targetIds[targetTouches[i].identifier] = true;
	            i++;
	        }
	    }

	    // filter changed touches to only contain touches that exist in the collected target ids
	    i = 0;
	    while (i < changedTouches.length) {
	        if (targetIds[changedTouches[i].identifier]) {
	            changedTargetTouches.push(changedTouches[i]);
	        }

	        // cleanup removed touches
	        if (type & (INPUT_END | INPUT_CANCEL)) {
	            delete targetIds[changedTouches[i].identifier];
	        }
	        i++;
	    }

	    if (!changedTargetTouches.length) {
	        return;
	    }

	    return [
	        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
	        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
	        changedTargetTouches
	    ];
	}

	/**
	 * Combined touch and mouse input
	 *
	 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
	 * This because touch devices also emit mouse events while doing a touch.
	 *
	 * @constructor
	 * @extends Input
	 */

	var DEDUP_TIMEOUT = 2500;
	var DEDUP_DISTANCE = 25;

	function TouchMouseInput() {
	    Input.apply(this, arguments);

	    var handler = bindFn(this.handler, this);
	    this.touch = new TouchInput(this.manager, handler);
	    this.mouse = new MouseInput(this.manager, handler);

	    this.primaryTouch = null;
	    this.lastTouches = [];
	}

	inherit(TouchMouseInput, Input, {
	    /**
	     * handle mouse and touch events
	     * @param {Hammer} manager
	     * @param {String} inputEvent
	     * @param {Object} inputData
	     */
	    handler: function TMEhandler(manager, inputEvent, inputData) {
	        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
	            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

	        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
	            return;
	        }

	        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
	        if (isTouch) {
	            recordTouches.call(this, inputEvent, inputData);
	        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
	            return;
	        }

	        this.callback(manager, inputEvent, inputData);
	    },

	    /**
	     * remove the event listeners
	     */
	    destroy: function destroy() {
	        this.touch.destroy();
	        this.mouse.destroy();
	    }
	});

	function recordTouches(eventType, eventData) {
	    if (eventType & INPUT_START) {
	        this.primaryTouch = eventData.changedPointers[0].identifier;
	        setLastTouch.call(this, eventData);
	    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	        setLastTouch.call(this, eventData);
	    }
	}

	function setLastTouch(eventData) {
	    var touch = eventData.changedPointers[0];

	    if (touch.identifier === this.primaryTouch) {
	        var lastTouch = {x: touch.clientX, y: touch.clientY};
	        this.lastTouches.push(lastTouch);
	        var lts = this.lastTouches;
	        var removeLastTouch = function() {
	            var i = lts.indexOf(lastTouch);
	            if (i > -1) {
	                lts.splice(i, 1);
	            }
	        };
	        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
	    }
	}

	function isSyntheticEvent(eventData) {
	    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
	    for (var i = 0; i < this.lastTouches.length; i++) {
	        var t = this.lastTouches[i];
	        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
	        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
	            return true;
	        }
	    }
	    return false;
	}

	var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
	var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

	// magical touchAction value
	var TOUCH_ACTION_COMPUTE = 'compute';
	var TOUCH_ACTION_AUTO = 'auto';
	var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
	var TOUCH_ACTION_NONE = 'none';
	var TOUCH_ACTION_PAN_X = 'pan-x';
	var TOUCH_ACTION_PAN_Y = 'pan-y';
	var TOUCH_ACTION_MAP = getTouchActionProps();

	/**
	 * Touch Action
	 * sets the touchAction property or uses the js alternative
	 * @param {Manager} manager
	 * @param {String} value
	 * @constructor
	 */
	function TouchAction(manager, value) {
	    this.manager = manager;
	    this.set(value);
	}

	TouchAction.prototype = {
	    /**
	     * set the touchAction value on the element or enable the polyfill
	     * @param {String} value
	     */
	    set: function(value) {
	        // find out the touch-action by the event handlers
	        if (value == TOUCH_ACTION_COMPUTE) {
	            value = this.compute();
	        }

	        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
	            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
	        }
	        this.actions = value.toLowerCase().trim();
	    },

	    /**
	     * just re-set the touchAction value
	     */
	    update: function() {
	        this.set(this.manager.options.touchAction);
	    },

	    /**
	     * compute the value for the touchAction property based on the recognizer's settings
	     * @returns {String} value
	     */
	    compute: function() {
	        var actions = [];
	        each(this.manager.recognizers, function(recognizer) {
	            if (boolOrFn(recognizer.options.enable, [recognizer])) {
	                actions = actions.concat(recognizer.getTouchAction());
	            }
	        });
	        return cleanTouchActions(actions.join(' '));
	    },

	    /**
	     * this method is called on each input cycle and provides the preventing of the browser behavior
	     * @param {Object} input
	     */
	    preventDefaults: function(input) {
	        var srcEvent = input.srcEvent;
	        var direction = input.offsetDirection;

	        // if the touch action did prevented once this session
	        if (this.manager.session.prevented) {
	            srcEvent.preventDefault();
	            return;
	        }

	        var actions = this.actions;
	        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
	        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
	        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

	        if (hasNone) {
	            //do not prevent defaults if this is a tap gesture

	            var isTapPointer = input.pointers.length === 1;
	            var isTapMovement = input.distance < 2;
	            var isTapTouchTime = input.deltaTime < 250;

	            if (isTapPointer && isTapMovement && isTapTouchTime) {
	                return;
	            }
	        }

	        if (hasPanX && hasPanY) {
	            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
	            return;
	        }

	        if (hasNone ||
	            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
	            (hasPanX && direction & DIRECTION_VERTICAL)) {
	            return this.preventSrc(srcEvent);
	        }
	    },

	    /**
	     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
	     * @param {Object} srcEvent
	     */
	    preventSrc: function(srcEvent) {
	        this.manager.session.prevented = true;
	        srcEvent.preventDefault();
	    }
	};

	/**
	 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
	 * @param {String} actions
	 * @returns {*}
	 */
	function cleanTouchActions(actions) {
	    // none
	    if (inStr(actions, TOUCH_ACTION_NONE)) {
	        return TOUCH_ACTION_NONE;
	    }

	    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
	    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

	    // if both pan-x and pan-y are set (different recognizers
	    // for different directions, e.g. horizontal pan but vertical swipe?)
	    // we need none (as otherwise with pan-x pan-y combined none of these
	    // recognizers will work, since the browser would handle all panning
	    if (hasPanX && hasPanY) {
	        return TOUCH_ACTION_NONE;
	    }

	    // pan-x OR pan-y
	    if (hasPanX || hasPanY) {
	        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
	    }

	    // manipulation
	    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
	        return TOUCH_ACTION_MANIPULATION;
	    }

	    return TOUCH_ACTION_AUTO;
	}

	function getTouchActionProps() {
	    if (!NATIVE_TOUCH_ACTION) {
	        return false;
	    }
	    var touchMap = {};
	    var cssSupports = window.CSS && window.CSS.supports;
	    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

	        // If css.supports is not supported but there is native touch-action assume it supports
	        // all values. This is the case for IE 10 and 11.
	        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
	    });
	    return touchMap;
	}

	/**
	 * Recognizer flow explained; *
	 * All recognizers have the initial state of POSSIBLE when a input session starts.
	 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
	 * Example session for mouse-input: mousedown -> mousemove -> mouseup
	 *
	 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
	 * which determines with state it should be.
	 *
	 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
	 * POSSIBLE to give it another change on the next cycle.
	 *
	 *               Possible
	 *                  |
	 *            +-----+---------------+
	 *            |                     |
	 *      +-----+-----+               |
	 *      |           |               |
	 *   Failed      Cancelled          |
	 *                          +-------+------+
	 *                          |              |
	 *                      Recognized       Began
	 *                                         |
	 *                                      Changed
	 *                                         |
	 *                                  Ended/Recognized
	 */
	var STATE_POSSIBLE = 1;
	var STATE_BEGAN = 2;
	var STATE_CHANGED = 4;
	var STATE_ENDED = 8;
	var STATE_RECOGNIZED = STATE_ENDED;
	var STATE_CANCELLED = 16;
	var STATE_FAILED = 32;

	/**
	 * Recognizer
	 * Every recognizer needs to extend from this class.
	 * @constructor
	 * @param {Object} options
	 */
	function Recognizer(options) {
	    this.options = assign({}, this.defaults, options || {});

	    this.id = uniqueId();

	    this.manager = null;

	    // default is enable true
	    this.options.enable = ifUndefined(this.options.enable, true);

	    this.state = STATE_POSSIBLE;

	    this.simultaneous = {};
	    this.requireFail = [];
	}

	Recognizer.prototype = {
	    /**
	     * @virtual
	     * @type {Object}
	     */
	    defaults: {},

	    /**
	     * set options
	     * @param {Object} options
	     * @return {Recognizer}
	     */
	    set: function(options) {
	        assign(this.options, options);

	        // also update the touchAction, in case something changed about the directions/enabled state
	        this.manager && this.manager.touchAction.update();
	        return this;
	    },

	    /**
	     * recognize simultaneous with an other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    recognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
	            return this;
	        }

	        var simultaneous = this.simultaneous;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (!simultaneous[otherRecognizer.id]) {
	            simultaneous[otherRecognizer.id] = otherRecognizer;
	            otherRecognizer.recognizeWith(this);
	        }
	        return this;
	    },

	    /**
	     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRecognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
	            return this;
	        }

	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        delete this.simultaneous[otherRecognizer.id];
	        return this;
	    },

	    /**
	     * recognizer can only run when an other is failing
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    requireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
	            return this;
	        }

	        var requireFail = this.requireFail;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (inArray(requireFail, otherRecognizer) === -1) {
	            requireFail.push(otherRecognizer);
	            otherRecognizer.requireFailure(this);
	        }
	        return this;
	    },

	    /**
	     * drop the requireFailure link. it does not remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRequireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
	            return this;
	        }

	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        var index = inArray(this.requireFail, otherRecognizer);
	        if (index > -1) {
	            this.requireFail.splice(index, 1);
	        }
	        return this;
	    },

	    /**
	     * has require failures boolean
	     * @returns {boolean}
	     */
	    hasRequireFailures: function() {
	        return this.requireFail.length > 0;
	    },

	    /**
	     * if the recognizer can recognize simultaneous with an other recognizer
	     * @param {Recognizer} otherRecognizer
	     * @returns {Boolean}
	     */
	    canRecognizeWith: function(otherRecognizer) {
	        return !!this.simultaneous[otherRecognizer.id];
	    },

	    /**
	     * You should use `tryEmit` instead of `emit` directly to check
	     * that all the needed recognizers has failed before emitting.
	     * @param {Object} input
	     */
	    emit: function(input) {
	        var self = this;
	        var state = this.state;

	        function emit(event) {
	            self.manager.emit(event, input);
	        }

	        // 'panstart' and 'panmove'
	        if (state < STATE_ENDED) {
	            emit(self.options.event + stateStr(state));
	        }

	        emit(self.options.event); // simple 'eventName' events

	        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
	            emit(input.additionalEvent);
	        }

	        // panend and pancancel
	        if (state >= STATE_ENDED) {
	            emit(self.options.event + stateStr(state));
	        }
	    },

	    /**
	     * Check that all the require failure recognizers has failed,
	     * if true, it emits a gesture event,
	     * otherwise, setup the state to FAILED.
	     * @param {Object} input
	     */
	    tryEmit: function(input) {
	        if (this.canEmit()) {
	            return this.emit(input);
	        }
	        // it's failing anyway
	        this.state = STATE_FAILED;
	    },

	    /**
	     * can we emit?
	     * @returns {boolean}
	     */
	    canEmit: function() {
	        var i = 0;
	        while (i < this.requireFail.length) {
	            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
	                return false;
	            }
	            i++;
	        }
	        return true;
	    },

	    /**
	     * update the recognizer
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        // make a new copy of the inputData
	        // so we can change the inputData without messing up the other recognizers
	        var inputDataClone = assign({}, inputData);

	        // is is enabled and allow recognizing?
	        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
	            this.reset();
	            this.state = STATE_FAILED;
	            return;
	        }

	        // reset when we've reached the end
	        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
	            this.state = STATE_POSSIBLE;
	        }

	        this.state = this.process(inputDataClone);

	        // the recognizer has recognized a gesture
	        // so trigger an event
	        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
	            this.tryEmit(inputDataClone);
	        }
	    },

	    /**
	     * return the state of the recognizer
	     * the actual recognizing happens in this method
	     * @virtual
	     * @param {Object} inputData
	     * @returns {Const} STATE
	     */
	    process: function(inputData) { }, // jshint ignore:line

	    /**
	     * return the preferred touch-action
	     * @virtual
	     * @returns {Array}
	     */
	    getTouchAction: function() { },

	    /**
	     * called when the gesture isn't allowed to recognize
	     * like when another is being recognized or it is disabled
	     * @virtual
	     */
	    reset: function() { }
	};

	/**
	 * get a usable string, used as event postfix
	 * @param {Const} state
	 * @returns {String} state
	 */
	function stateStr(state) {
	    if (state & STATE_CANCELLED) {
	        return 'cancel';
	    } else if (state & STATE_ENDED) {
	        return 'end';
	    } else if (state & STATE_CHANGED) {
	        return 'move';
	    } else if (state & STATE_BEGAN) {
	        return 'start';
	    }
	    return '';
	}

	/**
	 * direction cons to string
	 * @param {Const} direction
	 * @returns {String}
	 */
	function directionStr(direction) {
	    if (direction == DIRECTION_DOWN) {
	        return 'down';
	    } else if (direction == DIRECTION_UP) {
	        return 'up';
	    } else if (direction == DIRECTION_LEFT) {
	        return 'left';
	    } else if (direction == DIRECTION_RIGHT) {
	        return 'right';
	    }
	    return '';
	}

	/**
	 * get a recognizer by name if it is bound to a manager
	 * @param {Recognizer|String} otherRecognizer
	 * @param {Recognizer} recognizer
	 * @returns {Recognizer}
	 */
	function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
	    var manager = recognizer.manager;
	    if (manager) {
	        return manager.get(otherRecognizer);
	    }
	    return otherRecognizer;
	}

	/**
	 * This recognizer is just used as a base for the simple attribute recognizers.
	 * @constructor
	 * @extends Recognizer
	 */
	function AttrRecognizer() {
	    Recognizer.apply(this, arguments);
	}

	inherit(AttrRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof AttrRecognizer
	     */
	    defaults: {
	        /**
	         * @type {Number}
	         * @default 1
	         */
	        pointers: 1
	    },

	    /**
	     * Used to check if it the recognizer receives valid input, like input.distance > 10.
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {Boolean} recognized
	     */
	    attrTest: function(input) {
	        var optionPointers = this.options.pointers;
	        return optionPointers === 0 || input.pointers.length === optionPointers;
	    },

	    /**
	     * Process the input and return the state for the recognizer
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {*} State
	     */
	    process: function(input) {
	        var state = this.state;
	        var eventType = input.eventType;

	        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
	        var isValid = this.attrTest(input);

	        // on cancel input and we've recognized before, return STATE_CANCELLED
	        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
	            return state | STATE_CANCELLED;
	        } else if (isRecognized || isValid) {
	            if (eventType & INPUT_END) {
	                return state | STATE_ENDED;
	            } else if (!(state & STATE_BEGAN)) {
	                return STATE_BEGAN;
	            }
	            return state | STATE_CHANGED;
	        }
	        return STATE_FAILED;
	    }
	});

	/**
	 * Pan
	 * Recognized when the pointer is down and moved in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PanRecognizer() {
	    AttrRecognizer.apply(this, arguments);

	    this.pX = null;
	    this.pY = null;
	}

	inherit(PanRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PanRecognizer
	     */
	    defaults: {
	        event: 'pan',
	        threshold: 10,
	        pointers: 1,
	        direction: DIRECTION_ALL
	    },

	    getTouchAction: function() {
	        var direction = this.options.direction;
	        var actions = [];
	        if (direction & DIRECTION_HORIZONTAL) {
	            actions.push(TOUCH_ACTION_PAN_Y);
	        }
	        if (direction & DIRECTION_VERTICAL) {
	            actions.push(TOUCH_ACTION_PAN_X);
	        }
	        return actions;
	    },

	    directionTest: function(input) {
	        var options = this.options;
	        var hasMoved = true;
	        var distance = input.distance;
	        var direction = input.direction;
	        var x = input.deltaX;
	        var y = input.deltaY;

	        // lock to axis?
	        if (!(direction & options.direction)) {
	            if (options.direction & DIRECTION_HORIZONTAL) {
	                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
	                hasMoved = x != this.pX;
	                distance = Math.abs(input.deltaX);
	            } else {
	                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
	                hasMoved = y != this.pY;
	                distance = Math.abs(input.deltaY);
	            }
	        }
	        input.direction = direction;
	        return hasMoved && distance > options.threshold && direction & options.direction;
	    },

	    attrTest: function(input) {
	        return AttrRecognizer.prototype.attrTest.call(this, input) &&
	            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
	    },

	    emit: function(input) {

	        this.pX = input.deltaX;
	        this.pY = input.deltaY;

	        var direction = directionStr(input.direction);

	        if (direction) {
	            input.additionalEvent = this.options.event + direction;
	        }
	        this._super.emit.call(this, input);
	    }
	});

	/**
	 * Pinch
	 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PinchRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(PinchRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'pinch',
	        threshold: 0,
	        pointers: 2
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },

	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
	    },

	    emit: function(input) {
	        if (input.scale !== 1) {
	            var inOut = input.scale < 1 ? 'in' : 'out';
	            input.additionalEvent = this.options.event + inOut;
	        }
	        this._super.emit.call(this, input);
	    }
	});

	/**
	 * Press
	 * Recognized when the pointer is down for x ms without any movement.
	 * @constructor
	 * @extends Recognizer
	 */
	function PressRecognizer() {
	    Recognizer.apply(this, arguments);

	    this._timer = null;
	    this._input = null;
	}

	inherit(PressRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PressRecognizer
	     */
	    defaults: {
	        event: 'press',
	        pointers: 1,
	        time: 251, // minimal time of the pointer to be pressed
	        threshold: 9 // a minimal movement is ok, but keep it low
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_AUTO];
	    },

	    process: function(input) {
	        var options = this.options;
	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTime = input.deltaTime > options.time;

	        this._input = input;

	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
	            this.reset();
	        } else if (input.eventType & INPUT_START) {
	            this.reset();
	            this._timer = setTimeoutContext(function() {
	                this.state = STATE_RECOGNIZED;
	                this.tryEmit();
	            }, options.time, this);
	        } else if (input.eventType & INPUT_END) {
	            return STATE_RECOGNIZED;
	        }
	        return STATE_FAILED;
	    },

	    reset: function() {
	        clearTimeout(this._timer);
	    },

	    emit: function(input) {
	        if (this.state !== STATE_RECOGNIZED) {
	            return;
	        }

	        if (input && (input.eventType & INPUT_END)) {
	            this.manager.emit(this.options.event + 'up', input);
	        } else {
	            this._input.timeStamp = now();
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});

	/**
	 * Rotate
	 * Recognized when two or more pointer are moving in a circular motion.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function RotateRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(RotateRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof RotateRecognizer
	     */
	    defaults: {
	        event: 'rotate',
	        threshold: 0,
	        pointers: 2
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },

	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
	    }
	});

	/**
	 * Swipe
	 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function SwipeRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(SwipeRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof SwipeRecognizer
	     */
	    defaults: {
	        event: 'swipe',
	        threshold: 10,
	        velocity: 0.3,
	        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
	        pointers: 1
	    },

	    getTouchAction: function() {
	        return PanRecognizer.prototype.getTouchAction.call(this);
	    },

	    attrTest: function(input) {
	        var direction = this.options.direction;
	        var velocity;

	        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
	            velocity = input.overallVelocity;
	        } else if (direction & DIRECTION_HORIZONTAL) {
	            velocity = input.overallVelocityX;
	        } else if (direction & DIRECTION_VERTICAL) {
	            velocity = input.overallVelocityY;
	        }

	        return this._super.attrTest.call(this, input) &&
	            direction & input.offsetDirection &&
	            input.distance > this.options.threshold &&
	            input.maxPointers == this.options.pointers &&
	            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
	    },

	    emit: function(input) {
	        var direction = directionStr(input.offsetDirection);
	        if (direction) {
	            this.manager.emit(this.options.event + direction, input);
	        }

	        this.manager.emit(this.options.event, input);
	    }
	});

	/**
	 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
	 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
	 * a single tap.
	 *
	 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
	 * multi-taps being recognized.
	 * @constructor
	 * @extends Recognizer
	 */
	function TapRecognizer() {
	    Recognizer.apply(this, arguments);

	    // previous time and center,
	    // used for tap counting
	    this.pTime = false;
	    this.pCenter = false;

	    this._timer = null;
	    this._input = null;
	    this.count = 0;
	}

	inherit(TapRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'tap',
	        pointers: 1,
	        taps: 1,
	        interval: 300, // max time between the multi-tap taps
	        time: 250, // max time of the pointer to be down (like finger on the screen)
	        threshold: 9, // a minimal movement is ok, but keep it low
	        posThreshold: 10 // a multi-tap can be a bit off the initial position
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_MANIPULATION];
	    },

	    process: function(input) {
	        var options = this.options;

	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTouchTime = input.deltaTime < options.time;

	        this.reset();

	        if ((input.eventType & INPUT_START) && (this.count === 0)) {
	            return this.failTimeout();
	        }

	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (validMovement && validTouchTime && validPointers) {
	            if (input.eventType != INPUT_END) {
	                return this.failTimeout();
	            }

	            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
	            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

	            this.pTime = input.timeStamp;
	            this.pCenter = input.center;

	            if (!validMultiTap || !validInterval) {
	                this.count = 1;
	            } else {
	                this.count += 1;
	            }

	            this._input = input;

	            // if tap count matches we have recognized it,
	            // else it has began recognizing...
	            var tapCount = this.count % options.taps;
	            if (tapCount === 0) {
	                // no failing requirements, immediately trigger the tap event
	                // or wait as long as the multitap interval to trigger
	                if (!this.hasRequireFailures()) {
	                    return STATE_RECOGNIZED;
	                } else {
	                    this._timer = setTimeoutContext(function() {
	                        this.state = STATE_RECOGNIZED;
	                        this.tryEmit();
	                    }, options.interval, this);
	                    return STATE_BEGAN;
	                }
	            }
	        }
	        return STATE_FAILED;
	    },

	    failTimeout: function() {
	        this._timer = setTimeoutContext(function() {
	            this.state = STATE_FAILED;
	        }, this.options.interval, this);
	        return STATE_FAILED;
	    },

	    reset: function() {
	        clearTimeout(this._timer);
	    },

	    emit: function() {
	        if (this.state == STATE_RECOGNIZED) {
	            this._input.tapCount = this.count;
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});

	/**
	 * Simple way to create a manager with a default set of recognizers.
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Hammer(element, options) {
	    options = options || {};
	    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
	    return new Manager(element, options);
	}

	/**
	 * @const {string}
	 */
	Hammer.VERSION = '2.0.7';

	/**
	 * default settings
	 * @namespace
	 */
	Hammer.defaults = {
	    /**
	     * set if DOM events are being triggered.
	     * But this is slower and unused by simple implementations, so disabled by default.
	     * @type {Boolean}
	     * @default false
	     */
	    domEvents: false,

	    /**
	     * The value for the touchAction property/fallback.
	     * When set to `compute` it will magically set the correct value based on the added recognizers.
	     * @type {String}
	     * @default compute
	     */
	    touchAction: TOUCH_ACTION_COMPUTE,

	    /**
	     * @type {Boolean}
	     * @default true
	     */
	    enable: true,

	    /**
	     * EXPERIMENTAL FEATURE -- can be removed/changed
	     * Change the parent input target element.
	     * If Null, then it is being set the to main element.
	     * @type {Null|EventTarget}
	     * @default null
	     */
	    inputTarget: null,

	    /**
	     * force an input class
	     * @type {Null|Function}
	     * @default null
	     */
	    inputClass: null,

	    /**
	     * Default recognizer setup when calling `Hammer()`
	     * When creating a new Manager these will be skipped.
	     * @type {Array}
	     */
	    preset: [
	        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
	        [RotateRecognizer, {enable: false}],
	        [PinchRecognizer, {enable: false}, ['rotate']],
	        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
	        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
	        [TapRecognizer],
	        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
	        [PressRecognizer]
	    ],

	    /**
	     * Some CSS properties can be used to improve the working of Hammer.
	     * Add them to this method and they will be set when creating a new Manager.
	     * @namespace
	     */
	    cssProps: {
	        /**
	         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userSelect: 'none',

	        /**
	         * Disable the Windows Phone grippers when pressing an element.
	         * @type {String}
	         * @default 'none'
	         */
	        touchSelect: 'none',

	        /**
	         * Disables the default callout shown when you touch and hold a touch target.
	         * On iOS, when you touch and hold a touch target such as a link, Safari displays
	         * a callout containing information about the link. This property allows you to disable that callout.
	         * @type {String}
	         * @default 'none'
	         */
	        touchCallout: 'none',

	        /**
	         * Specifies whether zooming is enabled. Used by IE10>
	         * @type {String}
	         * @default 'none'
	         */
	        contentZooming: 'none',

	        /**
	         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userDrag: 'none',

	        /**
	         * Overrides the highlight color shown when the user taps a link or a JavaScript
	         * clickable element in iOS. This property obeys the alpha value, if specified.
	         * @type {String}
	         * @default 'rgba(0,0,0,0)'
	         */
	        tapHighlightColor: 'rgba(0,0,0,0)'
	    }
	};

	var STOP = 1;
	var FORCED_STOP = 2;

	/**
	 * Manager
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Manager(element, options) {
	    this.options = assign({}, Hammer.defaults, options || {});

	    this.options.inputTarget = this.options.inputTarget || element;

	    this.handlers = {};
	    this.session = {};
	    this.recognizers = [];
	    this.oldCssProps = {};

	    this.element = element;
	    this.input = createInputInstance(this);
	    this.touchAction = new TouchAction(this, this.options.touchAction);

	    toggleCssProps(this, true);

	    each(this.options.recognizers, function(item) {
	        var recognizer = this.add(new (item[0])(item[1]));
	        item[2] && recognizer.recognizeWith(item[2]);
	        item[3] && recognizer.requireFailure(item[3]);
	    }, this);
	}

	Manager.prototype = {
	    /**
	     * set options
	     * @param {Object} options
	     * @returns {Manager}
	     */
	    set: function(options) {
	        assign(this.options, options);

	        // Options that need a little more setup
	        if (options.touchAction) {
	            this.touchAction.update();
	        }
	        if (options.inputTarget) {
	            // Clean up existing event listeners and reinitialize
	            this.input.destroy();
	            this.input.target = options.inputTarget;
	            this.input.init();
	        }
	        return this;
	    },

	    /**
	     * stop recognizing for this session.
	     * This session will be discarded, when a new [input]start event is fired.
	     * When forced, the recognizer cycle is stopped immediately.
	     * @param {Boolean} [force]
	     */
	    stop: function(force) {
	        this.session.stopped = force ? FORCED_STOP : STOP;
	    },

	    /**
	     * run the recognizers!
	     * called by the inputHandler function on every movement of the pointers (touches)
	     * it walks through all the recognizers and tries to detect the gesture that is being made
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        var session = this.session;
	        if (session.stopped) {
	            return;
	        }

	        // run the touch-action polyfill
	        this.touchAction.preventDefaults(inputData);

	        var recognizer;
	        var recognizers = this.recognizers;

	        // this holds the recognizer that is being recognized.
	        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
	        // if no recognizer is detecting a thing, it is set to `null`
	        var curRecognizer = session.curRecognizer;

	        // reset when the last recognizer is recognized
	        // or when we're in a new session
	        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
	            curRecognizer = session.curRecognizer = null;
	        }

	        var i = 0;
	        while (i < recognizers.length) {
	            recognizer = recognizers[i];

	            // find out if we are allowed try to recognize the input for this one.
	            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
	            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
	            //      that is being recognized.
	            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
	            //      this can be setup with the `recognizeWith()` method on the recognizer.
	            if (session.stopped !== FORCED_STOP && ( // 1
	                    !curRecognizer || recognizer == curRecognizer || // 2
	                    recognizer.canRecognizeWith(curRecognizer))) { // 3
	                recognizer.recognize(inputData);
	            } else {
	                recognizer.reset();
	            }

	            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
	            // current active recognizer. but only if we don't already have an active recognizer
	            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
	                curRecognizer = session.curRecognizer = recognizer;
	            }
	            i++;
	        }
	    },

	    /**
	     * get a recognizer by its event name.
	     * @param {Recognizer|String} recognizer
	     * @returns {Recognizer|Null}
	     */
	    get: function(recognizer) {
	        if (recognizer instanceof Recognizer) {
	            return recognizer;
	        }

	        var recognizers = this.recognizers;
	        for (var i = 0; i < recognizers.length; i++) {
	            if (recognizers[i].options.event == recognizer) {
	                return recognizers[i];
	            }
	        }
	        return null;
	    },

	    /**
	     * add a recognizer to the manager
	     * existing recognizers with the same event name will be removed
	     * @param {Recognizer} recognizer
	     * @returns {Recognizer|Manager}
	     */
	    add: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'add', this)) {
	            return this;
	        }

	        // remove existing
	        var existing = this.get(recognizer.options.event);
	        if (existing) {
	            this.remove(existing);
	        }

	        this.recognizers.push(recognizer);
	        recognizer.manager = this;

	        this.touchAction.update();
	        return recognizer;
	    },

	    /**
	     * remove a recognizer by name or instance
	     * @param {Recognizer|String} recognizer
	     * @returns {Manager}
	     */
	    remove: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'remove', this)) {
	            return this;
	        }

	        recognizer = this.get(recognizer);

	        // let's make sure this recognizer exists
	        if (recognizer) {
	            var recognizers = this.recognizers;
	            var index = inArray(recognizers, recognizer);

	            if (index !== -1) {
	                recognizers.splice(index, 1);
	                this.touchAction.update();
	            }
	        }

	        return this;
	    },

	    /**
	     * bind event
	     * @param {String} events
	     * @param {Function} handler
	     * @returns {EventEmitter} this
	     */
	    on: function(events, handler) {
	        if (events === undefined) {
	            return;
	        }
	        if (handler === undefined) {
	            return;
	        }

	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            handlers[event] = handlers[event] || [];
	            handlers[event].push(handler);
	        });
	        return this;
	    },

	    /**
	     * unbind event, leave emit blank to remove all handlers
	     * @param {String} events
	     * @param {Function} [handler]
	     * @returns {EventEmitter} this
	     */
	    off: function(events, handler) {
	        if (events === undefined) {
	            return;
	        }

	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            if (!handler) {
	                delete handlers[event];
	            } else {
	                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
	            }
	        });
	        return this;
	    },

	    /**
	     * emit event to the listeners
	     * @param {String} event
	     * @param {Object} data
	     */
	    emit: function(event, data) {
	        // we also want to trigger dom events
	        if (this.options.domEvents) {
	            triggerDomEvent(event, data);
	        }

	        // no handlers, so skip it all
	        var handlers = this.handlers[event] && this.handlers[event].slice();
	        if (!handlers || !handlers.length) {
	            return;
	        }

	        data.type = event;
	        data.preventDefault = function() {
	            data.srcEvent.preventDefault();
	        };

	        var i = 0;
	        while (i < handlers.length) {
	            handlers[i](data);
	            i++;
	        }
	    },

	    /**
	     * destroy the manager and unbinds all events
	     * it doesn't unbind dom events, that is the user own responsibility
	     */
	    destroy: function() {
	        this.element && toggleCssProps(this, false);

	        this.handlers = {};
	        this.session = {};
	        this.input.destroy();
	        this.element = null;
	    }
	};

	/**
	 * add/remove the css properties as defined in manager.options.cssProps
	 * @param {Manager} manager
	 * @param {Boolean} add
	 */
	function toggleCssProps(manager, add) {
	    var element = manager.element;
	    if (!element.style) {
	        return;
	    }
	    var prop;
	    each(manager.options.cssProps, function(value, name) {
	        prop = prefixed(element.style, name);
	        if (add) {
	            manager.oldCssProps[prop] = element.style[prop];
	            element.style[prop] = value;
	        } else {
	            element.style[prop] = manager.oldCssProps[prop] || '';
	        }
	    });
	    if (!add) {
	        manager.oldCssProps = {};
	    }
	}

	/**
	 * trigger dom event
	 * @param {String} event
	 * @param {Object} data
	 */
	function triggerDomEvent(event, data) {
	    var gestureEvent = document.createEvent('Event');
	    gestureEvent.initEvent(event, true, true);
	    gestureEvent.gesture = data;
	    data.target.dispatchEvent(gestureEvent);
	}

	assign(Hammer, {
	    INPUT_START: INPUT_START,
	    INPUT_MOVE: INPUT_MOVE,
	    INPUT_END: INPUT_END,
	    INPUT_CANCEL: INPUT_CANCEL,

	    STATE_POSSIBLE: STATE_POSSIBLE,
	    STATE_BEGAN: STATE_BEGAN,
	    STATE_CHANGED: STATE_CHANGED,
	    STATE_ENDED: STATE_ENDED,
	    STATE_RECOGNIZED: STATE_RECOGNIZED,
	    STATE_CANCELLED: STATE_CANCELLED,
	    STATE_FAILED: STATE_FAILED,

	    DIRECTION_NONE: DIRECTION_NONE,
	    DIRECTION_LEFT: DIRECTION_LEFT,
	    DIRECTION_RIGHT: DIRECTION_RIGHT,
	    DIRECTION_UP: DIRECTION_UP,
	    DIRECTION_DOWN: DIRECTION_DOWN,
	    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
	    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
	    DIRECTION_ALL: DIRECTION_ALL,

	    Manager: Manager,
	    Input: Input,
	    TouchAction: TouchAction,

	    TouchInput: TouchInput,
	    MouseInput: MouseInput,
	    PointerEventInput: PointerEventInput,
	    TouchMouseInput: TouchMouseInput,
	    SingleTouchInput: SingleTouchInput,

	    Recognizer: Recognizer,
	    AttrRecognizer: AttrRecognizer,
	    Tap: TapRecognizer,
	    Pan: PanRecognizer,
	    Swipe: SwipeRecognizer,
	    Pinch: PinchRecognizer,
	    Rotate: RotateRecognizer,
	    Press: PressRecognizer,

	    on: addEventListeners,
	    off: removeEventListeners,
	    each: each,
	    merge: merge,
	    extend: extend,
	    assign: assign,
	    inherit: inherit,
	    bindFn: bindFn,
	    prefixed: prefixed
	});

	// this prevents errors when Hammer is loaded in the presence of an AMD
	//  style loader but by script tag, not by the loader.
	var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
	freeGlobal.Hammer = Hammer;

	if (true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	        return Hammer;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module != 'undefined' && module.exports) {
	    module.exports = Hammer;
	} else {
	    window[exportName] = Hammer;
	}

	})(window, document, 'Hammer');


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(13);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(35)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js?minimize!./materialize.css", function() {
				var newContent = require("!!./../../css-loader/index.js?minimize!./materialize.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(14)();
	// imports


	// module
	exports.push([module.id, ".materialize-red{background-color:#e51c23!important}.materialize-red-text{color:#e51c23!important}.materialize-red.lighten-5{background-color:#fdeaeb!important}.materialize-red-text.text-lighten-5{color:#fdeaeb!important}.materialize-red.lighten-4{background-color:#f8c1c3!important}.materialize-red-text.text-lighten-4{color:#f8c1c3!important}.materialize-red.lighten-3{background-color:#f3989b!important}.materialize-red-text.text-lighten-3{color:#f3989b!important}.materialize-red.lighten-2{background-color:#ee6e73!important}.materialize-red-text.text-lighten-2{color:#ee6e73!important}.materialize-red.lighten-1{background-color:#ea454b!important}.materialize-red-text.text-lighten-1{color:#ea454b!important}.materialize-red.darken-1{background-color:#d0181e!important}.materialize-red-text.text-darken-1{color:#d0181e!important}.materialize-red.darken-2{background-color:#b9151b!important}.materialize-red-text.text-darken-2{color:#b9151b!important}.materialize-red.darken-3{background-color:#a21318!important}.materialize-red-text.text-darken-3{color:#a21318!important}.materialize-red.darken-4{background-color:#8b1014!important}.materialize-red-text.text-darken-4{color:#8b1014!important}.red{background-color:#f44336!important}.red-text{color:#f44336!important}.red.lighten-5{background-color:#ffebee!important}.red-text.text-lighten-5{color:#ffebee!important}.red.lighten-4{background-color:#ffcdd2!important}.red-text.text-lighten-4{color:#ffcdd2!important}.red.lighten-3{background-color:#ef9a9a!important}.red-text.text-lighten-3{color:#ef9a9a!important}.red.lighten-2{background-color:#e57373!important}.red-text.text-lighten-2{color:#e57373!important}.red.lighten-1{background-color:#ef5350!important}.red-text.text-lighten-1{color:#ef5350!important}.red.darken-1{background-color:#e53935!important}.red-text.text-darken-1{color:#e53935!important}.red.darken-2{background-color:#d32f2f!important}.red-text.text-darken-2{color:#d32f2f!important}.red.darken-3{background-color:#c62828!important}.red-text.text-darken-3{color:#c62828!important}.red.darken-4{background-color:#b71c1c!important}.red-text.text-darken-4{color:#b71c1c!important}.red.accent-1{background-color:#ff8a80!important}.red-text.text-accent-1{color:#ff8a80!important}.red.accent-2{background-color:#ff5252!important}.red-text.text-accent-2{color:#ff5252!important}.red.accent-3{background-color:#ff1744!important}.red-text.text-accent-3{color:#ff1744!important}.red.accent-4{background-color:#d50000!important}.red-text.text-accent-4{color:#d50000!important}.pink{background-color:#e91e63!important}.pink-text{color:#e91e63!important}.pink.lighten-5{background-color:#fce4ec!important}.pink-text.text-lighten-5{color:#fce4ec!important}.pink.lighten-4{background-color:#f8bbd0!important}.pink-text.text-lighten-4{color:#f8bbd0!important}.pink.lighten-3{background-color:#f48fb1!important}.pink-text.text-lighten-3{color:#f48fb1!important}.pink.lighten-2{background-color:#f06292!important}.pink-text.text-lighten-2{color:#f06292!important}.pink.lighten-1{background-color:#ec407a!important}.pink-text.text-lighten-1{color:#ec407a!important}.pink.darken-1{background-color:#d81b60!important}.pink-text.text-darken-1{color:#d81b60!important}.pink.darken-2{background-color:#c2185b!important}.pink-text.text-darken-2{color:#c2185b!important}.pink.darken-3{background-color:#ad1457!important}.pink-text.text-darken-3{color:#ad1457!important}.pink.darken-4{background-color:#880e4f!important}.pink-text.text-darken-4{color:#880e4f!important}.pink.accent-1{background-color:#ff80ab!important}.pink-text.text-accent-1{color:#ff80ab!important}.pink.accent-2{background-color:#ff4081!important}.pink-text.text-accent-2{color:#ff4081!important}.pink.accent-3{background-color:#f50057!important}.pink-text.text-accent-3{color:#f50057!important}.pink.accent-4{background-color:#c51162!important}.pink-text.text-accent-4{color:#c51162!important}.purple{background-color:#9c27b0!important}.purple-text{color:#9c27b0!important}.purple.lighten-5{background-color:#f3e5f5!important}.purple-text.text-lighten-5{color:#f3e5f5!important}.purple.lighten-4{background-color:#e1bee7!important}.purple-text.text-lighten-4{color:#e1bee7!important}.purple.lighten-3{background-color:#ce93d8!important}.purple-text.text-lighten-3{color:#ce93d8!important}.purple.lighten-2{background-color:#ba68c8!important}.purple-text.text-lighten-2{color:#ba68c8!important}.purple.lighten-1{background-color:#ab47bc!important}.purple-text.text-lighten-1{color:#ab47bc!important}.purple.darken-1{background-color:#8e24aa!important}.purple-text.text-darken-1{color:#8e24aa!important}.purple.darken-2{background-color:#7b1fa2!important}.purple-text.text-darken-2{color:#7b1fa2!important}.purple.darken-3{background-color:#6a1b9a!important}.purple-text.text-darken-3{color:#6a1b9a!important}.purple.darken-4{background-color:#4a148c!important}.purple-text.text-darken-4{color:#4a148c!important}.purple.accent-1{background-color:#ea80fc!important}.purple-text.text-accent-1{color:#ea80fc!important}.purple.accent-2{background-color:#e040fb!important}.purple-text.text-accent-2{color:#e040fb!important}.purple.accent-3{background-color:#d500f9!important}.purple-text.text-accent-3{color:#d500f9!important}.purple.accent-4{background-color:#a0f!important}.purple-text.text-accent-4{color:#a0f!important}.deep-purple{background-color:#673ab7!important}.deep-purple-text{color:#673ab7!important}.deep-purple.lighten-5{background-color:#ede7f6!important}.deep-purple-text.text-lighten-5{color:#ede7f6!important}.deep-purple.lighten-4{background-color:#d1c4e9!important}.deep-purple-text.text-lighten-4{color:#d1c4e9!important}.deep-purple.lighten-3{background-color:#b39ddb!important}.deep-purple-text.text-lighten-3{color:#b39ddb!important}.deep-purple.lighten-2{background-color:#9575cd!important}.deep-purple-text.text-lighten-2{color:#9575cd!important}.deep-purple.lighten-1{background-color:#7e57c2!important}.deep-purple-text.text-lighten-1{color:#7e57c2!important}.deep-purple.darken-1{background-color:#5e35b1!important}.deep-purple-text.text-darken-1{color:#5e35b1!important}.deep-purple.darken-2{background-color:#512da8!important}.deep-purple-text.text-darken-2{color:#512da8!important}.deep-purple.darken-3{background-color:#4527a0!important}.deep-purple-text.text-darken-3{color:#4527a0!important}.deep-purple.darken-4{background-color:#311b92!important}.deep-purple-text.text-darken-4{color:#311b92!important}.deep-purple.accent-1{background-color:#b388ff!important}.deep-purple-text.text-accent-1{color:#b388ff!important}.deep-purple.accent-2{background-color:#7c4dff!important}.deep-purple-text.text-accent-2{color:#7c4dff!important}.deep-purple.accent-3{background-color:#651fff!important}.deep-purple-text.text-accent-3{color:#651fff!important}.deep-purple.accent-4{background-color:#6200ea!important}.deep-purple-text.text-accent-4{color:#6200ea!important}.indigo{background-color:#3f51b5!important}.indigo-text{color:#3f51b5!important}.indigo.lighten-5{background-color:#e8eaf6!important}.indigo-text.text-lighten-5{color:#e8eaf6!important}.indigo.lighten-4{background-color:#c5cae9!important}.indigo-text.text-lighten-4{color:#c5cae9!important}.indigo.lighten-3{background-color:#9fa8da!important}.indigo-text.text-lighten-3{color:#9fa8da!important}.indigo.lighten-2{background-color:#7986cb!important}.indigo-text.text-lighten-2{color:#7986cb!important}.indigo.lighten-1{background-color:#5c6bc0!important}.indigo-text.text-lighten-1{color:#5c6bc0!important}.indigo.darken-1{background-color:#3949ab!important}.indigo-text.text-darken-1{color:#3949ab!important}.indigo.darken-2{background-color:#303f9f!important}.indigo-text.text-darken-2{color:#303f9f!important}.indigo.darken-3{background-color:#283593!important}.indigo-text.text-darken-3{color:#283593!important}.indigo.darken-4{background-color:#1a237e!important}.indigo-text.text-darken-4{color:#1a237e!important}.indigo.accent-1{background-color:#8c9eff!important}.indigo-text.text-accent-1{color:#8c9eff!important}.indigo.accent-2{background-color:#536dfe!important}.indigo-text.text-accent-2{color:#536dfe!important}.indigo.accent-3{background-color:#3d5afe!important}.indigo-text.text-accent-3{color:#3d5afe!important}.indigo.accent-4{background-color:#304ffe!important}.indigo-text.text-accent-4{color:#304ffe!important}.blue{background-color:#2196f3!important}.blue-text{color:#2196f3!important}.blue.lighten-5{background-color:#e3f2fd!important}.blue-text.text-lighten-5{color:#e3f2fd!important}.blue.lighten-4{background-color:#bbdefb!important}.blue-text.text-lighten-4{color:#bbdefb!important}.blue.lighten-3{background-color:#90caf9!important}.blue-text.text-lighten-3{color:#90caf9!important}.blue.lighten-2{background-color:#64b5f6!important}.blue-text.text-lighten-2{color:#64b5f6!important}.blue.lighten-1{background-color:#42a5f5!important}.blue-text.text-lighten-1{color:#42a5f5!important}.blue.darken-1{background-color:#1e88e5!important}.blue-text.text-darken-1{color:#1e88e5!important}.blue.darken-2{background-color:#1976d2!important}.blue-text.text-darken-2{color:#1976d2!important}.blue.darken-3{background-color:#1565c0!important}.blue-text.text-darken-3{color:#1565c0!important}.blue.darken-4{background-color:#0d47a1!important}.blue-text.text-darken-4{color:#0d47a1!important}.blue.accent-1{background-color:#82b1ff!important}.blue-text.text-accent-1{color:#82b1ff!important}.blue.accent-2{background-color:#448aff!important}.blue-text.text-accent-2{color:#448aff!important}.blue.accent-3{background-color:#2979ff!important}.blue-text.text-accent-3{color:#2979ff!important}.blue.accent-4{background-color:#2962ff!important}.blue-text.text-accent-4{color:#2962ff!important}.light-blue{background-color:#03a9f4!important}.light-blue-text{color:#03a9f4!important}.light-blue.lighten-5{background-color:#e1f5fe!important}.light-blue-text.text-lighten-5{color:#e1f5fe!important}.light-blue.lighten-4{background-color:#b3e5fc!important}.light-blue-text.text-lighten-4{color:#b3e5fc!important}.light-blue.lighten-3{background-color:#81d4fa!important}.light-blue-text.text-lighten-3{color:#81d4fa!important}.light-blue.lighten-2{background-color:#4fc3f7!important}.light-blue-text.text-lighten-2{color:#4fc3f7!important}.light-blue.lighten-1{background-color:#29b6f6!important}.light-blue-text.text-lighten-1{color:#29b6f6!important}.light-blue.darken-1{background-color:#039be5!important}.light-blue-text.text-darken-1{color:#039be5!important}.light-blue.darken-2{background-color:#0288d1!important}.light-blue-text.text-darken-2{color:#0288d1!important}.light-blue.darken-3{background-color:#0277bd!important}.light-blue-text.text-darken-3{color:#0277bd!important}.light-blue.darken-4{background-color:#01579b!important}.light-blue-text.text-darken-4{color:#01579b!important}.light-blue.accent-1{background-color:#80d8ff!important}.light-blue-text.text-accent-1{color:#80d8ff!important}.light-blue.accent-2{background-color:#40c4ff!important}.light-blue-text.text-accent-2{color:#40c4ff!important}.light-blue.accent-3{background-color:#00b0ff!important}.light-blue-text.text-accent-3{color:#00b0ff!important}.light-blue.accent-4{background-color:#0091ea!important}.light-blue-text.text-accent-4{color:#0091ea!important}.cyan{background-color:#00bcd4!important}.cyan-text{color:#00bcd4!important}.cyan.lighten-5{background-color:#e0f7fa!important}.cyan-text.text-lighten-5{color:#e0f7fa!important}.cyan.lighten-4{background-color:#b2ebf2!important}.cyan-text.text-lighten-4{color:#b2ebf2!important}.cyan.lighten-3{background-color:#80deea!important}.cyan-text.text-lighten-3{color:#80deea!important}.cyan.lighten-2{background-color:#4dd0e1!important}.cyan-text.text-lighten-2{color:#4dd0e1!important}.cyan.lighten-1{background-color:#26c6da!important}.cyan-text.text-lighten-1{color:#26c6da!important}.cyan.darken-1{background-color:#00acc1!important}.cyan-text.text-darken-1{color:#00acc1!important}.cyan.darken-2{background-color:#0097a7!important}.cyan-text.text-darken-2{color:#0097a7!important}.cyan.darken-3{background-color:#00838f!important}.cyan-text.text-darken-3{color:#00838f!important}.cyan.darken-4{background-color:#006064!important}.cyan-text.text-darken-4{color:#006064!important}.cyan.accent-1{background-color:#84ffff!important}.cyan-text.text-accent-1{color:#84ffff!important}.cyan.accent-2{background-color:#18ffff!important}.cyan-text.text-accent-2{color:#18ffff!important}.cyan.accent-3{background-color:#00e5ff!important}.cyan-text.text-accent-3{color:#00e5ff!important}.cyan.accent-4{background-color:#00b8d4!important}.cyan-text.text-accent-4{color:#00b8d4!important}.teal{background-color:#009688!important}.teal-text{color:#009688!important}.teal.lighten-5{background-color:#e0f2f1!important}.teal-text.text-lighten-5{color:#e0f2f1!important}.teal.lighten-4{background-color:#b2dfdb!important}.teal-text.text-lighten-4{color:#b2dfdb!important}.teal.lighten-3{background-color:#80cbc4!important}.teal-text.text-lighten-3{color:#80cbc4!important}.teal.lighten-2{background-color:#4db6ac!important}.teal-text.text-lighten-2{color:#4db6ac!important}.teal.lighten-1{background-color:#26a69a!important}.teal-text.text-lighten-1{color:#26a69a!important}.teal.darken-1{background-color:#00897b!important}.teal-text.text-darken-1{color:#00897b!important}.teal.darken-2{background-color:#00796b!important}.teal-text.text-darken-2{color:#00796b!important}.teal.darken-3{background-color:#00695c!important}.teal-text.text-darken-3{color:#00695c!important}.teal.darken-4{background-color:#004d40!important}.teal-text.text-darken-4{color:#004d40!important}.teal.accent-1{background-color:#a7ffeb!important}.teal-text.text-accent-1{color:#a7ffeb!important}.teal.accent-2{background-color:#64ffda!important}.teal-text.text-accent-2{color:#64ffda!important}.teal.accent-3{background-color:#1de9b6!important}.teal-text.text-accent-3{color:#1de9b6!important}.teal.accent-4{background-color:#00bfa5!important}.teal-text.text-accent-4{color:#00bfa5!important}.green{background-color:#4caf50!important}.green-text{color:#4caf50!important}.green.lighten-5{background-color:#e8f5e9!important}.green-text.text-lighten-5{color:#e8f5e9!important}.green.lighten-4{background-color:#c8e6c9!important}.green-text.text-lighten-4{color:#c8e6c9!important}.green.lighten-3{background-color:#a5d6a7!important}.green-text.text-lighten-3{color:#a5d6a7!important}.green.lighten-2{background-color:#81c784!important}.green-text.text-lighten-2{color:#81c784!important}.green.lighten-1{background-color:#66bb6a!important}.green-text.text-lighten-1{color:#66bb6a!important}.green.darken-1{background-color:#43a047!important}.green-text.text-darken-1{color:#43a047!important}.green.darken-2{background-color:#388e3c!important}.green-text.text-darken-2{color:#388e3c!important}.green.darken-3{background-color:#2e7d32!important}.green-text.text-darken-3{color:#2e7d32!important}.green.darken-4{background-color:#1b5e20!important}.green-text.text-darken-4{color:#1b5e20!important}.green.accent-1{background-color:#b9f6ca!important}.green-text.text-accent-1{color:#b9f6ca!important}.green.accent-2{background-color:#69f0ae!important}.green-text.text-accent-2{color:#69f0ae!important}.green.accent-3{background-color:#00e676!important}.green-text.text-accent-3{color:#00e676!important}.green.accent-4{background-color:#00c853!important}.green-text.text-accent-4{color:#00c853!important}.light-green{background-color:#8bc34a!important}.light-green-text{color:#8bc34a!important}.light-green.lighten-5{background-color:#f1f8e9!important}.light-green-text.text-lighten-5{color:#f1f8e9!important}.light-green.lighten-4{background-color:#dcedc8!important}.light-green-text.text-lighten-4{color:#dcedc8!important}.light-green.lighten-3{background-color:#c5e1a5!important}.light-green-text.text-lighten-3{color:#c5e1a5!important}.light-green.lighten-2{background-color:#aed581!important}.light-green-text.text-lighten-2{color:#aed581!important}.light-green.lighten-1{background-color:#9ccc65!important}.light-green-text.text-lighten-1{color:#9ccc65!important}.light-green.darken-1{background-color:#7cb342!important}.light-green-text.text-darken-1{color:#7cb342!important}.light-green.darken-2{background-color:#689f38!important}.light-green-text.text-darken-2{color:#689f38!important}.light-green.darken-3{background-color:#558b2f!important}.light-green-text.text-darken-3{color:#558b2f!important}.light-green.darken-4{background-color:#33691e!important}.light-green-text.text-darken-4{color:#33691e!important}.light-green.accent-1{background-color:#ccff90!important}.light-green-text.text-accent-1{color:#ccff90!important}.light-green.accent-2{background-color:#b2ff59!important}.light-green-text.text-accent-2{color:#b2ff59!important}.light-green.accent-3{background-color:#76ff03!important}.light-green-text.text-accent-3{color:#76ff03!important}.light-green.accent-4{background-color:#64dd17!important}.light-green-text.text-accent-4{color:#64dd17!important}.lime{background-color:#cddc39!important}.lime-text{color:#cddc39!important}.lime.lighten-5{background-color:#f9fbe7!important}.lime-text.text-lighten-5{color:#f9fbe7!important}.lime.lighten-4{background-color:#f0f4c3!important}.lime-text.text-lighten-4{color:#f0f4c3!important}.lime.lighten-3{background-color:#e6ee9c!important}.lime-text.text-lighten-3{color:#e6ee9c!important}.lime.lighten-2{background-color:#dce775!important}.lime-text.text-lighten-2{color:#dce775!important}.lime.lighten-1{background-color:#d4e157!important}.lime-text.text-lighten-1{color:#d4e157!important}.lime.darken-1{background-color:#c0ca33!important}.lime-text.text-darken-1{color:#c0ca33!important}.lime.darken-2{background-color:#afb42b!important}.lime-text.text-darken-2{color:#afb42b!important}.lime.darken-3{background-color:#9e9d24!important}.lime-text.text-darken-3{color:#9e9d24!important}.lime.darken-4{background-color:#827717!important}.lime-text.text-darken-4{color:#827717!important}.lime.accent-1{background-color:#f4ff81!important}.lime-text.text-accent-1{color:#f4ff81!important}.lime.accent-2{background-color:#eeff41!important}.lime-text.text-accent-2{color:#eeff41!important}.lime.accent-3{background-color:#c6ff00!important}.lime-text.text-accent-3{color:#c6ff00!important}.lime.accent-4{background-color:#aeea00!important}.lime-text.text-accent-4{color:#aeea00!important}.yellow{background-color:#ffeb3b!important}.yellow-text{color:#ffeb3b!important}.yellow.lighten-5{background-color:#fffde7!important}.yellow-text.text-lighten-5{color:#fffde7!important}.yellow.lighten-4{background-color:#fff9c4!important}.yellow-text.text-lighten-4{color:#fff9c4!important}.yellow.lighten-3{background-color:#fff59d!important}.yellow-text.text-lighten-3{color:#fff59d!important}.yellow.lighten-2{background-color:#fff176!important}.yellow-text.text-lighten-2{color:#fff176!important}.yellow.lighten-1{background-color:#ffee58!important}.yellow-text.text-lighten-1{color:#ffee58!important}.yellow.darken-1{background-color:#fdd835!important}.yellow-text.text-darken-1{color:#fdd835!important}.yellow.darken-2{background-color:#fbc02d!important}.yellow-text.text-darken-2{color:#fbc02d!important}.yellow.darken-3{background-color:#f9a825!important}.yellow-text.text-darken-3{color:#f9a825!important}.yellow.darken-4{background-color:#f57f17!important}.yellow-text.text-darken-4{color:#f57f17!important}.yellow.accent-1{background-color:#ffff8d!important}.yellow-text.text-accent-1{color:#ffff8d!important}.yellow.accent-2{background-color:#ff0!important}.yellow-text.text-accent-2{color:#ff0!important}.yellow.accent-3{background-color:#ffea00!important}.yellow-text.text-accent-3{color:#ffea00!important}.yellow.accent-4{background-color:#ffd600!important}.yellow-text.text-accent-4{color:#ffd600!important}.amber{background-color:#ffc107!important}.amber-text{color:#ffc107!important}.amber.lighten-5{background-color:#fff8e1!important}.amber-text.text-lighten-5{color:#fff8e1!important}.amber.lighten-4{background-color:#ffecb3!important}.amber-text.text-lighten-4{color:#ffecb3!important}.amber.lighten-3{background-color:#ffe082!important}.amber-text.text-lighten-3{color:#ffe082!important}.amber.lighten-2{background-color:#ffd54f!important}.amber-text.text-lighten-2{color:#ffd54f!important}.amber.lighten-1{background-color:#ffca28!important}.amber-text.text-lighten-1{color:#ffca28!important}.amber.darken-1{background-color:#ffb300!important}.amber-text.text-darken-1{color:#ffb300!important}.amber.darken-2{background-color:#ffa000!important}.amber-text.text-darken-2{color:#ffa000!important}.amber.darken-3{background-color:#ff8f00!important}.amber-text.text-darken-3{color:#ff8f00!important}.amber.darken-4{background-color:#ff6f00!important}.amber-text.text-darken-4{color:#ff6f00!important}.amber.accent-1{background-color:#ffe57f!important}.amber-text.text-accent-1{color:#ffe57f!important}.amber.accent-2{background-color:#ffd740!important}.amber-text.text-accent-2{color:#ffd740!important}.amber.accent-3{background-color:#ffc400!important}.amber-text.text-accent-3{color:#ffc400!important}.amber.accent-4{background-color:#ffab00!important}.amber-text.text-accent-4{color:#ffab00!important}.orange{background-color:#ff9800!important}.orange-text{color:#ff9800!important}.orange.lighten-5{background-color:#fff3e0!important}.orange-text.text-lighten-5{color:#fff3e0!important}.orange.lighten-4{background-color:#ffe0b2!important}.orange-text.text-lighten-4{color:#ffe0b2!important}.orange.lighten-3{background-color:#ffcc80!important}.orange-text.text-lighten-3{color:#ffcc80!important}.orange.lighten-2{background-color:#ffb74d!important}.orange-text.text-lighten-2{color:#ffb74d!important}.orange.lighten-1{background-color:#ffa726!important}.orange-text.text-lighten-1{color:#ffa726!important}.orange.darken-1{background-color:#fb8c00!important}.orange-text.text-darken-1{color:#fb8c00!important}.orange.darken-2{background-color:#f57c00!important}.orange-text.text-darken-2{color:#f57c00!important}.orange.darken-3{background-color:#ef6c00!important}.orange-text.text-darken-3{color:#ef6c00!important}.orange.darken-4{background-color:#e65100!important}.orange-text.text-darken-4{color:#e65100!important}.orange.accent-1{background-color:#ffd180!important}.orange-text.text-accent-1{color:#ffd180!important}.orange.accent-2{background-color:#ffab40!important}.orange-text.text-accent-2{color:#ffab40!important}.orange.accent-3{background-color:#ff9100!important}.orange-text.text-accent-3{color:#ff9100!important}.orange.accent-4{background-color:#ff6d00!important}.orange-text.text-accent-4{color:#ff6d00!important}.deep-orange{background-color:#ff5722!important}.deep-orange-text{color:#ff5722!important}.deep-orange.lighten-5{background-color:#fbe9e7!important}.deep-orange-text.text-lighten-5{color:#fbe9e7!important}.deep-orange.lighten-4{background-color:#ffccbc!important}.deep-orange-text.text-lighten-4{color:#ffccbc!important}.deep-orange.lighten-3{background-color:#ffab91!important}.deep-orange-text.text-lighten-3{color:#ffab91!important}.deep-orange.lighten-2{background-color:#ff8a65!important}.deep-orange-text.text-lighten-2{color:#ff8a65!important}.deep-orange.lighten-1{background-color:#ff7043!important}.deep-orange-text.text-lighten-1{color:#ff7043!important}.deep-orange.darken-1{background-color:#f4511e!important}.deep-orange-text.text-darken-1{color:#f4511e!important}.deep-orange.darken-2{background-color:#e64a19!important}.deep-orange-text.text-darken-2{color:#e64a19!important}.deep-orange.darken-3{background-color:#d84315!important}.deep-orange-text.text-darken-3{color:#d84315!important}.deep-orange.darken-4{background-color:#bf360c!important}.deep-orange-text.text-darken-4{color:#bf360c!important}.deep-orange.accent-1{background-color:#ff9e80!important}.deep-orange-text.text-accent-1{color:#ff9e80!important}.deep-orange.accent-2{background-color:#ff6e40!important}.deep-orange-text.text-accent-2{color:#ff6e40!important}.deep-orange.accent-3{background-color:#ff3d00!important}.deep-orange-text.text-accent-3{color:#ff3d00!important}.deep-orange.accent-4{background-color:#dd2c00!important}.deep-orange-text.text-accent-4{color:#dd2c00!important}.brown{background-color:#795548!important}.brown-text{color:#795548!important}.brown.lighten-5{background-color:#efebe9!important}.brown-text.text-lighten-5{color:#efebe9!important}.brown.lighten-4{background-color:#d7ccc8!important}.brown-text.text-lighten-4{color:#d7ccc8!important}.brown.lighten-3{background-color:#bcaaa4!important}.brown-text.text-lighten-3{color:#bcaaa4!important}.brown.lighten-2{background-color:#a1887f!important}.brown-text.text-lighten-2{color:#a1887f!important}.brown.lighten-1{background-color:#8d6e63!important}.brown-text.text-lighten-1{color:#8d6e63!important}.brown.darken-1{background-color:#6d4c41!important}.brown-text.text-darken-1{color:#6d4c41!important}.brown.darken-2{background-color:#5d4037!important}.brown-text.text-darken-2{color:#5d4037!important}.brown.darken-3{background-color:#4e342e!important}.brown-text.text-darken-3{color:#4e342e!important}.brown.darken-4{background-color:#3e2723!important}.brown-text.text-darken-4{color:#3e2723!important}.blue-grey{background-color:#607d8b!important}.blue-grey-text{color:#607d8b!important}.blue-grey.lighten-5{background-color:#eceff1!important}.blue-grey-text.text-lighten-5{color:#eceff1!important}.blue-grey.lighten-4{background-color:#cfd8dc!important}.blue-grey-text.text-lighten-4{color:#cfd8dc!important}.blue-grey.lighten-3{background-color:#b0bec5!important}.blue-grey-text.text-lighten-3{color:#b0bec5!important}.blue-grey.lighten-2{background-color:#90a4ae!important}.blue-grey-text.text-lighten-2{color:#90a4ae!important}.blue-grey.lighten-1{background-color:#78909c!important}.blue-grey-text.text-lighten-1{color:#78909c!important}.blue-grey.darken-1{background-color:#546e7a!important}.blue-grey-text.text-darken-1{color:#546e7a!important}.blue-grey.darken-2{background-color:#455a64!important}.blue-grey-text.text-darken-2{color:#455a64!important}.blue-grey.darken-3{background-color:#37474f!important}.blue-grey-text.text-darken-3{color:#37474f!important}.blue-grey.darken-4{background-color:#263238!important}.blue-grey-text.text-darken-4{color:#263238!important}.grey{background-color:#9e9e9e!important}.grey-text{color:#9e9e9e!important}.grey.lighten-5{background-color:#fafafa!important}.grey-text.text-lighten-5{color:#fafafa!important}.grey.lighten-4{background-color:#f5f5f5!important}.grey-text.text-lighten-4{color:#f5f5f5!important}.grey.lighten-3{background-color:#eee!important}.grey-text.text-lighten-3{color:#eee!important}.grey.lighten-2{background-color:#e0e0e0!important}.grey-text.text-lighten-2{color:#e0e0e0!important}.grey.lighten-1{background-color:#bdbdbd!important}.grey-text.text-lighten-1{color:#bdbdbd!important}.grey.darken-1{background-color:#757575!important}.grey-text.text-darken-1{color:#757575!important}.grey.darken-2{background-color:#616161!important}.grey-text.text-darken-2{color:#616161!important}.grey.darken-3{background-color:#424242!important}.grey-text.text-darken-3{color:#424242!important}.grey.darken-4{background-color:#212121!important}.grey-text.text-darken-4{color:#212121!important}.shades.black{background-color:#000!important}.shades-text.text-black{color:#000!important}.shades.white{background-color:#fff!important}.shades-text.text-white{color:#fff!important}.shades.transparent{background-color:transparent!important}.shades-text.text-transparent{color:transparent!important}.black{background-color:#000!important}.black-text{color:#000!important}.white{background-color:#fff!important}.white-text{color:#fff!important}.transparent{background-color:transparent!important}.transparent-text{color:transparent!important}\n/*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}html{box-sizing:border-box}*,:after,:before{box-sizing:inherit}ul{list-style-type:none}ul.browser-default{list-style-type:initial}a{color:#039be5;text-decoration:none;-webkit-tap-highlight-color:transparent}.valign-wrapper{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}.valign-wrapper .valign{display:block}ul{padding:0}ul li{list-style-type:none}.clearfix{clear:both}.z-depth-0{box-shadow:none!important}.btn,.btn-floating,.btn-large,.card,.card-panel,.collapsible,.dropdown-content,.side-nav,.toast,.z-depth-1,nav{box-shadow:0 2px 5px 0 rgba(0,0,0,.16),0 2px 10px 0 rgba(0,0,0,.12)}.btn-floating:hover,.btn-large:hover,.btn:hover,.z-depth-1-half{box-shadow:0 5px 11px 0 rgba(0,0,0,.18),0 4px 15px 0 rgba(0,0,0,.15)}.z-depth-2{box-shadow:0 8px 17px 0 rgba(0,0,0,.2),0 6px 20px 0 rgba(0,0,0,.19)}.z-depth-3{box-shadow:0 12px 15px 0 rgba(0,0,0,.24),0 17px 50px 0 rgba(0,0,0,.19)}.modal,.z-depth-4{box-shadow:0 16px 28px 0 rgba(0,0,0,.22),0 25px 55px 0 rgba(0,0,0,.21)}.z-depth-5{box-shadow:0 27px 24px 0 rgba(0,0,0,.2),0 40px 77px 0 rgba(0,0,0,.22)}.hoverable{transition:box-shadow .25s;box-shadow:0}.hoverable:hover{transition:box-shadow .25s;box-shadow:0 8px 17px 0 rgba(0,0,0,.2),0 6px 20px 0 rgba(0,0,0,.19)}.divider{height:1px;overflow:hidden;background-color:#e0e0e0}blockquote{margin:20px 0;padding-left:1.5rem;border-left:5px solid #ee6e73}i{line-height:inherit}i.left{float:left;margin-right:15px}i.right{float:right;margin-left:15px}i.tiny{font-size:1rem}i.small{font-size:2rem}i.medium{font-size:4rem}i.large{font-size:6rem}img.responsive-img,video.responsive-video{max-width:100%;height:auto}.pagination li{display:inline-block;font-size:1.2rem;padding:0 10px;line-height:30px;border-radius:2px;text-align:center}.pagination li a{color:#444}.pagination li.active a{color:#fff}.pagination li.active{background-color:#ee6e73}.pagination li.disabled a{cursor:default;color:#999}.pagination li i{font-size:2.2rem;vertical-align:middle}.pagination li.pages ul li{display:inline-block;float:none}@media only screen and (max-width:992px){.pagination{width:100%}.pagination li.next,.pagination li.prev{width:10%}.pagination li.pages{width:80%;overflow:hidden;white-space:nowrap}}.breadcrumb{font-size:18px;color:hsla(0,0%,100%,.7)}.breadcrumb [class*=mdi-],.breadcrumb [class^=mdi-],.breadcrumb i,.breadcrumb i.material-icons{display:inline-block;float:left;font-size:24px}.breadcrumb:before{content:'\\E5CC';color:hsla(0,0%,100%,.7);vertical-align:top;display:inline-block;font-family:Material Icons;font-weight:400;font-style:normal;font-size:25px;margin:0 10px 0 8px;-webkit-font-smoothing:antialiased}.breadcrumb:first-child:before{display:none}.breadcrumb:last-child{color:#fff}.parallax-container{position:relative;overflow:hidden;height:500px}.parallax{top:0;left:0;right:0;z-index:-1}.parallax,.parallax img{position:absolute;bottom:0}.parallax img{display:none;left:50%;min-width:100%;min-height:100%;-webkit-transform:translateZ(0);transform:translateZ(0);-webkit-transform:translateX(-50%);transform:translateX(-50%)}.pin-bottom,.pin-top{position:relative}.pinned{position:fixed!important}.fade-in,ul.staggered-list li{opacity:0}.fade-in{-webkit-transform-origin:0 50%;transform-origin:0 50%}@media only screen and (max-width:600px){.hide-on-small-and-down,.hide-on-small-only{display:none!important}}@media only screen and (max-width:992px){.hide-on-med-and-down{display:none!important}}@media only screen and (min-width:601px){.hide-on-med-and-up{display:none!important}}@media only screen and (min-width:600px) and (max-width:992px){.hide-on-med-only{display:none!important}}@media only screen and (min-width:993px){.hide-on-large-only{display:none!important}}@media only screen and (min-width:993px){.show-on-large{display:block!important}}@media only screen and (min-width:600px) and (max-width:992px){.show-on-medium{display:block!important}}@media only screen and (max-width:600px){.show-on-small{display:block!important}}@media only screen and (min-width:601px){.show-on-medium-and-up{display:block!important}}@media only screen and (max-width:992px){.show-on-medium-and-down{display:block!important}}@media only screen and (max-width:600px){.center-on-small-only{text-align:center}}footer.page-footer{margin-top:20px;padding-top:20px;background-color:#ee6e73}footer.page-footer .footer-copyright{overflow:hidden;height:50px;line-height:50px;color:hsla(0,0%,100%,.8);background-color:rgba(51,51,51,.08)}table,td,th{border:none}table{width:100%;display:table}table.bordered>tbody>tr,table.bordered>thead>tr{border-bottom:1px solid #d0d0d0}table.striped>tbody>tr:nth-child(odd){background-color:#f2f2f2}table.striped>tbody>tr>td{border-radius:0}table.highlight>tbody>tr{transition:background-color .25s ease}table.highlight>tbody>tr:hover{background-color:#f2f2f2}table.centered tbody tr td,table.centered thead tr th{text-align:center}thead{border-bottom:1px solid #d0d0d0}td,th{padding:15px 5px;display:table-cell;text-align:left;vertical-align:middle;border-radius:2px}@media only screen and (max-width:992px){table.responsive-table{width:100%;border-collapse:collapse;border-spacing:0;display:block;position:relative}table.responsive-table td:empty:before{content:'\\A0'}table.responsive-table td,table.responsive-table th{margin:0;vertical-align:top}table.responsive-table th{text-align:left}table.responsive-table thead{display:block;float:left}table.responsive-table thead tr{display:block;padding:0 10px 0 0}table.responsive-table thead tr th:before{content:\"\\A0\"}table.responsive-table tbody{display:block;width:auto;position:relative;overflow-x:auto;white-space:nowrap}table.responsive-table tbody tr{display:inline-block;vertical-align:top}table.responsive-table th{display:block;text-align:right}table.responsive-table td{display:block;min-height:1.25em;text-align:left}table.responsive-table tr{padding:0 10px}table.responsive-table thead{border:0;border-right:1px solid #d0d0d0}table.responsive-table.bordered th{border-bottom:0;border-left:0}table.responsive-table.bordered td{border-left:0;border-right:0;border-bottom:0}table.responsive-table.bordered tr{border:0}table.responsive-table.bordered tbody tr{border-right:1px solid #d0d0d0}}.collection{margin:.5rem 0 1rem;border:1px solid #e0e0e0;border-radius:2px;overflow:hidden;position:relative}.collection .collection-item{background-color:#fff;line-height:1.5rem;padding:10px 20px;margin:0;border-bottom:1px solid #e0e0e0}.collection .collection-item.avatar{min-height:84px;padding-left:72px;position:relative}.collection .collection-item.avatar .circle{position:absolute;width:42px;height:42px;overflow:hidden;left:15px;display:inline-block;vertical-align:middle}.collection .collection-item.avatar i.circle{font-size:18px;line-height:42px;color:#fff;background-color:#999;text-align:center}.collection .collection-item.avatar .title{font-size:16px}.collection .collection-item.avatar p{margin:0}.collection .collection-item.avatar .secondary-content{position:absolute;top:16px;right:16px}.collection .collection-item:last-child{border-bottom:none}.collection .collection-item.active{background-color:#26a69a;color:#eafaf9}.collection .collection-item.active .secondary-content{color:#fff}.collection a.collection-item{display:block;transition:.25s;color:#26a69a}.collection a.collection-item:not(.active):hover{background-color:#ddd}.collection.with-header .collection-header{background-color:#fff;border-bottom:1px solid #e0e0e0;padding:10px 20px}.collection.with-header .collection-item{padding-left:30px}.collection.with-header .collection-item.avatar{padding-left:72px}.secondary-content{float:right;color:#26a69a}.collapsible .collection{margin:0;border:none}span.badge{min-width:3rem;padding:0 6px;text-align:center;font-size:1rem;line-height:inherit;color:#757575;position:absolute;right:15px;box-sizing:border-box}span.badge.new{font-weight:300;font-size:.8rem;color:#fff;background-color:#26a69a;border-radius:2px}span.badge.new:after{content:\" new\"}nav ul a span.badge{position:static;margin-left:4px;line-height:0}.video-container{position:relative;padding-bottom:56.25%;height:0;overflow:hidden}.video-container embed,.video-container iframe,.video-container object{position:absolute;top:0;left:0;width:100%;height:100%}.progress{position:relative;height:4px;display:block;width:100%;background-color:#acece6;border-radius:2px;margin:.5rem 0 1rem;overflow:hidden}.progress .determinate{position:absolute;top:0;left:0;bottom:0;transition:width .3s linear}.progress .determinate,.progress .indeterminate{background-color:#26a69a}.progress .indeterminate:before{-webkit-animation:indeterminate 2.1s cubic-bezier(.65,.815,.735,.395) infinite;animation:indeterminate 2.1s cubic-bezier(.65,.815,.735,.395) infinite}.progress .indeterminate:after,.progress .indeterminate:before{content:'';position:absolute;background-color:inherit;top:0;left:0;bottom:0;will-change:left,right}.progress .indeterminate:after{-webkit-animation:indeterminate-short 2.1s cubic-bezier(.165,.84,.44,1) infinite;animation:indeterminate-short 2.1s cubic-bezier(.165,.84,.44,1) infinite;-webkit-animation-delay:1.15s;animation-delay:1.15s}@-webkit-keyframes indeterminate{0%{left:-35%;right:100%}60%{left:100%;right:-90%}to{left:100%;right:-90%}}@keyframes indeterminate{0%{left:-35%;right:100%}60%{left:100%;right:-90%}to{left:100%;right:-90%}}@-webkit-keyframes indeterminate-short{0%{left:-200%;right:100%}60%{left:107%;right:-8%}to{left:107%;right:-8%}}@keyframes indeterminate-short{0%{left:-200%;right:100%}60%{left:107%;right:-8%}to{left:107%;right:-8%}}.hide{display:none!important}.left-align{text-align:left}.right-align{text-align:right}.center,.center-align{text-align:center}.left{float:left!important}.right{float:right!important}.no-select,input[type=range],input[type=range]+.thumb{-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.circle{border-radius:50%}.center-block{display:block;margin-left:auto;margin-right:auto}.truncate{display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.no-padding{padding:0!important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';font-feature-settings:'liga'}.container{margin:0 auto;max-width:1280px;width:90%}@media only screen and (min-width:601px){.container{width:85%}}@media only screen and (min-width:993px){.container{width:70%}}.container .row{margin-left:-.75rem;margin-right:-.75rem}.section{padding-top:1rem;padding-bottom:1rem}.section.no-pad{padding:0}.section.no-pad-bot{padding-bottom:0}.section.no-pad-top{padding-top:0}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;box-sizing:border-box;padding:0 .75rem}.row .col[class*=pull-],.row .col[class*=push-]{position:relative}.row .col.s1{width:8.3333333333%}.row .col.s1,.row .col.s2{margin-left:auto;left:auto;right:auto}.row .col.s2{width:16.6666666667%}.row .col.s3{width:25%}.row .col.s3,.row .col.s4{margin-left:auto;left:auto;right:auto}.row .col.s4{width:33.3333333333%}.row .col.s5{width:41.6666666667%}.row .col.s5,.row .col.s6{margin-left:auto;left:auto;right:auto}.row .col.s6{width:50%}.row .col.s7{width:58.3333333333%}.row .col.s7,.row .col.s8{margin-left:auto;left:auto;right:auto}.row .col.s8{width:66.6666666667%}.row .col.s9{width:75%}.row .col.s9,.row .col.s10{margin-left:auto;left:auto;right:auto}.row .col.s10{width:83.3333333333%}.row .col.s11{width:91.6666666667%}.row .col.s11,.row .col.s12{margin-left:auto;left:auto;right:auto}.row .col.s12{width:100%}.row .col.offset-s1{margin-left:8.3333333333%}.row .col.pull-s1{right:8.3333333333%}.row .col.push-s1{left:8.3333333333%}.row .col.offset-s2{margin-left:16.6666666667%}.row .col.pull-s2{right:16.6666666667%}.row .col.push-s2{left:16.6666666667%}.row .col.offset-s3{margin-left:25%}.row .col.pull-s3{right:25%}.row .col.push-s3{left:25%}.row .col.offset-s4{margin-left:33.3333333333%}.row .col.pull-s4{right:33.3333333333%}.row .col.push-s4{left:33.3333333333%}.row .col.offset-s5{margin-left:41.6666666667%}.row .col.pull-s5{right:41.6666666667%}.row .col.push-s5{left:41.6666666667%}.row .col.offset-s6{margin-left:50%}.row .col.pull-s6{right:50%}.row .col.push-s6{left:50%}.row .col.offset-s7{margin-left:58.3333333333%}.row .col.pull-s7{right:58.3333333333%}.row .col.push-s7{left:58.3333333333%}.row .col.offset-s8{margin-left:66.6666666667%}.row .col.pull-s8{right:66.6666666667%}.row .col.push-s8{left:66.6666666667%}.row .col.offset-s9{margin-left:75%}.row .col.pull-s9{right:75%}.row .col.push-s9{left:75%}.row .col.offset-s10{margin-left:83.3333333333%}.row .col.pull-s10{right:83.3333333333%}.row .col.push-s10{left:83.3333333333%}.row .col.offset-s11{margin-left:91.6666666667%}.row .col.pull-s11{right:91.6666666667%}.row .col.push-s11{left:91.6666666667%}.row .col.offset-s12{margin-left:100%}.row .col.pull-s12{right:100%}.row .col.push-s12{left:100%}@media only screen and (min-width:601px){.row .col.m1{width:8.3333333333%}.row .col.m1,.row .col.m2{margin-left:auto;left:auto;right:auto}.row .col.m2{width:16.6666666667%}.row .col.m3{width:25%}.row .col.m3,.row .col.m4{margin-left:auto;left:auto;right:auto}.row .col.m4{width:33.3333333333%}.row .col.m5{width:41.6666666667%}.row .col.m5,.row .col.m6{margin-left:auto;left:auto;right:auto}.row .col.m6{width:50%}.row .col.m7{width:58.3333333333%}.row .col.m7,.row .col.m8{margin-left:auto;left:auto;right:auto}.row .col.m8{width:66.6666666667%}.row .col.m9{width:75%}.row .col.m9,.row .col.m10{margin-left:auto;left:auto;right:auto}.row .col.m10{width:83.3333333333%}.row .col.m11{width:91.6666666667%}.row .col.m11,.row .col.m12{margin-left:auto;left:auto;right:auto}.row .col.m12{width:100%}.row .col.offset-m1{margin-left:8.3333333333%}.row .col.pull-m1{right:8.3333333333%}.row .col.push-m1{left:8.3333333333%}.row .col.offset-m2{margin-left:16.6666666667%}.row .col.pull-m2{right:16.6666666667%}.row .col.push-m2{left:16.6666666667%}.row .col.offset-m3{margin-left:25%}.row .col.pull-m3{right:25%}.row .col.push-m3{left:25%}.row .col.offset-m4{margin-left:33.3333333333%}.row .col.pull-m4{right:33.3333333333%}.row .col.push-m4{left:33.3333333333%}.row .col.offset-m5{margin-left:41.6666666667%}.row .col.pull-m5{right:41.6666666667%}.row .col.push-m5{left:41.6666666667%}.row .col.offset-m6{margin-left:50%}.row .col.pull-m6{right:50%}.row .col.push-m6{left:50%}.row .col.offset-m7{margin-left:58.3333333333%}.row .col.pull-m7{right:58.3333333333%}.row .col.push-m7{left:58.3333333333%}.row .col.offset-m8{margin-left:66.6666666667%}.row .col.pull-m8{right:66.6666666667%}.row .col.push-m8{left:66.6666666667%}.row .col.offset-m9{margin-left:75%}.row .col.pull-m9{right:75%}.row .col.push-m9{left:75%}.row .col.offset-m10{margin-left:83.3333333333%}.row .col.pull-m10{right:83.3333333333%}.row .col.push-m10{left:83.3333333333%}.row .col.offset-m11{margin-left:91.6666666667%}.row .col.pull-m11{right:91.6666666667%}.row .col.push-m11{left:91.6666666667%}.row .col.offset-m12{margin-left:100%}.row .col.pull-m12{right:100%}.row .col.push-m12{left:100%}}@media only screen and (min-width:993px){.row .col.l1{width:8.3333333333%}.row .col.l1,.row .col.l2{margin-left:auto;left:auto;right:auto}.row .col.l2{width:16.6666666667%}.row .col.l3{width:25%}.row .col.l3,.row .col.l4{margin-left:auto;left:auto;right:auto}.row .col.l4{width:33.3333333333%}.row .col.l5{width:41.6666666667%}.row .col.l5,.row .col.l6{margin-left:auto;left:auto;right:auto}.row .col.l6{width:50%}.row .col.l7{width:58.3333333333%}.row .col.l7,.row .col.l8{margin-left:auto;left:auto;right:auto}.row .col.l8{width:66.6666666667%}.row .col.l9{width:75%}.row .col.l9,.row .col.l10{margin-left:auto;left:auto;right:auto}.row .col.l10{width:83.3333333333%}.row .col.l11{width:91.6666666667%}.row .col.l11,.row .col.l12{margin-left:auto;left:auto;right:auto}.row .col.l12{width:100%}.row .col.offset-l1{margin-left:8.3333333333%}.row .col.pull-l1{right:8.3333333333%}.row .col.push-l1{left:8.3333333333%}.row .col.offset-l2{margin-left:16.6666666667%}.row .col.pull-l2{right:16.6666666667%}.row .col.push-l2{left:16.6666666667%}.row .col.offset-l3{margin-left:25%}.row .col.pull-l3{right:25%}.row .col.push-l3{left:25%}.row .col.offset-l4{margin-left:33.3333333333%}.row .col.pull-l4{right:33.3333333333%}.row .col.push-l4{left:33.3333333333%}.row .col.offset-l5{margin-left:41.6666666667%}.row .col.pull-l5{right:41.6666666667%}.row .col.push-l5{left:41.6666666667%}.row .col.offset-l6{margin-left:50%}.row .col.pull-l6{right:50%}.row .col.push-l6{left:50%}.row .col.offset-l7{margin-left:58.3333333333%}.row .col.pull-l7{right:58.3333333333%}.row .col.push-l7{left:58.3333333333%}.row .col.offset-l8{margin-left:66.6666666667%}.row .col.pull-l8{right:66.6666666667%}.row .col.push-l8{left:66.6666666667%}.row .col.offset-l9{margin-left:75%}.row .col.pull-l9{right:75%}.row .col.push-l9{left:75%}.row .col.offset-l10{margin-left:83.3333333333%}.row .col.pull-l10{right:83.3333333333%}.row .col.push-l10{left:83.3333333333%}.row .col.offset-l11{margin-left:91.6666666667%}.row .col.pull-l11{right:91.6666666667%}.row .col.push-l11{left:91.6666666667%}.row .col.offset-l12{margin-left:100%}.row .col.pull-l12{right:100%}.row .col.push-l12{left:100%}}nav{background-color:#ee6e73;width:100%;height:56px;line-height:56px}nav,nav a{color:#fff}nav [class*=mdi-],nav [class^=mdi-],nav i,nav i.material-icons{display:block;font-size:2rem;height:56px;line-height:56px}nav .nav-wrapper{position:relative;height:100%}@media only screen and (min-width:993px){nav a.button-collapse{display:none}}nav .button-collapse{float:left;position:relative;z-index:1;height:56px}nav .button-collapse i{font-size:2.7rem;height:56px;line-height:56px}nav .brand-logo{position:absolute;color:#fff;display:inline-block;font-size:2.1rem;padding:0;white-space:nowrap}nav .brand-logo.center{left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}@media only screen and (max-width:992px){nav .brand-logo{left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}nav .brand-logo.left,nav .brand-logo.right{padding:0;-webkit-transform:none;transform:none}nav .brand-logo.left{left:.5rem}nav .brand-logo.right{right:.5rem;left:auto}}nav .brand-logo.right{right:.5rem;padding:0}nav ul{margin:0}nav ul li{transition:background-color .3s;float:left;padding:0}nav ul li.active{background-color:rgba(0,0,0,.1)}nav ul a{transition:background-color .3s;font-size:1rem;color:#fff;display:inline-block;padding:0 15px;cursor:pointer}nav ul a.btn,nav ul a.btn-flat,nav ul a.btn-floating,nav ul a.btn-large{margin-top:-2px;margin-left:15px;margin-right:15px}nav ul a:hover{background-color:rgba(0,0,0,.1)}nav ul.left{float:left}nav .input-field{margin:0}nav .input-field input{height:100%;font-size:1.2rem;border:none;padding-left:2rem}nav .input-field input:focus,nav .input-field input[type=date]:valid,nav .input-field input[type=email]:valid,nav .input-field input[type=password]:valid,nav .input-field input[type=text]:valid,nav .input-field input[type=url]:valid{border:none;box-shadow:none}nav .input-field label{top:0;left:0}nav .input-field label i{color:hsla(0,0%,100%,.7);transition:color .3s}nav .input-field label.active i{color:#fff}nav .input-field label.active{-webkit-transform:translateY(0);transform:translateY(0)}.navbar-fixed{position:relative;height:56px;z-index:998}.navbar-fixed nav{position:fixed}@media only screen and (min-width:601px){nav,nav .nav-wrapper i,nav a.button-collapse,nav a.button-collapse i{height:64px;line-height:64px}.navbar-fixed{height:64px}}@font-face{font-family:Roboto;src:local(Roboto Thin),url(" + __webpack_require__(15) + ");src:url(" + __webpack_require__(15) + "?#iefix) format(\"embedded-opentype\"),url(" + __webpack_require__(16) + ") format(\"woff2\"),url(" + __webpack_require__(17) + ") format(\"woff\"),url(" + __webpack_require__(18) + ") format(\"truetype\");font-weight:200}@font-face{font-family:Roboto;src:local(Roboto Light),url(" + __webpack_require__(19) + ");src:url(" + __webpack_require__(19) + "?#iefix) format(\"embedded-opentype\"),url(" + __webpack_require__(20) + ") format(\"woff2\"),url(" + __webpack_require__(21) + ") format(\"woff\"),url(" + __webpack_require__(22) + ") format(\"truetype\");font-weight:300}@font-face{font-family:Roboto;src:local(Roboto Regular),url(" + __webpack_require__(23) + ");src:url(" + __webpack_require__(23) + "?#iefix) format(\"embedded-opentype\"),url(" + __webpack_require__(24) + ") format(\"woff2\"),url(" + __webpack_require__(25) + ") format(\"woff\"),url(" + __webpack_require__(26) + ") format(\"truetype\");font-weight:400}@font-face{font-family:Roboto;src:url(" + __webpack_require__(27) + ");src:url(" + __webpack_require__(27) + "?#iefix) format(\"embedded-opentype\"),url(" + __webpack_require__(28) + ") format(\"woff2\"),url(" + __webpack_require__(29) + ") format(\"woff\"),url(" + __webpack_require__(30) + ") format(\"truetype\");font-weight:500}@font-face{font-family:Roboto;src:url(" + __webpack_require__(31) + ");src:url(" + __webpack_require__(31) + "?#iefix) format(\"embedded-opentype\"),url(" + __webpack_require__(32) + ") format(\"woff2\"),url(" + __webpack_require__(33) + ") format(\"woff\"),url(" + __webpack_require__(34) + ") format(\"truetype\");font-weight:700}a{text-decoration:none}html{line-height:1.5;font-family:Roboto,sans-serif;font-weight:400;color:rgba(0,0,0,.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}h1,h2,h3,h4,h5,h6{font-weight:400;line-height:1.1}h1 a,h2 a,h3 a,h4 a,h5 a,h6 a{font-weight:inherit}h1{font-size:4.2rem;margin:2.1rem 0 1.68rem}h1,h2{line-height:110%}h2{font-size:3.56rem;margin:1.78rem 0 1.424rem}h3{font-size:2.92rem;margin:1.46rem 0 1.168rem}h3,h4{line-height:110%}h4{font-size:2.28rem;margin:1.14rem 0 .912rem}h5{font-size:1.64rem;margin:.82rem 0 .656rem}h5,h6{line-height:110%}h6{font-size:1rem;margin:.5rem 0 .4rem}em{font-style:italic}strong{font-weight:500}small{font-size:75%}.light,footer.page-footer .footer-copyright{font-weight:300}.thin{font-weight:200}.flow-text{font-weight:300}@media only screen and (min-width:360px){.flow-text{font-size:1.2rem}}@media only screen and (min-width:390px){.flow-text{font-size:1.224rem}}@media only screen and (min-width:420px){.flow-text{font-size:1.248rem}}@media only screen and (min-width:450px){.flow-text{font-size:1.272rem}}@media only screen and (min-width:480px){.flow-text{font-size:1.296rem}}@media only screen and (min-width:510px){.flow-text{font-size:1.32rem}}@media only screen and (min-width:540px){.flow-text{font-size:1.344rem}}@media only screen and (min-width:570px){.flow-text{font-size:1.368rem}}@media only screen and (min-width:600px){.flow-text{font-size:1.392rem}}@media only screen and (min-width:630px){.flow-text{font-size:1.416rem}}@media only screen and (min-width:660px){.flow-text{font-size:1.44rem}}@media only screen and (min-width:690px){.flow-text{font-size:1.464rem}}@media only screen and (min-width:720px){.flow-text{font-size:1.488rem}}@media only screen and (min-width:750px){.flow-text{font-size:1.512rem}}@media only screen and (min-width:780px){.flow-text{font-size:1.536rem}}@media only screen and (min-width:810px){.flow-text{font-size:1.56rem}}@media only screen and (min-width:840px){.flow-text{font-size:1.584rem}}@media only screen and (min-width:870px){.flow-text{font-size:1.608rem}}@media only screen and (min-width:900px){.flow-text{font-size:1.632rem}}@media only screen and (min-width:930px){.flow-text{font-size:1.656rem}}@media only screen and (min-width:960px){.flow-text{font-size:1.68rem}}@media only screen and (max-width:360px){.flow-text{font-size:1.2rem}}.card-panel{padding:20px}.card,.card-panel{transition:box-shadow .25s;margin:.5rem 0 1rem;border-radius:2px;background-color:#fff}.card{position:relative}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card.large,.card.medium,.card.small{position:relative}.card.large .card-image,.card.medium .card-image,.card.small .card-image{max-height:60%;overflow:hidden}.card.large .card-content,.card.medium .card-content,.card.small .card-content{max-height:40%;overflow:hidden}.card.large .card-action,.card.medium .card-action,.card.small .card-action{position:absolute;bottom:0;left:0;right:0}.card.small{height:300px}.card.medium{height:400px}.card.large{height:500px}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-image .card-title{color:#fff;position:absolute;bottom:0;left:0;padding:20px}.card .card-content{padding:20px;border-radius:0 0 2px 2px}.card .card-content p{margin:0;color:inherit}.card .card-content .card-title{line-height:48px}.card .card-action{position:relative;background-color:inherit;border-top:1px solid hsla(0,0%,63%,.2);padding:20px;z-index:2}.card .card-action a:not(.btn):not(.btn-large):not(.btn-floating){color:#ffab40;margin-right:20px;transition:color .3s ease;text-transform:uppercase}.card .card-action a:not(.btn):not(.btn-large):not(.btn-floating):hover{color:#ffd8a6}.card .card-action+.card-reveal{z-index:1;padding-bottom:64px}.card .card-reveal{padding:20px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}#toast-container{display:block;position:fixed;z-index:10000}@media only screen and (max-width:600px){#toast-container{min-width:100%;bottom:0}}@media only screen and (min-width:601px) and (max-width:992px){#toast-container{left:5%;bottom:7%;max-width:90%}}@media only screen and (min-width:993px){#toast-container{top:10%;right:7%;max-width:86%}}.toast{border-radius:2px;top:0;width:auto;clear:both;margin-top:10px;position:relative;max-width:100%;height:auto;min-height:48px;line-height:1.5em;word-break:break-all;background-color:#323232;padding:10px 25px;font-size:1.1rem;font-weight:300;color:#fff;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between}.toast .btn,.toast .btn-flat,.toast .btn-large{margin:0;margin-left:3rem}.toast.rounded{border-radius:24px}@media only screen and (max-width:600px){.toast{width:100%;border-radius:0}}@media only screen and (min-width:601px) and (max-width:992px){.toast{float:left}}@media only screen and (min-width:993px){.toast{float:right}}.tabs{display:-ms-flexbox;display:flex;position:relative;overflow-x:auto;overflow-y:hidden;height:48px;background-color:#fff;margin:0 auto;width:100%;white-space:nowrap}.tabs .tab{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;float:left;text-align:center;line-height:48px;height:48px;padding:0;margin:0;text-transform:uppercase;letter-spacing:.8px;width:15%;min-width:80px}.tabs .tab,.tabs .tab a{display:block;text-overflow:ellipsis;overflow:hidden}.tabs .tab a{color:#ee6e73;width:100%;height:100%;transition:color .28s ease}.tabs .tab a:hover{color:#f9c9cb}.tabs .tab.disabled a{color:#f9c9cb;cursor:default}.tabs .indicator{position:absolute;bottom:0;height:2px;background-color:#f6b2b5;will-change:left,right}.material-tooltip{padding:10px 8px;font-size:1rem;z-index:2000;background-color:transparent;border-radius:2px;color:#fff;min-height:36px;line-height:120%;text-align:center;max-width:calc(100% - 4px);overflow:hidden;left:0;top:0;pointer-events:none;will-change:top,left}.backdrop,.material-tooltip{opacity:0;display:none;position:absolute}.backdrop{height:7px;width:14px;border-radius:0 0 14px 14px;background-color:#323232;z-index:-1;-webkit-transform-origin:50% 10%;transform-origin:50% 10%;will-change:transform,opacity}.btn,.btn-flat,.btn-large{border:none;border-radius:2px;display:inline-block;height:36px;line-height:36px;outline:0;padding:0 2rem;text-transform:uppercase;vertical-align:middle;-webkit-tap-highlight-color:transparent}.btn-floating.disabled,.btn-floating:disabled,.btn-large.disabled,.btn-large:disabled .btn-large:disabled,.btn.disabled,.btn:disabled .btn-large:disabled,.disabled.btn-large{background-color:#dfdfdf!important;box-shadow:none;color:#9f9f9f!important;cursor:default}.btn-floating.disabled *,.btn-floating:disabled *,.btn-large.disabled *,.btn-large:disabled .btn-large:disabled *,.btn.disabled *,.btn:disabled .btn-large:disabled *,.disabled.btn-large *{pointer-events:none}.btn-floating.disabled:hover,.btn-floating:disabled:hover,.btn-large.disabled:hover,.btn-large:disabled .btn-large:disabled:hover,.btn.disabled:hover,.btn:disabled .btn-large:disabled:hover,.disabled.btn-large:hover{background-color:#dfdfdf!important;color:#9f9f9f!important}.btn-flat i,.btn-floating i,.btn-large i,.btn i{font-size:1.3rem;line-height:inherit}.btn,.btn-large{text-decoration:none;color:#fff;background-color:#26a69a;text-align:center;letter-spacing:.5px;transition:.2s ease-out;cursor:pointer}.btn-large:hover,.btn:hover{background-color:#2bbbad}.btn-floating{position:relative;overflow:hidden;z-index:1;width:37px;height:37px;padding:0;background-color:#26a69a;border-radius:50%;transition:.3s;cursor:pointer;vertical-align:middle}.btn-floating,.btn-floating i{display:inline-block;color:#fff;line-height:37px}.btn-floating i{width:inherit;text-align:center;font-size:1.6rem}.btn-floating:hover{background-color:#26a69a}.btn-floating:before{border-radius:0}.btn-floating.btn-large{width:55.5px;height:55.5px}.btn-floating.btn-large i{line-height:55.5px}button.btn-floating{border:none}.fixed-action-btn{position:fixed;right:23px;bottom:23px;padding-top:15px;margin-bottom:0;z-index:998}.fixed-action-btn.active ul{visibility:visible}.fixed-action-btn.horizontal{padding:0 0 0 15px}.fixed-action-btn.horizontal ul{text-align:right;right:64px;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);height:100%;left:auto;width:500px}.fixed-action-btn.horizontal ul li{display:inline-block;margin:15px 15px 0 0}.fixed-action-btn ul{left:0;right:0;text-align:center;position:absolute;bottom:64px;margin:0;visibility:hidden}.fixed-action-btn ul li{margin-bottom:15px}.fixed-action-btn ul a.btn-floating{opacity:0}.btn-flat{box-shadow:none;background-color:transparent;color:#343434;cursor:pointer}.btn-flat.disabled{color:#b3b3b3;cursor:default}.btn-large{height:54px;line-height:54px}.btn-large i{font-size:1.6rem}.btn-block{display:block}.dropdown-content{background-color:#fff;margin:0;display:none;min-width:100px;max-height:650px;overflow-y:auto;opacity:0;position:absolute;z-index:999;will-change:width,height}.dropdown-content li{clear:both;color:rgba(0,0,0,.87);cursor:pointer;min-height:50px;line-height:1.5rem;width:100%;text-align:left;text-transform:none}.dropdown-content li.active,.dropdown-content li.selected,.dropdown-content li:hover{background-color:#eee}.dropdown-content li.active.selected{background-color:#e1e1e1}.dropdown-content li.divider{min-height:0;height:1px}.dropdown-content li>a,.dropdown-content li>span{font-size:16px;color:#26a69a;display:block;line-height:22px;padding:14px 16px}.dropdown-content li>span>label{top:1px;left:3px;height:18px}.dropdown-content li>a>i{height:inherit;line-height:inherit}\n\n/*!\n * Waves v0.6.0\n * http://fian.my.id/Waves\n *\n * Copyright 2014 Alfiana E. Sibuea and other contributors\n * Released under the MIT license\n * https://github.com/fians/Waves/blob/master/LICENSE\n */.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;will-change:opacity,transform;transition:all .3s ease-out}.waves-effect .waves-ripple{position:absolute;border-radius:50%;width:20px;height:20px;margin-top:-10px;margin-left:-10px;opacity:0;background:rgba(0,0,0,.2);transition:all .7s ease-out;transition-property:opacity,-webkit-transform;transition-property:transform,opacity;transition-property:transform,opacity,-webkit-transform;-webkit-transform:scale(0);transform:scale(0);pointer-events:none}.waves-effect.waves-light .waves-ripple{background-color:hsla(0,0%,100%,.45)}.waves-effect.waves-red .waves-ripple{background-color:rgba(244,67,54,.7)}.waves-effect.waves-yellow .waves-ripple{background-color:rgba(255,235,59,.7)}.waves-effect.waves-orange .waves-ripple{background-color:rgba(255,152,0,.7)}.waves-effect.waves-purple .waves-ripple{background-color:rgba(156,39,176,.7)}.waves-effect.waves-green .waves-ripple{background-color:rgba(76,175,80,.7)}.waves-effect.waves-teal .waves-ripple{background-color:rgba(0,150,136,.7)}.waves-effect input[type=button],.waves-effect input[type=reset],.waves-effect input[type=submit]{border:0;font-style:normal;font-size:inherit;text-transform:inherit;background:none}.waves-notransition{transition:none!important}.waves-circle{-webkit-transform:translateZ(0);transform:translateZ(0);-webkit-mask-image:-webkit-radial-gradient(circle,#fff 100%,#000 0)}.waves-input-wrapper{border-radius:.2em;vertical-align:bottom}.waves-input-wrapper .waves-button-input{position:relative;top:0;left:0;z-index:1}.waves-circle{text-align:center;width:2.5em;height:2.5em;line-height:2.5em;border-radius:50%;-webkit-mask-image:none}.waves-block{display:block}a.waves-effect .waves-ripple{z-index:-1}.modal{display:none;position:fixed;left:0;right:0;background-color:#fafafa;padding:0;max-height:70%;width:55%;margin:auto;overflow-y:auto;border-radius:2px;will-change:top,opacity}@media only screen and (max-width:992px){.modal{width:80%}}.modal h1,.modal h2,.modal h3,.modal h4{margin-top:0}.modal .modal-content{padding:24px}.modal .modal-close{cursor:pointer}.modal .modal-footer{border-radius:0 0 2px 2px;background-color:#fafafa;padding:4px 6px;height:56px;width:100%}.modal .modal-footer .btn,.modal .modal-footer .btn-flat,.modal .modal-footer .btn-large{float:right;margin:6px 0}.lean-overlay{position:fixed;z-index:999;top:-100px;left:0;bottom:0;right:0;height:125%;width:100%;background:#000;display:none;will-change:opacity}.modal.modal-fixed-footer{padding:0;height:70%}.modal.modal-fixed-footer .modal-content{position:absolute;height:calc(100% - 56px);max-height:100%;width:100%;overflow-y:auto}.modal.modal-fixed-footer .modal-footer{border-top:1px solid rgba(0,0,0,.1);position:absolute;bottom:0}.modal.bottom-sheet{top:auto;bottom:-100%;margin:0;width:100%;max-height:45%;border-radius:0;will-change:bottom,opacity}.collapsible{border-top:1px solid #ddd;border-right:1px solid #ddd;border-left:1px solid #ddd;margin:.5rem 0 1rem}.collapsible-header{display:block;cursor:pointer;min-height:3rem;line-height:3rem;padding:0 1rem;background-color:#fff;border-bottom:1px solid #ddd}.collapsible-header i{width:2rem;font-size:1.6rem;line-height:3rem;display:block;float:left;text-align:center;margin-right:1rem}.collapsible-body{display:none;border-bottom:1px solid #ddd;box-sizing:border-box}.collapsible-body p{margin:0;padding:2rem}.side-nav .collapsible,.side-nav.fixed .collapsible{border:none;box-shadow:none}.side-nav .collapsible li,.side-nav.fixed .collapsible li{padding:0}.side-nav .collapsible-header,.side-nav.fixed .collapsible-header{background-color:transparent;border:none;line-height:inherit;height:inherit;padding:0 30px}.side-nav .collapsible-header:hover,.side-nav.fixed .collapsible-header:hover{background-color:rgba(0,0,0,.05)}.side-nav .collapsible-header i,.side-nav.fixed .collapsible-header i{line-height:inherit}.side-nav .collapsible-body,.side-nav.fixed .collapsible-body{border:0;background-color:#fff}.side-nav .collapsible-body li a,.side-nav.fixed .collapsible-body li a{padding:0 37.5px 0 45px}.collapsible.popout{border:none;box-shadow:none}.collapsible.popout>li{box-shadow:0 2px 5px 0 rgba(0,0,0,.16),0 2px 10px 0 rgba(0,0,0,.12);margin:0 24px;transition:margin .35s cubic-bezier(.25,.46,.45,.94)}.collapsible.popout>li.active{box-shadow:0 5px 11px 0 rgba(0,0,0,.18),0 4px 15px 0 rgba(0,0,0,.15);margin:16px 0}.chip{display:inline-block;height:32px;font-size:13px;font-weight:500;color:rgba(0,0,0,.6);line-height:32px;padding:0 12px;border-radius:16px;background-color:#e4e4e4}.chip img{float:left;margin:0 8px 0 -12px;height:32px;width:32px;border-radius:50%}.chip i.material-icons{cursor:pointer;float:right;font-size:16px;line-height:32px;padding-left:8px}.materialboxed{display:block;cursor:zoom-in;position:relative;transition:opacity .4s}.materialboxed:hover{will-change:left,top,width,height}.materialboxed:hover:not(.active){opacity:.8}.materialboxed.active{cursor:zoom-out}#materialbox-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background-color:#292929;z-index:1000;will-change:opacity}.materialbox-caption{position:fixed;display:none;color:#fff;line-height:50px;bottom:0;width:100%;text-align:center;padding:0 15%;height:50px;z-index:1000;-webkit-font-smoothing:antialiased}select:focus{outline:1px solid #c9f3ef}button:focus{outline:none;background-color:#2ab7a9}label{font-size:.8rem;color:#9e9e9e}::-webkit-input-placeholder{color:#d1d1d1}:-moz-placeholder,::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}input:not([type]),input[type=date],input[type=datetime-local],input[type=datetime],input[type=email],input[type=number],input[type=password],input[type=search],input[type=tel],input[type=text],input[type=time],input[type=url],textarea.materialize-textarea{background-color:transparent;border:none;border-bottom:1px solid #9e9e9e;border-radius:0;outline:none;height:3rem;width:100%;font-size:1rem;margin:0 0 15px;padding:0;box-shadow:none;box-sizing:content-box;transition:all .3s}input:not([type]):disabled,input:not([type])[readonly=readonly],input[type=date]:disabled,input[type=date][readonly=readonly],input[type=datetime-local]:disabled,input[type=datetime-local][readonly=readonly],input[type=datetime]:disabled,input[type=datetime][readonly=readonly],input[type=email]:disabled,input[type=email][readonly=readonly],input[type=number]:disabled,input[type=number][readonly=readonly],input[type=password]:disabled,input[type=password][readonly=readonly],input[type=search]:disabled,input[type=search][readonly=readonly],input[type=tel]:disabled,input[type=tel][readonly=readonly],input[type=text]:disabled,input[type=text][readonly=readonly],input[type=time]:disabled,input[type=time][readonly=readonly],input[type=url]:disabled,input[type=url][readonly=readonly],textarea.materialize-textarea:disabled,textarea.materialize-textarea[readonly=readonly]{color:rgba(0,0,0,.26);border-bottom:1px dotted rgba(0,0,0,.26)}input:not([type]):disabled+label,input:not([type])[readonly=readonly]+label,input[type=date]:disabled+label,input[type=date][readonly=readonly]+label,input[type=datetime-local]:disabled+label,input[type=datetime-local][readonly=readonly]+label,input[type=datetime]:disabled+label,input[type=datetime][readonly=readonly]+label,input[type=email]:disabled+label,input[type=email][readonly=readonly]+label,input[type=number]:disabled+label,input[type=number][readonly=readonly]+label,input[type=password]:disabled+label,input[type=password][readonly=readonly]+label,input[type=search]:disabled+label,input[type=search][readonly=readonly]+label,input[type=tel]:disabled+label,input[type=tel][readonly=readonly]+label,input[type=text]:disabled+label,input[type=text][readonly=readonly]+label,input[type=time]:disabled+label,input[type=time][readonly=readonly]+label,input[type=url]:disabled+label,input[type=url][readonly=readonly]+label,textarea.materialize-textarea:disabled+label,textarea.materialize-textarea[readonly=readonly]+label{color:rgba(0,0,0,.26)}input:not([type]):focus:not([readonly]),input[type=date]:focus:not([readonly]),input[type=datetime-local]:focus:not([readonly]),input[type=datetime]:focus:not([readonly]),input[type=email]:focus:not([readonly]),input[type=number]:focus:not([readonly]),input[type=password]:focus:not([readonly]),input[type=search]:focus:not([readonly]),input[type=tel]:focus:not([readonly]),input[type=text]:focus:not([readonly]),input[type=time]:focus:not([readonly]),input[type=url]:focus:not([readonly]),textarea.materialize-textarea:focus:not([readonly]){border-bottom:1px solid #26a69a;box-shadow:0 1px 0 0 #26a69a}input:not([type]):focus:not([readonly])+label,input[type=date]:focus:not([readonly])+label,input[type=datetime-local]:focus:not([readonly])+label,input[type=datetime]:focus:not([readonly])+label,input[type=email]:focus:not([readonly])+label,input[type=number]:focus:not([readonly])+label,input[type=password]:focus:not([readonly])+label,input[type=search]:focus:not([readonly])+label,input[type=tel]:focus:not([readonly])+label,input[type=text]:focus:not([readonly])+label,input[type=time]:focus:not([readonly])+label,input[type=url]:focus:not([readonly])+label,textarea.materialize-textarea:focus:not([readonly])+label{color:#26a69a}input:not([type]).valid,input:not([type]):focus.valid,input[type=date].valid,input[type=date]:focus.valid,input[type=datetime-local].valid,input[type=datetime-local]:focus.valid,input[type=datetime].valid,input[type=datetime]:focus.valid,input[type=email].valid,input[type=email]:focus.valid,input[type=number].valid,input[type=number]:focus.valid,input[type=password].valid,input[type=password]:focus.valid,input[type=search].valid,input[type=search]:focus.valid,input[type=tel].valid,input[type=tel]:focus.valid,input[type=text].valid,input[type=text]:focus.valid,input[type=time].valid,input[type=time]:focus.valid,input[type=url].valid,input[type=url]:focus.valid,textarea.materialize-textarea.valid,textarea.materialize-textarea:focus.valid{border-bottom:1px solid #4caf50;box-shadow:0 1px 0 0 #4caf50}input:not([type]).valid+label:after,input:not([type]):focus.valid+label:after,input[type=date].valid+label:after,input[type=date]:focus.valid+label:after,input[type=datetime-local].valid+label:after,input[type=datetime-local]:focus.valid+label:after,input[type=datetime].valid+label:after,input[type=datetime]:focus.valid+label:after,input[type=email].valid+label:after,input[type=email]:focus.valid+label:after,input[type=number].valid+label:after,input[type=number]:focus.valid+label:after,input[type=password].valid+label:after,input[type=password]:focus.valid+label:after,input[type=search].valid+label:after,input[type=search]:focus.valid+label:after,input[type=tel].valid+label:after,input[type=tel]:focus.valid+label:after,input[type=text].valid+label:after,input[type=text]:focus.valid+label:after,input[type=time].valid+label:after,input[type=time]:focus.valid+label:after,input[type=url].valid+label:after,input[type=url]:focus.valid+label:after,textarea.materialize-textarea.valid+label:after,textarea.materialize-textarea:focus.valid+label:after{content:attr(data-success);color:#4caf50;opacity:1}input:not([type]).invalid,input:not([type]):focus.invalid,input[type=date].invalid,input[type=date]:focus.invalid,input[type=datetime-local].invalid,input[type=datetime-local]:focus.invalid,input[type=datetime].invalid,input[type=datetime]:focus.invalid,input[type=email].invalid,input[type=email]:focus.invalid,input[type=number].invalid,input[type=number]:focus.invalid,input[type=password].invalid,input[type=password]:focus.invalid,input[type=search].invalid,input[type=search]:focus.invalid,input[type=tel].invalid,input[type=tel]:focus.invalid,input[type=text].invalid,input[type=text]:focus.invalid,input[type=time].invalid,input[type=time]:focus.invalid,input[type=url].invalid,input[type=url]:focus.invalid,textarea.materialize-textarea.invalid,textarea.materialize-textarea:focus.invalid{border-bottom:1px solid #f44336;box-shadow:0 1px 0 0 #f44336}input:not([type]).invalid+label:after,input:not([type]):focus.invalid+label:after,input[type=date].invalid+label:after,input[type=date]:focus.invalid+label:after,input[type=datetime-local].invalid+label:after,input[type=datetime-local]:focus.invalid+label:after,input[type=datetime].invalid+label:after,input[type=datetime]:focus.invalid+label:after,input[type=email].invalid+label:after,input[type=email]:focus.invalid+label:after,input[type=number].invalid+label:after,input[type=number]:focus.invalid+label:after,input[type=password].invalid+label:after,input[type=password]:focus.invalid+label:after,input[type=search].invalid+label:after,input[type=search]:focus.invalid+label:after,input[type=tel].invalid+label:after,input[type=tel]:focus.invalid+label:after,input[type=text].invalid+label:after,input[type=text]:focus.invalid+label:after,input[type=time].invalid+label:after,input[type=time]:focus.invalid+label:after,input[type=url].invalid+label:after,input[type=url]:focus.invalid+label:after,textarea.materialize-textarea.invalid+label:after,textarea.materialize-textarea:focus.invalid+label:after{content:attr(data-error);color:#f44336;opacity:1}input:not([type]).validate+label,input[type=date].validate+label,input[type=datetime-local].validate+label,input[type=datetime].validate+label,input[type=email].validate+label,input[type=number].validate+label,input[type=password].validate+label,input[type=search].validate+label,input[type=tel].validate+label,input[type=text].validate+label,input[type=time].validate+label,input[type=url].validate+label,textarea.materialize-textarea.validate+label{width:100%;pointer-events:none}input:not([type])+label:after,input[type=date]+label:after,input[type=datetime-local]+label:after,input[type=datetime]+label:after,input[type=email]+label:after,input[type=number]+label:after,input[type=password]+label:after,input[type=search]+label:after,input[type=tel]+label:after,input[type=text]+label:after,input[type=time]+label:after,input[type=url]+label:after,textarea.materialize-textarea+label:after{display:block;content:\"\";position:absolute;top:65px;opacity:0;transition:opacity .2s ease-out,color .2s ease-out}.input-field{position:relative;margin-top:1rem}.input-field label{color:#9e9e9e;position:absolute;top:.8rem;left:.75rem;font-size:1rem;cursor:text;transition:.2s ease-out}.input-field label.active{font-size:.8rem;-webkit-transform:translateY(-140%);transform:translateY(-140%)}.input-field .prefix{position:absolute;width:3rem;font-size:2rem;transition:color .2s}.input-field .prefix.active{color:#26a69a}.input-field .prefix~input,.input-field .prefix~textarea{margin-left:3rem;width:92%;width:calc(100% - 3rem)}.input-field .prefix~textarea{padding-top:.8rem}.input-field .prefix~label{margin-left:3rem}@media only screen and (max-width:992px){.input-field .prefix~input{width:86%;width:calc(100% - 3rem)}}@media only screen and (max-width:600px){.input-field .prefix~input{width:80%;width:calc(100% - 3rem)}}.input-field input[type=search]{display:block;line-height:inherit;padding-left:4rem;width:calc(100% - 4rem)}.input-field input[type=search]:focus{background-color:#fff;border:0;box-shadow:none;color:#444}.input-field input[type=search]:focus+label i,.input-field input[type=search]:focus~.material-icons,.input-field input[type=search]:focus~.mdi-navigation-close{color:#444}.input-field input[type=search]+label{left:1rem}.input-field input[type=search]~.material-icons,.input-field input[type=search]~.mdi-navigation-close{position:absolute;top:0;right:1rem;color:transparent;cursor:pointer;font-size:2rem;transition:color .3s}textarea{width:100%;height:3rem;background-color:transparent}textarea.materialize-textarea{overflow-y:hidden;padding:1.6rem 0;resize:none;min-height:3rem}.hiddendiv{display:none;white-space:pre-wrap;word-wrap:break-word;overflow-wrap:break-word;padding-top:1.2rem}[type=radio]:checked,[type=radio]:not(:checked){position:absolute;left:-9999px;opacity:0}[type=radio]:checked+label,[type=radio]:not(:checked)+label{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=radio]+label:after,[type=radio]+label:before{content:'';position:absolute;left:0;top:0;margin:4px;width:16px;height:16px;z-index:0;transition:.28s ease}[type=radio].with-gap:checked+label:after,[type=radio].with-gap:checked+label:before,[type=radio]:checked+label:after,[type=radio]:checked+label:before,[type=radio]:not(:checked)+label:after,[type=radio]:not(:checked)+label:before{border-radius:50%}[type=radio]:not(:checked)+label:after,[type=radio]:not(:checked)+label:before{border:2px solid #5a5a5a}[type=radio]:not(:checked)+label:after{z-index:-1;-webkit-transform:scale(0);transform:scale(0)}[type=radio]:checked+label:before{border:2px solid transparent}[type=radio].with-gap:checked+label:after,[type=radio].with-gap:checked+label:before,[type=radio]:checked+label:after{border:2px solid #26a69a}[type=radio].with-gap:checked+label:after,[type=radio]:checked+label:after{background-color:#26a69a;z-index:0}[type=radio]:checked+label:after{-webkit-transform:scale(1.02);transform:scale(1.02)}[type=radio].with-gap:checked+label:after{-webkit-transform:scale(.5);transform:scale(.5)}[type=radio].tabbed:focus+label:before{box-shadow:0 0 0 10px rgba(0,0,0,.1)}[type=radio].with-gap:disabled:checked+label:before{border:2px solid rgba(0,0,0,.26)}[type=radio].with-gap:disabled:checked+label:after{border:none;background-color:rgba(0,0,0,.26)}[type=radio]:disabled:checked+label:before,[type=radio]:disabled:not(:checked)+label:before{background-color:transparent;border-color:rgba(0,0,0,.26)}[type=radio]:disabled+label{color:rgba(0,0,0,.26)}[type=radio]:disabled:not(:checked)+label:before{border-color:rgba(0,0,0,.26)}[type=radio]:disabled:checked+label:after{background-color:rgba(0,0,0,.26);border-color:#bdbdbd}form p{margin-bottom:10px;text-align:left}form p:last-child{margin-bottom:0}[type=checkbox]:checked,[type=checkbox]:not(:checked){position:absolute;left:-9999px;opacity:0}[type=checkbox]+label{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-user-select:none;-moz-user-select:none;-khtml-user-select:none;-ms-user-select:none}[type=checkbox]+label:before,[type=checkbox]:not(.filled-in)+label:after{content:'';position:absolute;top:0;left:0;width:18px;height:18px;z-index:0;border:2px solid #5a5a5a;border-radius:1px;margin-top:2px;transition:.2s}[type=checkbox]:not(.filled-in)+label:after{border:0;-webkit-transform:scale(0);transform:scale(0)}[type=checkbox]:not(:checked):disabled+label:before{border:none;background-color:rgba(0,0,0,.26)}[type=checkbox].tabbed:focus+label:after{-webkit-transform:scale(1);transform:scale(1);border:0;border-radius:50%;box-shadow:0 0 0 10px rgba(0,0,0,.1);background-color:rgba(0,0,0,.1)}[type=checkbox]:checked+label:before{top:-4px;left:-5px;width:12px;height:22px;border-top:2px solid transparent;border-left:2px solid transparent;border-right:2px solid #26a69a;border-bottom:2px solid #26a69a;-webkit-transform:rotate(40deg);transform:rotate(40deg);-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=checkbox]:checked:disabled+label:before{border-right:2px solid rgba(0,0,0,.26);border-bottom:2px solid rgba(0,0,0,.26)}[type=checkbox]:indeterminate+label:before{top:-11px;left:-12px;width:10px;height:22px;border-top:none;border-left:none;border-right:2px solid #26a69a;border-bottom:none;-webkit-transform:rotate(90deg);transform:rotate(90deg);-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=checkbox]:indeterminate:disabled+label:before{border-right:2px solid rgba(0,0,0,.26);background-color:transparent}[type=checkbox].filled-in+label:after{border-radius:2px}[type=checkbox].filled-in+label:after,[type=checkbox].filled-in+label:before{content:'';left:0;position:absolute;transition:border .25s,background-color .25s,width .2s .1s,height .2s .1s,top .2s .1s,left .2s .1s;z-index:1}[type=checkbox].filled-in:not(:checked)+label:before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotate(37deg);transform:rotate(37deg);-webkit-transform-origin:20% 40%;transform-origin:100% 100%}[type=checkbox].filled-in:not(:checked)+label:after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0;z-index:0}[type=checkbox].filled-in:checked+label:before{top:0;left:1px;width:8px;height:13px;border-top:2px solid transparent;border-left:2px solid transparent;border-right:2px solid #fff;border-bottom:2px solid #fff;-webkit-transform:rotate(37deg);transform:rotate(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=checkbox].filled-in:checked+label:after{top:0;width:20px;height:20px;border:2px solid #26a69a;background-color:#26a69a;z-index:0}[type=checkbox].filled-in.tabbed:focus+label:after{border-radius:2px;border-color:#5a5a5a;background-color:rgba(0,0,0,.1)}[type=checkbox].filled-in.tabbed:checked:focus+label:after{border-radius:2px;background-color:#26a69a;border-color:#26a69a}[type=checkbox].filled-in:disabled:not(:checked)+label:before{background-color:transparent;border:2px solid transparent}[type=checkbox].filled-in:disabled:not(:checked)+label:after{border-color:transparent;background-color:#bdbdbd}[type=checkbox].filled-in:disabled:checked+label:before{background-color:transparent}[type=checkbox].filled-in:disabled:checked+label:after{background-color:#bdbdbd;border-color:#bdbdbd}.switch,.switch *{-webkit-user-select:none;-moz-user-select:none;-khtml-user-select:none;-ms-user-select:none}.switch label{cursor:pointer}.switch label input[type=checkbox]{opacity:0;width:0;height:0}.switch label input[type=checkbox]:checked+.lever{background-color:#84c7c1}.switch label input[type=checkbox]:checked+.lever:after{background-color:#26a69a;left:24px}.switch label .lever{content:\"\";display:inline-block;position:relative;width:40px;height:15px;background-color:#818181;border-radius:15px;margin-right:10px;transition:background .3s ease;vertical-align:middle;margin:0 16px}.switch label .lever:after{content:\"\";position:absolute;display:inline-block;width:21px;height:21px;background-color:#f1f1f1;border-radius:21px;box-shadow:0 1px 3px 1px rgba(0,0,0,.4);left:-5px;top:-3px;transition:left .3s ease,background .3s ease,box-shadow .1s ease}input[type=checkbox]:checked:not(:disabled).tabbed:focus~.lever:after,input[type=checkbox]:checked:not(:disabled)~.lever:active:after{box-shadow:0 1px 3px 1px rgba(0,0,0,.4),0 0 0 15px rgba(38,166,154,.1)}input[type=checkbox]:not(:disabled).tabbed:focus~.lever:after,input[type=checkbox]:not(:disabled)~.lever:active:after{box-shadow:0 1px 3px 1px rgba(0,0,0,.4),0 0 0 15px rgba(0,0,0,.08)}.switch input[type=checkbox][disabled]+.lever{cursor:default}.switch label input[type=checkbox][disabled]+.lever:after,.switch label input[type=checkbox][disabled]:checked+.lever:after{background-color:#bdbdbd}select{display:none}select.browser-default{display:block}select{background-color:hsla(0,0%,100%,.9);width:100%;padding:5px;border:1px solid #f2f2f2;border-radius:2px;height:3rem}.select-label{position:absolute}.select-wrapper{position:relative}.select-wrapper input.select-dropdown{position:relative;cursor:pointer;background-color:transparent;border:none;border-bottom:1px solid #9e9e9e;outline:none;height:3rem;line-height:3rem;width:100%;font-size:1rem;margin:0 0 15px;padding:0;display:block}.select-wrapper span.caret{color:initial;position:absolute;right:0;top:16px;font-size:10px}.select-wrapper span.caret.disabled{color:rgba(0,0,0,.26)}.select-wrapper+label{position:absolute;top:-14px;font-size:.8rem}select:disabled{color:rgba(0,0,0,.3)}.select-wrapper input.select-dropdown:disabled{color:rgba(0,0,0,.3);cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;border-bottom:1px solid rgba(0,0,0,.3)}.select-wrapper i{color:rgba(0,0,0,.3)}.select-dropdown li.disabled,.select-dropdown li.disabled>span,.select-dropdown li.optgroup{color:rgba(0,0,0,.3);background-color:transparent}.prefix~.select-wrapper{margin-left:3rem;width:92%;width:calc(100% - 3rem)}.prefix~label{margin-left:3rem}.select-dropdown li img{height:40px;width:40px;margin:5px 15px;float:right}.select-dropdown li.optgroup{border-top:1px solid #eee}.select-dropdown li.optgroup.selected>span{color:rgba(0,0,0,.7)}.select-dropdown li.optgroup>span{color:rgba(0,0,0,.4)}.select-dropdown li.optgroup~li.optgroup-option{padding-left:1rem}.file-field{position:relative}.file-field .file-path-wrapper{overflow:hidden;padding-left:10px}.file-field input.file-path{width:100%}.file-field .btn,.file-field .btn-large{float:left;height:3rem;line-height:3rem}.file-field span{cursor:pointer}.file-field input[type=file]{position:absolute;top:0;right:0;left:0;bottom:0;width:100%;margin:0;padding:0;font-size:20px;cursor:pointer;opacity:0;filter:alpha(opacity=0)}.range-field{position:relative}input[type=range],input[type=range]+.thumb{cursor:pointer}input[type=range]{position:relative;background-color:transparent;border:none;outline:none;width:100%;margin:15px 0;padding:0}input[type=range]:focus{outline:none}input[type=range]+.thumb{position:absolute;border:none;height:0;width:0;border-radius:50%;background-color:#26a69a;top:10px;margin-left:-6px;-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}input[type=range]+.thumb .value{display:block;width:30px;text-align:center;color:#26a69a;font-size:0;-webkit-transform:rotate(45deg);transform:rotate(45deg)}input[type=range]+.thumb.active{border-radius:50% 50% 50% 0}input[type=range]+.thumb.active .value{color:#fff;margin-left:-1px;margin-top:8px;font-size:10px}input[type=range]{-webkit-appearance:none}input[type=range]::-webkit-slider-runnable-track{height:3px;background:#c2c0c2;border:none}input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;border:none;height:14px;width:14px;border-radius:50%;background-color:#26a69a;-webkit-transform-origin:50% 50%;transform-origin:50% 50%;margin:-5px 0 0;transition:.3s}input[type=range]:focus::-webkit-slider-runnable-track{background:#ccc}input[type=range]{border:1px solid #fff}input[type=range]::-moz-range-track{height:3px;background:#ddd;border:none}input[type=range]::-moz-range-thumb{border:none;height:14px;width:14px;border-radius:50%;background:#26a69a;margin-top:-5px}input[type=range]:-moz-focusring{outline:1px solid #fff;outline-offset:-1px}input[type=range]:focus::-moz-range-track{background:#ccc}input[type=range]::-ms-track{height:3px;background:transparent;border-color:transparent;border-width:6px 0;color:transparent}input[type=range]::-ms-fill-lower{background:#777}input[type=range]::-ms-fill-upper{background:#ddd}input[type=range]::-ms-thumb{border:none;height:14px;width:14px;border-radius:50%;background:#26a69a}input[type=range]:focus::-ms-fill-lower{background:#888}input[type=range]:focus::-ms-fill-upper{background:#ccc}.table-of-contents.fixed{position:fixed}.table-of-contents li{padding:2px 0}.table-of-contents a{font-weight:300;color:#757575;padding-left:20px;height:1.5rem;line-height:1.5rem;letter-spacing:.4;display:inline-block}.table-of-contents a:hover{color:#a8a8a8;padding-left:19px;border-left:1px solid #ea4a4f}.table-of-contents a.active{font-weight:500;padding-left:18px;border-left:2px solid #ea4a4f}.side-nav{position:fixed;width:240px;left:0;top:0;margin:0;-webkit-transform:translateX(-100%);transform:translateX(-100%);height:calc(100% + 60px);height:100%;padding-bottom:60px;background-color:#fff;z-index:999;overflow-y:auto;will-change:transform;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-transform:translateX(-105%);transform:translateX(-105%)}.side-nav.right-aligned{right:0;-webkit-transform:translateX(105%);transform:translateX(105%);left:auto;-webkit-transform:translateX(100%);transform:translateX(100%)}.side-nav .collapsible{margin:0}.side-nav li{float:none;line-height:64px}.side-nav li.active{background-color:rgba(0,0,0,.05)}.side-nav a{color:#444;display:block;font-size:1rem;height:64px;line-height:64px;padding:0 30px}.side-nav a:hover{background-color:rgba(0,0,0,.05)}.side-nav a.btn,.side-nav a.btn-flat,.side-nav a.btn-floating,.side-nav a.btn-large{margin:10px 15px}.side-nav a.btn,.side-nav a.btn-floating,.side-nav a.btn-large{color:#fff}.side-nav a.btn-flat{color:#343434}.side-nav a.btn-large:hover,.side-nav a.btn:hover{background-color:#2bbbad}.side-nav a.btn-floating:hover{background-color:#26a69a}.drag-target{height:100%;width:10px;position:fixed;top:0;z-index:998}.side-nav.fixed a{display:block;padding:0 30px;color:#444}.side-nav.fixed{left:0;-webkit-transform:translateX(0);transform:translateX(0);position:fixed}.side-nav.fixed.right-aligned{right:0;left:auto}@media only screen and (max-width:992px){.side-nav.fixed{-webkit-transform:translateX(-105%);transform:translateX(-105%)}.side-nav.fixed.right-aligned{-webkit-transform:translateX(105%);transform:translateX(105%)}}.side-nav .collapsible-body li.active,.side-nav.fixed .collapsible-body li.active{background-color:#ee6e73}.side-nav .collapsible-body li.active a,.side-nav.fixed .collapsible-body li.active a{color:#fff}#sidenav-overlay{position:fixed;top:0;left:0;right:0;height:120vh;background-color:rgba(0,0,0,.5);z-index:997;will-change:opacity}.preloader-wrapper{display:inline-block;position:relative;width:48px;height:48px}.preloader-wrapper.small{width:36px;height:36px}.preloader-wrapper.big{width:64px;height:64px}.preloader-wrapper.active{-webkit-animation:container-rotate 1568ms linear infinite;animation:container-rotate 1568ms linear infinite}@-webkit-keyframes container-rotate{to{-webkit-transform:rotate(1turn)}}@keyframes container-rotate{to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}.spinner-layer{position:absolute;width:100%;height:100%;opacity:0;border-color:#26a69a}.spinner-blue,.spinner-blue-only{border-color:#4285f4}.spinner-red,.spinner-red-only{border-color:#db4437}.spinner-yellow,.spinner-yellow-only{border-color:#f4b400}.spinner-green,.spinner-green-only{border-color:#0f9d58}.active .spinner-layer.spinner-blue{-webkit-animation:fill-unfill-rotate 5332ms cubic-bezier(.4,0,.2,1) infinite both,blue-fade-in-out 5332ms cubic-bezier(.4,0,.2,1) infinite both;animation:fill-unfill-rotate 5332ms cubic-bezier(.4,0,.2,1) infinite both,blue-fade-in-out 5332ms cubic-bezier(.4,0,.2,1) infinite both}.active .spinner-layer.spinner-red{-webkit-animation:fill-unfill-rotate 5332ms cubic-bezier(.4,0,.2,1) infinite both,red-fade-in-out 5332ms cubic-bezier(.4,0,.2,1) infinite both;animation:fill-unfill-rotate 5332ms cubic-bezier(.4,0,.2,1) infinite both,red-fade-in-out 5332ms cubic-bezier(.4,0,.2,1) infinite both}.active .spinner-layer.spinner-yellow{-webkit-animation:fill-unfill-rotate 5332ms cubic-bezier(.4,0,.2,1) infinite both,yellow-fade-in-out 5332ms cubic-bezier(.4,0,.2,1) infinite both;animation:fill-unfill-rotate 5332ms cubic-bezier(.4,0,.2,1) infinite both,yellow-fade-in-out 5332ms cubic-bezier(.4,0,.2,1) infinite both}.active .spinner-layer.spinner-green{-webkit-animation:fill-unfill-rotate 5332ms cubic-bezier(.4,0,.2,1) infinite both,green-fade-in-out 5332ms cubic-bezier(.4,0,.2,1) infinite both;animation:fill-unfill-rotate 5332ms cubic-bezier(.4,0,.2,1) infinite both,green-fade-in-out 5332ms cubic-bezier(.4,0,.2,1) infinite both}.active .spinner-layer,.active .spinner-layer.spinner-blue-only,.active .spinner-layer.spinner-green-only,.active .spinner-layer.spinner-red-only,.active .spinner-layer.spinner-yellow-only{opacity:1;-webkit-animation:fill-unfill-rotate 5332ms cubic-bezier(.4,0,.2,1) infinite both;animation:fill-unfill-rotate 5332ms cubic-bezier(.4,0,.2,1) infinite both}@-webkit-keyframes fill-unfill-rotate{12.5%{-webkit-transform:rotate(135deg)}25%{-webkit-transform:rotate(270deg)}37.5%{-webkit-transform:rotate(405deg)}50%{-webkit-transform:rotate(540deg)}62.5%{-webkit-transform:rotate(675deg)}75%{-webkit-transform:rotate(810deg)}87.5%{-webkit-transform:rotate(945deg)}to{-webkit-transform:rotate(3turn)}}@keyframes fill-unfill-rotate{12.5%{-webkit-transform:rotate(135deg);transform:rotate(135deg)}25%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}37.5%{-webkit-transform:rotate(405deg);transform:rotate(405deg)}50%{-webkit-transform:rotate(540deg);transform:rotate(540deg)}62.5%{-webkit-transform:rotate(675deg);transform:rotate(675deg)}75%{-webkit-transform:rotate(810deg);transform:rotate(810deg)}87.5%{-webkit-transform:rotate(945deg);transform:rotate(945deg)}to{-webkit-transform:rotate(3turn);transform:rotate(3turn)}}@-webkit-keyframes blue-fade-in-out{0%{opacity:1}25%{opacity:1}26%{opacity:0}89%{opacity:0}90%{opacity:1}to{opacity:1}}@keyframes blue-fade-in-out{0%{opacity:1}25%{opacity:1}26%{opacity:0}89%{opacity:0}90%{opacity:1}to{opacity:1}}@-webkit-keyframes red-fade-in-out{0%{opacity:0}15%{opacity:0}25%{opacity:1}50%{opacity:1}51%{opacity:0}}@keyframes red-fade-in-out{0%{opacity:0}15%{opacity:0}25%{opacity:1}50%{opacity:1}51%{opacity:0}}@-webkit-keyframes yellow-fade-in-out{0%{opacity:0}40%{opacity:0}50%{opacity:1}75%{opacity:1}76%{opacity:0}}@keyframes yellow-fade-in-out{0%{opacity:0}40%{opacity:0}50%{opacity:1}75%{opacity:1}76%{opacity:0}}@-webkit-keyframes green-fade-in-out{0%{opacity:0}65%{opacity:0}75%{opacity:1}90%{opacity:1}to{opacity:0}}@keyframes green-fade-in-out{0%{opacity:0}65%{opacity:0}75%{opacity:1}90%{opacity:1}to{opacity:0}}.gap-patch{position:absolute;top:0;left:45%;width:10%;height:100%;overflow:hidden;border-color:inherit}.gap-patch .circle{width:1000%;left:-450%}.circle-clipper{display:inline-block;position:relative;width:50%;height:100%;overflow:hidden;border-color:inherit}.circle-clipper .circle{width:200%;height:100%;border-width:3px;border-style:solid;border-color:inherit;border-bottom-color:transparent!important;border-radius:50%;-webkit-animation:none;animation:none;position:absolute;top:0;right:0;bottom:0}.circle-clipper.left .circle{left:0;border-right-color:transparent!important;-webkit-transform:rotate(129deg);transform:rotate(129deg)}.circle-clipper.right .circle{left:-100%;border-left-color:transparent!important;-webkit-transform:rotate(-129deg);transform:rotate(-129deg)}.active .circle-clipper.left .circle{-webkit-animation:left-spin 1333ms cubic-bezier(.4,0,.2,1) infinite both;animation:left-spin 1333ms cubic-bezier(.4,0,.2,1) infinite both}.active .circle-clipper.right .circle{-webkit-animation:right-spin 1333ms cubic-bezier(.4,0,.2,1) infinite both;animation:right-spin 1333ms cubic-bezier(.4,0,.2,1) infinite both}@-webkit-keyframes left-spin{0%{-webkit-transform:rotate(130deg)}50%{-webkit-transform:rotate(-5deg)}to{-webkit-transform:rotate(130deg)}}@keyframes left-spin{0%{-webkit-transform:rotate(130deg);transform:rotate(130deg)}50%{-webkit-transform:rotate(-5deg);transform:rotate(-5deg)}to{-webkit-transform:rotate(130deg);transform:rotate(130deg)}}@-webkit-keyframes right-spin{0%{-webkit-transform:rotate(-130deg)}50%{-webkit-transform:rotate(5deg)}to{-webkit-transform:rotate(-130deg)}}@keyframes right-spin{0%{-webkit-transform:rotate(-130deg);transform:rotate(-130deg)}50%{-webkit-transform:rotate(5deg);transform:rotate(5deg)}to{-webkit-transform:rotate(-130deg);transform:rotate(-130deg)}}#spinnerContainer.cooldown{-webkit-animation:container-rotate 1568ms linear infinite,fade-out .4s cubic-bezier(.4,0,.2,1);animation:container-rotate 1568ms linear infinite,fade-out .4s cubic-bezier(.4,0,.2,1)}@-webkit-keyframes fade-out{0%{opacity:1}to{opacity:0}}@keyframes fade-out{0%{opacity:1}to{opacity:0}}.slider{position:relative;height:400px;width:100%}.slider.fullscreen{height:100%;width:100%;position:absolute;top:0;left:0;right:0;bottom:0}.slider.fullscreen ul.slides{height:100%}.slider.fullscreen ul.indicators{z-index:2;bottom:30px}.slider .slides{background-color:#9e9e9e;margin:0;height:400px}.slider .slides li{opacity:0;position:absolute;top:0;left:0;z-index:1;width:100%;height:inherit;overflow:hidden}.slider .slides li img{height:100%;width:100%;background-size:cover;background-position:50%}.slider .slides li .caption{color:#fff;position:absolute;top:15%;left:15%;width:70%;opacity:0}.slider .slides li .caption p{color:#e0e0e0}.slider .slides li.active{z-index:2}.slider .indicators{position:absolute;text-align:center;left:0;right:0;bottom:0;margin:0}.slider .indicators .indicator-item{display:inline-block;position:relative;cursor:pointer;height:16px;width:16px;margin:0 12px;background-color:#e0e0e0;transition:background-color .3s;border-radius:50%}.slider .indicators .indicator-item.active{background-color:#4caf50}.carousel{overflow:hidden;position:relative;width:100%;height:400px;-webkit-perspective:500px;perspective:500px;-webkit-transform-style:preserve-3d;transform-style:preserve-3d;-webkit-transform-origin:0 50%;transform-origin:0 50%}.carousel .carousel-item{width:200px;position:absolute;top:0;left:0}.carousel .carousel-item img{width:100%}.carousel.carousel-slider{top:0;left:0;height:0}.carousel.carousel-slider .carousel-item{width:100%;height:100%;position:absolute;top:0;left:0}.picker{font-size:16px;text-align:left;line-height:1.2;color:#000;position:absolute;z-index:10000;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.picker__input{cursor:default}.picker__input.picker__input--active{border-color:#0089ec}.picker__holder{width:100%;overflow-y:auto;-webkit-overflow-scrolling:touch}\n\n/*!\n * Default mobile-first, responsive styling for pickadate.js\n * Demo: http://amsul.github.io/pickadate.js\n */.picker__frame,.picker__holder{bottom:0;left:0;right:0;top:100%}.picker__holder{position:fixed;transition:background .15s ease-out,top 0s .15s;-webkit-backface-visibility:hidden}.picker__frame{position:absolute;margin:0 auto;min-width:256px;width:300px;max-height:350px;-ms-filter:\"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)\";filter:alpha(opacity=0);-moz-opacity:0;opacity:0;transition:all .15s ease-out}@media (min-height:28.875em){.picker__frame{overflow:visible;top:auto;bottom:-100%;max-height:80%}}@media (min-height:40.125em){.picker__frame{margin-bottom:7.5%}}.picker__wrap{display:table;width:100%;height:100%}@media (min-height:28.875em){.picker__wrap{display:block}}.picker__box{background:#fff;display:table-cell;vertical-align:middle}@media (min-height:28.875em){.picker__box{display:block;border:1px solid #777;border-top-color:#898989;border-bottom-width:0;border-radius:5px 5px 0 0;box-shadow:0 12px 36px 16px rgba(0,0,0,.24)}}.picker--opened .picker__holder{top:0;background:transparent;-ms-filter:\"progid:DXImageTransform.Microsoft.gradient(startColorstr=#1E000000,endColorstr=#1E000000)\";zoom:1;background:rgba(0,0,0,.32);transition:background .15s ease-out}.picker--opened .picker__frame{top:0;-ms-filter:\"progid:DXImageTransform.Microsoft.Alpha(Opacity=100)\";filter:alpha(opacity=100);-moz-opacity:1;opacity:1}@media (min-height:35.875em){.picker--opened .picker__frame{top:10%;bottom:auto}}.picker__input.picker__input--active{border-color:#e3f2fd}.picker__frame{margin:0 auto;max-width:325px}@media (min-height:38.875em){.picker--opened .picker__frame{top:10%;bottom:auto}}.picker__box{padding:0 1em}.picker__header{text-align:center;position:relative;margin-top:.75em}.picker__month,.picker__year{display:inline-block;margin-left:.25em;margin-right:.25em}.picker__select--month,.picker__select--year{height:2em;padding:0;margin-left:.25em;margin-right:.25em}.picker__select--month.browser-default{display:inline;background-color:#fff;width:40%}.picker__select--year.browser-default{display:inline;background-color:#fff;width:26%}.picker__select--month:focus,.picker__select--year:focus{border-color:rgba(0,0,0,.05)}.picker__nav--next,.picker__nav--prev{position:absolute;padding:.5em 1.25em;width:1em;height:1em;box-sizing:content-box;top:-.25em}.picker__nav--prev{left:-1em;padding-right:1.25em}.picker__nav--next{right:-1em;padding-left:1.25em}.picker__nav--disabled,.picker__nav--disabled:before,.picker__nav--disabled:before:hover,.picker__nav--disabled:hover{cursor:default;background:none;border-right-color:#f5f5f5;border-left-color:#f5f5f5}.picker__table{border-collapse:collapse;border-spacing:0;table-layout:fixed;font-size:1rem;width:100%;margin-top:.75em;margin-bottom:.5em}.picker__table,.picker__table td,.picker__table th{text-align:center}.picker__table td{margin:0;padding:0}.picker__weekday{width:14.285714286%;font-size:.75em;padding-bottom:.25em;color:#999;font-weight:500}@media (min-height:33.875em){.picker__weekday{padding-bottom:.5em}}.picker__day--today{position:relative;color:#595959;letter-spacing:-.3;padding:.75rem 0;font-weight:400;border:1px solid transparent}.picker__day--disabled:before{border-top-color:#aaa}.picker__day--infocus:hover{cursor:pointer;color:#000;font-weight:500}.picker__day--outfocus{display:none;padding:.75rem 0;color:#fff}.picker__day--outfocus:hover{cursor:pointer;color:#ddd;font-weight:500}.picker--focused .picker__day--highlighted,.picker__day--highlighted:hover{cursor:pointer}.picker--focused .picker__day--selected,.picker__day--selected,.picker__day--selected:hover{border-radius:50%;-webkit-transform:scale(.75);transform:scale(.75);background:#0089ec;color:#fff}.picker--focused .picker__day--disabled,.picker__day--disabled,.picker__day--disabled:hover{background:#f5f5f5;border-color:#f5f5f5;color:#ddd;cursor:default}.picker__day--highlighted.picker__day--disabled,.picker__day--highlighted.picker__day--disabled:hover{background:#bbb}.picker__footer{text-align:center;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between}.picker__button--clear,.picker__button--close,.picker__button--today{border:1px solid #fff;background:#fff;font-size:.8em;padding:.66em 0;font-weight:700;width:33%;display:inline-block;vertical-align:bottom}.picker__button--clear:hover,.picker__button--close:hover,.picker__button--today:hover{cursor:pointer;color:#000;background:#b1dcfb;border-bottom-color:#b1dcfb}.picker__button--clear:focus,.picker__button--close:focus,.picker__button--today:focus{background:#b1dcfb;border-color:rgba(0,0,0,.05);outline:none}.picker__button--clear:before,.picker__button--close:before,.picker__button--today:before{position:relative;display:inline-block;height:0}.picker__button--clear:before,.picker__button--today:before{content:\" \";margin-right:.45em}.picker__button--today:before{top:-.05em;width:0;border-top:.66em solid #0059bc;border-left:.66em solid transparent}.picker__button--clear:before{top:-.25em;width:.66em;border-top:3px solid #e20}.picker__button--close:before{content:\"\\D7\";top:-.1em;vertical-align:top;font-size:1.1em;margin-right:.35em;color:#777}.picker__button--today[disabled],.picker__button--today[disabled]:hover{background:#f5f5f5;border-color:#f5f5f5;color:#ddd;cursor:default}.picker__button--today[disabled]:before{border-top-color:#aaa}.picker__box{border-radius:2px;overflow:hidden}.picker__date-display{text-align:center;background-color:#26a69a;color:#fff;padding-bottom:15px;font-weight:300}.picker__nav--next:hover,.picker__nav--prev:hover{cursor:pointer;color:#000;background:#a1ded8}.picker__weekday-display{background-color:#1f897f;padding:10px;font-weight:200;letter-spacing:.5;font-size:1rem;margin-bottom:15px}.picker__month-display{text-transform:uppercase;font-size:2rem}.picker__day-display{font-size:4.5rem;font-weight:400}.picker__year-display{font-size:1.8rem;color:hsla(0,0%,100%,.4)}.picker__box{padding:0}.picker__calendar-container{padding:0 1rem}.picker__calendar-container thead{border:none}.picker__table{margin-top:0;margin-bottom:.5em}.picker__day--infocus{color:#595959;letter-spacing:-.3;padding:.75rem 0;font-weight:400;border:1px solid transparent}.picker__day.picker__day--today{color:#26a69a}.picker__day.picker__day--today.picker__day--selected{color:#fff}.picker__weekday{font-size:.9rem}.picker--focused .picker__day--selected,.picker__day--selected,.picker__day--selected:hover{border-radius:50%;-webkit-transform:scale(.9);transform:scale(.9);background-color:#26a69a;color:#fff}.picker--focused .picker__day--selected.picker__day--outfocus,.picker__day--selected.picker__day--outfocus,.picker__day--selected:hover.picker__day--outfocus{background-color:#a1ded8}.picker__footer{text-align:right;padding:5px 10px}.picker__close,.picker__today{font-size:1.1rem;padding:0 1rem;color:#26a69a}.picker__nav--next:before,.picker__nav--prev:before{content:\" \";border-top:.5em solid transparent;border-bottom:.5em solid transparent;border-right:.75em solid #676767;width:0;height:0;display:block;margin:0 auto}.picker__nav--next:before{border-right:0;border-left:.75em solid #676767}button.picker__clear:focus,button.picker__close:focus,button.picker__today:focus{background-color:#a1ded8}.picker__list{list-style:none;padding:.75em 0 4.2em;margin:0}.picker__list-item{border-bottom:1px solid #ddd;border-top:1px solid #ddd;margin-bottom:-1px;position:relative;background:#fff;padding:.75em 1.25em}@media (min-height:46.75em){.picker__list-item{padding:.5em 1em}}.picker__list-item:hover{cursor:pointer;color:#000;background:#b1dcfb}.picker__list-item--highlighted,.picker__list-item:hover{border-color:#0089ec;z-index:10}.picker--focused .picker__list-item--highlighted,.picker__list-item--highlighted:hover{cursor:pointer;color:#000;background:#b1dcfb}.picker--focused .picker__list-item--selected,.picker__list-item--selected,.picker__list-item--selected:hover{background:#0089ec;color:#fff;z-index:10}.picker--focused .picker__list-item--disabled,.picker__list-item--disabled,.picker__list-item--disabled:hover{background:#f5f5f5;border-color:#f5f5f5;color:#ddd;cursor:default;border-color:#ddd;z-index:auto}.picker--time .picker__button--clear{display:block;width:80%;margin:1em auto 0;padding:1em 1.25em;background:none;border:0;font-weight:500;font-size:.67em;text-align:center;text-transform:uppercase;color:#666}.picker--time .picker__button--clear:focus,.picker--time .picker__button--clear:hover{color:#000;background:#b1dcfb;background:#e20;border-color:#e20;cursor:pointer;color:#fff;outline:none}.picker--time .picker__button--clear:before{top:-.25em;color:#666;font-size:1.25em;font-weight:700}.picker--time .picker__button--clear:focus:before,.picker--time .picker__button--clear:hover:before{color:#fff}.picker--time .picker__frame{min-width:256px;max-width:320px}.picker--time .picker__box{font-size:1em;background:#f2f2f2;padding:0}@media (min-height:40.125em){.picker--time .picker__box{margin-bottom:5em}}", ""]);

	// exports


/***/ },
/* 14 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "dfe56a876d0282555d1e2458e278060f.eot";

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "954bbdeb86483e4ffea00c4591530ece.woff2";

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "7500519de3d82e33d1587f8042e2afcb.woff";

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "94998475f6aea65f558494802416c1cf.ttf";

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "a990f611f2305dc12965f186c2ef2690.eot";

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "69f8a0617ac472f78e45841323a3df9e.woff2";

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "3b813c2ae0d04909a33a18d792912ee7.woff";

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "46e48ce0628835f68a7369d0254e4283.ttf";

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "30799efa5bf74129468ad4e257551dc3.eot";

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "2751ee43015f9884c3642f103b7f70c9.woff2";

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ba3dcd8903e3d0af5de7792777f8ae0d.woff";

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "df7b648ce5356ea1ebce435b3459fd60.ttf";

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "4d9f3f9e5195e7b074bb63ba4ce42208.eot";

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "574fd0b50367f886d359e8264938fc37.woff2";

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "fc78759e93a6cac50458610e3d9d63a0.woff";

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "894a2ede85a483bf9bedefd4db45cdb9.ttf";

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ecdd509cadbf1ea78b8d2e31ec52328c.eot";

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "39b2c3031be6b4ea96e2e3e95d307814.woff2";

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "dc81817def276b4f21395f7ea5e88dcd.woff";

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "e31fcf1885e371e19f5786c2bdfeae1b.ttf";

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();

		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}

	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}

	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}

	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	var replaceText = (function () {
		var textStore = [];

		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;

		if(media) {
			styleElement.setAttribute("media", media)
		}

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}

	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;

		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}

		var blob = new Blob([css], { type: "text/css" });

		var oldSrc = linkElement.href;

		linkElement.href = URL.createObjectURL(blob);

		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;/* WEBPACK VAR INJECTION */(function($, process, global) {/*!
	(The MIT License)

	Copyright (c) 2012-2014 Marcin Warpechowski
	Copyright (c) 2015 Handsoncode sp. z o.o. <hello@handsoncode.net>

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	'Software'), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:

	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	*/
	(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Handsontable = f()}})(function(){var define,module,exports;return (function outer (modules, cache, entry) {
	  // Save the require from previous bundle to this closure if any
	  var previousRequire = typeof require == "function" && require;
	  var globalNS = JSON.parse('{"zeroclipboard":"ZeroClipboard","moment":"moment","pikaday":"Pikaday"}') || {};

	  function newRequire(name, jumped){
	    if(!cache[name]) {

	      if(!modules[name]) {
	        // if we cannot find the the module within our internal map or
	        // cache jump to the current global require ie. the last bundle
	        // that was added to the page.
	        var currentRequire = typeof require == "function" && require;
	        if (!jumped && currentRequire) return require(name, true);

	        // If there are other bundles on this page the require from the
	        // previous one is saved to 'previousRequire'. Repeat this as
	        // many times as there are bundles until the module is found or
	        // we exhaust the require chain.
	        if (previousRequire) return require(name, true);

	        // Try to find module from global scope
	        if (globalNS[name] && typeof window[globalNS[name]] !== 'undefined') {
	          return window[globalNS[name]];
	        }

	        var err = new Error('Cannot find module \'' + name + '\'');
	        err.code = 'MODULE_NOT_FOUND';
	        throw err;
	      }
	      var m = cache[name] = {exports:{}};
	      modules[name][0].call(m.exports, function(x){
	        var id = modules[name][1][x];
	        return newRequire(id ? id : x);
	      },m,m.exports,outer,modules,cache,entry);
	    }

	    return cache[name].exports;
	  }
	  for(var i=0;i<entry.length;i++) newRequire(entry[i]);

	  // Override the current require with this new one
	  return newRequire;
	})
	({1:[function(_dereq_,module,exports){
	if (window.jQuery) {
	  $.fn.handsontable = function (action) {
	    var i,
	      ilen,
	      args,
	      output,
	      userSettings,
	      $this = this.first(), // Use only first element from list
	      instance = $this.data('handsontable');

	    // Init case
	    if (typeof action !== 'string') {
	      userSettings = action || {};

	      if (instance) {
	        instance.updateSettings(userSettings);

	      } else {
	        instance = new Handsontable.Core($this[0], userSettings);
	        $this.data('handsontable', instance);
	        instance.init();
	      }

	      return $this;

	    } else { // Action case
	      args = [];

	      if (arguments.length > 1) {
	        for (i = 1, ilen = arguments.length; i < ilen; i++) {
	          args.push(arguments[i]);
	        }
	      }

	      if (instance) {
	        if (typeof instance[action] !== 'undefined') {
	          output = instance[action].apply(instance, args);

	          if (action === 'destroy'){
	            $this.removeData();
	          }

	        } else {
	          throw new Error('Handsontable do not provide action: ' + action);
	        }
	      }

	      return output;
	    }
	  };
	}



	},{}],2:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableBorder: {get: function() {
	      return WalkontableBorder;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47__46__46__47__46__46__47_helpers_47_browser__,
	    $___46__46__47__46__46__47__46__46__47_eventManager__,
	    $__cell_47_coords__,
	    $__overlay_47__95_base_46_js__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    getComputedStyle = $__0.getComputedStyle,
	    getTrimmingContainer = $__0.getTrimmingContainer,
	    innerWidth = $__0.innerWidth,
	    innerHeight = $__0.innerHeight,
	    offset = $__0.offset,
	    outerHeight = $__0.outerHeight,
	    outerWidth = $__0.outerWidth;
	var stopImmediatePropagation = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_event__}).stopImmediatePropagation;
	var isMobileBrowser = ($___46__46__47__46__46__47__46__46__47_helpers_47_browser__ = _dereq_("helpers/browser"), $___46__46__47__46__46__47__46__46__47_helpers_47_browser__ && $___46__46__47__46__46__47__46__46__47_helpers_47_browser__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_browser__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_browser__}).isMobileBrowser;
	var EventManager = ($___46__46__47__46__46__47__46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47__46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47__46__46__47_eventManager__}).EventManager;
	var WalkontableCellCoords = ($__cell_47_coords__ = _dereq_("cell/coords"), $__cell_47_coords__ && $__cell_47_coords__.__esModule && $__cell_47_coords__ || {default: $__cell_47_coords__}).WalkontableCellCoords;
	var WalkontableOverlay = ($__overlay_47__95_base_46_js__ = _dereq_("overlay/_base.js"), $__overlay_47__95_base_46_js__ && $__overlay_47__95_base_46_js__.__esModule && $__overlay_47__95_base_46_js__ || {default: $__overlay_47__95_base_46_js__}).WalkontableOverlay;
	var WalkontableBorder = function WalkontableBorder(wotInstance, settings) {
	  if (!settings) {
	    return;
	  }
	  this.eventManager = new EventManager(wotInstance);
	  this.instance = wotInstance;
	  this.wot = wotInstance;
	  this.settings = settings;
	  this.mouseDown = false;
	  this.main = null;
	  this.top = null;
	  this.left = null;
	  this.bottom = null;
	  this.right = null;
	  this.topStyle = null;
	  this.leftStyle = null;
	  this.bottomStyle = null;
	  this.rightStyle = null;
	  this.cornerDefaultStyle = {
	    width: '5px',
	    height: '5px',
	    borderWidth: '2px',
	    borderStyle: 'solid',
	    borderColor: '#FFF'
	  };
	  this.corner = null;
	  this.cornerStyle = null;
	  this.createBorders(settings);
	  this.registerListeners();
	};
	($traceurRuntime.createClass)(WalkontableBorder, {
	  registerListeners: function() {
	    var $__6 = this;
	    this.eventManager.addEventListener(document.body, 'mousedown', (function() {
	      return $__6.onMouseDown();
	    }));
	    this.eventManager.addEventListener(document.body, 'mouseup', (function() {
	      return $__6.onMouseUp();
	    }));
	    var $__8 = this,
	        $__9 = function(c, len) {
	          $__8.eventManager.addEventListener($__8.main.childNodes[c], 'mouseenter', (function(event) {
	            return $__6.onMouseEnter(event, $__6.main.childNodes[c]);
	          }));
	        };
	    for (var c = 0,
	        len = this.main.childNodes.length; c < len; c++) {
	      $__9(c, len);
	    }
	  },
	  onMouseDown: function() {
	    this.mouseDown = true;
	  },
	  onMouseUp: function() {
	    this.mouseDown = false;
	  },
	  onMouseEnter: function(event, parentElement) {
	    if (!this.mouseDown || !this.wot.getSetting('hideBorderOnMouseDownOver')) {
	      return;
	    }
	    event.preventDefault();
	    stopImmediatePropagation(event);
	    var _this = this;
	    var bounds = parentElement.getBoundingClientRect();
	    parentElement.style.display = 'none';
	    function isOutside(event) {
	      if (event.clientY < Math.floor(bounds.top)) {
	        return true;
	      }
	      if (event.clientY > Math.ceil(bounds.top + bounds.height)) {
	        return true;
	      }
	      if (event.clientX < Math.floor(bounds.left)) {
	        return true;
	      }
	      if (event.clientX > Math.ceil(bounds.left + bounds.width)) {
	        return true;
	      }
	    }
	    function handler(event) {
	      if (isOutside(event)) {
	        _this.eventManager.removeEventListener(document.body, 'mousemove', handler);
	        parentElement.style.display = 'block';
	      }
	    }
	    this.eventManager.addEventListener(document.body, 'mousemove', handler);
	  },
	  createBorders: function(settings) {
	    this.main = document.createElement('div');
	    var borderDivs = ['top', 'left', 'bottom', 'right', 'corner'];
	    var style = this.main.style;
	    style.position = 'absolute';
	    style.top = 0;
	    style.left = 0;
	    for (var i = 0; i < 5; i++) {
	      var position = borderDivs[i];
	      var div = document.createElement('div');
	      div.className = 'wtBorder ' + (this.settings.className || '');
	      if (this.settings[position] && this.settings[position].hide) {
	        div.className += ' hidden';
	      }
	      style = div.style;
	      style.backgroundColor = (this.settings[position] && this.settings[position].color) ? this.settings[position].color : settings.border.color;
	      style.height = (this.settings[position] && this.settings[position].width) ? this.settings[position].width + 'px' : settings.border.width + 'px';
	      style.width = (this.settings[position] && this.settings[position].width) ? this.settings[position].width + 'px' : settings.border.width + 'px';
	      this.main.appendChild(div);
	    }
	    this.top = this.main.childNodes[0];
	    this.left = this.main.childNodes[1];
	    this.bottom = this.main.childNodes[2];
	    this.right = this.main.childNodes[3];
	    this.topStyle = this.top.style;
	    this.leftStyle = this.left.style;
	    this.bottomStyle = this.bottom.style;
	    this.rightStyle = this.right.style;
	    this.corner = this.main.childNodes[4];
	    this.corner.className += ' corner';
	    this.cornerStyle = this.corner.style;
	    this.cornerStyle.width = this.cornerDefaultStyle.width;
	    this.cornerStyle.height = this.cornerDefaultStyle.height;
	    this.cornerStyle.border = [this.cornerDefaultStyle.borderWidth, this.cornerDefaultStyle.borderStyle, this.cornerDefaultStyle.borderColor].join(' ');
	    if (isMobileBrowser()) {
	      this.createMultipleSelectorHandles();
	    }
	    this.disappear();
	    if (!this.wot.wtTable.bordersHolder) {
	      this.wot.wtTable.bordersHolder = document.createElement('div');
	      this.wot.wtTable.bordersHolder.className = 'htBorders';
	      this.wot.wtTable.spreader.appendChild(this.wot.wtTable.bordersHolder);
	    }
	    this.wot.wtTable.bordersHolder.insertBefore(this.main, this.wot.wtTable.bordersHolder.firstChild);
	  },
	  createMultipleSelectorHandles: function() {
	    this.selectionHandles = {
	      topLeft: document.createElement('DIV'),
	      topLeftHitArea: document.createElement('DIV'),
	      bottomRight: document.createElement('DIV'),
	      bottomRightHitArea: document.createElement('DIV')
	    };
	    var width = 10;
	    var hitAreaWidth = 40;
	    this.selectionHandles.topLeft.className = 'topLeftSelectionHandle';
	    this.selectionHandles.topLeftHitArea.className = 'topLeftSelectionHandle-HitArea';
	    this.selectionHandles.bottomRight.className = 'bottomRightSelectionHandle';
	    this.selectionHandles.bottomRightHitArea.className = 'bottomRightSelectionHandle-HitArea';
	    this.selectionHandles.styles = {
	      topLeft: this.selectionHandles.topLeft.style,
	      topLeftHitArea: this.selectionHandles.topLeftHitArea.style,
	      bottomRight: this.selectionHandles.bottomRight.style,
	      bottomRightHitArea: this.selectionHandles.bottomRightHitArea.style
	    };
	    var hitAreaStyle = {
	      position: 'absolute',
	      height: hitAreaWidth + 'px',
	      width: hitAreaWidth + 'px',
	      'border-radius': parseInt(hitAreaWidth / 1.5, 10) + 'px'
	    };
	    for (var prop in hitAreaStyle) {
	      if (hitAreaStyle.hasOwnProperty(prop)) {
	        this.selectionHandles.styles.bottomRightHitArea[prop] = hitAreaStyle[prop];
	        this.selectionHandles.styles.topLeftHitArea[prop] = hitAreaStyle[prop];
	      }
	    }
	    var handleStyle = {
	      position: 'absolute',
	      height: width + 'px',
	      width: width + 'px',
	      'border-radius': parseInt(width / 1.5, 10) + 'px',
	      background: '#F5F5FF',
	      border: '1px solid #4285c8'
	    };
	    for (var prop$__10 in handleStyle) {
	      if (handleStyle.hasOwnProperty(prop$__10)) {
	        this.selectionHandles.styles.bottomRight[prop$__10] = handleStyle[prop$__10];
	        this.selectionHandles.styles.topLeft[prop$__10] = handleStyle[prop$__10];
	      }
	    }
	    this.main.appendChild(this.selectionHandles.topLeft);
	    this.main.appendChild(this.selectionHandles.bottomRight);
	    this.main.appendChild(this.selectionHandles.topLeftHitArea);
	    this.main.appendChild(this.selectionHandles.bottomRightHitArea);
	  },
	  isPartRange: function(row, col) {
	    if (this.wot.selections.area.cellRange) {
	      if (row != this.wot.selections.area.cellRange.to.row || col != this.wot.selections.area.cellRange.to.col) {
	        return true;
	      }
	    }
	    return false;
	  },
	  updateMultipleSelectionHandlesPosition: function(row, col, top, left, width, height) {
	    var handleWidth = parseInt(this.selectionHandles.styles.topLeft.width, 10);
	    var hitAreaWidth = parseInt(this.selectionHandles.styles.topLeftHitArea.width, 10);
	    this.selectionHandles.styles.topLeft.top = parseInt(top - handleWidth, 10) + 'px';
	    this.selectionHandles.styles.topLeft.left = parseInt(left - handleWidth, 10) + 'px';
	    this.selectionHandles.styles.topLeftHitArea.top = parseInt(top - (hitAreaWidth / 4) * 3, 10) + 'px';
	    this.selectionHandles.styles.topLeftHitArea.left = parseInt(left - (hitAreaWidth / 4) * 3, 10) + 'px';
	    this.selectionHandles.styles.bottomRight.top = parseInt(top + height, 10) + 'px';
	    this.selectionHandles.styles.bottomRight.left = parseInt(left + width, 10) + 'px';
	    this.selectionHandles.styles.bottomRightHitArea.top = parseInt(top + height - hitAreaWidth / 4, 10) + 'px';
	    this.selectionHandles.styles.bottomRightHitArea.left = parseInt(left + width - hitAreaWidth / 4, 10) + 'px';
	    if (this.settings.border.multipleSelectionHandlesVisible && this.settings.border.multipleSelectionHandlesVisible()) {
	      this.selectionHandles.styles.topLeft.display = 'block';
	      this.selectionHandles.styles.topLeftHitArea.display = 'block';
	      if (this.isPartRange(row, col)) {
	        this.selectionHandles.styles.bottomRight.display = 'none';
	        this.selectionHandles.styles.bottomRightHitArea.display = 'none';
	      } else {
	        this.selectionHandles.styles.bottomRight.display = 'block';
	        this.selectionHandles.styles.bottomRightHitArea.display = 'block';
	      }
	    } else {
	      this.selectionHandles.styles.topLeft.display = 'none';
	      this.selectionHandles.styles.bottomRight.display = 'none';
	      this.selectionHandles.styles.topLeftHitArea.display = 'none';
	      this.selectionHandles.styles.bottomRightHitArea.display = 'none';
	    }
	    if (row == this.wot.wtSettings.getSetting('fixedRowsTop') || col == this.wot.wtSettings.getSetting('fixedColumnsLeft')) {
	      this.selectionHandles.styles.topLeft.zIndex = '9999';
	      this.selectionHandles.styles.topLeftHitArea.zIndex = '9999';
	    } else {
	      this.selectionHandles.styles.topLeft.zIndex = '';
	      this.selectionHandles.styles.topLeftHitArea.zIndex = '';
	    }
	  },
	  appear: function(corners) {
	    if (this.disabled) {
	      return;
	    }
	    var isMultiple,
	        fromTD,
	        toTD,
	        fromOffset,
	        toOffset,
	        containerOffset,
	        top,
	        minTop,
	        left,
	        minLeft,
	        height,
	        width,
	        fromRow,
	        fromColumn,
	        toRow,
	        toColumn,
	        trimmingContainer,
	        cornerOverlappingContainer,
	        ilen;
	    ilen = this.wot.wtTable.getRenderedRowsCount();
	    for (var i = 0; i < ilen; i++) {
	      var s = this.wot.wtTable.rowFilter.renderedToSource(i);
	      if (s >= corners[0] && s <= corners[2]) {
	        fromRow = s;
	        break;
	      }
	    }
	    for (var i$__11 = ilen - 1; i$__11 >= 0; i$__11--) {
	      var s$__12 = this.wot.wtTable.rowFilter.renderedToSource(i$__11);
	      if (s$__12 >= corners[0] && s$__12 <= corners[2]) {
	        toRow = s$__12;
	        break;
	      }
	    }
	    ilen = this.wot.wtTable.getRenderedColumnsCount();
	    for (var i$__13 = 0; i$__13 < ilen; i$__13++) {
	      var s$__14 = this.wot.wtTable.columnFilter.renderedToSource(i$__13);
	      if (s$__14 >= corners[1] && s$__14 <= corners[3]) {
	        fromColumn = s$__14;
	        break;
	      }
	    }
	    for (var i$__15 = ilen - 1; i$__15 >= 0; i$__15--) {
	      var s$__16 = this.wot.wtTable.columnFilter.renderedToSource(i$__15);
	      if (s$__16 >= corners[1] && s$__16 <= corners[3]) {
	        toColumn = s$__16;
	        break;
	      }
	    }
	    if (fromRow === void 0 || fromColumn === void 0) {
	      this.disappear();
	      return;
	    }
	    isMultiple = (fromRow !== toRow || fromColumn !== toColumn);
	    fromTD = this.wot.wtTable.getCell(new WalkontableCellCoords(fromRow, fromColumn));
	    toTD = isMultiple ? this.wot.wtTable.getCell(new WalkontableCellCoords(toRow, toColumn)) : fromTD;
	    fromOffset = offset(fromTD);
	    toOffset = isMultiple ? offset(toTD) : fromOffset;
	    containerOffset = offset(this.wot.wtTable.TABLE);
	    minTop = fromOffset.top;
	    height = toOffset.top + outerHeight(toTD) - minTop;
	    minLeft = fromOffset.left;
	    width = toOffset.left + outerWidth(toTD) - minLeft;
	    top = minTop - containerOffset.top - 1;
	    left = minLeft - containerOffset.left - 1;
	    var style = getComputedStyle(fromTD);
	    if (parseInt(style.borderTopWidth, 10) > 0) {
	      top += 1;
	      height = height > 0 ? height - 1 : 0;
	    }
	    if (parseInt(style.borderLeftWidth, 10) > 0) {
	      left += 1;
	      width = width > 0 ? width - 1 : 0;
	    }
	    this.topStyle.top = top + 'px';
	    this.topStyle.left = left + 'px';
	    this.topStyle.width = width + 'px';
	    this.topStyle.display = 'block';
	    this.leftStyle.top = top + 'px';
	    this.leftStyle.left = left + 'px';
	    this.leftStyle.height = height + 'px';
	    this.leftStyle.display = 'block';
	    var delta = Math.floor(this.settings.border.width / 2);
	    this.bottomStyle.top = top + height - delta + 'px';
	    this.bottomStyle.left = left + 'px';
	    this.bottomStyle.width = width + 'px';
	    this.bottomStyle.display = 'block';
	    this.rightStyle.top = top + 'px';
	    this.rightStyle.left = left + width - delta + 'px';
	    this.rightStyle.height = height + 1 + 'px';
	    this.rightStyle.display = 'block';
	    if (isMobileBrowser() || (!this.hasSetting(this.settings.border.cornerVisible) || this.isPartRange(toRow, toColumn))) {
	      this.cornerStyle.display = 'none';
	    } else {
	      this.cornerStyle.top = top + height - 4 + 'px';
	      this.cornerStyle.left = left + width - 4 + 'px';
	      this.cornerStyle.borderRightWidth = this.cornerDefaultStyle.borderWidth;
	      this.cornerStyle.width = this.cornerDefaultStyle.width;
	      this.cornerStyle.display = 'block';
	      trimmingContainer = getTrimmingContainer(this.wot.wtTable.TABLE);
	      if (toColumn === this.wot.getSetting('totalColumns') - 1) {
	        cornerOverlappingContainer = toTD.offsetLeft + outerWidth(toTD) >= innerWidth(trimmingContainer);
	        if (cornerOverlappingContainer) {
	          this.cornerStyle.left = Math.floor(left + width - 3 - parseInt(this.cornerDefaultStyle.width) / 2) + 'px';
	          this.cornerStyle.borderRightWidth = 0;
	        }
	      }
	      if (toRow === this.wot.getSetting('totalRows') - 1) {
	        cornerOverlappingContainer = toTD.offsetTop + outerHeight(toTD) >= innerHeight(trimmingContainer);
	        if (cornerOverlappingContainer) {
	          this.cornerStyle.top = Math.floor(top + height - 3 - parseInt(this.cornerDefaultStyle.height) / 2) + 'px';
	          this.cornerStyle.borderBottomWidth = 0;
	        }
	      }
	    }
	    if (isMobileBrowser()) {
	      this.updateMultipleSelectionHandlesPosition(fromRow, fromColumn, top, left, width, height);
	    }
	  },
	  disappear: function() {
	    this.topStyle.display = 'none';
	    this.leftStyle.display = 'none';
	    this.bottomStyle.display = 'none';
	    this.rightStyle.display = 'none';
	    this.cornerStyle.display = 'none';
	    if (isMobileBrowser()) {
	      this.selectionHandles.styles.topLeft.display = 'none';
	      this.selectionHandles.styles.bottomRight.display = 'none';
	    }
	  },
	  hasSetting: function(setting) {
	    if (typeof setting === 'function') {
	      return setting();
	    }
	    return !!setting;
	  }
	}, {});
	;
	window.WalkontableBorder = WalkontableBorder;

	//# 
	},{"cell/coords":5,"eventManager":41,"helpers/browser":43,"helpers/dom/element":46,"helpers/dom/event":47,"overlay/_base.js":11}],3:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableViewportColumnsCalculator: {get: function() {
	      return WalkontableViewportColumnsCalculator;
	    }},
	  __esModule: {value: true}
	});
	var privatePool = new WeakMap();
	var WalkontableViewportColumnsCalculator = function WalkontableViewportColumnsCalculator(viewportWidth, scrollOffset, totalColumns, columnWidthFn, overrideFn, onlyFullyVisible, stretchH) {
	  var stretchingColumnWidthFn = arguments[7] !== (void 0) ? arguments[7] : (function(width) {
	    return width;
	  });
	  privatePool.set(this, {
	    viewportWidth: viewportWidth,
	    scrollOffset: scrollOffset,
	    totalColumns: totalColumns,
	    columnWidthFn: columnWidthFn,
	    overrideFn: overrideFn,
	    onlyFullyVisible: onlyFullyVisible,
	    stretchingColumnWidthFn: stretchingColumnWidthFn
	  });
	  this.count = 0;
	  this.startColumn = null;
	  this.endColumn = null;
	  this.startPosition = null;
	  this.stretchAllRatio = 0;
	  this.stretchLastWidth = 0;
	  this.stretch = stretchH;
	  this.totalTargetWidth = 0;
	  this.needVerifyLastColumnWidth = true;
	  this.stretchAllColumnsWidth = [];
	  this.calculate();
	};
	var $WalkontableViewportColumnsCalculator = WalkontableViewportColumnsCalculator;
	($traceurRuntime.createClass)(WalkontableViewportColumnsCalculator, {
	  calculate: function() {
	    var sum = 0;
	    var needReverse = true;
	    var startPositions = [];
	    var columnWidth;
	    var priv = privatePool.get(this);
	    var onlyFullyVisible = priv.onlyFullyVisible;
	    var overrideFn = priv.overrideFn;
	    var scrollOffset = priv.scrollOffset;
	    var totalColumns = priv.totalColumns;
	    var viewportWidth = priv.viewportWidth;
	    for (var i = 0; i < totalColumns; i++) {
	      columnWidth = this._getColumnWidth(i);
	      if (sum <= scrollOffset && !onlyFullyVisible) {
	        this.startColumn = i;
	      }
	      if (sum >= scrollOffset && sum + columnWidth <= scrollOffset + viewportWidth) {
	        if (this.startColumn == null) {
	          this.startColumn = i;
	        }
	        this.endColumn = i;
	      }
	      startPositions.push(sum);
	      sum += columnWidth;
	      if (!onlyFullyVisible) {
	        this.endColumn = i;
	      }
	      if (sum >= scrollOffset + viewportWidth) {
	        needReverse = false;
	        break;
	      }
	    }
	    if (this.endColumn === totalColumns - 1 && needReverse) {
	      this.startColumn = this.endColumn;
	      while (this.startColumn > 0) {
	        var viewportSum = startPositions[this.endColumn] + columnWidth - startPositions[this.startColumn - 1];
	        if (viewportSum <= viewportWidth || !onlyFullyVisible) {
	          this.startColumn--;
	        }
	        if (viewportSum > viewportWidth) {
	          break;
	        }
	      }
	    }
	    if (this.startColumn !== null && overrideFn) {
	      overrideFn(this);
	    }
	    this.startPosition = startPositions[this.startColumn];
	    if (this.startPosition == void 0) {
	      this.startPosition = null;
	    }
	    if (this.startColumn !== null) {
	      this.count = this.endColumn - this.startColumn + 1;
	    }
	  },
	  refreshStretching: function(totalWidth) {
	    if (this.stretch === 'none') {
	      return;
	    }
	    this.totalTargetWidth = totalWidth;
	    var priv = privatePool.get(this);
	    var totalColumns = priv.totalColumns;
	    var sumAll = 0;
	    for (var i = 0; i < totalColumns; i++) {
	      var columnWidth = this._getColumnWidth(i);
	      var permanentColumnWidth = priv.stretchingColumnWidthFn(void 0, i);
	      if (typeof permanentColumnWidth === 'number') {
	        totalWidth -= permanentColumnWidth;
	      } else {
	        sumAll += columnWidth;
	      }
	    }
	    var remainingSize = totalWidth - sumAll;
	    if (this.stretch === 'all' && remainingSize > 0) {
	      this.stretchAllRatio = totalWidth / sumAll;
	      this.stretchAllColumnsWidth = [];
	      this.needVerifyLastColumnWidth = true;
	    } else if (this.stretch === 'last' && totalWidth !== Infinity) {
	      var columnWidth$__1 = this._getColumnWidth(totalColumns - 1);
	      var lastColumnWidth = remainingSize + columnWidth$__1;
	      this.stretchLastWidth = lastColumnWidth >= 0 ? lastColumnWidth : columnWidth$__1;
	    }
	  },
	  getStretchedColumnWidth: function(column, baseWidth) {
	    var result = null;
	    if (this.stretch === 'all' && this.stretchAllRatio !== 0) {
	      result = this._getStretchedAllColumnWidth(column, baseWidth);
	    } else if (this.stretch === 'last' && this.stretchLastWidth !== 0) {
	      result = this._getStretchedLastColumnWidth(column);
	    }
	    return result;
	  },
	  _getStretchedAllColumnWidth: function(column, baseWidth) {
	    var sumRatioWidth = 0;
	    var priv = privatePool.get(this);
	    var totalColumns = priv.totalColumns;
	    if (!this.stretchAllColumnsWidth[column]) {
	      var stretchedWidth = Math.round(baseWidth * this.stretchAllRatio);
	      var newStretchedWidth = priv.stretchingColumnWidthFn(stretchedWidth, column);
	      if (newStretchedWidth === void 0) {
	        this.stretchAllColumnsWidth[column] = stretchedWidth;
	      } else {
	        this.stretchAllColumnsWidth[column] = isNaN(newStretchedWidth) ? this._getColumnWidth(column) : newStretchedWidth;
	      }
	    }
	    if (this.stretchAllColumnsWidth.length === totalColumns && this.needVerifyLastColumnWidth) {
	      this.needVerifyLastColumnWidth = false;
	      for (var i = 0; i < this.stretchAllColumnsWidth.length; i++) {
	        sumRatioWidth += this.stretchAllColumnsWidth[i];
	      }
	      if (sumRatioWidth !== this.totalTargetWidth) {
	        this.stretchAllColumnsWidth[this.stretchAllColumnsWidth.length - 1] += this.totalTargetWidth - sumRatioWidth;
	      }
	    }
	    return this.stretchAllColumnsWidth[column];
	  },
	  _getStretchedLastColumnWidth: function(column) {
	    var priv = privatePool.get(this);
	    var totalColumns = priv.totalColumns;
	    if (column === totalColumns - 1) {
	      return this.stretchLastWidth;
	    }
	    return null;
	  },
	  _getColumnWidth: function(column) {
	    var width = privatePool.get(this).columnWidthFn(column);
	    if (width === void 0) {
	      width = $WalkontableViewportColumnsCalculator.DEFAULT_WIDTH;
	    }
	    return width;
	  }
	}, {get DEFAULT_WIDTH() {
	    return 50;
	  }});
	;
	window.WalkontableViewportColumnsCalculator = WalkontableViewportColumnsCalculator;

	//# 
	},{}],4:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableViewportRowsCalculator: {get: function() {
	      return WalkontableViewportRowsCalculator;
	    }},
	  __esModule: {value: true}
	});
	var privatePool = new WeakMap();
	var WalkontableViewportRowsCalculator = function WalkontableViewportRowsCalculator(viewportHeight, scrollOffset, totalRows, rowHeightFn, overrideFn, onlyFullyVisible, horizontalScrollbarHeight) {
	  privatePool.set(this, {
	    viewportHeight: viewportHeight,
	    scrollOffset: scrollOffset,
	    totalRows: totalRows,
	    rowHeightFn: rowHeightFn,
	    overrideFn: overrideFn,
	    onlyFullyVisible: onlyFullyVisible,
	    horizontalScrollbarHeight: horizontalScrollbarHeight
	  });
	  this.count = 0;
	  this.startRow = null;
	  this.endRow = null;
	  this.startPosition = null;
	  this.calculate();
	};
	var $WalkontableViewportRowsCalculator = WalkontableViewportRowsCalculator;
	($traceurRuntime.createClass)(WalkontableViewportRowsCalculator, {calculate: function() {
	    var sum = 0;
	    var needReverse = true;
	    var startPositions = [];
	    var priv = privatePool.get(this);
	    var onlyFullyVisible = priv.onlyFullyVisible;
	    var overrideFn = priv.overrideFn;
	    var rowHeightFn = priv.rowHeightFn;
	    var scrollOffset = priv.scrollOffset;
	    var totalRows = priv.totalRows;
	    var viewportHeight = priv.viewportHeight;
	    var horizontalScrollbarHeight = priv.horizontalScrollbarHeight || 0;
	    for (var i = 0; i < totalRows; i++) {
	      var rowHeight = rowHeightFn(i);
	      if (rowHeight === undefined) {
	        rowHeight = $WalkontableViewportRowsCalculator.DEFAULT_HEIGHT;
	      }
	      if (sum <= scrollOffset && !onlyFullyVisible) {
	        this.startRow = i;
	      }
	      if (sum >= scrollOffset && sum + rowHeight <= scrollOffset + viewportHeight - horizontalScrollbarHeight) {
	        if (this.startRow === null) {
	          this.startRow = i;
	        }
	        this.endRow = i;
	      }
	      startPositions.push(sum);
	      sum += rowHeight;
	      if (!onlyFullyVisible) {
	        this.endRow = i;
	      }
	      if (sum >= scrollOffset + viewportHeight - horizontalScrollbarHeight) {
	        needReverse = false;
	        break;
	      }
	    }
	    if (this.endRow === totalRows - 1 && needReverse) {
	      this.startRow = this.endRow;
	      while (this.startRow > 0) {
	        var viewportSum = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1];
	        if (viewportSum <= viewportHeight - horizontalScrollbarHeight || !onlyFullyVisible) {
	          this.startRow--;
	        }
	        if (viewportSum >= viewportHeight - horizontalScrollbarHeight) {
	          break;
	        }
	      }
	    }
	    if (this.startRow !== null && overrideFn) {
	      overrideFn(this);
	    }
	    this.startPosition = startPositions[this.startRow];
	    if (this.startPosition == void 0) {
	      this.startPosition = null;
	    }
	    if (this.startRow !== null) {
	      this.count = this.endRow - this.startRow + 1;
	    }
	  }}, {get DEFAULT_HEIGHT() {
	    return 23;
	  }});
	;
	window.WalkontableViewportRowsCalculator = WalkontableViewportRowsCalculator;

	//# 
	},{}],5:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableCellCoords: {get: function() {
	      return WalkontableCellCoords;
	    }},
	  __esModule: {value: true}
	});
	var WalkontableCellCoords = function WalkontableCellCoords(row, col) {
	  if (typeof row !== 'undefined' && typeof col !== 'undefined') {
	    this.row = row;
	    this.col = col;
	  } else {
	    this.row = null;
	    this.col = null;
	  }
	};
	($traceurRuntime.createClass)(WalkontableCellCoords, {
	  isValid: function(wotInstance) {
	    if (this.row < 0 || this.col < 0) {
	      return false;
	    }
	    if (this.row >= wotInstance.getSetting('totalRows') || this.col >= wotInstance.getSetting('totalColumns')) {
	      return false;
	    }
	    return true;
	  },
	  isEqual: function(cellCoords) {
	    if (cellCoords === this) {
	      return true;
	    }
	    return this.row === cellCoords.row && this.col === cellCoords.col;
	  },
	  isSouthEastOf: function(testedCoords) {
	    return this.row >= testedCoords.row && this.col >= testedCoords.col;
	  },
	  isNorthWestOf: function(testedCoords) {
	    return this.row <= testedCoords.row && this.col <= testedCoords.col;
	  },
	  isSouthWestOf: function(testedCoords) {
	    return this.row >= testedCoords.row && this.col <= testedCoords.col;
	  },
	  isNorthEastOf: function(testedCoords) {
	    return this.row <= testedCoords.row && this.col >= testedCoords.col;
	  }
	}, {});
	;
	window.WalkontableCellCoords = WalkontableCellCoords;

	//# 
	},{}],6:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableCellRange: {get: function() {
	      return WalkontableCellRange;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_cell_47_coords__;
	var WalkontableCellCoords = ($___46__46__47_cell_47_coords__ = _dereq_("cell/coords"), $___46__46__47_cell_47_coords__ && $___46__46__47_cell_47_coords__.__esModule && $___46__46__47_cell_47_coords__ || {default: $___46__46__47_cell_47_coords__}).WalkontableCellCoords;
	var WalkontableCellRange = function WalkontableCellRange(highlight, from, to) {
	  this.highlight = highlight;
	  this.from = from;
	  this.to = to;
	};
	var $WalkontableCellRange = WalkontableCellRange;
	($traceurRuntime.createClass)(WalkontableCellRange, {
	  isValid: function(wotInstance) {
	    return this.from.isValid(wotInstance) && this.to.isValid(wotInstance);
	  },
	  isSingle: function() {
	    return this.from.row === this.to.row && this.from.col === this.to.col;
	  },
	  getHeight: function() {
	    return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;
	  },
	  getWidth: function() {
	    return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;
	  },
	  includes: function(cellCoords) {
	    var $__2 = cellCoords,
	        row = $__2.row,
	        col = $__2.col;
	    var topLeft = this.getTopLeftCorner();
	    var bottomRight = this.getBottomRightCorner();
	    return topLeft.row <= row && bottomRight.row >= row && topLeft.col <= col && bottomRight.col >= col;
	  },
	  includesRange: function(testedRange) {
	    return this.includes(testedRange.getTopLeftCorner()) && this.includes(testedRange.getBottomRightCorner());
	  },
	  isEqual: function(testedRange) {
	    return (Math.min(this.from.row, this.to.row) == Math.min(testedRange.from.row, testedRange.to.row)) && (Math.max(this.from.row, this.to.row) == Math.max(testedRange.from.row, testedRange.to.row)) && (Math.min(this.from.col, this.to.col) == Math.min(testedRange.from.col, testedRange.to.col)) && (Math.max(this.from.col, this.to.col) == Math.max(testedRange.from.col, testedRange.to.col));
	  },
	  overlaps: function(testedRange) {
	    return testedRange.isSouthEastOf(this.getTopLeftCorner()) && testedRange.isNorthWestOf(this.getBottomRightCorner());
	  },
	  isSouthEastOf: function(testedCoords) {
	    return this.getTopLeftCorner().isSouthEastOf(testedCoords) || this.getBottomRightCorner().isSouthEastOf(testedCoords);
	  },
	  isNorthWestOf: function(testedCoords) {
	    return this.getTopLeftCorner().isNorthWestOf(testedCoords) || this.getBottomRightCorner().isNorthWestOf(testedCoords);
	  },
	  expand: function(cellCoords) {
	    var topLeft = this.getTopLeftCorner();
	    var bottomRight = this.getBottomRightCorner();
	    if (cellCoords.row < topLeft.row || cellCoords.col < topLeft.col || cellCoords.row > bottomRight.row || cellCoords.col > bottomRight.col) {
	      this.from = new WalkontableCellCoords(Math.min(topLeft.row, cellCoords.row), Math.min(topLeft.col, cellCoords.col));
	      this.to = new WalkontableCellCoords(Math.max(bottomRight.row, cellCoords.row), Math.max(bottomRight.col, cellCoords.col));
	      return true;
	    }
	    return false;
	  },
	  expandByRange: function(expandingRange) {
	    if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {
	      return false;
	    }
	    var topLeft = this.getTopLeftCorner();
	    var bottomRight = this.getBottomRightCorner();
	    var topRight = this.getTopRightCorner();
	    var bottomLeft = this.getBottomLeftCorner();
	    var expandingTopLeft = expandingRange.getTopLeftCorner();
	    var expandingBottomRight = expandingRange.getBottomRightCorner();
	    var resultTopRow = Math.min(topLeft.row, expandingTopLeft.row);
	    var resultTopCol = Math.min(topLeft.col, expandingTopLeft.col);
	    var resultBottomRow = Math.max(bottomRight.row, expandingBottomRight.row);
	    var resultBottomCol = Math.max(bottomRight.col, expandingBottomRight.col);
	    var finalFrom = new WalkontableCellCoords(resultTopRow, resultTopCol),
	        finalTo = new WalkontableCellCoords(resultBottomRow, resultBottomCol);
	    var isCorner = new $WalkontableCellRange(finalFrom, finalFrom, finalTo).isCorner(this.from, expandingRange),
	        onlyMerge = expandingRange.isEqual(new $WalkontableCellRange(finalFrom, finalFrom, finalTo));
	    if (isCorner && !onlyMerge) {
	      if (this.from.col > finalFrom.col) {
	        finalFrom.col = resultBottomCol;
	        finalTo.col = resultTopCol;
	      }
	      if (this.from.row > finalFrom.row) {
	        finalFrom.row = resultBottomRow;
	        finalTo.row = resultTopRow;
	      }
	    }
	    this.from = finalFrom;
	    this.to = finalTo;
	    return true;
	  },
	  getDirection: function() {
	    if (this.from.isNorthWestOf(this.to)) {
	      return 'NW-SE';
	    } else if (this.from.isNorthEastOf(this.to)) {
	      return 'NE-SW';
	    } else if (this.from.isSouthEastOf(this.to)) {
	      return 'SE-NW';
	    } else if (this.from.isSouthWestOf(this.to)) {
	      return 'SW-NE';
	    }
	  },
	  setDirection: function(direction) {
	    switch (direction) {
	      case 'NW-SE':
	        this.from = this.getTopLeftCorner();
	        this.to = this.getBottomRightCorner();
	        break;
	      case 'NE-SW':
	        this.from = this.getTopRightCorner();
	        this.to = this.getBottomLeftCorner();
	        break;
	      case 'SE-NW':
	        this.from = this.getBottomRightCorner();
	        this.to = this.getTopLeftCorner();
	        break;
	      case 'SW-NE':
	        this.from = this.getBottomLeftCorner();
	        this.to = this.getTopRightCorner();
	        break;
	    }
	  },
	  getTopLeftCorner: function() {
	    return new WalkontableCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
	  },
	  getBottomRightCorner: function() {
	    return new WalkontableCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
	  },
	  getTopRightCorner: function() {
	    return new WalkontableCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
	  },
	  getBottomLeftCorner: function() {
	    return new WalkontableCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
	  },
	  isCorner: function(coords, expandedRange) {
	    if (expandedRange) {
	      if (expandedRange.includes(coords)) {
	        if (this.getTopLeftCorner().isEqual(new WalkontableCellCoords(expandedRange.from.row, expandedRange.from.col)) || this.getTopRightCorner().isEqual(new WalkontableCellCoords(expandedRange.from.row, expandedRange.to.col)) || this.getBottomLeftCorner().isEqual(new WalkontableCellCoords(expandedRange.to.row, expandedRange.from.col)) || this.getBottomRightCorner().isEqual(new WalkontableCellCoords(expandedRange.to.row, expandedRange.to.col))) {
	          return true;
	        }
	      }
	    }
	    return coords.isEqual(this.getTopLeftCorner()) || coords.isEqual(this.getTopRightCorner()) || coords.isEqual(this.getBottomLeftCorner()) || coords.isEqual(this.getBottomRightCorner());
	  },
	  getOppositeCorner: function(coords, expandedRange) {
	    if (!(coords instanceof WalkontableCellCoords)) {
	      return false;
	    }
	    if (expandedRange) {
	      if (expandedRange.includes(coords)) {
	        if (this.getTopLeftCorner().isEqual(new WalkontableCellCoords(expandedRange.from.row, expandedRange.from.col))) {
	          return this.getBottomRightCorner();
	        }
	        if (this.getTopRightCorner().isEqual(new WalkontableCellCoords(expandedRange.from.row, expandedRange.to.col))) {
	          return this.getBottomLeftCorner();
	        }
	        if (this.getBottomLeftCorner().isEqual(new WalkontableCellCoords(expandedRange.to.row, expandedRange.from.col))) {
	          return this.getTopRightCorner();
	        }
	        if (this.getBottomRightCorner().isEqual(new WalkontableCellCoords(expandedRange.to.row, expandedRange.to.col))) {
	          return this.getTopLeftCorner();
	        }
	      }
	    }
	    if (coords.isEqual(this.getBottomRightCorner())) {
	      return this.getTopLeftCorner();
	    } else if (coords.isEqual(this.getTopLeftCorner())) {
	      return this.getBottomRightCorner();
	    } else if (coords.isEqual(this.getTopRightCorner())) {
	      return this.getBottomLeftCorner();
	    } else if (coords.isEqual(this.getBottomLeftCorner())) {
	      return this.getTopRightCorner();
	    }
	  },
	  getBordersSharedWith: function(range) {
	    if (!this.includesRange(range)) {
	      return [];
	    }
	    var thisBorders = {
	      top: Math.min(this.from.row, this.to.row),
	      bottom: Math.max(this.from.row, this.to.row),
	      left: Math.min(this.from.col, this.to.col),
	      right: Math.max(this.from.col, this.to.col)
	    };
	    var rangeBorders = {
	      top: Math.min(range.from.row, range.to.row),
	      bottom: Math.max(range.from.row, range.to.row),
	      left: Math.min(range.from.col, range.to.col),
	      right: Math.max(range.from.col, range.to.col)
	    };
	    var result = [];
	    if (thisBorders.top == rangeBorders.top) {
	      result.push('top');
	    }
	    if (thisBorders.right == rangeBorders.right) {
	      result.push('right');
	    }
	    if (thisBorders.bottom == rangeBorders.bottom) {
	      result.push('bottom');
	    }
	    if (thisBorders.left == rangeBorders.left) {
	      result.push('left');
	    }
	    return result;
	  },
	  getInner: function() {
	    var topLeft = this.getTopLeftCorner();
	    var bottomRight = this.getBottomRightCorner();
	    var out = [];
	    for (var r = topLeft.row; r <= bottomRight.row; r++) {
	      for (var c = topLeft.col; c <= bottomRight.col; c++) {
	        if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {
	          out.push(new WalkontableCellCoords(r, c));
	        }
	      }
	    }
	    return out;
	  },
	  getAll: function() {
	    var topLeft = this.getTopLeftCorner();
	    var bottomRight = this.getBottomRightCorner();
	    var out = [];
	    for (var r = topLeft.row; r <= bottomRight.row; r++) {
	      for (var c = topLeft.col; c <= bottomRight.col; c++) {
	        if (topLeft.row === r && topLeft.col === c) {
	          out.push(topLeft);
	        } else if (bottomRight.row === r && bottomRight.col === c) {
	          out.push(bottomRight);
	        } else {
	          out.push(new WalkontableCellCoords(r, c));
	        }
	      }
	    }
	    return out;
	  },
	  forAll: function(callback) {
	    var topLeft = this.getTopLeftCorner();
	    var bottomRight = this.getBottomRightCorner();
	    for (var r = topLeft.row; r <= bottomRight.row; r++) {
	      for (var c = topLeft.col; c <= bottomRight.col; c++) {
	        var breakIteration = callback(r, c);
	        if (breakIteration === false) {
	          return;
	        }
	      }
	    }
	  }
	}, {});
	;
	window.WalkontableCellRange = WalkontableCellRange;

	//# 
	},{"cell/coords":5}],7:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  Walkontable: {get: function() {
	      return Walkontable;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47__46__46__47_helpers_47_object__,
	    $___46__46__47__46__46__47__46__46__47_helpers_47_string__,
	    $__event__,
	    $__overlays__,
	    $__scroll__,
	    $__settings__,
	    $__table__,
	    $__viewport__,
	    $__overlay_47__95_base_46_js__,
	    $__overlay_47_top_46_js__,
	    $__overlay_47_left_46_js__,
	    $__overlay_47_debug_46_js__,
	    $__overlay_47_topLeftCorner_46_js__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    fastInnerText = $__0.fastInnerText,
	    isVisible = $__0.isVisible,
	    removeClass = $__0.removeClass;
	var objectEach = ($___46__46__47__46__46__47__46__46__47_helpers_47_object__ = _dereq_("helpers/object"), $___46__46__47__46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_object__}).objectEach;
	var $__2 = ($___46__46__47__46__46__47__46__46__47_helpers_47_string__ = _dereq_("helpers/string"), $___46__46__47__46__46__47__46__46__47_helpers_47_string__ && $___46__46__47__46__46__47__46__46__47_helpers_47_string__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_string__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_string__}),
	    toUpperCaseFirst = $__2.toUpperCaseFirst,
	    randomString = $__2.randomString;
	var WalkontableEvent = ($__event__ = _dereq_("event"), $__event__ && $__event__.__esModule && $__event__ || {default: $__event__}).WalkontableEvent;
	var WalkontableOverlays = ($__overlays__ = _dereq_("overlays"), $__overlays__ && $__overlays__.__esModule && $__overlays__ || {default: $__overlays__}).WalkontableOverlays;
	var WalkontableScroll = ($__scroll__ = _dereq_("scroll"), $__scroll__ && $__scroll__.__esModule && $__scroll__ || {default: $__scroll__}).WalkontableScroll;
	var WalkontableSettings = ($__settings__ = _dereq_("settings"), $__settings__ && $__settings__.__esModule && $__settings__ || {default: $__settings__}).WalkontableSettings;
	var WalkontableTable = ($__table__ = _dereq_("table"), $__table__ && $__table__.__esModule && $__table__ || {default: $__table__}).WalkontableTable;
	var WalkontableViewport = ($__viewport__ = _dereq_("viewport"), $__viewport__ && $__viewport__.__esModule && $__viewport__ || {default: $__viewport__}).WalkontableViewport;
	var WalkontableOverlay = ($__overlay_47__95_base_46_js__ = _dereq_("overlay/_base.js"), $__overlay_47__95_base_46_js__ && $__overlay_47__95_base_46_js__.__esModule && $__overlay_47__95_base_46_js__ || {default: $__overlay_47__95_base_46_js__}).WalkontableOverlay;
	var WalkontableTopOverlay = ($__overlay_47_top_46_js__ = _dereq_("overlay/top.js"), $__overlay_47_top_46_js__ && $__overlay_47_top_46_js__.__esModule && $__overlay_47_top_46_js__ || {default: $__overlay_47_top_46_js__}).WalkontableTopOverlay;
	var WalkontableLeftOverlay = ($__overlay_47_left_46_js__ = _dereq_("overlay/left.js"), $__overlay_47_left_46_js__ && $__overlay_47_left_46_js__.__esModule && $__overlay_47_left_46_js__ || {default: $__overlay_47_left_46_js__}).WalkontableLeftOverlay;
	var WalkontableDebugOverlay = ($__overlay_47_debug_46_js__ = _dereq_("overlay/debug.js"), $__overlay_47_debug_46_js__ && $__overlay_47_debug_46_js__.__esModule && $__overlay_47_debug_46_js__ || {default: $__overlay_47_debug_46_js__}).WalkontableDebugOverlay;
	var WalkontableTopLeftCornerOverlay = ($__overlay_47_topLeftCorner_46_js__ = _dereq_("overlay/topLeftCorner.js"), $__overlay_47_topLeftCorner_46_js__ && $__overlay_47_topLeftCorner_46_js__.__esModule && $__overlay_47_topLeftCorner_46_js__ || {default: $__overlay_47_topLeftCorner_46_js__}).WalkontableTopLeftCornerOverlay;
	var Walkontable = function Walkontable(settings) {
	  var originalHeaders = [];
	  this.guid = 'wt_' + randomString();
	  if (settings.cloneSource) {
	    this.cloneSource = settings.cloneSource;
	    this.cloneOverlay = settings.cloneOverlay;
	    this.wtSettings = settings.cloneSource.wtSettings;
	    this.wtTable = new WalkontableTable(this, settings.table, settings.wtRootElement);
	    this.wtScroll = new WalkontableScroll(this);
	    this.wtViewport = settings.cloneSource.wtViewport;
	    this.wtEvent = new WalkontableEvent(this);
	    this.selections = this.cloneSource.selections;
	  } else {
	    this.wtSettings = new WalkontableSettings(this, settings);
	    this.wtTable = new WalkontableTable(this, settings.table);
	    this.wtScroll = new WalkontableScroll(this);
	    this.wtViewport = new WalkontableViewport(this);
	    this.wtEvent = new WalkontableEvent(this);
	    this.selections = this.getSetting('selections');
	    this.wtOverlays = new WalkontableOverlays(this);
	    this.exportSettingsAsClassNames();
	  }
	  if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {
	    for (var c = 0,
	        clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {
	      originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);
	    }
	    if (!this.getSetting('columnHeaders').length) {
	      this.update('columnHeaders', [function(column, TH) {
	        fastInnerText(TH, originalHeaders[column]);
	      }]);
	    }
	  }
	  this.drawn = false;
	  this.drawInterrupted = false;
	};
	($traceurRuntime.createClass)(Walkontable, {
	  draw: function() {
	    var fastDraw = arguments[0] !== (void 0) ? arguments[0] : false;
	    this.drawInterrupted = false;
	    if (!fastDraw && !isVisible(this.wtTable.TABLE)) {
	      this.drawInterrupted = true;
	    } else {
	      this.wtTable.draw(fastDraw);
	    }
	    return this;
	  },
	  getCell: function(coords) {
	    var topmost = arguments[1] !== (void 0) ? arguments[1] : false;
	    if (!topmost) {
	      return this.wtTable.getCell(coords);
	    }
	    var totalRows = this.wtSettings.getSetting('totalRows');
	    var fixedRowsTop = this.wtSettings.getSetting('fixedRowsTop');
	    var fixedRowsBottom = this.wtSettings.getSetting('fixedRowsBottom');
	    var fixedColumns = this.wtSettings.getSetting('fixedColumnsLeft');
	    if (coords.row < fixedRowsTop && coords.col < fixedColumns) {
	      return this.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell(coords);
	    } else if (coords.row < fixedRowsTop) {
	      return this.wtOverlays.topOverlay.clone.wtTable.getCell(coords);
	    } else if (coords.col < fixedColumns && coords.row >= totalRows - fixedRowsBottom) {
	      if (this.wtOverlays.bottomLeftCornerOverlay.clone) {
	        return this.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.getCell(coords);
	      }
	    } else if (coords.col < fixedColumns) {
	      return this.wtOverlays.leftOverlay.clone.wtTable.getCell(coords);
	    } else if (coords.row < totalRows && coords.row > totalRows - fixedRowsBottom) {
	      if (this.wtOverlays.bottomOverlay.clone) {
	        return this.wtOverlays.bottomOverlay.clone.wtTable.getCell(coords);
	      }
	    }
	    return this.wtTable.getCell(coords);
	  },
	  update: function(settings, value) {
	    return this.wtSettings.update(settings, value);
	  },
	  scrollVertical: function(row) {
	    this.wtOverlays.topOverlay.scrollTo(row);
	    this.getSetting('onScrollVertically');
	    return this;
	  },
	  scrollHorizontal: function(column) {
	    this.wtOverlays.leftOverlay.scrollTo(column);
	    this.getSetting('onScrollHorizontally');
	    return this;
	  },
	  scrollViewport: function(coords) {
	    this.wtScroll.scrollViewport(coords);
	    return this;
	  },
	  getViewport: function() {
	    return [this.wtTable.getFirstVisibleRow(), this.wtTable.getFirstVisibleColumn(), this.wtTable.getLastVisibleRow(), this.wtTable.getLastVisibleColumn()];
	  },
	  getOverlayName: function() {
	    return this.cloneOverlay ? this.cloneOverlay.type : 'master';
	  },
	  isOverlayName: function(name) {
	    if (this.cloneOverlay) {
	      return this.cloneOverlay.type === name;
	    }
	    return false;
	  },
	  exportSettingsAsClassNames: function() {
	    var $__14 = this;
	    var toExport = {
	      rowHeaders: ['array'],
	      columnHeaders: ['array']
	    };
	    var allClassNames = [];
	    var newClassNames = [];
	    objectEach(toExport, (function(optionType, key) {
	      if (optionType.indexOf('array') > -1 && $__14.getSetting(key).length) {
	        newClassNames.push('ht' + toUpperCaseFirst(key));
	      }
	      allClassNames.push('ht' + toUpperCaseFirst(key));
	    }));
	    removeClass(this.wtTable.wtRootElement.parentNode, allClassNames);
	    addClass(this.wtTable.wtRootElement.parentNode, newClassNames);
	  },
	  getSetting: function(key, param1, param2, param3, param4) {
	    return this.wtSettings.getSetting(key, param1, param2, param3, param4);
	  },
	  hasSetting: function(key) {
	    return this.wtSettings.has(key);
	  },
	  destroy: function() {
	    this.wtOverlays.destroy();
	    this.wtEvent.destroy();
	  }
	}, {});
	;
	window.Walkontable = Walkontable;

	//# 
	},{"event":8,"helpers/dom/element":46,"helpers/object":52,"helpers/string":54,"overlay/_base.js":11,"overlay/debug.js":12,"overlay/left.js":13,"overlay/top.js":14,"overlay/topLeftCorner.js":15,"overlays":16,"scroll":17,"settings":19,"table":20,"viewport":22}],8:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableEvent: {get: function() {
	      return WalkontableEvent;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47__46__46__47_helpers_47_browser__,
	    $___46__46__47__46__46__47__46__46__47_eventManager__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    closest = $__0.closest,
	    hasClass = $__0.hasClass,
	    isChildOf = $__0.isChildOf;
	var isMobileBrowser = ($___46__46__47__46__46__47__46__46__47_helpers_47_browser__ = _dereq_("helpers/browser"), $___46__46__47__46__46__47__46__46__47_helpers_47_browser__ && $___46__46__47__46__46__47__46__46__47_helpers_47_browser__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_browser__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_browser__}).isMobileBrowser;
	var eventManagerObject = ($___46__46__47__46__46__47__46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47__46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47__46__46__47_eventManager__}).eventManager;
	function WalkontableEvent(instance) {
	  var that = this;
	  var eventManager = eventManagerObject(instance);
	  this.instance = instance;
	  var dblClickOrigin = [null, null];
	  this.dblClickTimeout = [null, null];
	  var onMouseDown = function(event) {
	    var cell = that.parentCell(event.realTarget);
	    if (hasClass(event.realTarget, 'corner')) {
	      that.instance.getSetting('onCellCornerMouseDown', event, event.realTarget);
	    } else if (cell.TD) {
	      if (that.instance.hasSetting('onCellMouseDown')) {
	        that.instance.getSetting('onCellMouseDown', event, cell.coords, cell.TD, that.instance);
	      }
	    }
	    if (event.button !== 2) {
	      if (cell.TD) {
	        dblClickOrigin[0] = cell.TD;
	        clearTimeout(that.dblClickTimeout[0]);
	        that.dblClickTimeout[0] = setTimeout(function() {
	          dblClickOrigin[0] = null;
	        }, 1000);
	      }
	    }
	  };
	  var onTouchMove = function(event) {
	    that.instance.touchMoving = true;
	  };
	  var longTouchTimeout;
	  var onTouchStart = function(event) {
	    var container = this;
	    eventManager.addEventListener(this, 'touchmove', onTouchMove);
	    that.checkIfTouchMove = setTimeout(function() {
	      if (that.instance.touchMoving === true) {
	        that.instance.touchMoving = void 0;
	        eventManager.removeEventListener('touchmove', onTouchMove, false);
	        return;
	      } else {
	        onMouseDown(event);
	      }
	    }, 30);
	  };
	  var onMouseOver = function(event) {
	    var table,
	        td,
	        mainWOT;
	    if (that.instance.hasSetting('onCellMouseOver')) {
	      table = that.instance.wtTable.TABLE;
	      td = closest(event.realTarget, ['TD', 'TH'], table);
	      mainWOT = that.instance.cloneSource || that.instance;
	      if (td && td !== mainWOT.lastMouseOver && isChildOf(td, table)) {
	        mainWOT.lastMouseOver = td;
	        that.instance.getSetting('onCellMouseOver', event, that.instance.wtTable.getCoords(td), td, that.instance);
	      }
	    }
	  };
	  var onMouseUp = function(event) {
	    if (event.button !== 2) {
	      var cell = that.parentCell(event.realTarget);
	      if (cell.TD === dblClickOrigin[0] && cell.TD === dblClickOrigin[1]) {
	        if (hasClass(event.realTarget, 'corner')) {
	          that.instance.getSetting('onCellCornerDblClick', event, cell.coords, cell.TD, that.instance);
	        } else {
	          that.instance.getSetting('onCellDblClick', event, cell.coords, cell.TD, that.instance);
	        }
	        dblClickOrigin[0] = null;
	        dblClickOrigin[1] = null;
	      } else if (cell.TD === dblClickOrigin[0]) {
	        dblClickOrigin[1] = cell.TD;
	        clearTimeout(that.dblClickTimeout[1]);
	        that.dblClickTimeout[1] = setTimeout(function() {
	          dblClickOrigin[1] = null;
	        }, 500);
	      }
	    }
	  };
	  var onTouchEnd = function(event) {
	    clearTimeout(longTouchTimeout);
	    event.preventDefault();
	    onMouseUp(event);
	  };
	  eventManager.addEventListener(this.instance.wtTable.holder, 'mousedown', onMouseDown);
	  eventManager.addEventListener(this.instance.wtTable.TABLE, 'mouseover', onMouseOver);
	  eventManager.addEventListener(this.instance.wtTable.holder, 'mouseup', onMouseUp);
	  if (this.instance.wtTable.holder.parentNode.parentNode && isMobileBrowser() && !that.instance.wtTable.isWorkingOnClone()) {
	    var classSelector = '.' + this.instance.wtTable.holder.parentNode.className.split(' ').join('.');
	    eventManager.addEventListener(this.instance.wtTable.holder, 'touchstart', function(event) {
	      that.instance.touchApplied = true;
	      if (isChildOf(event.target, classSelector)) {
	        onTouchStart.call(event.target, event);
	      }
	    });
	    eventManager.addEventListener(this.instance.wtTable.holder, 'touchend', function(event) {
	      that.instance.touchApplied = false;
	      if (isChildOf(event.target, classSelector)) {
	        onTouchEnd.call(event.target, event);
	      }
	    });
	    if (!that.instance.momentumScrolling) {
	      that.instance.momentumScrolling = {};
	    }
	    eventManager.addEventListener(this.instance.wtTable.holder, 'scroll', function(event) {
	      clearTimeout(that.instance.momentumScrolling._timeout);
	      if (!that.instance.momentumScrolling.ongoing) {
	        that.instance.getSetting('onBeforeTouchScroll');
	      }
	      that.instance.momentumScrolling.ongoing = true;
	      that.instance.momentumScrolling._timeout = setTimeout(function() {
	        if (!that.instance.touchApplied) {
	          that.instance.momentumScrolling.ongoing = false;
	          that.instance.getSetting('onAfterMomentumScroll');
	        }
	      }, 200);
	    });
	  }
	  eventManager.addEventListener(window, 'resize', function() {
	    if (that.instance.getSetting('stretchH') !== 'none') {
	      that.instance.draw();
	    }
	  });
	  this.destroy = function() {
	    clearTimeout(this.dblClickTimeout[0]);
	    clearTimeout(this.dblClickTimeout[1]);
	    eventManager.destroy();
	  };
	}
	WalkontableEvent.prototype.parentCell = function(elem) {
	  var cell = {};
	  var TABLE = this.instance.wtTable.TABLE;
	  var TD = closest(elem, ['TD', 'TH'], TABLE);
	  var referenceTABLE = closest(TD, ['TABLE']);
	  if (TD && isChildOf(TD, TABLE) && referenceTABLE == TABLE) {
	    cell.coords = this.instance.wtTable.getCoords(TD);
	    cell.TD = TD;
	  } else if (hasClass(elem, 'wtBorder') && hasClass(elem, 'current')) {
	    cell.coords = this.instance.selections.current.cellRange.highlight;
	    cell.TD = this.instance.wtTable.getCell(cell.coords);
	  } else if (hasClass(elem, 'wtBorder') && hasClass(elem, 'area')) {
	    if (this.instance.selections.area.cellRange) {
	      cell.coords = this.instance.selections.area.cellRange.to;
	      cell.TD = this.instance.wtTable.getCell(cell.coords);
	    }
	  }
	  return cell;
	};
	;
	window.WalkontableEvent = WalkontableEvent;

	//# 
	},{"eventManager":41,"helpers/browser":43,"helpers/dom/element":46}],9:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableColumnFilter: {get: function() {
	      return WalkontableColumnFilter;
	    }},
	  __esModule: {value: true}
	});
	var WalkontableColumnFilter = function WalkontableColumnFilter(offset, total, countTH) {
	  this.offset = offset;
	  this.total = total;
	  this.countTH = countTH;
	};
	($traceurRuntime.createClass)(WalkontableColumnFilter, {
	  offsetted: function(index) {
	    return index + this.offset;
	  },
	  unOffsetted: function(index) {
	    return index - this.offset;
	  },
	  renderedToSource: function(index) {
	    return this.offsetted(index);
	  },
	  sourceToRendered: function(index) {
	    return this.unOffsetted(index);
	  },
	  offsettedTH: function(index) {
	    return index - this.countTH;
	  },
	  unOffsettedTH: function(index) {
	    return index + this.countTH;
	  },
	  visibleRowHeadedColumnToSourceColumn: function(index) {
	    return this.renderedToSource(this.offsettedTH(index));
	  },
	  sourceColumnToVisibleRowHeadedColumn: function(index) {
	    return this.unOffsettedTH(this.sourceToRendered(index));
	  }
	}, {});
	;
	window.WalkontableColumnFilter = WalkontableColumnFilter;

	//# 
	},{}],10:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableRowFilter: {get: function() {
	      return WalkontableRowFilter;
	    }},
	  __esModule: {value: true}
	});
	var WalkontableRowFilter = function WalkontableRowFilter(offset, total, countTH) {
	  this.offset = offset;
	  this.total = total;
	  this.countTH = countTH;
	};
	($traceurRuntime.createClass)(WalkontableRowFilter, {
	  offsetted: function(index) {
	    return index + this.offset;
	  },
	  unOffsetted: function(index) {
	    return index - this.offset;
	  },
	  renderedToSource: function(index) {
	    return this.offsetted(index);
	  },
	  sourceToRendered: function(index) {
	    return this.unOffsetted(index);
	  },
	  offsettedTH: function(index) {
	    return index - this.countTH;
	  },
	  unOffsettedTH: function(index) {
	    return index + this.countTH;
	  },
	  visibleColHeadedRowToSourceRow: function(index) {
	    return this.renderedToSource(this.offsettedTH(index));
	  },
	  sourceRowToVisibleColHeadedRow: function(index) {
	    return this.unOffsettedTH(this.sourceToRendered(index));
	  }
	}, {});
	;
	window.WalkontableRowFilter = WalkontableRowFilter;

	//# 
	},{}],11:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableOverlay: {get: function() {
	      return WalkontableOverlay;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_object__,
	    $___46__46__47__46__46__47__46__46__47__46__46__47_eventManager__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    getScrollableElement = $__0.getScrollableElement,
	    getTrimmingContainer = $__0.getTrimmingContainer;
	var defineGetter = ($___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_object__ = _dereq_("helpers/object"), $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_object__}).defineGetter;
	var eventManagerObject = ($___46__46__47__46__46__47__46__46__47__46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47__46__46__47__46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47__46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47__46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47__46__46__47__46__46__47_eventManager__}).eventManager;
	var registeredOverlays = {};
	var WalkontableOverlay = function WalkontableOverlay(wotInstance) {
	  defineGetter(this, 'wot', wotInstance, {writable: false});
	  this.instance = this.wot;
	  this.type = '';
	  this.mainTableScrollableElement = null;
	  this.TABLE = this.wot.wtTable.TABLE;
	  this.hider = this.wot.wtTable.hider;
	  this.spreader = this.wot.wtTable.spreader;
	  this.holder = this.wot.wtTable.holder;
	  this.wtRootElement = this.wot.wtTable.wtRootElement;
	  this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);
	  this.needFullRender = this.shouldBeRendered();
	  this.areElementSizesAdjusted = false;
	};
	var $WalkontableOverlay = WalkontableOverlay;
	($traceurRuntime.createClass)(WalkontableOverlay, {
	  shouldBeRendered: function() {
	    return true;
	  },
	  updateTrimmingContainer: function() {
	    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);
	  },
	  updateMainScrollableElement: function() {
	    this.mainTableScrollableElement = getScrollableElement(this.wot.wtTable.TABLE);
	  },
	  makeClone: function(direction) {
	    if ($WalkontableOverlay.CLONE_TYPES.indexOf(direction) === -1) {
	      throw new Error('Clone type "' + direction + '" is not supported.');
	    }
	    var clone = document.createElement('DIV');
	    var clonedTable = document.createElement('TABLE');
	    clone.className = 'ht_clone_' + direction + ' handsontable';
	    clone.style.position = 'absolute';
	    clone.style.top = 0;
	    clone.style.left = 0;
	    clone.style.overflow = 'hidden';
	    clonedTable.className = this.wot.wtTable.TABLE.className;
	    clone.appendChild(clonedTable);
	    this.type = direction;
	    this.wot.wtTable.wtRootElement.parentNode.appendChild(clone);
	    var preventOverflow = this.wot.getSetting('preventOverflow');
	    if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === $WalkontableOverlay.CLONE_TOP || preventOverflow === 'vertical' && this.type === $WalkontableOverlay.CLONE_LEFT) {
	      this.mainTableScrollableElement = window;
	    } else {
	      this.mainTableScrollableElement = getScrollableElement(this.wot.wtTable.TABLE);
	    }
	    return new Walkontable({
	      cloneSource: this.wot,
	      cloneOverlay: this,
	      table: clonedTable
	    });
	  },
	  refresh: function() {
	    var fastDraw = arguments[0] !== (void 0) ? arguments[0] : false;
	    var nextCycleRenderFlag = this.shouldBeRendered();
	    if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {
	      this.clone.draw(fastDraw);
	    }
	    this.needFullRender = nextCycleRenderFlag;
	  },
	  destroy: function() {
	    eventManagerObject(this.clone).destroy();
	  }
	}, {
	  get CLONE_TOP() {
	    return 'top';
	  },
	  get CLONE_BOTTOM() {
	    return 'bottom';
	  },
	  get CLONE_LEFT() {
	    return 'left';
	  },
	  get CLONE_TOP_LEFT_CORNER() {
	    return 'top_left_corner';
	  },
	  get CLONE_BOTTOM_LEFT_CORNER() {
	    return 'bottom_left_corner';
	  },
	  get CLONE_DEBUG() {
	    return 'debug';
	  },
	  get CLONE_TYPES() {
	    return [$WalkontableOverlay.CLONE_TOP, $WalkontableOverlay.CLONE_BOTTOM, $WalkontableOverlay.CLONE_LEFT, $WalkontableOverlay.CLONE_TOP_LEFT_CORNER, $WalkontableOverlay.CLONE_BOTTOM_LEFT_CORNER, $WalkontableOverlay.CLONE_DEBUG];
	  },
	  registerOverlay: function(type, overlayClass) {
	    if ($WalkontableOverlay.CLONE_TYPES.indexOf(type) === -1) {
	      throw new Error(("Unsupported overlay (" + type + ")."));
	    }
	    registeredOverlays[type] = overlayClass;
	  },
	  createOverlay: function(type, wot) {
	    return new registeredOverlays[type](wot);
	  },
	  isOverlayTypeOf: function(overlay, type) {
	    if (!overlay || !registeredOverlays[type]) {
	      return false;
	    }
	    return overlay instanceof registeredOverlays[type];
	  }
	});
	;
	window.WalkontableOverlay = WalkontableOverlay;

	//# 
	},{"eventManager":41,"helpers/dom/element":46,"helpers/object":52}],12:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableDebugOverlay: {get: function() {
	      return WalkontableDebugOverlay;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___95_base__;
	var addClass = ($___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}).addClass;
	var WalkontableOverlay = ($___95_base__ = _dereq_("_base"), $___95_base__ && $___95_base__.__esModule && $___95_base__ || {default: $___95_base__}).WalkontableOverlay;
	var WalkontableDebugOverlay = function WalkontableDebugOverlay(wotInstance) {
	  $traceurRuntime.superConstructor($WalkontableDebugOverlay).call(this, wotInstance);
	  this.clone = this.makeClone(WalkontableOverlay.CLONE_DEBUG);
	  this.clone.wtTable.holder.style.opacity = 0.4;
	  this.clone.wtTable.holder.style.textShadow = '0 0 2px #ff0000';
	  addClass(this.clone.wtTable.holder.parentNode, 'wtDebugVisible');
	};
	var $WalkontableDebugOverlay = WalkontableDebugOverlay;
	($traceurRuntime.createClass)(WalkontableDebugOverlay, {}, {}, WalkontableOverlay);
	;
	window.WalkontableDebugOverlay = WalkontableDebugOverlay;
	WalkontableOverlay.registerOverlay(WalkontableOverlay.CLONE_DEBUG, WalkontableDebugOverlay);

	//# 
	},{"_base":11,"helpers/dom/element":46}],13:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableLeftOverlay: {get: function() {
	      return WalkontableLeftOverlay;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___95_base__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    getScrollbarWidth = $__0.getScrollbarWidth,
	    getScrollLeft = $__0.getScrollLeft,
	    getWindowScrollTop = $__0.getWindowScrollTop,
	    hasClass = $__0.hasClass,
	    outerWidth = $__0.outerWidth,
	    innerHeight = $__0.innerHeight,
	    removeClass = $__0.removeClass,
	    setOverlayPosition = $__0.setOverlayPosition,
	    resetCssTransform = $__0.resetCssTransform;
	var WalkontableOverlay = ($___95_base__ = _dereq_("_base"), $___95_base__ && $___95_base__.__esModule && $___95_base__ || {default: $___95_base__}).WalkontableOverlay;
	var WalkontableLeftOverlay = function WalkontableLeftOverlay(wotInstance) {
	  $traceurRuntime.superConstructor($WalkontableLeftOverlay).call(this, wotInstance);
	  this.clone = this.makeClone(WalkontableOverlay.CLONE_LEFT);
	};
	var $WalkontableLeftOverlay = WalkontableLeftOverlay;
	($traceurRuntime.createClass)(WalkontableLeftOverlay, {
	  shouldBeRendered: function() {
	    return this.wot.getSetting('fixedColumnsLeft') || this.wot.getSetting('rowHeaders').length ? true : false;
	  },
	  resetFixedPosition: function() {
	    if (!this.needFullRender || !this.wot.wtTable.holder.parentNode) {
	      return;
	    }
	    var overlayRoot = this.clone.wtTable.holder.parentNode;
	    var headerPosition = 0;
	    var preventOverflow = this.wot.getSetting('preventOverflow');
	    if (this.trimmingContainer === window && (!preventOverflow || preventOverflow !== 'horizontal')) {
	      var box = this.wot.wtTable.hider.getBoundingClientRect();
	      var left = Math.ceil(box.left);
	      var right = Math.ceil(box.right);
	      var finalLeft;
	      var finalTop;
	      finalTop = this.wot.wtTable.hider.style.top;
	      finalTop = finalTop === '' ? 0 : finalTop;
	      if (left < 0 && (right - overlayRoot.offsetWidth) > 0) {
	        finalLeft = -left;
	      } else {
	        finalLeft = 0;
	      }
	      headerPosition = finalLeft;
	      finalLeft = finalLeft + 'px';
	      setOverlayPosition(overlayRoot, finalLeft, finalTop);
	    } else {
	      headerPosition = this.getScrollPosition();
	      resetCssTransform(overlayRoot);
	    }
	    this.adjustHeaderBordersPosition(headerPosition);
	    this.adjustElementsSize();
	  },
	  setScrollPosition: function(pos) {
	    if (this.mainTableScrollableElement === window) {
	      window.scrollTo(pos, getWindowScrollTop());
	    } else {
	      this.mainTableScrollableElement.scrollLeft = pos;
	    }
	  },
	  onScroll: function() {
	    this.wot.getSetting('onScrollVertically');
	  },
	  sumCellSizes: function(from, to) {
	    var sum = 0;
	    var defaultColumnWidth = this.wot.wtSettings.defaultColumnWidth;
	    while (from < to) {
	      sum += this.wot.wtTable.getStretchedColumnWidth(from) || defaultColumnWidth;
	      from++;
	    }
	    return sum;
	  },
	  adjustElementsSize: function() {
	    var force = arguments[0] !== (void 0) ? arguments[0] : false;
	    this.updateTrimmingContainer();
	    if (this.needFullRender || force) {
	      this.adjustRootElementSize();
	      this.adjustRootChildrenSize();
	      if (!force) {
	        this.areElementSizesAdjusted = true;
	      }
	    }
	  },
	  adjustRootElementSize: function() {
	    var masterHolder = this.wot.wtTable.holder;
	    var scrollbarHeight = masterHolder.clientHeight === masterHolder.offsetHeight ? 0 : getScrollbarWidth();
	    var overlayRoot = this.clone.wtTable.holder.parentNode;
	    var overlayRootStyle = overlayRoot.style;
	    var preventOverflow = this.wot.getSetting('preventOverflow');
	    var tableWidth;
	    if (this.trimmingContainer !== window || preventOverflow === 'vertical') {
	      var height = this.wot.wtViewport.getWorkspaceHeight() - scrollbarHeight;
	      height = Math.min(height, innerHeight(this.wot.wtTable.wtRootElement));
	      overlayRootStyle.height = height + 'px';
	    } else {
	      overlayRootStyle.height = '';
	    }
	    this.clone.wtTable.holder.style.height = overlayRootStyle.height;
	    tableWidth = outerWidth(this.clone.wtTable.TABLE);
	    overlayRootStyle.width = (tableWidth === 0 ? tableWidth : tableWidth + 4) + 'px';
	  },
	  adjustRootChildrenSize: function() {
	    var scrollbarWidth = getScrollbarWidth();
	    this.clone.wtTable.hider.style.height = this.hider.style.height;
	    this.clone.wtTable.holder.style.height = this.clone.wtTable.holder.parentNode.style.height;
	    if (scrollbarWidth === 0) {
	      scrollbarWidth = 30;
	    }
	    this.clone.wtTable.holder.style.width = parseInt(this.clone.wtTable.holder.parentNode.style.width, 10) + scrollbarWidth + 'px';
	  },
	  applyToDOM: function() {
	    var total = this.wot.getSetting('totalColumns');
	    if (!this.areElementSizesAdjusted) {
	      this.adjustElementsSize();
	    }
	    if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === 'number') {
	      this.spreader.style.left = this.wot.wtViewport.columnsRenderCalculator.startPosition + 'px';
	    } else if (total === 0) {
	      this.spreader.style.left = '0';
	    } else {
	      throw new Error('Incorrect value of the columnsRenderCalculator');
	    }
	    this.spreader.style.right = '';
	    if (this.needFullRender) {
	      this.syncOverlayOffset();
	    }
	  },
	  syncOverlayOffset: function() {
	    if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === 'number') {
	      this.clone.wtTable.spreader.style.top = this.wot.wtViewport.rowsRenderCalculator.startPosition + 'px';
	    } else {
	      this.clone.wtTable.spreader.style.top = '';
	    }
	  },
	  scrollTo: function(sourceCol, beyondRendered) {
	    var newX = this.getTableParentOffset();
	    var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
	    var mainHolder = sourceInstance.wtTable.holder;
	    var scrollbarCompensation = 0;
	    if (beyondRendered && mainHolder.offsetWidth !== mainHolder.clientWidth) {
	      scrollbarCompensation = getScrollbarWidth();
	    }
	    if (beyondRendered) {
	      newX += this.sumCellSizes(0, sourceCol + 1);
	      newX -= this.wot.wtViewport.getViewportWidth();
	    } else {
	      newX += this.sumCellSizes(this.wot.getSetting('fixedColumnsLeft'), sourceCol);
	    }
	    newX += scrollbarCompensation;
	    this.setScrollPosition(newX);
	  },
	  getTableParentOffset: function() {
	    var preventOverflow = this.wot.getSetting('preventOverflow');
	    var offset = 0;
	    if (!preventOverflow && this.trimmingContainer === window) {
	      offset = this.wot.wtTable.holderOffset.left;
	    }
	    return offset;
	  },
	  getScrollPosition: function() {
	    return getScrollLeft(this.mainTableScrollableElement);
	  },
	  adjustHeaderBordersPosition: function(position) {
	    var masterParent = this.wot.wtTable.holder.parentNode;
	    var rowHeaders = this.wot.getSetting('rowHeaders');
	    var fixedColumnsLeft = this.wot.getSetting('fixedColumnsLeft');
	    if (fixedColumnsLeft && !rowHeaders.length) {
	      addClass(masterParent, 'innerBorderLeft');
	    } else if (!fixedColumnsLeft && rowHeaders.length) {
	      var previousState = hasClass(masterParent, 'innerBorderLeft');
	      if (position) {
	        addClass(masterParent, 'innerBorderLeft');
	      } else {
	        removeClass(masterParent, 'innerBorderLeft');
	      }
	      if (!previousState && position || previousState && !position) {
	        this.wot.wtOverlays.adjustElementsSize();
	      }
	    }
	  }
	}, {}, WalkontableOverlay);
	;
	window.WalkontableLeftOverlay = WalkontableLeftOverlay;
	WalkontableOverlay.registerOverlay(WalkontableOverlay.CLONE_LEFT, WalkontableLeftOverlay);

	//# 
	},{"_base":11,"helpers/dom/element":46}],14:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableTopOverlay: {get: function() {
	      return WalkontableTopOverlay;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___95_base__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    getScrollbarWidth = $__0.getScrollbarWidth,
	    getScrollTop = $__0.getScrollTop,
	    getWindowScrollLeft = $__0.getWindowScrollLeft,
	    hasClass = $__0.hasClass,
	    outerHeight = $__0.outerHeight,
	    innerWidth = $__0.innerWidth,
	    removeClass = $__0.removeClass,
	    setOverlayPosition = $__0.setOverlayPosition,
	    resetCssTransform = $__0.resetCssTransform;
	var WalkontableOverlay = ($___95_base__ = _dereq_("_base"), $___95_base__ && $___95_base__.__esModule && $___95_base__ || {default: $___95_base__}).WalkontableOverlay;
	var WalkontableTopOverlay = function WalkontableTopOverlay(wotInstance) {
	  $traceurRuntime.superConstructor($WalkontableTopOverlay).call(this, wotInstance);
	  this.clone = this.makeClone(WalkontableOverlay.CLONE_TOP);
	};
	var $WalkontableTopOverlay = WalkontableTopOverlay;
	($traceurRuntime.createClass)(WalkontableTopOverlay, {
	  shouldBeRendered: function() {
	    return this.wot.getSetting('fixedRowsTop') || this.wot.getSetting('columnHeaders').length ? true : false;
	  },
	  resetFixedPosition: function() {
	    if (!this.needFullRender || !this.wot.wtTable.holder.parentNode) {
	      return;
	    }
	    var overlayRoot = this.clone.wtTable.holder.parentNode;
	    var headerPosition = 0;
	    var preventOverflow = this.wot.getSetting('preventOverflow');
	    if (this.trimmingContainer === window && (!preventOverflow || preventOverflow !== 'vertical')) {
	      var box = this.wot.wtTable.hider.getBoundingClientRect();
	      var top = Math.ceil(box.top);
	      var bottom = Math.ceil(box.bottom);
	      var finalLeft;
	      var finalTop;
	      finalLeft = this.wot.wtTable.hider.style.left;
	      finalLeft = finalLeft === '' ? 0 : finalLeft;
	      if (top < 0 && (bottom - overlayRoot.offsetHeight) > 0) {
	        finalTop = -top;
	      } else {
	        finalTop = 0;
	      }
	      headerPosition = finalTop;
	      finalTop = finalTop + 'px';
	      setOverlayPosition(overlayRoot, finalLeft, finalTop);
	    } else {
	      headerPosition = this.getScrollPosition();
	      resetCssTransform(overlayRoot);
	    }
	    this.adjustHeaderBordersPosition(headerPosition);
	    this.adjustElementsSize();
	  },
	  setScrollPosition: function(pos) {
	    if (this.mainTableScrollableElement === window) {
	      window.scrollTo(getWindowScrollLeft(), pos);
	    } else {
	      this.mainTableScrollableElement.scrollTop = pos;
	    }
	  },
	  onScroll: function() {
	    this.wot.getSetting('onScrollHorizontally');
	  },
	  sumCellSizes: function(from, to) {
	    var sum = 0;
	    var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;
	    while (from < to) {
	      var height = this.wot.wtTable.getRowHeight(from);
	      sum += height === void 0 ? defaultRowHeight : height;
	      from++;
	    }
	    return sum;
	  },
	  adjustElementsSize: function() {
	    var force = arguments[0] !== (void 0) ? arguments[0] : false;
	    this.updateTrimmingContainer();
	    if (this.needFullRender || force) {
	      this.adjustRootElementSize();
	      this.adjustRootChildrenSize();
	      if (!force) {
	        this.areElementSizesAdjusted = true;
	      }
	    }
	  },
	  adjustRootElementSize: function() {
	    var masterHolder = this.wot.wtTable.holder;
	    var scrollbarWidth = masterHolder.clientWidth === masterHolder.offsetWidth ? 0 : getScrollbarWidth();
	    var overlayRoot = this.clone.wtTable.holder.parentNode;
	    var overlayRootStyle = overlayRoot.style;
	    var preventOverflow = this.wot.getSetting('preventOverflow');
	    var tableHeight;
	    if (this.trimmingContainer !== window || preventOverflow === 'horizontal') {
	      var width = this.wot.wtViewport.getWorkspaceWidth() - scrollbarWidth;
	      width = Math.min(width, innerWidth(this.wot.wtTable.wtRootElement));
	      overlayRootStyle.width = width + 'px';
	    } else {
	      overlayRootStyle.width = '';
	    }
	    this.clone.wtTable.holder.style.width = overlayRootStyle.width;
	    tableHeight = outerHeight(this.clone.wtTable.TABLE);
	    overlayRootStyle.height = (tableHeight === 0 ? tableHeight : tableHeight + 4) + 'px';
	  },
	  adjustRootChildrenSize: function() {
	    var scrollbarWidth = getScrollbarWidth();
	    this.clone.wtTable.hider.style.width = this.hider.style.width;
	    this.clone.wtTable.holder.style.width = this.clone.wtTable.holder.parentNode.style.width;
	    if (scrollbarWidth === 0) {
	      scrollbarWidth = 30;
	    }
	    this.clone.wtTable.holder.style.height = parseInt(this.clone.wtTable.holder.parentNode.style.height, 10) + scrollbarWidth + 'px';
	  },
	  applyToDOM: function() {
	    var total = this.wot.getSetting('totalRows');
	    if (!this.areElementSizesAdjusted) {
	      this.adjustElementsSize();
	    }
	    if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === 'number') {
	      this.spreader.style.top = this.wot.wtViewport.rowsRenderCalculator.startPosition + 'px';
	    } else if (total === 0) {
	      this.spreader.style.top = '0';
	    } else {
	      throw new Error('Incorrect value of the rowsRenderCalculator');
	    }
	    this.spreader.style.bottom = '';
	    if (this.needFullRender) {
	      this.syncOverlayOffset();
	    }
	  },
	  syncOverlayOffset: function() {
	    if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === 'number') {
	      this.clone.wtTable.spreader.style.left = this.wot.wtViewport.columnsRenderCalculator.startPosition + 'px';
	    } else {
	      this.clone.wtTable.spreader.style.left = '';
	    }
	  },
	  scrollTo: function(sourceRow, bottomEdge) {
	    var newY = this.getTableParentOffset();
	    var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
	    var mainHolder = sourceInstance.wtTable.holder;
	    var scrollbarCompensation = 0;
	    if (bottomEdge && mainHolder.offsetHeight !== mainHolder.clientHeight) {
	      scrollbarCompensation = getScrollbarWidth();
	    }
	    if (bottomEdge) {
	      var fixedRowsBottom = this.wot.getSetting('fixedRowsBottom');
	      var fixedRowsTop = this.wot.getSetting('fixedRowsTop');
	      var totalRows = this.wot.getSetting('totalRows');
	      newY += this.sumCellSizes(0, sourceRow + 1);
	      newY -= this.wot.wtViewport.getViewportHeight() - this.sumCellSizes(totalRows - fixedRowsBottom, totalRows);
	      newY += 1;
	    } else {
	      newY += this.sumCellSizes(this.wot.getSetting('fixedRowsTop'), sourceRow);
	    }
	    newY += scrollbarCompensation;
	    this.setScrollPosition(newY);
	  },
	  getTableParentOffset: function() {
	    if (this.mainTableScrollableElement === window) {
	      return this.wot.wtTable.holderOffset.top;
	    } else {
	      return 0;
	    }
	  },
	  getScrollPosition: function() {
	    return getScrollTop(this.mainTableScrollableElement);
	  },
	  adjustHeaderBordersPosition: function(position) {
	    if (this.wot.getSetting('fixedRowsTop') === 0 && this.wot.getSetting('columnHeaders').length > 0) {
	      var masterParent = this.wot.wtTable.holder.parentNode;
	      var previousState = hasClass(masterParent, 'innerBorderTop');
	      if (position || this.wot.getSetting('totalRows') === 0) {
	        addClass(masterParent, 'innerBorderTop');
	      } else {
	        removeClass(masterParent, 'innerBorderTop');
	      }
	      if (!previousState && position || previousState && !position) {
	        this.wot.wtOverlays.adjustElementsSize();
	      }
	    }
	    if (this.wot.getSetting('rowHeaders').length === 0) {
	      var secondHeaderCell = this.clone.wtTable.THEAD.querySelectorAll('th:nth-of-type(2)');
	      if (secondHeaderCell) {
	        for (var i = 0; i < secondHeaderCell.length; i++) {
	          secondHeaderCell[i].style['border-left-width'] = 0;
	        }
	      }
	    }
	  }
	}, {}, WalkontableOverlay);
	;
	window.WalkontableTopOverlay = WalkontableTopOverlay;
	WalkontableOverlay.registerOverlay(WalkontableOverlay.CLONE_TOP, WalkontableTopOverlay);

	//# 
	},{"_base":11,"helpers/dom/element":46}],15:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableTopLeftCornerOverlay: {get: function() {
	      return WalkontableTopLeftCornerOverlay;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___95_base__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    outerHeight = $__0.outerHeight,
	    outerWidth = $__0.outerWidth,
	    setOverlayPosition = $__0.setOverlayPosition,
	    resetCssTransform = $__0.resetCssTransform;
	var WalkontableOverlay = ($___95_base__ = _dereq_("_base"), $___95_base__ && $___95_base__.__esModule && $___95_base__ || {default: $___95_base__}).WalkontableOverlay;
	var WalkontableTopLeftCornerOverlay = function WalkontableTopLeftCornerOverlay(wotInstance) {
	  $traceurRuntime.superConstructor($WalkontableTopLeftCornerOverlay).call(this, wotInstance);
	  this.clone = this.makeClone(WalkontableOverlay.CLONE_TOP_LEFT_CORNER);
	};
	var $WalkontableTopLeftCornerOverlay = WalkontableTopLeftCornerOverlay;
	($traceurRuntime.createClass)(WalkontableTopLeftCornerOverlay, {
	  shouldBeRendered: function() {
	    return (this.wot.getSetting('fixedRowsTop') || this.wot.getSetting('columnHeaders').length) && (this.wot.getSetting('fixedColumnsLeft') || this.wot.getSetting('rowHeaders').length) ? true : false;
	  },
	  resetFixedPosition: function() {
	    this.updateTrimmingContainer();
	    if (!this.wot.wtTable.holder.parentNode) {
	      return;
	    }
	    var overlayRoot = this.clone.wtTable.holder.parentNode;
	    var tableHeight = outerHeight(this.clone.wtTable.TABLE);
	    var tableWidth = outerWidth(this.clone.wtTable.TABLE);
	    var preventOverflow = this.wot.getSetting('preventOverflow');
	    if (this.trimmingContainer === window) {
	      var box = this.wot.wtTable.hider.getBoundingClientRect();
	      var top = Math.ceil(box.top);
	      var left = Math.ceil(box.left);
	      var bottom = Math.ceil(box.bottom);
	      var right = Math.ceil(box.right);
	      var finalLeft = '0';
	      var finalTop = '0';
	      if (!preventOverflow || preventOverflow === 'vertical') {
	        if (left < 0 && (right - overlayRoot.offsetWidth) > 0) {
	          finalLeft = -left + 'px';
	        }
	      }
	      if (!preventOverflow || preventOverflow === 'horizontal') {
	        if (top < 0 && (bottom - overlayRoot.offsetHeight) > 0) {
	          finalTop = -top + 'px';
	        }
	      }
	      setOverlayPosition(overlayRoot, finalLeft, finalTop);
	    } else {
	      resetCssTransform(overlayRoot);
	    }
	    overlayRoot.style.height = (tableHeight === 0 ? tableHeight : tableHeight + 4) + 'px';
	    overlayRoot.style.width = (tableWidth === 0 ? tableWidth : tableWidth + 4) + 'px';
	  }
	}, {}, WalkontableOverlay);
	;
	window.WalkontableTopLeftCornerOverlay = WalkontableTopLeftCornerOverlay;
	WalkontableOverlay.registerOverlay(WalkontableOverlay.CLONE_TOP_LEFT_CORNER, WalkontableTopLeftCornerOverlay);

	//# 
	},{"_base":11,"helpers/dom/element":46}],16:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableOverlays: {get: function() {
	      return WalkontableOverlays;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47__46__46__47_helpers_47_unicode__,
	    $___46__46__47__46__46__47__46__46__47_helpers_47_browser__,
	    $___46__46__47__46__46__47__46__46__47_eventManager__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    getScrollableElement = $__0.getScrollableElement,
	    getScrollbarWidth = $__0.getScrollbarWidth,
	    getScrollLeft = $__0.getScrollLeft,
	    getScrollTop = $__0.getScrollTop;
	var arrayEach = ($___46__46__47__46__46__47__46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47__46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_array__}).arrayEach;
	var isKey = ($___46__46__47__46__46__47__46__46__47_helpers_47_unicode__ = _dereq_("helpers/unicode"), $___46__46__47__46__46__47__46__46__47_helpers_47_unicode__ && $___46__46__47__46__46__47__46__46__47_helpers_47_unicode__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_unicode__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_unicode__}).isKey;
	var isMobileBrowser = ($___46__46__47__46__46__47__46__46__47_helpers_47_browser__ = _dereq_("helpers/browser"), $___46__46__47__46__46__47__46__46__47_helpers_47_browser__ && $___46__46__47__46__46__47__46__46__47_helpers_47_browser__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_browser__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_browser__}).isMobileBrowser;
	var EventManager = ($___46__46__47__46__46__47__46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47__46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47__46__46__47_eventManager__}).EventManager;
	var WalkontableOverlays = function WalkontableOverlays(wotInstance) {
	  this.wot = wotInstance;
	  this.instance = this.wot;
	  this.eventManager = new EventManager(this.wot);
	  this.wot.update('scrollbarWidth', getScrollbarWidth());
	  this.wot.update('scrollbarHeight', getScrollbarWidth());
	  this.scrollableElement = getScrollableElement(this.wot.wtTable.TABLE);
	  this.topOverlay = WalkontableOverlay.createOverlay(WalkontableOverlay.CLONE_TOP, this.wot);
	  if (typeof WalkontableBottomOverlay === 'undefined') {
	    this.bottomOverlay = {needFullRender: false};
	  } else {
	    this.bottomOverlay = WalkontableOverlay.createOverlay(WalkontableOverlay.CLONE_BOTTOM, this.wot);
	  }
	  this.leftOverlay = WalkontableOverlay.createOverlay(WalkontableOverlay.CLONE_LEFT, this.wot);
	  if (this.topOverlay.needFullRender && this.leftOverlay.needFullRender) {
	    this.topLeftCornerOverlay = WalkontableOverlay.createOverlay(WalkontableOverlay.CLONE_TOP_LEFT_CORNER, this.wot);
	  }
	  if (this.bottomOverlay.needFullRender && this.leftOverlay.needFullRender && typeof WalkontableBottomLeftCornerOverlay !== 'undefined') {
	    this.bottomLeftCornerOverlay = WalkontableOverlay.createOverlay(WalkontableOverlay.CLONE_BOTTOM_LEFT_CORNER, this.wot);
	  } else {
	    this.bottomLeftCornerOverlay = {needFullRender: false};
	  }
	  if (this.wot.getSetting('debug')) {
	    this.debug = WalkontableOverlay.createOverlay(WalkontableOverlay.CLONE_DEBUG, this.wot);
	  }
	  this.destroyed = false;
	  this.keyPressed = false;
	  this.spreaderLastSize = {
	    width: null,
	    height: null
	  };
	  this.overlayScrollPositions = {
	    master: {
	      top: 0,
	      left: 0
	    },
	    top: {
	      top: null,
	      left: 0
	    },
	    bottom: {
	      top: null,
	      left: 0
	    },
	    left: {
	      top: 0,
	      left: null
	    }
	  };
	  this.pendingScrollCallbacks = {
	    master: {
	      top: 0,
	      left: 0
	    },
	    top: {left: 0},
	    bottom: {left: 0},
	    left: {top: 0}
	  };
	  this.verticalScrolling = false;
	  this.horizontalScrolling = false;
	  this.delegatedScrollCallback = false;
	  this.registeredListeners = [];
	  this.registerListeners();
	};
	($traceurRuntime.createClass)(WalkontableOverlays, {
	  refreshAll: function() {
	    if (!this.wot.drawn) {
	      return;
	    }
	    if (!this.wot.wtTable.holder.parentNode) {
	      this.destroy();
	      return;
	    }
	    this.wot.draw(true);
	    if (this.verticalScrolling) {
	      this.leftOverlay.onScroll();
	    }
	    if (this.horizontalScrolling) {
	      this.topOverlay.onScroll();
	    }
	    this.verticalScrolling = false;
	    this.horizontalScrolling = false;
	  },
	  registerListeners: function() {
	    var $__5 = this;
	    var topOverlayScrollable = this.topOverlay.mainTableScrollableElement;
	    var leftOverlayScrollable = this.leftOverlay.mainTableScrollableElement;
	    var listenersToRegister = [];
	    listenersToRegister.push([document.documentElement, 'keydown', (function(event) {
	      return $__5.onKeyDown(event);
	    })]);
	    listenersToRegister.push([document.documentElement, 'keyup', (function() {
	      return $__5.onKeyUp();
	    })]);
	    listenersToRegister.push([document, 'visibilitychange', (function() {
	      return $__5.onKeyUp();
	    })]);
	    listenersToRegister.push([topOverlayScrollable, 'scroll', (function(event) {
	      return $__5.onTableScroll(event);
	    })]);
	    if (topOverlayScrollable !== leftOverlayScrollable) {
	      listenersToRegister.push([leftOverlayScrollable, 'scroll', (function(event) {
	        return $__5.onTableScroll(event);
	      })]);
	    }
	    if (this.topOverlay.needFullRender) {
	      listenersToRegister.push([this.topOverlay.clone.wtTable.holder, 'scroll', (function(event) {
	        return $__5.onTableScroll(event);
	      })]);
	      listenersToRegister.push([this.topOverlay.clone.wtTable.holder, 'wheel', (function(event) {
	        return $__5.onTableScroll(event);
	      })]);
	    }
	    if (this.bottomOverlay.needFullRender) {
	      listenersToRegister.push([this.bottomOverlay.clone.wtTable.holder, 'scroll', (function(event) {
	        return $__5.onTableScroll(event);
	      })]);
	      listenersToRegister.push([this.bottomOverlay.clone.wtTable.holder, 'wheel', (function(event) {
	        return $__5.onTableScroll(event);
	      })]);
	    }
	    if (this.leftOverlay.needFullRender) {
	      listenersToRegister.push([this.leftOverlay.clone.wtTable.holder, 'scroll', (function(event) {
	        return $__5.onTableScroll(event);
	      })]);
	      listenersToRegister.push([this.leftOverlay.clone.wtTable.holder, 'wheel', (function(event) {
	        return $__5.onTableScroll(event);
	      })]);
	    }
	    if (this.topOverlay.trimmingContainer !== window && this.leftOverlay.trimmingContainer !== window) {
	      listenersToRegister.push([window, 'wheel', (function(event) {
	        var overlay;
	        var deltaY = event.wheelDeltaY || event.deltaY;
	        var deltaX = event.wheelDeltaX || event.deltaX;
	        if ($__5.topOverlay.clone.wtTable.holder.contains(event.realTarget)) {
	          overlay = 'top';
	        } else if ($__5.bottomOverlay.clone && $__5.bottomOverlay.clone.wtTable.holder.contains(event.realTarget)) {
	          overlay = 'bottom';
	        } else if ($__5.leftOverlay.clone.wtTable.holder.contains(event.realTarget)) {
	          overlay = 'left';
	        }
	        if (overlay == 'top' && deltaY !== 0) {
	          event.preventDefault();
	        } else if (overlay == 'left' && deltaX !== 0) {
	          event.preventDefault();
	        } else if (overlay == 'bottom' && deltaY !== 0) {
	          event.preventDefault();
	        }
	      })]);
	    }
	    while (listenersToRegister.length) {
	      var listener = listenersToRegister.pop();
	      this.eventManager.addEventListener(listener[0], listener[1], listener[2]);
	      this.registeredListeners.push(listener);
	    }
	  },
	  deregisterListeners: function() {
	    while (this.registeredListeners.length) {
	      var listener = this.registeredListeners.pop();
	      this.eventManager.removeEventListener(listener[0], listener[1], listener[2]);
	    }
	  },
	  onTableScroll: function(event) {
	    if (isMobileBrowser()) {
	      return;
	    }
	    var masterHorizontal = this.leftOverlay.mainTableScrollableElement;
	    var masterVertical = this.topOverlay.mainTableScrollableElement;
	    var target = event.target;
	    if (this.keyPressed) {
	      if ((masterVertical !== window && target !== window && !event.target.contains(masterVertical)) || (masterHorizontal !== window && target !== window && !event.target.contains(masterHorizontal))) {
	        return;
	      }
	    }
	    if (event.type === 'scroll') {
	      this.syncScrollPositions(event);
	    } else {
	      this.translateMouseWheelToScroll(event);
	    }
	  },
	  onKeyDown: function(event) {
	    this.keyPressed = isKey(event.keyCode, 'ARROW_UP|ARROW_RIGHT|ARROW_DOWN|ARROW_LEFT');
	  },
	  onKeyUp: function() {
	    this.keyPressed = false;
	  },
	  translateMouseWheelToScroll: function(event) {
	    var topOverlay = this.topOverlay.clone.wtTable.holder;
	    var bottomOverlay = this.bottomOverlay.clone ? this.bottomOverlay.clone.wtTable.holder : null;
	    var leftOverlay = this.leftOverlay.clone.wtTable.holder;
	    var eventMockup = {type: 'wheel'};
	    var tempElem = event.target;
	    var deltaY = event.wheelDeltaY || (-1) * event.deltaY;
	    var deltaX = event.wheelDeltaX || (-1) * event.deltaX;
	    var parentHolder;
	    if (event.deltaMode === 1) {
	      deltaY = deltaY * 120;
	      deltaX = deltaX * 120;
	    }
	    while (tempElem != document && tempElem != null) {
	      if (tempElem.className.indexOf('wtHolder') > -1) {
	        parentHolder = tempElem;
	        break;
	      }
	      tempElem = tempElem.parentNode;
	    }
	    eventMockup.target = parentHolder;
	    if (parentHolder == topOverlay) {
	      this.syncScrollPositions(eventMockup, (-0.2) * deltaY);
	    } else if (parentHolder == bottomOverlay) {
	      this.syncScrollPositions(eventMockup, (-0.2) * deltaY);
	    } else if (parentHolder == leftOverlay) {
	      this.syncScrollPositions(eventMockup, (-0.2) * deltaX);
	    }
	    return false;
	  },
	  syncScrollPositions: function(event) {
	    var fakeScrollValue = arguments[1] !== (void 0) ? arguments[1] : null;
	    if (this.destroyed) {
	      return;
	    }
	    if (arguments.length === 0) {
	      this.syncScrollWithMaster();
	      return;
	    }
	    var masterHorizontal = this.leftOverlay.mainTableScrollableElement;
	    var masterVertical = this.topOverlay.mainTableScrollableElement;
	    var target = event.target;
	    var tempScrollValue = 0;
	    var scrollValueChanged = false;
	    var topOverlay;
	    var leftOverlay;
	    var bottomOverlay;
	    var delegatedScroll = false;
	    var preventOverflow = this.wot.getSetting('preventOverflow');
	    if (this.topOverlay.needFullRender) {
	      topOverlay = this.topOverlay.clone.wtTable.holder;
	    }
	    if (this.bottomOverlay.needFullRender) {
	      bottomOverlay = this.bottomOverlay.clone.wtTable.holder;
	    }
	    if (this.leftOverlay.needFullRender) {
	      leftOverlay = this.leftOverlay.clone.wtTable.holder;
	    }
	    if (target === document) {
	      target = window;
	    }
	    if (target === masterHorizontal || target === masterVertical) {
	      if (preventOverflow) {
	        tempScrollValue = getScrollLeft(this.scrollableElement);
	      } else {
	        tempScrollValue = getScrollLeft(target);
	      }
	      this.horizontalScrolling = true;
	      this.overlayScrollPositions.master.left = tempScrollValue;
	      scrollValueChanged = true;
	      if (this.pendingScrollCallbacks.master.left > 0) {
	        this.pendingScrollCallbacks.master.left--;
	      } else {
	        if (topOverlay && topOverlay.scrollLeft !== tempScrollValue) {
	          if (fakeScrollValue == null) {
	            this.pendingScrollCallbacks.top.left++;
	          }
	          topOverlay.scrollLeft = tempScrollValue;
	          delegatedScroll = (masterHorizontal !== window);
	        }
	        if (bottomOverlay && bottomOverlay.scrollLeft !== tempScrollValue) {
	          if (fakeScrollValue == null) {
	            this.pendingScrollCallbacks.bottom.left++;
	          }
	          bottomOverlay.scrollLeft = tempScrollValue;
	          delegatedScroll = (masterHorizontal !== window);
	        }
	      }
	      tempScrollValue = getScrollTop(target);
	      this.verticalScrolling = true;
	      this.overlayScrollPositions.master.top = tempScrollValue;
	      scrollValueChanged = true;
	      if (this.pendingScrollCallbacks.master.top > 0) {
	        this.pendingScrollCallbacks.master.top--;
	      } else {
	        if (leftOverlay && leftOverlay.scrollTop !== tempScrollValue) {
	          if (fakeScrollValue == null) {
	            this.pendingScrollCallbacks.left.top++;
	          }
	          leftOverlay.scrollTop = tempScrollValue;
	          delegatedScroll = (masterVertical !== window);
	        }
	      }
	    } else if (target === bottomOverlay) {
	      tempScrollValue = getScrollLeft(target);
	      this.horizontalScrolling = true;
	      this.overlayScrollPositions.bottom.left = tempScrollValue;
	      scrollValueChanged = true;
	      if (this.pendingScrollCallbacks.bottom.left > 0) {
	        this.pendingScrollCallbacks.bottom.left--;
	      } else {
	        if (fakeScrollValue == null) {
	          this.pendingScrollCallbacks.master.left++;
	        }
	        masterHorizontal.scrollLeft = tempScrollValue;
	        if (topOverlay && topOverlay.scrollLeft !== tempScrollValue) {
	          if (fakeScrollValue == null) {
	            this.pendingScrollCallbacks.top.left++;
	          }
	          topOverlay.scrollLeft = tempScrollValue;
	          delegatedScroll = (masterVertical !== window);
	        }
	      }
	      if (fakeScrollValue !== null) {
	        scrollValueChanged = true;
	        masterVertical.scrollTop += fakeScrollValue;
	      }
	    } else if (target === topOverlay) {
	      tempScrollValue = getScrollLeft(target);
	      this.horizontalScrolling = true;
	      this.overlayScrollPositions.top.left = tempScrollValue;
	      scrollValueChanged = true;
	      if (this.pendingScrollCallbacks.top.left > 0) {
	        this.pendingScrollCallbacks.top.left--;
	      } else {
	        if (fakeScrollValue == null) {
	          this.pendingScrollCallbacks.master.left++;
	        }
	        masterHorizontal.scrollLeft = tempScrollValue;
	      }
	      if (fakeScrollValue !== null) {
	        scrollValueChanged = true;
	        masterVertical.scrollTop += fakeScrollValue;
	      }
	      if (bottomOverlay && bottomOverlay.scrollLeft !== tempScrollValue) {
	        if (fakeScrollValue == null) {
	          this.pendingScrollCallbacks.bottom.left++;
	        }
	        bottomOverlay.scrollLeft = tempScrollValue;
	        delegatedScroll = (masterVertical !== window);
	      }
	    } else if (target === leftOverlay) {
	      tempScrollValue = getScrollTop(target);
	      if (this.overlayScrollPositions.left.top !== tempScrollValue) {
	        this.verticalScrolling = true;
	        this.overlayScrollPositions.left.top = tempScrollValue;
	        scrollValueChanged = true;
	        if (this.pendingScrollCallbacks.left.top > 0) {
	          this.pendingScrollCallbacks.left.top--;
	        } else {
	          if (fakeScrollValue == null) {
	            this.pendingScrollCallbacks.master.top++;
	          }
	          masterVertical.scrollTop = tempScrollValue;
	        }
	      }
	      if (fakeScrollValue !== null) {
	        scrollValueChanged = true;
	        masterVertical.scrollLeft += fakeScrollValue;
	      }
	    }
	    if (!this.keyPressed && scrollValueChanged && event.type === 'scroll') {
	      if (this.delegatedScrollCallback) {
	        this.delegatedScrollCallback = false;
	      } else {
	        this.refreshAll();
	      }
	      if (delegatedScroll) {
	        this.delegatedScrollCallback = true;
	      }
	    }
	  },
	  syncScrollWithMaster: function() {
	    var master = this.topOverlay.mainTableScrollableElement;
	    if (this.topOverlay.needFullRender) {
	      this.topOverlay.clone.wtTable.holder.scrollLeft = master.scrollLeft;
	    }
	    if (this.leftOverlay.needFullRender) {
	      this.leftOverlay.clone.wtTable.holder.scrollTop = master.scrollTop;
	    }
	  },
	  updateMainScrollableElements: function() {
	    this.deregisterListeners();
	    this.leftOverlay.updateMainScrollableElement();
	    this.topOverlay.updateMainScrollableElement();
	    if (this.bottomOverlay.needFullRender) {
	      this.bottomOverlay.updateMainScrollableElement();
	    }
	    this.scrollableElement = getScrollableElement(this.wot.wtTable.TABLE);
	    this.registerListeners();
	  },
	  destroy: function() {
	    this.eventManager.destroy();
	    this.topOverlay.destroy();
	    if (this.bottomOverlay.clone) {
	      this.bottomOverlay.destroy();
	    }
	    this.leftOverlay.destroy();
	    if (this.topLeftCornerOverlay) {
	      this.topLeftCornerOverlay.destroy();
	    }
	    if (this.bottomLeftCornerOverlay && this.bottomLeftCornerOverlay.clone) {
	      this.bottomLeftCornerOverlay.destroy();
	    }
	    if (this.debug) {
	      this.debug.destroy();
	    }
	    this.destroyed = true;
	  },
	  refresh: function() {
	    var fastDraw = arguments[0] !== (void 0) ? arguments[0] : false;
	    if (this.topOverlay.areElementSizesAdjusted && this.leftOverlay.areElementSizesAdjusted) {
	      var container = this.wot.wtTable.wtRootElement.parentNode || this.wot.wtTable.wtRootElement;
	      var width = container.clientWidth;
	      var height = container.clientHeight;
	      if (width !== this.spreaderLastSize.width || height !== this.spreaderLastSize.height) {
	        this.spreaderLastSize.width = width;
	        this.spreaderLastSize.height = height;
	        this.adjustElementsSize();
	      }
	    }
	    if (this.bottomOverlay.clone) {
	      this.bottomOverlay.refresh(fastDraw);
	    }
	    this.leftOverlay.refresh(fastDraw);
	    this.topOverlay.refresh(fastDraw);
	    if (this.topLeftCornerOverlay) {
	      this.topLeftCornerOverlay.refresh(fastDraw);
	    }
	    if (this.bottomLeftCornerOverlay && this.bottomLeftCornerOverlay.clone) {
	      this.bottomLeftCornerOverlay.refresh(fastDraw);
	    }
	    if (this.debug) {
	      this.debug.refresh(fastDraw);
	    }
	  },
	  adjustElementsSize: function() {
	    var force = arguments[0] !== (void 0) ? arguments[0] : false;
	    var totalColumns = this.wot.getSetting('totalColumns');
	    var totalRows = this.wot.getSetting('totalRows');
	    var headerRowSize = this.wot.wtViewport.getRowHeaderWidth();
	    var headerColumnSize = this.wot.wtViewport.getColumnHeaderHeight();
	    var hiderStyle = this.wot.wtTable.hider.style;
	    hiderStyle.width = (headerRowSize + this.leftOverlay.sumCellSizes(0, totalColumns)) + 'px';
	    hiderStyle.height = (headerColumnSize + this.topOverlay.sumCellSizes(0, totalRows) + 1) + 'px';
	    this.topOverlay.adjustElementsSize(force);
	    this.leftOverlay.adjustElementsSize(force);
	    if (this.bottomOverlay.clone) {
	      this.bottomOverlay.adjustElementsSize(force);
	    }
	  },
	  applyToDOM: function() {
	    if (!this.topOverlay.areElementSizesAdjusted || !this.leftOverlay.areElementSizesAdjusted) {
	      this.adjustElementsSize();
	    }
	    this.topOverlay.applyToDOM();
	    if (this.bottomOverlay.clone) {
	      this.bottomOverlay.applyToDOM();
	    }
	    this.leftOverlay.applyToDOM();
	  },
	  getParentOverlay: function(element) {
	    if (!element) {
	      return null;
	    }
	    var overlays = [this.topOverlay, this.leftOverlay, this.bottomOverlay, this.topLeftCornerOverlay, this.bottomLeftCornerOverlay];
	    var result = null;
	    arrayEach(overlays, (function(elem, i) {
	      if (!elem) {
	        return;
	      }
	      if (elem.clone && elem.clone.wtTable.TABLE.contains(element)) {
	        result = elem.clone;
	      }
	    }));
	    return result;
	  }
	}, {});
	;
	window.WalkontableOverlays = WalkontableOverlays;

	//# 
	},{"eventManager":41,"helpers/array":42,"helpers/browser":43,"helpers/dom/element":46,"helpers/unicode":55}],17:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableScroll: {get: function() {
	      return WalkontableScroll;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47__46__46__47_helpers_47_number__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    innerHeight = $__0.innerHeight,
	    innerWidth = $__0.innerWidth,
	    getScrollLeft = $__0.getScrollLeft,
	    getScrollTop = $__0.getScrollTop,
	    offset = $__0.offset;
	var $__1 = ($___46__46__47__46__46__47__46__46__47_helpers_47_number__ = _dereq_("helpers/number"), $___46__46__47__46__46__47__46__46__47_helpers_47_number__ && $___46__46__47__46__46__47__46__46__47_helpers_47_number__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_number__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_number__}),
	    rangeEach = $__1.rangeEach,
	    rangeEachReverse = $__1.rangeEachReverse;
	var WalkontableScroll = function WalkontableScroll(wotInstance) {
	  this.wot = wotInstance;
	  this.instance = wotInstance;
	};
	($traceurRuntime.createClass)(WalkontableScroll, {
	  scrollViewport: function(coords) {
	    if (!this.wot.drawn) {
	      return;
	    }
	    var $__3 = this._getVariables(),
	        topOverlay = $__3.topOverlay,
	        leftOverlay = $__3.leftOverlay,
	        totalRows = $__3.totalRows,
	        totalColumns = $__3.totalColumns,
	        fixedRowsTop = $__3.fixedRowsTop,
	        fixedRowsBottom = $__3.fixedRowsBottom,
	        fixedColumnsLeft = $__3.fixedColumnsLeft;
	    if (coords.row < 0 || coords.row > totalRows - 1) {
	      throw new Error(("row " + coords.row + " does not exist"));
	    }
	    if (coords.col < 0 || coords.col > totalColumns - 1) {
	      throw new Error(("column " + coords.col + " does not exist"));
	    }
	    if (coords.row >= fixedRowsTop && coords.row < this.getFirstVisibleRow()) {
	      topOverlay.scrollTo(coords.row);
	    } else if (coords.row > this.getLastVisibleRow() && coords.row < totalRows - fixedRowsBottom) {
	      topOverlay.scrollTo(coords.row, true);
	    }
	    if (coords.col >= fixedColumnsLeft && coords.col < this.getFirstVisibleColumn()) {
	      leftOverlay.scrollTo(coords.col);
	    } else if (coords.col > this.getLastVisibleColumn()) {
	      leftOverlay.scrollTo(coords.col, true);
	    }
	  },
	  getFirstVisibleRow: function() {
	    var $__3 = this._getVariables(),
	        topOverlay = $__3.topOverlay,
	        wtTable = $__3.wtTable,
	        wtViewport = $__3.wtViewport,
	        totalRows = $__3.totalRows,
	        fixedRowsTop = $__3.fixedRowsTop;
	    var firstVisibleRow = wtTable.getFirstVisibleRow();
	    if (topOverlay.mainTableScrollableElement === window) {
	      var rootElementOffset = offset(wtTable.wtRootElement);
	      var totalTableHeight = innerHeight(wtTable.hider);
	      var windowHeight = innerHeight(window);
	      var windowScrollTop = getScrollTop(window);
	      if (rootElementOffset.top + totalTableHeight - windowHeight <= windowScrollTop) {
	        var rowsHeight = wtViewport.getColumnHeaderHeight();
	        rowsHeight += topOverlay.sumCellSizes(0, fixedRowsTop);
	        rangeEachReverse(totalRows, 1, (function(row) {
	          rowsHeight += topOverlay.sumCellSizes(row - 1, row);
	          if (rootElementOffset.top + totalTableHeight - rowsHeight <= windowScrollTop) {
	            firstVisibleRow = row;
	            return false;
	          }
	        }));
	      }
	    }
	    return firstVisibleRow;
	  },
	  getLastVisibleRow: function() {
	    var $__3 = this._getVariables(),
	        topOverlay = $__3.topOverlay,
	        wtTable = $__3.wtTable,
	        wtViewport = $__3.wtViewport,
	        totalRows = $__3.totalRows;
	    var lastVisibleRow = wtTable.getLastVisibleRow();
	    if (topOverlay.mainTableScrollableElement === window) {
	      var rootElementOffset = offset(wtTable.wtRootElement);
	      var windowHeight = innerHeight(window);
	      var windowScrollTop = getScrollTop(window);
	      if (rootElementOffset.top > windowScrollTop) {
	        var rowsHeight = wtViewport.getColumnHeaderHeight();
	        rangeEach(1, totalRows, (function(row) {
	          rowsHeight += topOverlay.sumCellSizes(row - 1, row);
	          if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {
	            lastVisibleRow = row - 2;
	            return false;
	          }
	        }));
	      }
	    }
	    return lastVisibleRow;
	  },
	  getFirstVisibleColumn: function() {
	    var $__3 = this._getVariables(),
	        leftOverlay = $__3.leftOverlay,
	        wtTable = $__3.wtTable,
	        wtViewport = $__3.wtViewport,
	        totalColumns = $__3.totalColumns,
	        fixedColumnsLeft = $__3.fixedColumnsLeft;
	    var firstVisibleColumn = wtTable.getFirstVisibleColumn();
	    if (leftOverlay.mainTableScrollableElement === window) {
	      var rootElementOffset = offset(wtTable.wtRootElement);
	      var totalTableWidth = innerWidth(wtTable.hider);
	      var windowWidth = innerWidth(window);
	      var windowScrollLeft = getScrollLeft(window);
	      if (rootElementOffset.left + totalTableWidth - windowWidth <= windowScrollLeft) {
	        var columnsWidth = wtViewport.getRowHeaderWidth();
	        rangeEachReverse(totalColumns, 1, (function(column) {
	          columnsWidth += leftOverlay.sumCellSizes(column - 1, column);
	          if (rootElementOffset.left + totalTableWidth - columnsWidth <= windowScrollLeft) {
	            firstVisibleColumn = column;
	            return false;
	          }
	        }));
	      }
	    }
	    return firstVisibleColumn;
	  },
	  getLastVisibleColumn: function() {
	    var $__3 = this._getVariables(),
	        leftOverlay = $__3.leftOverlay,
	        wtTable = $__3.wtTable,
	        wtViewport = $__3.wtViewport,
	        totalColumns = $__3.totalColumns;
	    var lastVisibleColumn = wtTable.getLastVisibleColumn();
	    if (leftOverlay.mainTableScrollableElement === window) {
	      var rootElementOffset = offset(wtTable.wtRootElement);
	      var windowWidth = innerWidth(window);
	      var windowScrollLeft = getScrollLeft(window);
	      if (rootElementOffset.left > windowScrollLeft) {
	        var columnsWidth = wtViewport.getRowHeaderWidth();
	        rangeEach(1, totalColumns, (function(column) {
	          columnsWidth += leftOverlay.sumCellSizes(column - 1, column);
	          if (rootElementOffset.left + columnsWidth - windowScrollLeft >= windowWidth) {
	            lastVisibleColumn = column - 2;
	            return false;
	          }
	        }));
	      }
	    }
	    return lastVisibleColumn;
	  },
	  _getVariables: function() {
	    var wot = this.wot;
	    var topOverlay = wot.wtOverlays.topOverlay;
	    var leftOverlay = wot.wtOverlays.leftOverlay;
	    var wtTable = wot.wtTable;
	    var wtViewport = wot.wtViewport;
	    var totalRows = wot.getSetting('totalRows');
	    var totalColumns = wot.getSetting('totalColumns');
	    var fixedRowsTop = wot.getSetting('fixedRowsTop');
	    var fixedRowsBottom = wot.getSetting('fixedRowsBottom');
	    var fixedColumnsLeft = wot.getSetting('fixedColumnsLeft');
	    return {
	      topOverlay: topOverlay,
	      leftOverlay: leftOverlay,
	      wtTable: wtTable,
	      wtViewport: wtViewport,
	      totalRows: totalRows,
	      totalColumns: totalColumns,
	      fixedRowsTop: fixedRowsTop,
	      fixedRowsBottom: fixedRowsBottom,
	      fixedColumnsLeft: fixedColumnsLeft
	    };
	  }
	}, {});
	;
	window.WalkontableScroll = WalkontableScroll;

	//# 
	},{"helpers/dom/element":46,"helpers/number":51}],18:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableSelection: {get: function() {
	      return WalkontableSelection;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $__border__,
	    $__cell_47_coords__,
	    $__cell_47_range__;
	var addClass = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}).addClass;
	var WalkontableBorder = ($__border__ = _dereq_("border"), $__border__ && $__border__.__esModule && $__border__ || {default: $__border__}).WalkontableBorder;
	var WalkontableCellCoords = ($__cell_47_coords__ = _dereq_("cell/coords"), $__cell_47_coords__ && $__cell_47_coords__.__esModule && $__cell_47_coords__ || {default: $__cell_47_coords__}).WalkontableCellCoords;
	var WalkontableCellRange = ($__cell_47_range__ = _dereq_("cell/range"), $__cell_47_range__ && $__cell_47_range__.__esModule && $__cell_47_range__ || {default: $__cell_47_range__}).WalkontableCellRange;
	var WalkontableSelection = function WalkontableSelection(settings, cellRange) {
	  this.settings = settings;
	  this.cellRange = cellRange || null;
	  this.instanceBorders = {};
	};
	($traceurRuntime.createClass)(WalkontableSelection, {
	  getBorder: function(wotInstance) {
	    if (this.instanceBorders[wotInstance.guid]) {
	      return this.instanceBorders[wotInstance.guid];
	    }
	    this.instanceBorders[wotInstance.guid] = new WalkontableBorder(wotInstance, this.settings);
	  },
	  isEmpty: function() {
	    return this.cellRange === null;
	  },
	  add: function(coords) {
	    if (this.isEmpty()) {
	      this.cellRange = new WalkontableCellRange(coords, coords, coords);
	    } else {
	      this.cellRange.expand(coords);
	    }
	  },
	  replace: function(oldCoords, newCoords) {
	    if (!this.isEmpty()) {
	      if (this.cellRange.from.isEqual(oldCoords)) {
	        this.cellRange.from = newCoords;
	        return true;
	      }
	      if (this.cellRange.to.isEqual(oldCoords)) {
	        this.cellRange.to = newCoords;
	        return true;
	      }
	    }
	    return false;
	  },
	  clear: function() {
	    this.cellRange = null;
	  },
	  getCorners: function() {
	    var topLeft = this.cellRange.getTopLeftCorner();
	    var bottomRight = this.cellRange.getBottomRightCorner();
	    return [topLeft.row, topLeft.col, bottomRight.row, bottomRight.col];
	  },
	  addClassAtCoords: function(wotInstance, sourceRow, sourceColumn, className) {
	    var TD = wotInstance.wtTable.getCell(new WalkontableCellCoords(sourceRow, sourceColumn));
	    if (typeof TD === 'object') {
	      addClass(TD, className);
	    }
	  },
	  draw: function(wotInstance) {
	    if (this.isEmpty()) {
	      if (this.settings.border) {
	        var border = this.getBorder(wotInstance);
	        if (border) {
	          border.disappear();
	        }
	      }
	      return;
	    }
	    var renderedRows = wotInstance.wtTable.getRenderedRowsCount();
	    var renderedColumns = wotInstance.wtTable.getRenderedColumnsCount();
	    var corners = this.getCorners();
	    var sourceRow,
	        sourceCol,
	        TH;
	    for (var column = 0; column < renderedColumns; column++) {
	      sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(column);
	      if (sourceCol >= corners[1] && sourceCol <= corners[3]) {
	        TH = wotInstance.wtTable.getColumnHeader(sourceCol);
	        if (TH && this.settings.highlightColumnClassName) {
	          addClass(TH, this.settings.highlightColumnClassName);
	        }
	      }
	    }
	    for (var row = 0; row < renderedRows; row++) {
	      sourceRow = wotInstance.wtTable.rowFilter.renderedToSource(row);
	      if (sourceRow >= corners[0] && sourceRow <= corners[2]) {
	        TH = wotInstance.wtTable.getRowHeader(sourceRow);
	        if (TH && this.settings.highlightRowClassName) {
	          addClass(TH, this.settings.highlightRowClassName);
	        }
	      }
	      for (var column$__5 = 0; column$__5 < renderedColumns; column$__5++) {
	        sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(column$__5);
	        if (sourceRow >= corners[0] && sourceRow <= corners[2] && sourceCol >= corners[1] && sourceCol <= corners[3]) {
	          if (this.settings.className) {
	            this.addClassAtCoords(wotInstance, sourceRow, sourceCol, this.settings.className);
	          }
	        } else if (sourceRow >= corners[0] && sourceRow <= corners[2]) {
	          if (this.settings.highlightRowClassName) {
	            this.addClassAtCoords(wotInstance, sourceRow, sourceCol, this.settings.highlightRowClassName);
	          }
	        } else if (sourceCol >= corners[1] && sourceCol <= corners[3]) {
	          if (this.settings.highlightColumnClassName) {
	            this.addClassAtCoords(wotInstance, sourceRow, sourceCol, this.settings.highlightColumnClassName);
	          }
	        }
	      }
	    }
	    wotInstance.getSetting('onBeforeDrawBorders', corners, this.settings.className);
	    if (this.settings.border) {
	      var border$__6 = this.getBorder(wotInstance);
	      if (border$__6) {
	        border$__6.appear(corners);
	      }
	    }
	  }
	}, {});
	;
	window.WalkontableSelection = WalkontableSelection;

	//# 
	},{"border":2,"cell/coords":5,"cell/range":6,"helpers/dom/element":46}],19:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableSettings: {get: function() {
	      return WalkontableSettings;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__;
	var fastInnerText = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}).fastInnerText;
	var WalkontableSettings = function WalkontableSettings(wotInstance, settings) {
	  var $__1 = this;
	  this.wot = wotInstance;
	  this.instance = wotInstance;
	  this.defaults = {
	    table: void 0,
	    debug: false,
	    externalRowCalculator: false,
	    stretchH: 'none',
	    currentRowClassName: null,
	    currentColumnClassName: null,
	    preventOverflow: function() {
	      return false;
	    },
	    data: void 0,
	    fixedColumnsLeft: 0,
	    fixedRowsTop: 0,
	    fixedRowsBottom: 0,
	    minSpareRows: 0,
	    rowHeaders: function() {
	      return [];
	    },
	    columnHeaders: function() {
	      return [];
	    },
	    totalRows: void 0,
	    totalColumns: void 0,
	    cellRenderer: (function(row, column, TD) {
	      var cellData = $__1.getSetting('data', row, column);
	      fastInnerText(TD, cellData === void 0 || cellData === null ? '' : cellData);
	    }),
	    columnWidth: function(col) {
	      return;
	    },
	    rowHeight: function(row) {
	      return;
	    },
	    defaultRowHeight: 23,
	    defaultColumnWidth: 50,
	    selections: null,
	    hideBorderOnMouseDownOver: false,
	    viewportRowCalculatorOverride: null,
	    viewportColumnCalculatorOverride: null,
	    onCellMouseDown: null,
	    onCellMouseOver: null,
	    onCellDblClick: null,
	    onCellCornerMouseDown: null,
	    onCellCornerDblClick: null,
	    beforeDraw: null,
	    onDraw: null,
	    onBeforeDrawBorders: null,
	    onScrollVertically: null,
	    onScrollHorizontally: null,
	    onBeforeTouchScroll: null,
	    onAfterMomentumScroll: null,
	    onBeforeStretchingColumnWidth: (function(width) {
	      return width;
	    }),
	    scrollbarWidth: 10,
	    scrollbarHeight: 10,
	    renderAllRows: false,
	    groups: false,
	    rowHeaderWidth: null,
	    columnHeaderHeight: null
	  };
	  this.settings = {};
	  for (var i in this.defaults) {
	    if (this.defaults.hasOwnProperty(i)) {
	      if (settings[i] !== void 0) {
	        this.settings[i] = settings[i];
	      } else if (this.defaults[i] === void 0) {
	        throw new Error('A required setting "' + i + '" was not provided');
	      } else {
	        this.settings[i] = this.defaults[i];
	      }
	    }
	  }
	};
	($traceurRuntime.createClass)(WalkontableSettings, {
	  update: function(settings, value) {
	    if (value === void 0) {
	      for (var i in settings) {
	        if (settings.hasOwnProperty(i)) {
	          this.settings[i] = settings[i];
	        }
	      }
	    } else {
	      this.settings[settings] = value;
	    }
	    return this.wot;
	  },
	  getSetting: function(key, param1, param2, param3, param4) {
	    if (typeof this.settings[key] === 'function') {
	      return this.settings[key](param1, param2, param3, param4);
	    } else if (param1 !== void 0 && Array.isArray(this.settings[key])) {
	      return this.settings[key][param1];
	    } else {
	      return this.settings[key];
	    }
	  },
	  has: function(key) {
	    return !!this.settings[key];
	  }
	}, {});
	;
	window.WalkontableSettings = WalkontableSettings;

	//# 
	},{"helpers/dom/element":46}],20:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableTable: {get: function() {
	      return WalkontableTable;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $__cell_47_coords__,
	    $__cell_47_range__,
	    $__filter_47_column__,
	    $__filter_47_row__,
	    $__tableRenderer__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    getStyle = $__0.getStyle,
	    getTrimmingContainer = $__0.getTrimmingContainer,
	    hasClass = $__0.hasClass,
	    index = $__0.index,
	    offset = $__0.offset,
	    removeClass = $__0.removeClass,
	    removeTextNodes = $__0.removeTextNodes,
	    overlayContainsElement = $__0.overlayContainsElement,
	    closest = $__0.closest;
	var WalkontableCellCoords = ($__cell_47_coords__ = _dereq_("cell/coords"), $__cell_47_coords__ && $__cell_47_coords__.__esModule && $__cell_47_coords__ || {default: $__cell_47_coords__}).WalkontableCellCoords;
	var WalkontableCellRange = ($__cell_47_range__ = _dereq_("cell/range"), $__cell_47_range__ && $__cell_47_range__.__esModule && $__cell_47_range__ || {default: $__cell_47_range__}).WalkontableCellRange;
	var WalkontableColumnFilter = ($__filter_47_column__ = _dereq_("filter/column"), $__filter_47_column__ && $__filter_47_column__.__esModule && $__filter_47_column__ || {default: $__filter_47_column__}).WalkontableColumnFilter;
	var WalkontableRowFilter = ($__filter_47_row__ = _dereq_("filter/row"), $__filter_47_row__ && $__filter_47_row__.__esModule && $__filter_47_row__ || {default: $__filter_47_row__}).WalkontableRowFilter;
	var WalkontableTableRenderer = ($__tableRenderer__ = _dereq_("tableRenderer"), $__tableRenderer__ && $__tableRenderer__.__esModule && $__tableRenderer__ || {default: $__tableRenderer__}).WalkontableTableRenderer;
	var WalkontableTable = function WalkontableTable(wotInstance, table) {
	  this.wot = wotInstance;
	  this.instance = this.wot;
	  this.TABLE = table;
	  this.TBODY = null;
	  this.THEAD = null;
	  this.COLGROUP = null;
	  this.tableOffset = 0;
	  this.holderOffset = 0;
	  removeTextNodes(this.TABLE);
	  this.spreader = this.createSpreader(this.TABLE);
	  this.hider = this.createHider(this.spreader);
	  this.holder = this.createHolder(this.hider);
	  this.wtRootElement = this.holder.parentNode;
	  this.alignOverlaysWithTrimmingContainer();
	  this.fixTableDomTree();
	  this.colgroupChildrenLength = this.COLGROUP.childNodes.length;
	  this.theadChildrenLength = this.THEAD.firstChild ? this.THEAD.firstChild.childNodes.length : 0;
	  this.tbodyChildrenLength = this.TBODY.childNodes.length;
	  this.rowFilter = null;
	  this.columnFilter = null;
	};
	($traceurRuntime.createClass)(WalkontableTable, {
	  fixTableDomTree: function() {
	    this.TBODY = this.TABLE.querySelector('tbody');
	    if (!this.TBODY) {
	      this.TBODY = document.createElement('tbody');
	      this.TABLE.appendChild(this.TBODY);
	    }
	    this.THEAD = this.TABLE.querySelector('thead');
	    if (!this.THEAD) {
	      this.THEAD = document.createElement('thead');
	      this.TABLE.insertBefore(this.THEAD, this.TBODY);
	    }
	    this.COLGROUP = this.TABLE.querySelector('colgroup');
	    if (!this.COLGROUP) {
	      this.COLGROUP = document.createElement('colgroup');
	      this.TABLE.insertBefore(this.COLGROUP, this.THEAD);
	    }
	    if (this.wot.getSetting('columnHeaders').length && !this.THEAD.childNodes.length) {
	      this.THEAD.appendChild(document.createElement('TR'));
	    }
	  },
	  createSpreader: function(table) {
	    var parent = table.parentNode;
	    var spreader;
	    if (!parent || parent.nodeType !== 1 || !hasClass(parent, 'wtHolder')) {
	      spreader = document.createElement('div');
	      spreader.className = 'wtSpreader';
	      if (parent) {
	        parent.insertBefore(spreader, table);
	      }
	      spreader.appendChild(table);
	    }
	    spreader.style.position = 'relative';
	    return spreader;
	  },
	  createHider: function(spreader) {
	    var parent = spreader.parentNode;
	    var hider;
	    if (!parent || parent.nodeType !== 1 || !hasClass(parent, 'wtHolder')) {
	      hider = document.createElement('div');
	      hider.className = 'wtHider';
	      if (parent) {
	        parent.insertBefore(hider, spreader);
	      }
	      hider.appendChild(spreader);
	    }
	    return hider;
	  },
	  createHolder: function(hider) {
	    var parent = hider.parentNode;
	    var holder;
	    if (!parent || parent.nodeType !== 1 || !hasClass(parent, 'wtHolder')) {
	      holder = document.createElement('div');
	      holder.style.position = 'relative';
	      holder.className = 'wtHolder';
	      if (parent) {
	        parent.insertBefore(holder, hider);
	      }
	      if (!this.isWorkingOnClone()) {
	        holder.parentNode.className += 'ht_master handsontable';
	      }
	      holder.appendChild(hider);
	    }
	    return holder;
	  },
	  alignOverlaysWithTrimmingContainer: function() {
	    var trimmingElement = getTrimmingContainer(this.wtRootElement);
	    if (!this.isWorkingOnClone()) {
	      this.holder.parentNode.style.position = 'relative';
	      if (trimmingElement === window) {
	        var preventOverflow = this.wot.getSetting('preventOverflow');
	        if (!preventOverflow) {
	          this.holder.style.overflow = 'visible';
	          this.wtRootElement.style.overflow = 'visible';
	        }
	      } else {
	        this.holder.style.width = getStyle(trimmingElement, 'width');
	        this.holder.style.height = getStyle(trimmingElement, 'height');
	        this.holder.style.overflow = '';
	      }
	    }
	  },
	  isWorkingOnClone: function() {
	    return !!this.wot.cloneSource;
	  },
	  draw: function(fastDraw) {
	    var totalRows = this.instance.getSetting('totalRows');
	    if (!this.isWorkingOnClone()) {
	      this.holderOffset = offset(this.holder);
	      fastDraw = this.wot.wtViewport.createRenderCalculators(fastDraw);
	    }
	    if (fastDraw) {
	      if (!this.isWorkingOnClone()) {
	        this.wot.wtViewport.createVisibleCalculators();
	      }
	      if (this.wot.wtOverlays) {
	        this.wot.wtOverlays.refresh(true);
	      }
	    } else {
	      if (this.isWorkingOnClone()) {
	        this.tableOffset = this.wot.cloneSource.wtTable.tableOffset;
	      } else {
	        this.tableOffset = offset(this.TABLE);
	      }
	      var startRow;
	      if (WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_DEBUG) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_TOP) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_TOP_LEFT_CORNER)) {
	        startRow = 0;
	      } else if (WalkontableOverlay.isOverlayTypeOf(this.instance.cloneOverlay, WalkontableOverlay.CLONE_BOTTOM) || WalkontableOverlay.isOverlayTypeOf(this.instance.cloneOverlay, WalkontableOverlay.CLONE_BOTTOM_LEFT_CORNER)) {
	        startRow = Math.max(totalRows - this.wot.getSetting('fixedRowsBottom'), 0);
	      } else {
	        startRow = this.wot.wtViewport.rowsRenderCalculator.startRow;
	      }
	      var startColumn;
	      if (WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_DEBUG) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_LEFT) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_TOP_LEFT_CORNER) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_BOTTOM_LEFT_CORNER)) {
	        startColumn = 0;
	      } else {
	        startColumn = this.wot.wtViewport.columnsRenderCalculator.startColumn;
	      }
	      this.rowFilter = new WalkontableRowFilter(startRow, totalRows, this.wot.getSetting('columnHeaders').length);
	      this.columnFilter = new WalkontableColumnFilter(startColumn, this.wot.getSetting('totalColumns'), this.wot.getSetting('rowHeaders').length);
	      this.alignOverlaysWithTrimmingContainer();
	      this._doDraw();
	    }
	    this.refreshSelections(fastDraw);
	    if (!this.isWorkingOnClone()) {
	      this.wot.wtOverlays.topOverlay.resetFixedPosition();
	      if (this.wot.wtOverlays.bottomOverlay.clone) {
	        this.wot.wtOverlays.bottomOverlay.resetFixedPosition();
	      }
	      this.wot.wtOverlays.leftOverlay.resetFixedPosition();
	      if (this.wot.wtOverlays.topLeftCornerOverlay) {
	        this.wot.wtOverlays.topLeftCornerOverlay.resetFixedPosition();
	      }
	      if (this.instance.wtOverlays.bottomLeftCornerOverlay && this.instance.wtOverlays.bottomLeftCornerOverlay.clone) {
	        this.wot.wtOverlays.bottomLeftCornerOverlay.resetFixedPosition();
	      }
	    }
	    this.wot.drawn = true;
	    return this;
	  },
	  _doDraw: function() {
	    var wtRenderer = new WalkontableTableRenderer(this);
	    wtRenderer.render();
	  },
	  removeClassFromCells: function(className) {
	    var nodes = this.TABLE.querySelectorAll('.' + className);
	    for (var i = 0,
	        len = nodes.length; i < len; i++) {
	      removeClass(nodes[i], className);
	    }
	  },
	  refreshSelections: function(fastDraw) {
	    if (!this.wot.selections) {
	      return;
	    }
	    var len = this.wot.selections.length;
	    if (fastDraw) {
	      for (var i = 0; i < len; i++) {
	        if (this.wot.selections[i].settings.className) {
	          this.removeClassFromCells(this.wot.selections[i].settings.className);
	        }
	        if (this.wot.selections[i].settings.highlightRowClassName) {
	          this.removeClassFromCells(this.wot.selections[i].settings.highlightRowClassName);
	        }
	        if (this.wot.selections[i].settings.highlightColumnClassName) {
	          this.removeClassFromCells(this.wot.selections[i].settings.highlightColumnClassName);
	        }
	      }
	    }
	    for (var i$__7 = 0; i$__7 < len; i$__7++) {
	      this.wot.selections[i$__7].draw(this.wot, fastDraw);
	    }
	  },
	  getCell: function(coords) {
	    if (this.isRowBeforeRenderedRows(coords.row)) {
	      return -1;
	    } else if (this.isRowAfterRenderedRows(coords.row)) {
	      return -2;
	    }
	    var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(coords.row)];
	    if (TR) {
	      return TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(coords.col)];
	    }
	  },
	  getColumnHeader: function(col) {
	    var level = arguments[1] !== (void 0) ? arguments[1] : 0;
	    var TR = this.THEAD.childNodes[level];
	    if (TR) {
	      return TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];
	    }
	  },
	  getRowHeader: function(row) {
	    if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {
	      return null;
	    }
	    var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
	    if (TR) {
	      return TR.childNodes[0];
	    }
	  },
	  getCoords: function(TD) {
	    if (TD.nodeName !== 'TD' && TD.nodeName !== 'TH') {
	      TD = closest(TD, ['TD', 'TH']);
	    }
	    var TR = TD.parentNode;
	    var CONTAINER = TR.parentNode;
	    var row = index(TR);
	    var col = TD.cellIndex;
	    if (overlayContainsElement(WalkontableOverlay.CLONE_TOP_LEFT_CORNER, TD) || overlayContainsElement(WalkontableOverlay.CLONE_TOP, TD)) {
	      if (CONTAINER.nodeName === 'THEAD') {
	        row -= CONTAINER.childNodes.length;
	      }
	    } else {
	      if (CONTAINER === this.THEAD) {
	        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);
	      } else {
	        row = this.rowFilter.renderedToSource(row);
	      }
	    }
	    if (overlayContainsElement(WalkontableOverlay.CLONE_TOP_LEFT_CORNER, TD) || overlayContainsElement(WalkontableOverlay.CLONE_LEFT, TD)) {
	      col = this.columnFilter.offsettedTH(col);
	    } else {
	      col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);
	    }
	    return new WalkontableCellCoords(row, col);
	  },
	  getTrForRow: function(row) {
	    return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
	  },
	  getFirstRenderedRow: function() {
	    return this.wot.wtViewport.rowsRenderCalculator.startRow;
	  },
	  getFirstVisibleRow: function() {
	    return this.wot.wtViewport.rowsVisibleCalculator.startRow;
	  },
	  getFirstRenderedColumn: function() {
	    return this.wot.wtViewport.columnsRenderCalculator.startColumn;
	  },
	  getFirstVisibleColumn: function() {
	    return this.wot.wtViewport.columnsVisibleCalculator.startColumn;
	  },
	  getLastRenderedRow: function() {
	    return this.wot.wtViewport.rowsRenderCalculator.endRow;
	  },
	  getLastVisibleRow: function() {
	    return this.wot.wtViewport.rowsVisibleCalculator.endRow;
	  },
	  getLastRenderedColumn: function() {
	    return this.wot.wtViewport.columnsRenderCalculator.endColumn;
	  },
	  getLastVisibleColumn: function() {
	    return this.wot.wtViewport.columnsVisibleCalculator.endColumn;
	  },
	  isRowBeforeRenderedRows: function(row) {
	    return (this.rowFilter.sourceToRendered(row) < 0 && row >= 0);
	  },
	  isRowAfterViewport: function(row) {
	    return (this.rowFilter.sourceToRendered(row) > this.getLastVisibleRow());
	  },
	  isRowAfterRenderedRows: function(row) {
	    return (this.rowFilter.sourceToRendered(row) > this.getLastRenderedRow());
	  },
	  isColumnBeforeViewport: function(column) {
	    return this.columnFilter.sourceToRendered(column) < 0 && column >= 0;
	  },
	  isColumnAfterViewport: function(column) {
	    return (this.columnFilter.sourceToRendered(column) > this.getLastVisibleColumn());
	  },
	  isLastRowFullyVisible: function() {
	    return this.getLastVisibleRow() === this.getLastRenderedRow();
	  },
	  isLastColumnFullyVisible: function() {
	    return this.getLastVisibleColumn() === this.getLastRenderedColumn();
	  },
	  getRenderedColumnsCount: function() {
	    var columnsCount = this.wot.wtViewport.columnsRenderCalculator.count;
	    var totalColumns = this.wot.getSetting('totalColumns');
	    if (this.wot.isOverlayName(WalkontableOverlay.CLONE_DEBUG)) {
	      columnsCount = totalColumns;
	    } else if (this.wot.isOverlayName(WalkontableOverlay.CLONE_LEFT) || this.wot.isOverlayName(WalkontableOverlay.CLONE_TOP_LEFT_CORNER) || this.wot.isOverlayName(WalkontableOverlay.CLONE_BOTTOM_LEFT_CORNER)) {
	      return Math.min(this.wot.getSetting('fixedColumnsLeft'), totalColumns);
	    }
	    return columnsCount;
	  },
	  getRenderedRowsCount: function() {
	    var rowsCount = this.wot.wtViewport.rowsRenderCalculator.count;
	    var totalRows = this.wot.getSetting('totalRows');
	    if (this.wot.isOverlayName(WalkontableOverlay.CLONE_DEBUG)) {
	      rowsCount = totalRows;
	    } else if (this.wot.isOverlayName(WalkontableOverlay.CLONE_TOP) || this.wot.isOverlayName(WalkontableOverlay.CLONE_TOP_LEFT_CORNER)) {
	      rowsCount = Math.min(this.wot.getSetting('fixedRowsTop'), totalRows);
	    } else if (this.wot.isOverlayName(WalkontableOverlay.CLONE_BOTTOM) || this.wot.isOverlayName(WalkontableOverlay.CLONE_BOTTOM_LEFT_CORNER)) {
	      rowsCount = Math.min(this.wot.getSetting('fixedRowsBottom'), totalRows);
	    }
	    return rowsCount;
	  },
	  getVisibleRowsCount: function() {
	    return this.wot.wtViewport.rowsVisibleCalculator.count;
	  },
	  allRowsInViewport: function() {
	    return this.wot.getSetting('totalRows') == this.getVisibleRowsCount();
	  },
	  getRowHeight: function(sourceRow) {
	    var height = this.wot.wtSettings.settings.rowHeight(sourceRow);
	    var oversizedHeight = this.wot.wtViewport.oversizedRows[sourceRow];
	    if (oversizedHeight !== void 0) {
	      height = height === void 0 ? oversizedHeight : Math.max(height, oversizedHeight);
	    }
	    return height;
	  },
	  getColumnHeaderHeight: function(level) {
	    var height = this.wot.wtSettings.settings.defaultRowHeight;
	    var oversizedHeight = this.wot.wtViewport.oversizedColumnHeaders[level];
	    if (oversizedHeight !== void 0) {
	      height = height ? Math.max(height, oversizedHeight) : oversizedHeight;
	    }
	    return height;
	  },
	  getVisibleColumnsCount: function() {
	    return this.wot.wtViewport.columnsVisibleCalculator.count;
	  },
	  allColumnsInViewport: function() {
	    return this.wot.getSetting('totalColumns') == this.getVisibleColumnsCount();
	  },
	  getColumnWidth: function(sourceColumn) {
	    var width = this.wot.wtSettings.settings.columnWidth;
	    if (typeof width === 'function') {
	      width = width(sourceColumn);
	    } else if (typeof width === 'object') {
	      width = width[sourceColumn];
	    }
	    return width || this.wot.wtSettings.settings.defaultColumnWidth;
	  },
	  getStretchedColumnWidth: function(sourceColumn) {
	    var columnWidth = this.getColumnWidth(sourceColumn);
	    var width = columnWidth == null ? this.instance.wtSettings.settings.defaultColumnWidth : columnWidth;
	    var calculator = this.wot.wtViewport.columnsRenderCalculator;
	    if (calculator) {
	      var stretchedWidth = calculator.getStretchedColumnWidth(sourceColumn, width);
	      if (stretchedWidth) {
	        width = stretchedWidth;
	      }
	    }
	    return width;
	  }
	}, {});
	;
	window.WalkontableTable = WalkontableTable;

	//# 
	},{"cell/coords":5,"cell/range":6,"filter/column":9,"filter/row":10,"helpers/dom/element":46,"tableRenderer":21}],21:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableTableRenderer: {get: function() {
	      return WalkontableTableRenderer;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    empty = $__0.empty,
	    getScrollbarWidth = $__0.getScrollbarWidth,
	    hasClass = $__0.hasClass,
	    innerHeight = $__0.innerHeight,
	    outerWidth = $__0.outerWidth;
	var performanceWarningAppeared = false;
	var WalkontableTableRenderer = function WalkontableTableRenderer(wtTable) {
	  this.wtTable = wtTable;
	  this.wot = wtTable.instance;
	  this.instance = wtTable.instance;
	  this.rowFilter = wtTable.rowFilter;
	  this.columnFilter = wtTable.columnFilter;
	  this.TABLE = wtTable.TABLE;
	  this.THEAD = wtTable.THEAD;
	  this.TBODY = wtTable.TBODY;
	  this.COLGROUP = wtTable.COLGROUP;
	  this.rowHeaders = [];
	  this.rowHeaderCount = 0;
	  this.columnHeaders = [];
	  this.columnHeaderCount = 0;
	  this.fixedRowsTop = 0;
	  this.fixedRowsBottom = 0;
	};
	($traceurRuntime.createClass)(WalkontableTableRenderer, {
	  render: function() {
	    if (!this.wtTable.isWorkingOnClone()) {
	      this.wot.getSetting('beforeDraw', true);
	    }
	    this.rowHeaders = this.wot.getSetting('rowHeaders');
	    this.rowHeaderCount = this.rowHeaders.length;
	    this.fixedRowsTop = this.wot.getSetting('fixedRowsTop');
	    this.fixedRowsBottom = this.wot.getSetting('fixedRowsBottom');
	    this.columnHeaders = this.wot.getSetting('columnHeaders');
	    this.columnHeaderCount = this.columnHeaders.length;
	    var columnsToRender = this.wtTable.getRenderedColumnsCount();
	    var rowsToRender = this.wtTable.getRenderedRowsCount();
	    var totalColumns = this.wot.getSetting('totalColumns');
	    var totalRows = this.wot.getSetting('totalRows');
	    var workspaceWidth;
	    var adjusted = false;
	    if (WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_BOTTOM) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_BOTTOM_LEFT_CORNER)) {
	      this.columnHeaders = [];
	      this.columnHeaderCount = 0;
	    }
	    if (totalColumns > 0) {
	      this.adjustAvailableNodes();
	      adjusted = true;
	      this.renderColumnHeaders();
	      this.renderRows(totalRows, rowsToRender, columnsToRender);
	      if (!this.wtTable.isWorkingOnClone()) {
	        workspaceWidth = this.wot.wtViewport.getWorkspaceWidth();
	        this.wot.wtViewport.containerWidth = null;
	      }
	      this.adjustColumnWidths(columnsToRender);
	      this.markOversizedColumnHeaders();
	      this.adjustColumnHeaderHeights();
	    }
	    if (!adjusted) {
	      this.adjustAvailableNodes();
	    }
	    this.removeRedundantRows(rowsToRender);
	    if (!this.wtTable.isWorkingOnClone() || this.wot.isOverlayName(WalkontableOverlay.CLONE_BOTTOM)) {
	      this.markOversizedRows();
	    }
	    if (!this.wtTable.isWorkingOnClone()) {
	      this.wot.wtViewport.createVisibleCalculators();
	      this.wot.wtOverlays.refresh(false);
	      var hiderWidth = outerWidth(this.wtTable.hider);
	      var tableWidth = outerWidth(this.wtTable.TABLE);
	      if (hiderWidth !== 0 && (tableWidth !== hiderWidth)) {
	        this.adjustColumnWidths(columnsToRender);
	      }
	      this.wot.wtOverlays.applyToDOM();
	      if (workspaceWidth !== this.wot.wtViewport.getWorkspaceWidth()) {
	        this.wot.wtViewport.containerWidth = null;
	        var firstRendered = this.wtTable.getFirstRenderedColumn();
	        var lastRendered = this.wtTable.getLastRenderedColumn();
	        var rowHeaderWidthSetting = this.wot.getSetting('rowHeaderWidth');
	        if (rowHeaderWidthSetting != null) {
	          for (var i = 0; i < this.rowHeaderCount; i++) {
	            this.COLGROUP.childNodes[i].style.width = (isNaN(rowHeaderWidthSetting) ? rowHeaderWidthSetting[i] : rowHeaderWidthSetting) + 'px';
	          }
	        }
	        for (var i$__2 = firstRendered; i$__2 < lastRendered; i$__2++) {
	          var width = this.wtTable.getStretchedColumnWidth(i$__2);
	          var renderedIndex = this.columnFilter.sourceToRendered(i$__2);
	          this.COLGROUP.childNodes[renderedIndex + this.rowHeaderCount].style.width = width + 'px';
	        }
	      }
	      this.wot.getSetting('onDraw', true);
	    } else if (this.wot.isOverlayName(WalkontableOverlay.CLONE_BOTTOM)) {
	      this.wot.cloneSource.wtOverlays.adjustElementsSize();
	    }
	  },
	  removeRedundantRows: function(renderedRowsCount) {
	    while (this.wtTable.tbodyChildrenLength > renderedRowsCount) {
	      this.TBODY.removeChild(this.TBODY.lastChild);
	      this.wtTable.tbodyChildrenLength--;
	    }
	  },
	  renderRows: function(totalRows, rowsToRender, columnsToRender) {
	    var lastTD,
	        TR;
	    var visibleRowIndex = 0;
	    var sourceRowIndex = this.rowFilter.renderedToSource(visibleRowIndex);
	    var isWorkingOnClone = this.wtTable.isWorkingOnClone();
	    while (sourceRowIndex < totalRows && sourceRowIndex >= 0) {
	      if (!performanceWarningAppeared && visibleRowIndex > 1000) {
	        performanceWarningAppeared = true;
	        console.warn('Performance tip: Handsontable rendered more than 1000 visible rows. Consider limiting the number ' + 'of rendered rows by specifying the table height and/or turning off the "renderAllRows" option.');
	      }
	      if (rowsToRender !== void 0 && visibleRowIndex === rowsToRender) {
	        break;
	      }
	      TR = this.getOrCreateTrForRow(visibleRowIndex, TR);
	      this.renderRowHeaders(sourceRowIndex, TR);
	      this.adjustColumns(TR, columnsToRender + this.rowHeaderCount);
	      lastTD = this.renderCells(sourceRowIndex, TR, columnsToRender);
	      if (!isWorkingOnClone || this.wot.isOverlayName(WalkontableOverlay.CLONE_BOTTOM)) {
	        this.resetOversizedRow(sourceRowIndex);
	      }
	      if (TR.firstChild) {
	        var height = this.wot.wtTable.getRowHeight(sourceRowIndex);
	        if (height) {
	          height--;
	          TR.firstChild.style.height = height + 'px';
	        } else {
	          TR.firstChild.style.height = '';
	        }
	      }
	      visibleRowIndex++;
	      sourceRowIndex = this.rowFilter.renderedToSource(visibleRowIndex);
	    }
	  },
	  resetOversizedRow: function(sourceRow) {
	    if (this.wot.getSetting('externalRowCalculator')) {
	      return;
	    }
	    if (this.wot.wtViewport.oversizedRows && this.wot.wtViewport.oversizedRows[sourceRow]) {
	      this.wot.wtViewport.oversizedRows[sourceRow] = void 0;
	    }
	  },
	  markOversizedRows: function() {
	    if (this.wot.getSetting('externalRowCalculator')) {
	      return;
	    }
	    var rowCount = this.instance.wtTable.TBODY.childNodes.length;
	    var expectedTableHeight = rowCount * this.instance.wtSettings.settings.defaultRowHeight;
	    var actualTableHeight = innerHeight(this.instance.wtTable.TBODY) - 1;
	    var previousRowHeight;
	    var rowInnerHeight;
	    var sourceRowIndex;
	    var currentTr;
	    var rowHeader;
	    var totalRows = this.instance.getSetting('totalRows');
	    if (expectedTableHeight === actualTableHeight && !this.instance.getSetting('fixedRowsBottom')) {
	      return;
	    }
	    while (rowCount) {
	      rowCount--;
	      sourceRowIndex = this.instance.wtTable.rowFilter.renderedToSource(rowCount);
	      previousRowHeight = this.instance.wtTable.getRowHeight(sourceRowIndex);
	      currentTr = this.instance.wtTable.getTrForRow(sourceRowIndex);
	      rowHeader = currentTr.querySelector('th');
	      if (rowHeader) {
	        rowInnerHeight = innerHeight(rowHeader);
	      } else {
	        rowInnerHeight = innerHeight(currentTr) - 1;
	      }
	      if ((!previousRowHeight && this.instance.wtSettings.settings.defaultRowHeight < rowInnerHeight || previousRowHeight < rowInnerHeight)) {
	        this.instance.wtViewport.oversizedRows[sourceRowIndex] = ++rowInnerHeight;
	      }
	    }
	  },
	  markOversizedColumnHeaders: function() {
	    var overlayName = this.wot.getOverlayName();
	    if (!this.columnHeaderCount || this.wot.wtViewport.hasOversizedColumnHeadersMarked[overlayName] || this.wtTable.isWorkingOnClone()) {
	      return;
	    }
	    var columnCount = this.wtTable.getRenderedColumnsCount();
	    for (var i = 0; i < this.columnHeaderCount; i++) {
	      for (var renderedColumnIndex = (-1) * this.rowHeaderCount; renderedColumnIndex < columnCount; renderedColumnIndex++) {
	        this.markIfOversizedColumnHeader(renderedColumnIndex);
	      }
	    }
	    this.wot.wtViewport.hasOversizedColumnHeadersMarked[overlayName] = true;
	  },
	  adjustColumnHeaderHeights: function() {
	    var columnHeaders = this.wot.getSetting('columnHeaders');
	    var children = this.wot.wtTable.THEAD.childNodes;
	    var oversizedColumnHeaders = this.wot.wtViewport.oversizedColumnHeaders;
	    for (var i = 0,
	        len = columnHeaders.length; i < len; i++) {
	      if (oversizedColumnHeaders[i]) {
	        if (children[i].childNodes.length === 0) {
	          return;
	        }
	        children[i].childNodes[0].style.height = oversizedColumnHeaders[i] + 'px';
	      }
	    }
	  },
	  markIfOversizedColumnHeader: function(col) {
	    var sourceColIndex = this.wot.wtTable.columnFilter.renderedToSource(col);
	    var level = this.columnHeaderCount;
	    var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;
	    var previousColHeaderHeight;
	    var currentHeader;
	    var currentHeaderHeight;
	    var columnHeaderHeightSetting = this.wot.getSetting('columnHeaderHeight') || [];
	    while (level) {
	      level--;
	      previousColHeaderHeight = this.wot.wtTable.getColumnHeaderHeight(level);
	      currentHeader = this.wot.wtTable.getColumnHeader(sourceColIndex, level);
	      if (!currentHeader) {
	        continue;
	      }
	      currentHeaderHeight = innerHeight(currentHeader);
	      if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {
	        this.wot.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;
	      }
	      if (Array.isArray(columnHeaderHeightSetting)) {
	        if (columnHeaderHeightSetting[level] != null) {
	          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];
	        }
	      } else if (!isNaN(columnHeaderHeightSetting)) {
	        this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;
	      }
	      if (this.wot.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {
	        this.wot.wtViewport.oversizedColumnHeaders[level] = (columnHeaderHeightSetting[level] || columnHeaderHeightSetting);
	      }
	    }
	  },
	  renderCells: function(sourceRowIndex, TR, columnsToRender) {
	    var TD;
	    var sourceColIndex;
	    for (var visibleColIndex = 0; visibleColIndex < columnsToRender; visibleColIndex++) {
	      sourceColIndex = this.columnFilter.renderedToSource(visibleColIndex);
	      if (visibleColIndex === 0) {
	        TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(sourceColIndex)];
	      } else {
	        TD = TD.nextSibling;
	      }
	      if (TD.nodeName == 'TH') {
	        TD = replaceThWithTd(TD, TR);
	      }
	      if (!hasClass(TD, 'hide')) {
	        TD.className = '';
	      }
	      TD.removeAttribute('style');
	      this.wot.wtSettings.settings.cellRenderer(sourceRowIndex, sourceColIndex, TD);
	    }
	    return TD;
	  },
	  adjustColumnWidths: function(columnsToRender) {
	    var scrollbarCompensation = 0;
	    var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
	    var mainHolder = sourceInstance.wtTable.holder;
	    if (mainHolder.offsetHeight < mainHolder.scrollHeight) {
	      scrollbarCompensation = getScrollbarWidth();
	    }
	    this.wot.wtViewport.columnsRenderCalculator.refreshStretching(this.wot.wtViewport.getViewportWidth() - scrollbarCompensation);
	    var rowHeaderWidthSetting = this.wot.getSetting('rowHeaderWidth');
	    if (rowHeaderWidthSetting != null) {
	      for (var i = 0; i < this.rowHeaderCount; i++) {
	        this.COLGROUP.childNodes[i].style.width = (isNaN(rowHeaderWidthSetting) ? rowHeaderWidthSetting[i] : rowHeaderWidthSetting) + 'px';
	      }
	    }
	    for (var renderedColIndex = 0; renderedColIndex < columnsToRender; renderedColIndex++) {
	      var width = this.wtTable.getStretchedColumnWidth(this.columnFilter.renderedToSource(renderedColIndex));
	      this.COLGROUP.childNodes[renderedColIndex + this.rowHeaderCount].style.width = width + 'px';
	    }
	  },
	  appendToTbody: function(TR) {
	    this.TBODY.appendChild(TR);
	    this.wtTable.tbodyChildrenLength++;
	  },
	  getOrCreateTrForRow: function(rowIndex, currentTr) {
	    var TR;
	    if (rowIndex >= this.wtTable.tbodyChildrenLength) {
	      TR = this.createRow();
	      this.appendToTbody(TR);
	    } else if (rowIndex === 0) {
	      TR = this.TBODY.firstChild;
	    } else {
	      TR = currentTr.nextSibling;
	    }
	    if (TR.className) {
	      TR.removeAttribute('class');
	    }
	    return TR;
	  },
	  createRow: function() {
	    var TR = document.createElement('TR');
	    for (var visibleColIndex = 0; visibleColIndex < this.rowHeaderCount; visibleColIndex++) {
	      TR.appendChild(document.createElement('TH'));
	    }
	    return TR;
	  },
	  renderRowHeader: function(row, col, TH) {
	    TH.className = '';
	    TH.removeAttribute('style');
	    this.rowHeaders[col](row, TH, col);
	  },
	  renderRowHeaders: function(row, TR) {
	    for (var TH = TR.firstChild,
	        visibleColIndex = 0; visibleColIndex < this.rowHeaderCount; visibleColIndex++) {
	      if (!TH) {
	        TH = document.createElement('TH');
	        TR.appendChild(TH);
	      } else if (TH.nodeName == 'TD') {
	        TH = replaceTdWithTh(TH, TR);
	      }
	      this.renderRowHeader(row, visibleColIndex, TH);
	      TH = TH.nextSibling;
	    }
	  },
	  adjustAvailableNodes: function() {
	    this.adjustColGroups();
	    this.adjustThead();
	  },
	  renderColumnHeaders: function() {
	    var overlayName = this.wot.getOverlayName();
	    if (!this.columnHeaderCount) {
	      return;
	    }
	    var columnCount = this.wtTable.getRenderedColumnsCount();
	    for (var i = 0; i < this.columnHeaderCount; i++) {
	      var TR = this.getTrForColumnHeaders(i);
	      for (var renderedColumnIndex = (-1) * this.rowHeaderCount; renderedColumnIndex < columnCount; renderedColumnIndex++) {
	        var sourceCol = this.columnFilter.renderedToSource(renderedColumnIndex);
	        this.renderColumnHeader(i, sourceCol, TR.childNodes[renderedColumnIndex + this.rowHeaderCount]);
	      }
	    }
	  },
	  adjustColGroups: function() {
	    var columnCount = this.wtTable.getRenderedColumnsCount();
	    while (this.wtTable.colgroupChildrenLength < columnCount + this.rowHeaderCount) {
	      this.COLGROUP.appendChild(document.createElement('COL'));
	      this.wtTable.colgroupChildrenLength++;
	    }
	    while (this.wtTable.colgroupChildrenLength > columnCount + this.rowHeaderCount) {
	      this.COLGROUP.removeChild(this.COLGROUP.lastChild);
	      this.wtTable.colgroupChildrenLength--;
	    }
	    if (this.rowHeaderCount) {
	      addClass(this.COLGROUP.childNodes[0], 'rowHeader');
	    }
	  },
	  adjustThead: function() {
	    var columnCount = this.wtTable.getRenderedColumnsCount();
	    var TR = this.THEAD.firstChild;
	    if (this.columnHeaders.length) {
	      for (var i = 0,
	          len = this.columnHeaders.length; i < len; i++) {
	        TR = this.THEAD.childNodes[i];
	        if (!TR) {
	          TR = document.createElement('TR');
	          this.THEAD.appendChild(TR);
	        }
	        this.theadChildrenLength = TR.childNodes.length;
	        while (this.theadChildrenLength < columnCount + this.rowHeaderCount) {
	          TR.appendChild(document.createElement('TH'));
	          this.theadChildrenLength++;
	        }
	        while (this.theadChildrenLength > columnCount + this.rowHeaderCount) {
	          TR.removeChild(TR.lastChild);
	          this.theadChildrenLength--;
	        }
	      }
	      var theadChildrenLength = this.THEAD.childNodes.length;
	      if (theadChildrenLength > this.columnHeaders.length) {
	        for (var i$__3 = this.columnHeaders.length; i$__3 < theadChildrenLength; i$__3++) {
	          this.THEAD.removeChild(this.THEAD.lastChild);
	        }
	      }
	    } else if (TR) {
	      empty(TR);
	    }
	  },
	  getTrForColumnHeaders: function(index) {
	    return this.THEAD.childNodes[index];
	  },
	  renderColumnHeader: function(row, col, TH) {
	    TH.className = '';
	    TH.removeAttribute('style');
	    return this.columnHeaders[row](col, TH, row);
	  },
	  adjustColumns: function(TR, desiredCount) {
	    var count = TR.childNodes.length;
	    while (count < desiredCount) {
	      var TD = document.createElement('TD');
	      TR.appendChild(TD);
	      count++;
	    }
	    while (count > desiredCount) {
	      TR.removeChild(TR.lastChild);
	      count--;
	    }
	  },
	  removeRedundantColumns: function(columnsToRender) {
	    while (this.wtTable.tbodyChildrenLength > columnsToRender) {
	      this.TBODY.removeChild(this.TBODY.lastChild);
	      this.wtTable.tbodyChildrenLength--;
	    }
	  }
	}, {});
	function replaceTdWithTh(TD, TR) {
	  var TH = document.createElement('TH');
	  TR.insertBefore(TH, TD);
	  TR.removeChild(TD);
	  return TH;
	}
	function replaceThWithTd(TH, TR) {
	  var TD = document.createElement('TD');
	  TR.insertBefore(TD, TH);
	  TR.removeChild(TH);
	  return TD;
	}
	;
	window.WalkontableTableRenderer = WalkontableTableRenderer;

	//# 
	},{"helpers/dom/element":46}],22:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableViewport: {get: function() {
	      return WalkontableViewport;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_browser__,
	    $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47__46__46__47_eventManager__,
	    $__calculator_47_viewportColumns__,
	    $__calculator_47_viewportRows__;
	var Handsontable = ($___46__46__47__46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47__46__46__47_browser__}).default;
	var $__1 = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    getScrollbarWidth = $__1.getScrollbarWidth,
	    getScrollTop = $__1.getScrollTop,
	    getStyle = $__1.getStyle,
	    offset = $__1.offset,
	    outerHeight = $__1.outerHeight,
	    outerWidth = $__1.outerWidth;
	var EventManager = ($___46__46__47__46__46__47__46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47__46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47__46__46__47_eventManager__}).EventManager;
	var WalkontableViewportColumnsCalculator = ($__calculator_47_viewportColumns__ = _dereq_("calculator/viewportColumns"), $__calculator_47_viewportColumns__ && $__calculator_47_viewportColumns__.__esModule && $__calculator_47_viewportColumns__ || {default: $__calculator_47_viewportColumns__}).WalkontableViewportColumnsCalculator;
	var WalkontableViewportRowsCalculator = ($__calculator_47_viewportRows__ = _dereq_("calculator/viewportRows"), $__calculator_47_viewportRows__ && $__calculator_47_viewportRows__.__esModule && $__calculator_47_viewportRows__ || {default: $__calculator_47_viewportRows__}).WalkontableViewportRowsCalculator;
	var WalkontableViewport = function WalkontableViewport(wotInstance) {
	  var $__5 = this;
	  this.wot = wotInstance;
	  this.instance = this.wot;
	  this.oversizedRows = [];
	  this.oversizedColumnHeaders = [];
	  this.hasOversizedColumnHeadersMarked = {};
	  this.clientHeight = 0;
	  this.containerWidth = NaN;
	  this.rowHeaderWidth = NaN;
	  this.rowsVisibleCalculator = null;
	  this.columnsVisibleCalculator = null;
	  this.eventManager = new EventManager(this.wot);
	  this.eventManager.addEventListener(window, 'resize', (function() {
	    $__5.clientHeight = $__5.getWorkspaceHeight();
	  }));
	};
	($traceurRuntime.createClass)(WalkontableViewport, {
	  getWorkspaceHeight: function() {
	    var trimmingContainer = this.instance.wtOverlays.topOverlay.trimmingContainer;
	    var elemHeight;
	    var height = 0;
	    if (trimmingContainer === window) {
	      height = document.documentElement.clientHeight;
	    } else {
	      elemHeight = outerHeight(trimmingContainer);
	      height = (elemHeight > 0 && trimmingContainer.clientHeight > 0) ? trimmingContainer.clientHeight : Infinity;
	    }
	    return height;
	  },
	  getWorkspaceWidth: function() {
	    var width;
	    var totalColumns = this.wot.getSetting('totalColumns');
	    var trimmingContainer = this.instance.wtOverlays.leftOverlay.trimmingContainer;
	    var overflow;
	    var stretchSetting = this.wot.getSetting('stretchH');
	    var docOffsetWidth = document.documentElement.offsetWidth;
	    var preventOverflow = this.wot.getSetting('preventOverflow');
	    if (preventOverflow) {
	      return outerWidth(this.instance.wtTable.wtRootElement);
	    }
	    if (Handsontable.freezeOverlays) {
	      width = Math.min(docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);
	    } else {
	      width = Math.min(this.getContainerFillWidth(), docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);
	    }
	    if (trimmingContainer === window && totalColumns > 0 && this.sumColumnWidths(0, totalColumns - 1) > width) {
	      return document.documentElement.clientWidth;
	    }
	    if (trimmingContainer !== window) {
	      overflow = getStyle(this.instance.wtOverlays.leftOverlay.trimmingContainer, 'overflow');
	      if (overflow == 'scroll' || overflow == 'hidden' || overflow == 'auto') {
	        return Math.max(width, trimmingContainer.clientWidth);
	      }
	    }
	    if (stretchSetting === 'none' || !stretchSetting) {
	      return Math.max(width, outerWidth(this.instance.wtTable.TABLE));
	    } else {
	      return width;
	    }
	  },
	  hasVerticalScroll: function() {
	    return this.getWorkspaceActualHeight() > this.getWorkspaceHeight();
	  },
	  hasHorizontalScroll: function() {
	    return this.getWorkspaceActualWidth() > this.getWorkspaceWidth();
	  },
	  sumColumnWidths: function(from, length) {
	    var sum = 0;
	    while (from < length) {
	      sum += this.wot.wtTable.getColumnWidth(from);
	      from++;
	    }
	    return sum;
	  },
	  getContainerFillWidth: function() {
	    if (this.containerWidth) {
	      return this.containerWidth;
	    }
	    var mainContainer = this.instance.wtTable.holder;
	    var fillWidth;
	    var dummyElement;
	    dummyElement = document.createElement('div');
	    dummyElement.style.width = '100%';
	    dummyElement.style.height = '1px';
	    mainContainer.appendChild(dummyElement);
	    fillWidth = dummyElement.offsetWidth;
	    this.containerWidth = fillWidth;
	    mainContainer.removeChild(dummyElement);
	    return fillWidth;
	  },
	  getWorkspaceOffset: function() {
	    return offset(this.wot.wtTable.TABLE);
	  },
	  getWorkspaceActualHeight: function() {
	    return outerHeight(this.wot.wtTable.TABLE);
	  },
	  getWorkspaceActualWidth: function() {
	    return outerWidth(this.wot.wtTable.TABLE) || outerWidth(this.wot.wtTable.TBODY) || outerWidth(this.wot.wtTable.THEAD);
	  },
	  getColumnHeaderHeight: function() {
	    if (isNaN(this.columnHeaderHeight)) {
	      this.columnHeaderHeight = outerHeight(this.wot.wtTable.THEAD);
	    }
	    return this.columnHeaderHeight;
	  },
	  getViewportHeight: function() {
	    var containerHeight = this.getWorkspaceHeight();
	    var columnHeaderHeight;
	    if (containerHeight === Infinity) {
	      return containerHeight;
	    }
	    columnHeaderHeight = this.getColumnHeaderHeight();
	    if (columnHeaderHeight > 0) {
	      containerHeight -= columnHeaderHeight;
	    }
	    return containerHeight;
	  },
	  getRowHeaderWidth: function() {
	    var rowHeadersHeightSetting = this.instance.getSetting('rowHeaderWidth');
	    var rowHeaders = this.instance.getSetting('rowHeaders');
	    if (rowHeadersHeightSetting) {
	      this.rowHeaderWidth = 0;
	      for (var i = 0,
	          len = rowHeaders.length; i < len; i++) {
	        this.rowHeaderWidth += rowHeadersHeightSetting[i] || rowHeadersHeightSetting;
	      }
	    }
	    if (this.wot.cloneSource) {
	      return this.wot.cloneSource.wtViewport.getRowHeaderWidth();
	    }
	    if (isNaN(this.rowHeaderWidth)) {
	      if (rowHeaders.length) {
	        var TH = this.instance.wtTable.TABLE.querySelector('TH');
	        this.rowHeaderWidth = 0;
	        for (var i$__7 = 0,
	            len$__8 = rowHeaders.length; i$__7 < len$__8; i$__7++) {
	          if (TH) {
	            this.rowHeaderWidth += outerWidth(TH);
	            TH = TH.nextSibling;
	          } else {
	            this.rowHeaderWidth += 50;
	          }
	        }
	      } else {
	        this.rowHeaderWidth = 0;
	      }
	    }
	    return this.rowHeaderWidth;
	  },
	  getViewportWidth: function() {
	    var containerWidth = this.getWorkspaceWidth();
	    var rowHeaderWidth;
	    if (containerWidth === Infinity) {
	      return containerWidth;
	    }
	    rowHeaderWidth = this.getRowHeaderWidth();
	    if (rowHeaderWidth > 0) {
	      return containerWidth - rowHeaderWidth;
	    }
	    return containerWidth;
	  },
	  createRowsCalculator: function() {
	    var visible = arguments[0] !== (void 0) ? arguments[0] : false;
	    var $__5 = this;
	    var height;
	    var pos;
	    var fixedRowsTop;
	    var scrollbarHeight;
	    var fixedRowsBottom;
	    var fixedRowsHeight;
	    var totalRows;
	    this.rowHeaderWidth = NaN;
	    if (this.wot.wtSettings.settings.renderAllRows) {
	      height = Infinity;
	    } else {
	      height = this.getViewportHeight();
	    }
	    pos = this.wot.wtOverlays.topOverlay.getScrollPosition() - this.wot.wtOverlays.topOverlay.getTableParentOffset();
	    if (pos < 0) {
	      pos = 0;
	    }
	    fixedRowsTop = this.wot.getSetting('fixedRowsTop');
	    fixedRowsBottom = this.wot.getSetting('fixedRowsBottom');
	    totalRows = this.wot.getSetting('totalRows');
	    if (fixedRowsTop) {
	      fixedRowsHeight = this.wot.wtOverlays.topOverlay.sumCellSizes(0, fixedRowsTop);
	      pos += fixedRowsHeight;
	      height -= fixedRowsHeight;
	    }
	    if (fixedRowsBottom && this.wot.wtOverlays.bottomOverlay.clone) {
	      fixedRowsHeight = this.wot.wtOverlays.bottomOverlay.sumCellSizes(totalRows - fixedRowsBottom, totalRows);
	      height -= fixedRowsHeight;
	    }
	    if (this.wot.wtTable.holder.clientHeight === this.wot.wtTable.holder.offsetHeight) {
	      scrollbarHeight = 0;
	    } else {
	      scrollbarHeight = getScrollbarWidth();
	    }
	    return new WalkontableViewportRowsCalculator(height, pos, this.wot.getSetting('totalRows'), (function(sourceRow) {
	      return $__5.wot.wtTable.getRowHeight(sourceRow);
	    }), visible ? null : this.wot.wtSettings.settings.viewportRowCalculatorOverride, visible, scrollbarHeight);
	  },
	  createColumnsCalculator: function() {
	    var visible = arguments[0] !== (void 0) ? arguments[0] : false;
	    var $__5 = this;
	    var width = this.getViewportWidth();
	    var pos;
	    var fixedColumnsLeft;
	    this.columnHeaderHeight = NaN;
	    pos = this.wot.wtOverlays.leftOverlay.getScrollPosition() - this.wot.wtOverlays.leftOverlay.getTableParentOffset();
	    if (pos < 0) {
	      pos = 0;
	    }
	    fixedColumnsLeft = this.wot.getSetting('fixedColumnsLeft');
	    if (fixedColumnsLeft) {
	      var fixedColumnsWidth = this.wot.wtOverlays.leftOverlay.sumCellSizes(0, fixedColumnsLeft);
	      pos += fixedColumnsWidth;
	      width -= fixedColumnsWidth;
	    }
	    if (this.wot.wtTable.holder.clientWidth !== this.wot.wtTable.holder.offsetWidth) {
	      width -= getScrollbarWidth();
	    }
	    return new WalkontableViewportColumnsCalculator(width, pos, this.wot.getSetting('totalColumns'), (function(sourceCol) {
	      return $__5.wot.wtTable.getColumnWidth(sourceCol);
	    }), visible ? null : this.wot.wtSettings.settings.viewportColumnCalculatorOverride, visible, this.wot.getSetting('stretchH'), (function(stretchedWidth, column) {
	      return $__5.wot.getSetting('onBeforeStretchingColumnWidth', stretchedWidth, column);
	    }));
	  },
	  createRenderCalculators: function() {
	    var fastDraw = arguments[0] !== (void 0) ? arguments[0] : false;
	    if (fastDraw) {
	      var proposedRowsVisibleCalculator = this.createRowsCalculator(true);
	      var proposedColumnsVisibleCalculator = this.createColumnsCalculator(true);
	      if (!(this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) && this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator))) {
	        fastDraw = false;
	      }
	    }
	    if (!fastDraw) {
	      this.rowsRenderCalculator = this.createRowsCalculator();
	      this.columnsRenderCalculator = this.createColumnsCalculator();
	    }
	    this.rowsVisibleCalculator = null;
	    this.columnsVisibleCalculator = null;
	    return fastDraw;
	  },
	  createVisibleCalculators: function() {
	    this.rowsVisibleCalculator = this.createRowsCalculator(true);
	    this.columnsVisibleCalculator = this.createColumnsCalculator(true);
	  },
	  areAllProposedVisibleRowsAlreadyRendered: function(proposedRowsVisibleCalculator) {
	    if (this.rowsVisibleCalculator) {
	      if (proposedRowsVisibleCalculator.startRow < this.rowsRenderCalculator.startRow || (proposedRowsVisibleCalculator.startRow === this.rowsRenderCalculator.startRow && proposedRowsVisibleCalculator.startRow > 0)) {
	        return false;
	      } else if (proposedRowsVisibleCalculator.endRow > this.rowsRenderCalculator.endRow || (proposedRowsVisibleCalculator.endRow === this.rowsRenderCalculator.endRow && proposedRowsVisibleCalculator.endRow < this.wot.getSetting('totalRows') - 1)) {
	        return false;
	      } else {
	        return true;
	      }
	    }
	    return false;
	  },
	  areAllProposedVisibleColumnsAlreadyRendered: function(proposedColumnsVisibleCalculator) {
	    if (this.columnsVisibleCalculator) {
	      if (proposedColumnsVisibleCalculator.startColumn < this.columnsRenderCalculator.startColumn || (proposedColumnsVisibleCalculator.startColumn === this.columnsRenderCalculator.startColumn && proposedColumnsVisibleCalculator.startColumn > 0)) {
	        return false;
	      } else if (proposedColumnsVisibleCalculator.endColumn > this.columnsRenderCalculator.endColumn || (proposedColumnsVisibleCalculator.endColumn === this.columnsRenderCalculator.endColumn && proposedColumnsVisibleCalculator.endColumn < this.wot.getSetting('totalColumns') - 1)) {
	        return false;
	      } else {
	        return true;
	      }
	    }
	    return false;
	  }
	}, {});
	;
	window.WalkontableViewport = WalkontableViewport;

	//# 
	},{"browser":23,"calculator/viewportColumns":3,"calculator/viewportRows":4,"eventManager":41,"helpers/dom/element":46}],23:[function(_dereq_,module,exports){
	"use strict";
	var $__shims_47_runtime__,
	    $__es6collections__,
	    $__pluginHooks__,
	    $__core__,
	    $__renderers_47__95_cellDecorator__,
	    $__cellTypes__,
	    $___46__46__47_plugins_47_jqueryHandsontable__,
	    $__helpers_47_array__,
	    $__helpers_47_browser__,
	    $__helpers_47_data__,
	    $__helpers_47_date__,
	    $__helpers_47_feature__,
	    $__helpers_47_function__,
	    $__helpers_47_mixed__,
	    $__helpers_47_number__,
	    $__helpers_47_object__,
	    $__helpers_47_setting__,
	    $__helpers_47_string__,
	    $__helpers_47_unicode__,
	    $__helpers_47_dom_47_element__,
	    $__helpers_47_dom_47_event__,
	    $__plugins__;
	function Handsontable(rootElement, userSettings) {
	  var instance = new Handsontable.Core(rootElement, userSettings || {});
	  instance.init();
	  return instance;
	}
	module.exports = Handsontable;
	Handsontable.utils = {};
	($__shims_47_runtime__ = _dereq_("shims/runtime"), $__shims_47_runtime__ && $__shims_47_runtime__.__esModule && $__shims_47_runtime__ || {default: $__shims_47_runtime__});
	($__es6collections__ = _dereq_("es6collections"), $__es6collections__ && $__es6collections__.__esModule && $__es6collections__ || {default: $__es6collections__});
	var Hooks = ($__pluginHooks__ = _dereq_("pluginHooks"), $__pluginHooks__ && $__pluginHooks__.__esModule && $__pluginHooks__ || {default: $__pluginHooks__}).Hooks;
	if (!Handsontable.hooks) {
	  Handsontable.hooks = new Hooks();
	}
	Handsontable.utils.Hooks = Hooks;
	($__core__ = _dereq_("core"), $__core__ && $__core__.__esModule && $__core__ || {default: $__core__});
	($__renderers_47__95_cellDecorator__ = _dereq_("renderers/_cellDecorator"), $__renderers_47__95_cellDecorator__ && $__renderers_47__95_cellDecorator__.__esModule && $__renderers_47__95_cellDecorator__ || {default: $__renderers_47__95_cellDecorator__});
	($__cellTypes__ = _dereq_("cellTypes"), $__cellTypes__ && $__cellTypes__.__esModule && $__cellTypes__ || {default: $__cellTypes__});
	($___46__46__47_plugins_47_jqueryHandsontable__ = _dereq_("plugins/jqueryHandsontable"), $___46__46__47_plugins_47_jqueryHandsontable__ && $___46__46__47_plugins_47_jqueryHandsontable__.__esModule && $___46__46__47_plugins_47_jqueryHandsontable__ || {default: $___46__46__47_plugins_47_jqueryHandsontable__});
	var arrayHelpers = ($__helpers_47_array__ = _dereq_("helpers/array"), $__helpers_47_array__ && $__helpers_47_array__.__esModule && $__helpers_47_array__ || {default: $__helpers_47_array__});
	var browserHelpers = ($__helpers_47_browser__ = _dereq_("helpers/browser"), $__helpers_47_browser__ && $__helpers_47_browser__.__esModule && $__helpers_47_browser__ || {default: $__helpers_47_browser__});
	var dataHelpers = ($__helpers_47_data__ = _dereq_("helpers/data"), $__helpers_47_data__ && $__helpers_47_data__.__esModule && $__helpers_47_data__ || {default: $__helpers_47_data__});
	var dateHelpers = ($__helpers_47_date__ = _dereq_("helpers/date"), $__helpers_47_date__ && $__helpers_47_date__.__esModule && $__helpers_47_date__ || {default: $__helpers_47_date__});
	var featureHelpers = ($__helpers_47_feature__ = _dereq_("helpers/feature"), $__helpers_47_feature__ && $__helpers_47_feature__.__esModule && $__helpers_47_feature__ || {default: $__helpers_47_feature__});
	var functionHelpers = ($__helpers_47_function__ = _dereq_("helpers/function"), $__helpers_47_function__ && $__helpers_47_function__.__esModule && $__helpers_47_function__ || {default: $__helpers_47_function__});
	var mixedHelpers = ($__helpers_47_mixed__ = _dereq_("helpers/mixed"), $__helpers_47_mixed__ && $__helpers_47_mixed__.__esModule && $__helpers_47_mixed__ || {default: $__helpers_47_mixed__});
	var numberHelpers = ($__helpers_47_number__ = _dereq_("helpers/number"), $__helpers_47_number__ && $__helpers_47_number__.__esModule && $__helpers_47_number__ || {default: $__helpers_47_number__});
	var objectHelpers = ($__helpers_47_object__ = _dereq_("helpers/object"), $__helpers_47_object__ && $__helpers_47_object__.__esModule && $__helpers_47_object__ || {default: $__helpers_47_object__});
	var settingHelpers = ($__helpers_47_setting__ = _dereq_("helpers/setting"), $__helpers_47_setting__ && $__helpers_47_setting__.__esModule && $__helpers_47_setting__ || {default: $__helpers_47_setting__});
	var stringHelpers = ($__helpers_47_string__ = _dereq_("helpers/string"), $__helpers_47_string__ && $__helpers_47_string__.__esModule && $__helpers_47_string__ || {default: $__helpers_47_string__});
	var unicodeHelpers = ($__helpers_47_unicode__ = _dereq_("helpers/unicode"), $__helpers_47_unicode__ && $__helpers_47_unicode__.__esModule && $__helpers_47_unicode__ || {default: $__helpers_47_unicode__});
	var domHelpers = ($__helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $__helpers_47_dom_47_element__ && $__helpers_47_dom_47_element__.__esModule && $__helpers_47_dom_47_element__ || {default: $__helpers_47_dom_47_element__});
	var domEventHelpers = ($__helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $__helpers_47_dom_47_event__ && $__helpers_47_dom_47_event__.__esModule && $__helpers_47_dom_47_event__ || {default: $__helpers_47_dom_47_event__});
	var HELPERS = [arrayHelpers, browserHelpers, dataHelpers, dateHelpers, featureHelpers, functionHelpers, mixedHelpers, numberHelpers, objectHelpers, settingHelpers, stringHelpers, unicodeHelpers];
	var DOM = [domHelpers, domEventHelpers];
	Handsontable.buildDate = 'Wed May 25 2016 12:36:41 GMT+0200 (CEST)';
	Handsontable.packageName = 'handsontable';
	Handsontable.version = '0.25.0';
	var baseVersion = '@@baseVersion';
	if (!/^@@/.test(baseVersion)) {
	  Handsontable.baseVersion = baseVersion;
	}
	Handsontable.plugins = {};
	var registerPlugin = ($__plugins__ = _dereq_("plugins"), $__plugins__ && $__plugins__.__esModule && $__plugins__ || {default: $__plugins__}).registerPlugin;
	Handsontable.plugins.registerPlugin = registerPlugin;
	Handsontable.helper = {};
	Handsontable.dom = {};
	Handsontable.Dom = Handsontable.dom;
	arrayHelpers.arrayEach(HELPERS, (function(helper) {
	  arrayHelpers.arrayEach(Object.getOwnPropertyNames(helper), (function(key) {
	    if (key.charAt(0) !== '_') {
	      Handsontable.helper[key] = helper[key];
	    }
	  }));
	}));
	arrayHelpers.arrayEach(DOM, (function(helper) {
	  arrayHelpers.arrayEach(Object.getOwnPropertyNames(helper), (function(key) {
	    if (key.charAt(0) !== '_') {
	      Handsontable.dom[key] = helper[key];
	    }
	  }));
	}));

	//# 
	},{"cellTypes":24,"core":25,"es6collections":"es6collections","helpers/array":42,"helpers/browser":43,"helpers/data":44,"helpers/date":45,"helpers/dom/element":46,"helpers/dom/event":47,"helpers/feature":48,"helpers/function":49,"helpers/mixed":50,"helpers/number":51,"helpers/object":52,"helpers/setting":53,"helpers/string":54,"helpers/unicode":55,"pluginHooks":58,"plugins":59,"plugins/jqueryHandsontable":1,"renderers/_cellDecorator":93,"shims/runtime":100}],24:[function(_dereq_,module,exports){
	"use strict";
	var $__helpers_47_browser__,
	    $__editors__,
	    $__renderers__,
	    $__editors_47_autocompleteEditor__,
	    $__editors_47_checkboxEditor__,
	    $__editors_47_dateEditor__,
	    $__editors_47_dropdownEditor__,
	    $__editors_47_handsontableEditor__,
	    $__editors_47_mobileTextEditor__,
	    $__editors_47_numericEditor__,
	    $__editors_47_passwordEditor__,
	    $__editors_47_selectEditor__,
	    $__editors_47_textEditor__,
	    $__renderers_47_autocompleteRenderer__,
	    $__renderers_47_checkboxRenderer__,
	    $__renderers_47_htmlRenderer__,
	    $__renderers_47_numericRenderer__,
	    $__renderers_47_passwordRenderer__,
	    $__renderers_47_textRenderer__,
	    $__validators_47_autocompleteValidator__,
	    $__validators_47_dateValidator__,
	    $__validators_47_timeValidator__,
	    $__validators_47_numericValidator__,
	    $__browser__;
	var isMobileBrowser = ($__helpers_47_browser__ = _dereq_("helpers/browser"), $__helpers_47_browser__ && $__helpers_47_browser__.__esModule && $__helpers_47_browser__ || {default: $__helpers_47_browser__}).isMobileBrowser;
	var getEditorConstructor = ($__editors__ = _dereq_("editors"), $__editors__ && $__editors__.__esModule && $__editors__ || {default: $__editors__}).getEditorConstructor;
	var getRenderer = ($__renderers__ = _dereq_("renderers"), $__renderers__ && $__renderers__.__esModule && $__renderers__ || {default: $__renderers__}).getRenderer;
	var AutocompleteEditor = ($__editors_47_autocompleteEditor__ = _dereq_("editors/autocompleteEditor"), $__editors_47_autocompleteEditor__ && $__editors_47_autocompleteEditor__.__esModule && $__editors_47_autocompleteEditor__ || {default: $__editors_47_autocompleteEditor__}).AutocompleteEditor;
	var CheckboxEditor = ($__editors_47_checkboxEditor__ = _dereq_("editors/checkboxEditor"), $__editors_47_checkboxEditor__ && $__editors_47_checkboxEditor__.__esModule && $__editors_47_checkboxEditor__ || {default: $__editors_47_checkboxEditor__}).CheckboxEditor;
	var DateEditor = ($__editors_47_dateEditor__ = _dereq_("editors/dateEditor"), $__editors_47_dateEditor__ && $__editors_47_dateEditor__.__esModule && $__editors_47_dateEditor__ || {default: $__editors_47_dateEditor__}).DateEditor;
	var DropdownEditor = ($__editors_47_dropdownEditor__ = _dereq_("editors/dropdownEditor"), $__editors_47_dropdownEditor__ && $__editors_47_dropdownEditor__.__esModule && $__editors_47_dropdownEditor__ || {default: $__editors_47_dropdownEditor__}).DropdownEditor;
	var HandsontableEditor = ($__editors_47_handsontableEditor__ = _dereq_("editors/handsontableEditor"), $__editors_47_handsontableEditor__ && $__editors_47_handsontableEditor__.__esModule && $__editors_47_handsontableEditor__ || {default: $__editors_47_handsontableEditor__}).HandsontableEditor;
	var MobileTextEditor = ($__editors_47_mobileTextEditor__ = _dereq_("editors/mobileTextEditor"), $__editors_47_mobileTextEditor__ && $__editors_47_mobileTextEditor__.__esModule && $__editors_47_mobileTextEditor__ || {default: $__editors_47_mobileTextEditor__}).MobileTextEditor;
	var NumericEditor = ($__editors_47_numericEditor__ = _dereq_("editors/numericEditor"), $__editors_47_numericEditor__ && $__editors_47_numericEditor__.__esModule && $__editors_47_numericEditor__ || {default: $__editors_47_numericEditor__}).NumericEditor;
	var PasswordEditor = ($__editors_47_passwordEditor__ = _dereq_("editors/passwordEditor"), $__editors_47_passwordEditor__ && $__editors_47_passwordEditor__.__esModule && $__editors_47_passwordEditor__ || {default: $__editors_47_passwordEditor__}).PasswordEditor;
	var SelectEditor = ($__editors_47_selectEditor__ = _dereq_("editors/selectEditor"), $__editors_47_selectEditor__ && $__editors_47_selectEditor__.__esModule && $__editors_47_selectEditor__ || {default: $__editors_47_selectEditor__}).SelectEditor;
	var TextEditor = ($__editors_47_textEditor__ = _dereq_("editors/textEditor"), $__editors_47_textEditor__ && $__editors_47_textEditor__.__esModule && $__editors_47_textEditor__ || {default: $__editors_47_textEditor__}).TextEditor;
	var AutocompleteRenderer = ($__renderers_47_autocompleteRenderer__ = _dereq_("renderers/autocompleteRenderer"), $__renderers_47_autocompleteRenderer__ && $__renderers_47_autocompleteRenderer__.__esModule && $__renderers_47_autocompleteRenderer__ || {default: $__renderers_47_autocompleteRenderer__}).AutocompleteRenderer;
	var CheckboxRenderer = ($__renderers_47_checkboxRenderer__ = _dereq_("renderers/checkboxRenderer"), $__renderers_47_checkboxRenderer__ && $__renderers_47_checkboxRenderer__.__esModule && $__renderers_47_checkboxRenderer__ || {default: $__renderers_47_checkboxRenderer__}).CheckboxRenderer;
	var HtmlRenderer = ($__renderers_47_htmlRenderer__ = _dereq_("renderers/htmlRenderer"), $__renderers_47_htmlRenderer__ && $__renderers_47_htmlRenderer__.__esModule && $__renderers_47_htmlRenderer__ || {default: $__renderers_47_htmlRenderer__}).HtmlRenderer;
	var NumericRenderer = ($__renderers_47_numericRenderer__ = _dereq_("renderers/numericRenderer"), $__renderers_47_numericRenderer__ && $__renderers_47_numericRenderer__.__esModule && $__renderers_47_numericRenderer__ || {default: $__renderers_47_numericRenderer__}).NumericRenderer;
	var PasswordRenderer = ($__renderers_47_passwordRenderer__ = _dereq_("renderers/passwordRenderer"), $__renderers_47_passwordRenderer__ && $__renderers_47_passwordRenderer__.__esModule && $__renderers_47_passwordRenderer__ || {default: $__renderers_47_passwordRenderer__}).PasswordRenderer;
	var TextRenderer = ($__renderers_47_textRenderer__ = _dereq_("renderers/textRenderer"), $__renderers_47_textRenderer__ && $__renderers_47_textRenderer__.__esModule && $__renderers_47_textRenderer__ || {default: $__renderers_47_textRenderer__}).TextRenderer;
	var AutocompleteValidator = ($__validators_47_autocompleteValidator__ = _dereq_("validators/autocompleteValidator"), $__validators_47_autocompleteValidator__ && $__validators_47_autocompleteValidator__.__esModule && $__validators_47_autocompleteValidator__ || {default: $__validators_47_autocompleteValidator__}).AutocompleteValidator;
	var DateValidator = ($__validators_47_dateValidator__ = _dereq_("validators/dateValidator"), $__validators_47_dateValidator__ && $__validators_47_dateValidator__.__esModule && $__validators_47_dateValidator__ || {default: $__validators_47_dateValidator__}).DateValidator;
	var TimeValidator = ($__validators_47_timeValidator__ = _dereq_("validators/timeValidator"), $__validators_47_timeValidator__ && $__validators_47_timeValidator__.__esModule && $__validators_47_timeValidator__ || {default: $__validators_47_timeValidator__}).TimeValidator;
	var NumericValidator = ($__validators_47_numericValidator__ = _dereq_("validators/numericValidator"), $__validators_47_numericValidator__ && $__validators_47_numericValidator__.__esModule && $__validators_47_numericValidator__ || {default: $__validators_47_numericValidator__}).NumericValidator;
	var Handsontable = ($__browser__ = _dereq_("browser"), $__browser__ && $__browser__.__esModule && $__browser__ || {default: $__browser__}).default;
	Handsontable.AutocompleteCell = {
	  editor: getEditorConstructor('autocomplete'),
	  renderer: getRenderer('autocomplete'),
	  validator: Handsontable.AutocompleteValidator
	};
	Handsontable.CheckboxCell = {
	  editor: getEditorConstructor('checkbox'),
	  renderer: getRenderer('checkbox')
	};
	Handsontable.TextCell = {
	  editor: isMobileBrowser() ? getEditorConstructor('mobile') : getEditorConstructor('text'),
	  renderer: getRenderer('text')
	};
	Handsontable.NumericCell = {
	  editor: getEditorConstructor('numeric'),
	  renderer: getRenderer('numeric'),
	  validator: Handsontable.NumericValidator,
	  dataType: 'number'
	};
	Handsontable.DateCell = {
	  editor: getEditorConstructor('date'),
	  validator: Handsontable.DateValidator,
	  renderer: getRenderer('autocomplete')
	};
	Handsontable.TimeCell = {
	  editor: getEditorConstructor('text'),
	  validator: Handsontable.TimeValidator,
	  renderer: getRenderer('text')
	};
	Handsontable.HandsontableCell = {
	  editor: getEditorConstructor('handsontable'),
	  renderer: getRenderer('autocomplete')
	};
	Handsontable.PasswordCell = {
	  editor: getEditorConstructor('password'),
	  renderer: getRenderer('password'),
	  copyable: false
	};
	Handsontable.DropdownCell = {
	  editor: getEditorConstructor('dropdown'),
	  renderer: getRenderer('autocomplete'),
	  validator: Handsontable.AutocompleteValidator
	};
	Handsontable.cellTypes = {
	  text: Handsontable.TextCell,
	  date: Handsontable.DateCell,
	  time: Handsontable.TimeCell,
	  numeric: Handsontable.NumericCell,
	  checkbox: Handsontable.CheckboxCell,
	  autocomplete: Handsontable.AutocompleteCell,
	  handsontable: Handsontable.HandsontableCell,
	  password: Handsontable.PasswordCell,
	  dropdown: Handsontable.DropdownCell
	};
	Handsontable.cellLookup = {validator: {
	    numeric: Handsontable.NumericValidator,
	    autocomplete: Handsontable.AutocompleteValidator
	  }};

	//# 
	},{"browser":23,"editors":29,"editors/autocompleteEditor":31,"editors/checkboxEditor":32,"editors/dateEditor":33,"editors/dropdownEditor":34,"editors/handsontableEditor":35,"editors/mobileTextEditor":36,"editors/numericEditor":37,"editors/passwordEditor":38,"editors/selectEditor":39,"editors/textEditor":40,"helpers/browser":43,"renderers":92,"renderers/autocompleteRenderer":94,"renderers/checkboxRenderer":95,"renderers/htmlRenderer":96,"renderers/numericRenderer":97,"renderers/passwordRenderer":98,"renderers/textRenderer":99,"validators/autocompleteValidator":105,"validators/dateValidator":106,"validators/numericValidator":107,"validators/timeValidator":108}],25:[function(_dereq_,module,exports){
	"use strict";
	var $__browser__,
	    $__numeral__,
	    $__helpers_47_dom_47_element__,
	    $__helpers_47_setting__,
	    $__helpers_47_browser__,
	    $__dataMap__,
	    $__editorManager__,
	    $__eventManager__,
	    $__helpers_47_object__,
	    $__helpers_47_array__,
	    $__plugins__,
	    $__renderers__,
	    $__helpers_47_string__,
	    $__helpers_47_number__,
	    $__tableView__,
	    $__dataSource__,
	    $__helpers_47_data__,
	    $__3rdparty_47_walkontable_47_src_47_cell_47_coords__,
	    $__3rdparty_47_walkontable_47_src_47_cell_47_range__,
	    $__3rdparty_47_walkontable_47_src_47_selection__,
	    $__3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__;
	var Handsontable = ($__browser__ = _dereq_("browser"), $__browser__ && $__browser__.__esModule && $__browser__ || {default: $__browser__}).default;
	var numeral = ($__numeral__ = _dereq_("numeral"), $__numeral__ && $__numeral__.__esModule && $__numeral__ || {default: $__numeral__}).default;
	var $__2 = ($__helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $__helpers_47_dom_47_element__ && $__helpers_47_dom_47_element__.__esModule && $__helpers_47_dom_47_element__ || {default: $__helpers_47_dom_47_element__}),
	    addClass = $__2.addClass,
	    empty = $__2.empty,
	    isChildOfWebComponentTable = $__2.isChildOfWebComponentTable,
	    removeClass = $__2.removeClass;
	var columnFactory = ($__helpers_47_setting__ = _dereq_("helpers/setting"), $__helpers_47_setting__ && $__helpers_47_setting__.__esModule && $__helpers_47_setting__ || {default: $__helpers_47_setting__}).columnFactory;
	var isMobileBrowser = ($__helpers_47_browser__ = _dereq_("helpers/browser"), $__helpers_47_browser__ && $__helpers_47_browser__.__esModule && $__helpers_47_browser__ || {default: $__helpers_47_browser__}).isMobileBrowser;
	var DataMap = ($__dataMap__ = _dereq_("dataMap"), $__dataMap__ && $__dataMap__.__esModule && $__dataMap__ || {default: $__dataMap__}).DataMap;
	var EditorManager = ($__editorManager__ = _dereq_("editorManager"), $__editorManager__ && $__editorManager__.__esModule && $__editorManager__ || {default: $__editorManager__}).EditorManager;
	var eventManagerObject = ($__eventManager__ = _dereq_("eventManager"), $__eventManager__ && $__eventManager__.__esModule && $__eventManager__ || {default: $__eventManager__}).eventManager;
	var $__8 = ($__helpers_47_object__ = _dereq_("helpers/object"), $__helpers_47_object__ && $__helpers_47_object__.__esModule && $__helpers_47_object__ || {default: $__helpers_47_object__}),
	    extend = $__8.extend,
	    duckSchema = $__8.duckSchema,
	    isObjectEquals = $__8.isObjectEquals,
	    deepClone = $__8.deepClone;
	var $__9 = ($__helpers_47_array__ = _dereq_("helpers/array"), $__helpers_47_array__ && $__helpers_47_array__.__esModule && $__helpers_47_array__ || {default: $__helpers_47_array__}),
	    arrayFlatten = $__9.arrayFlatten,
	    arrayMap = $__9.arrayMap;
	var getPlugin = ($__plugins__ = _dereq_("plugins"), $__plugins__ && $__plugins__.__esModule && $__plugins__ || {default: $__plugins__}).getPlugin;
	var getRenderer = ($__renderers__ = _dereq_("renderers"), $__renderers__ && $__renderers__.__esModule && $__renderers__ || {default: $__renderers__}).getRenderer;
	var randomString = ($__helpers_47_string__ = _dereq_("helpers/string"), $__helpers_47_string__ && $__helpers_47_string__.__esModule && $__helpers_47_string__ || {default: $__helpers_47_string__}).randomString;
	var rangeEach = ($__helpers_47_number__ = _dereq_("helpers/number"), $__helpers_47_number__ && $__helpers_47_number__.__esModule && $__helpers_47_number__ || {default: $__helpers_47_number__}).rangeEach;
	var TableView = ($__tableView__ = _dereq_("tableView"), $__tableView__ && $__tableView__.__esModule && $__tableView__ || {default: $__tableView__}).TableView;
	var DataSource = ($__dataSource__ = _dereq_("dataSource"), $__dataSource__ && $__dataSource__.__esModule && $__dataSource__ || {default: $__dataSource__}).DataSource;
	var $__16 = ($__helpers_47_data__ = _dereq_("helpers/data"), $__helpers_47_data__ && $__helpers_47_data__.__esModule && $__helpers_47_data__ || {default: $__helpers_47_data__}),
	    translateRowsToColumns = $__16.translateRowsToColumns,
	    cellMethodLookupFactory = $__16.cellMethodLookupFactory,
	    spreadsheetColumnLabel = $__16.spreadsheetColumnLabel;
	var WalkontableCellCoords = ($__3rdparty_47_walkontable_47_src_47_cell_47_coords__ = _dereq_("3rdparty/walkontable/src/cell/coords"), $__3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $__3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $__3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $__3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	var WalkontableCellRange = ($__3rdparty_47_walkontable_47_src_47_cell_47_range__ = _dereq_("3rdparty/walkontable/src/cell/range"), $__3rdparty_47_walkontable_47_src_47_cell_47_range__ && $__3rdparty_47_walkontable_47_src_47_cell_47_range__.__esModule && $__3rdparty_47_walkontable_47_src_47_cell_47_range__ || {default: $__3rdparty_47_walkontable_47_src_47_cell_47_range__}).WalkontableCellRange;
	var WalkontableSelection = ($__3rdparty_47_walkontable_47_src_47_selection__ = _dereq_("3rdparty/walkontable/src/selection"), $__3rdparty_47_walkontable_47_src_47_selection__ && $__3rdparty_47_walkontable_47_src_47_selection__.__esModule && $__3rdparty_47_walkontable_47_src_47_selection__ || {default: $__3rdparty_47_walkontable_47_src_47_selection__}).WalkontableSelection;
	var WalkontableViewportColumnsCalculator = ($__3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__ = _dereq_("3rdparty/walkontable/src/calculator/viewportColumns"), $__3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__ && $__3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__.__esModule && $__3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__ || {default: $__3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__}).WalkontableViewportColumnsCalculator;
	Handsontable.activeGuid = null;
	Handsontable.Core = function Core(rootElement, userSettings) {
	  var priv,
	      datamap,
	      dataSource,
	      grid,
	      selection,
	      editorManager,
	      instance = this,
	      GridSettings = function() {},
	      eventManager = eventManagerObject(instance);
	  extend(GridSettings.prototype, DefaultSettings.prototype);
	  extend(GridSettings.prototype, userSettings);
	  extend(GridSettings.prototype, expandType(userSettings));
	  this.rootElement = rootElement;
	  this.isHotTableEnv = isChildOfWebComponentTable(this.rootElement);
	  Handsontable.eventManager.isHotTableEnv = this.isHotTableEnv;
	  this.container = document.createElement('DIV');
	  this.renderCall = false;
	  rootElement.insertBefore(this.container, rootElement.firstChild);
	  this.guid = 'ht_' + randomString();
	  dataSource = new DataSource(instance);
	  if (!this.rootElement.id || this.rootElement.id.substring(0, 3) === 'ht_') {
	    this.rootElement.id = this.guid;
	  }
	  priv = {
	    cellSettings: [],
	    columnSettings: [],
	    columnsSettingConflicts: ['data', 'width'],
	    settings: new GridSettings(),
	    selRange: null,
	    isPopulated: null,
	    scrollable: null,
	    firstRun: true
	  };
	  grid = {
	    alter: function(action, index, amount, source, keepEmptyRows) {
	      var delta;
	      amount = amount || 1;
	      function spliceWith(data, index, count, toInject) {
	        var valueFactory = (function() {
	          var result;
	          if (toInject === 'array') {
	            result = [];
	          } else if (toInject === 'object') {
	            result = {};
	          }
	          return result;
	        });
	        var spliceArgs = arrayMap(new Array(count), (function() {
	          return valueFactory();
	        }));
	        spliceArgs.unshift(index, 0);
	        data.splice.apply(data, spliceArgs);
	      }
	      switch (action) {
	        case 'insert_row':
	          if (instance.getSettings().maxRows === instance.countSourceRows()) {
	            return;
	          }
	          delta = datamap.createRow(index, amount);
	          spliceWith(priv.cellSettings, index, amount, 'array');
	          if (delta) {
	            if (selection.isSelected() && priv.selRange.from.row >= index) {
	              priv.selRange.from.row = priv.selRange.from.row + delta;
	              selection.transformEnd(delta, 0);
	            } else {
	              selection.refreshBorders();
	            }
	          }
	          break;
	        case 'insert_col':
	          delta = datamap.createCol(index, amount);
	          for (var row = 0,
	              len = instance.countSourceRows(); row < len; row++) {
	            if (priv.cellSettings[row]) {
	              spliceWith(priv.cellSettings[row], index, amount);
	            }
	          }
	          if (delta) {
	            if (Array.isArray(instance.getSettings().colHeaders)) {
	              var spliceArray = [index, 0];
	              spliceArray.length += delta;
	              Array.prototype.splice.apply(instance.getSettings().colHeaders, spliceArray);
	            }
	            if (selection.isSelected() && priv.selRange.from.col >= index) {
	              priv.selRange.from.col = priv.selRange.from.col + delta;
	              selection.transformEnd(0, delta);
	            } else {
	              selection.refreshBorders();
	            }
	          }
	          break;
	        case 'remove_row':
	          datamap.removeRow(index, amount);
	          priv.cellSettings.splice(index, amount);
	          var totalRows = instance.countRows();
	          var fixedRowsTop = instance.getSettings().fixedRowsTop;
	          if (fixedRowsTop >= index + 1) {
	            instance.getSettings().fixedRowsTop -= Math.min(amount, fixedRowsTop - index);
	          }
	          var fixedRowsBottom = instance.getSettings().fixedRowsBottom;
	          if (fixedRowsBottom && index >= totalRows - fixedRowsBottom) {
	            instance.getSettings().fixedRowsBottom -= Math.min(amount, fixedRowsBottom);
	          }
	          grid.adjustRowsAndCols();
	          selection.refreshBorders();
	          break;
	        case 'remove_col':
	          var logicalColumnIndex = translateColIndex(index);
	          datamap.removeCol(index, amount);
	          for (var row$__22 = 0,
	              len$__23 = instance.countSourceRows(); row$__22 < len$__23; row$__22++) {
	            if (priv.cellSettings[row$__22]) {
	              priv.cellSettings[row$__22].splice(logicalColumnIndex, amount);
	            }
	          }
	          var fixedColumnsLeft = instance.getSettings().fixedColumnsLeft;
	          if (fixedColumnsLeft >= index + 1) {
	            instance.getSettings().fixedColumnsLeft -= Math.min(amount, fixedColumnsLeft - index);
	          }
	          if (Array.isArray(instance.getSettings().colHeaders)) {
	            if (typeof logicalColumnIndex == 'undefined') {
	              logicalColumnIndex = -1;
	            }
	            instance.getSettings().colHeaders.splice(logicalColumnIndex, amount);
	          }
	          grid.adjustRowsAndCols();
	          selection.refreshBorders();
	          break;
	        default:
	          throw new Error('There is no such action "' + action + '"');
	      }
	      if (!keepEmptyRows) {
	        grid.adjustRowsAndCols();
	      }
	    },
	    adjustRowsAndCols: function() {
	      if (priv.settings.minRows) {
	        var rows = instance.countRows();
	        if (rows < priv.settings.minRows) {
	          for (var r = 0,
	              minRows = priv.settings.minRows; r < minRows - rows; r++) {
	            datamap.createRow(instance.countRows(), 1, true);
	          }
	        }
	      }
	      if (priv.settings.minSpareRows) {
	        var emptyRows = instance.countEmptyRows(true);
	        if (emptyRows < priv.settings.minSpareRows) {
	          for (; emptyRows < priv.settings.minSpareRows && instance.countRows() < priv.settings.maxRows; emptyRows++) {
	            datamap.createRow(instance.countRows(), 1, true);
	          }
	        }
	      }
	      {
	        var emptyCols;
	        if (priv.settings.minCols || priv.settings.minSpareCols) {
	          emptyCols = instance.countEmptyCols(true);
	        }
	        if (priv.settings.minCols && !priv.settings.columns && instance.countCols() < priv.settings.minCols) {
	          for (; instance.countCols() < priv.settings.minCols; emptyCols++) {
	            datamap.createCol(instance.countCols(), 1, true);
	          }
	        }
	        if (priv.settings.minSpareCols && !priv.settings.columns && instance.dataType === 'array' && emptyCols < priv.settings.minSpareCols) {
	          for (; emptyCols < priv.settings.minSpareCols && instance.countCols() < priv.settings.maxCols; emptyCols++) {
	            datamap.createCol(instance.countCols(), 1, true);
	          }
	        }
	      }
	      var rowCount = instance.countRows();
	      var colCount = instance.countCols();
	      if (rowCount === 0 || colCount === 0) {
	        selection.deselect();
	      }
	      if (selection.isSelected()) {
	        var selectionChanged = false;
	        var fromRow = priv.selRange.from.row;
	        var fromCol = priv.selRange.from.col;
	        var toRow = priv.selRange.to.row;
	        var toCol = priv.selRange.to.col;
	        if (fromRow > rowCount - 1) {
	          fromRow = rowCount - 1;
	          selectionChanged = true;
	          if (toRow > fromRow) {
	            toRow = fromRow;
	          }
	        } else if (toRow > rowCount - 1) {
	          toRow = rowCount - 1;
	          selectionChanged = true;
	          if (fromRow > toRow) {
	            fromRow = toRow;
	          }
	        }
	        if (fromCol > colCount - 1) {
	          fromCol = colCount - 1;
	          selectionChanged = true;
	          if (toCol > fromCol) {
	            toCol = fromCol;
	          }
	        } else if (toCol > colCount - 1) {
	          toCol = colCount - 1;
	          selectionChanged = true;
	          if (fromCol > toCol) {
	            fromCol = toCol;
	          }
	        }
	        if (selectionChanged) {
	          instance.selectCell(fromRow, fromCol, toRow, toCol);
	        }
	      }
	      if (instance.view) {
	        instance.view.wt.wtOverlays.adjustElementsSize();
	      }
	    },
	    populateFromArray: function(start, input, end, source, method, direction, deltas) {
	      var r,
	          rlen,
	          c,
	          clen,
	          setData = [],
	          current = {};
	      rlen = input.length;
	      if (rlen === 0) {
	        return false;
	      }
	      var repeatCol,
	          repeatRow,
	          cmax,
	          rmax,
	          baseEnd = {
	            row: end === null ? null : end.row,
	            col: end === null ? null : end.col
	          };
	      switch (method) {
	        case 'shift_down':
	          repeatCol = end ? end.col - start.col + 1 : 0;
	          repeatRow = end ? end.row - start.row + 1 : 0;
	          input = translateRowsToColumns(input);
	          for (c = 0, clen = input.length, cmax = Math.max(clen, repeatCol); c < cmax; c++) {
	            if (c < clen) {
	              for (r = 0, rlen = input[c].length; r < repeatRow - rlen; r++) {
	                input[c].push(input[c][r % rlen]);
	              }
	              input[c].unshift(start.col + c, start.row, 0);
	              instance.spliceCol.apply(instance, input[c]);
	            } else {
	              input[c % clen][0] = start.col + c;
	              instance.spliceCol.apply(instance, input[c % clen]);
	            }
	          }
	          break;
	        case 'shift_right':
	          repeatCol = end ? end.col - start.col + 1 : 0;
	          repeatRow = end ? end.row - start.row + 1 : 0;
	          for (r = 0, rlen = input.length, rmax = Math.max(rlen, repeatRow); r < rmax; r++) {
	            if (r < rlen) {
	              for (c = 0, clen = input[r].length; c < repeatCol - clen; c++) {
	                input[r].push(input[r][c % clen]);
	              }
	              input[r].unshift(start.row + r, start.col, 0);
	              instance.spliceRow.apply(instance, input[r]);
	            } else {
	              input[r % rlen][0] = start.row + r;
	              instance.spliceRow.apply(instance, input[r % rlen]);
	            }
	          }
	          break;
	        case 'overwrite':
	        default:
	          current.row = start.row;
	          current.col = start.col;
	          var selected = {
	            row: (end && start) ? (end.row - start.row + 1) : 1,
	            col: (end && start) ? (end.col - start.col + 1) : 1
	          };
	          var skippedRow = 0;
	          var skippedColumn = 0;
	          var pushData = true;
	          var cellMeta;
	          var getInputValue = function getInputValue(row) {
	            var col = arguments[1] !== (void 0) ? arguments[1] : null;
	            var rowValue = input[row % input.length];
	            if (col !== null) {
	              return rowValue[col % rowValue.length];
	            }
	            return rowValue;
	          };
	          var rowInputLength = input.length;
	          var rowSelectionLength = end ? end.row - start.row + 1 : 0;
	          if (end) {
	            rlen = rowSelectionLength;
	          } else {
	            rlen = Math.max(rowInputLength, rowSelectionLength);
	          }
	          for (r = 0; r < rlen; r++) {
	            if ((end && current.row > end.row && rowSelectionLength > rowInputLength) || (!priv.settings.allowInsertRow && current.row > instance.countRows() - 1) || (current.row >= priv.settings.maxRows)) {
	              break;
	            }
	            var logicalRow = r - skippedRow;
	            var colInputLength = getInputValue(logicalRow).length;
	            var colSelectionLength = end ? end.col - start.col + 1 : 0;
	            if (end) {
	              clen = colSelectionLength;
	            } else {
	              clen = Math.max(colInputLength, colSelectionLength);
	            }
	            current.col = start.col;
	            cellMeta = instance.getCellMeta(current.row, current.col);
	            if ((source === 'paste' || source === 'autofill') && cellMeta.skipRowOnPaste) {
	              skippedRow++;
	              current.row++;
	              rlen++;
	              continue;
	            }
	            skippedColumn = 0;
	            for (c = 0; c < clen; c++) {
	              if ((end && current.col > end.col && colSelectionLength > colInputLength) || (!priv.settings.allowInsertColumn && current.col > instance.countCols() - 1) || (current.col >= priv.settings.maxCols)) {
	                break;
	              }
	              cellMeta = instance.getCellMeta(current.row, current.col);
	              if ((source === 'paste' || source === 'autofill') && cellMeta.skipColumnOnPaste) {
	                skippedColumn++;
	                current.col++;
	                clen++;
	                continue;
	              }
	              if (cellMeta.readOnly) {
	                current.col++;
	                continue;
	              }
	              var logicalColumn = c - skippedColumn;
	              var value = getInputValue(logicalRow, logicalColumn);
	              var orgValue = instance.getDataAtCell(current.row, current.col);
	              var index = {
	                row: logicalRow,
	                col: logicalColumn
	              };
	              if (source === 'autofill') {
	                var result = instance.runHooks('beforeAutofillInsidePopulate', index, direction, input, deltas, {}, selected);
	                if (result) {
	                  value = typeof(result.value) === 'undefined' ? value : result.value;
	                }
	              }
	              if (value !== null && typeof value === 'object') {
	                if (orgValue === null || typeof orgValue !== 'object') {
	                  pushData = false;
	                } else {
	                  var orgValueSchema = duckSchema(orgValue[0] || orgValue);
	                  var valueSchema = duckSchema(value[0] || value);
	                  if (isObjectEquals(orgValueSchema, valueSchema)) {
	                    value = deepClone(value);
	                  } else {
	                    pushData = false;
	                  }
	                }
	              } else if (orgValue !== null && typeof orgValue === 'object') {
	                pushData = false;
	              }
	              if (pushData) {
	                setData.push([current.row, current.col, value]);
	              }
	              pushData = true;
	              current.col++;
	            }
	            current.row++;
	          }
	          instance.setDataAtCell(setData, null, null, source || 'populateFromArray');
	          break;
	      }
	    }
	  };
	  this.selection = selection = {
	    inProgress: false,
	    selectedHeader: {
	      cols: false,
	      rows: false
	    },
	    setSelectedHeaders: function(rows, cols) {
	      instance.selection.selectedHeader.rows = rows;
	      instance.selection.selectedHeader.cols = cols;
	    },
	    begin: function() {
	      instance.selection.inProgress = true;
	    },
	    finish: function() {
	      var sel = instance.getSelected();
	      Handsontable.hooks.run(instance, 'afterSelectionEnd', sel[0], sel[1], sel[2], sel[3]);
	      Handsontable.hooks.run(instance, 'afterSelectionEndByProp', sel[0], instance.colToProp(sel[1]), sel[2], instance.colToProp(sel[3]));
	      instance.selection.inProgress = false;
	    },
	    isInProgress: function() {
	      return instance.selection.inProgress;
	    },
	    setRangeStart: function(coords, keepEditorOpened) {
	      Handsontable.hooks.run(instance, 'beforeSetRangeStart', coords);
	      priv.selRange = new WalkontableCellRange(coords, coords, coords);
	      selection.setRangeEnd(coords, null, keepEditorOpened);
	    },
	    setRangeEnd: function(coords, scrollToCell, keepEditorOpened) {
	      if (priv.selRange === null) {
	        return;
	      }
	      var disableVisualSelection,
	          isHeaderSelected = false,
	          areCoordsPositive = true;
	      var firstVisibleRow = instance.view.wt.wtTable.getFirstVisibleRow();
	      var firstVisibleColumn = instance.view.wt.wtTable.getFirstVisibleColumn();
	      var newRangeCoords = {
	        row: null,
	        col: null
	      };
	      Handsontable.hooks.run(instance, 'beforeSetRangeEnd', coords);
	      instance.selection.begin();
	      newRangeCoords.row = coords.row < 0 ? firstVisibleRow : coords.row;
	      newRangeCoords.col = coords.col < 0 ? firstVisibleColumn : coords.col;
	      priv.selRange.to = new WalkontableCellCoords(newRangeCoords.row, newRangeCoords.col);
	      if (!priv.settings.multiSelect) {
	        priv.selRange.from = coords;
	      }
	      instance.view.wt.selections.current.clear();
	      disableVisualSelection = instance.getCellMeta(priv.selRange.highlight.row, priv.selRange.highlight.col).disableVisualSelection;
	      if (typeof disableVisualSelection === 'string') {
	        disableVisualSelection = [disableVisualSelection];
	      }
	      if (disableVisualSelection === false || Array.isArray(disableVisualSelection) && disableVisualSelection.indexOf('current') === -1) {
	        instance.view.wt.selections.current.add(priv.selRange.highlight);
	      }
	      instance.view.wt.selections.area.clear();
	      if ((disableVisualSelection === false || Array.isArray(disableVisualSelection) && disableVisualSelection.indexOf('area') === -1) && selection.isMultiple()) {
	        instance.view.wt.selections.area.add(priv.selRange.from);
	        instance.view.wt.selections.area.add(priv.selRange.to);
	      }
	      if (priv.settings.currentRowClassName || priv.settings.currentColClassName) {
	        instance.view.wt.selections.highlight.clear();
	        instance.view.wt.selections.highlight.add(priv.selRange.from);
	        instance.view.wt.selections.highlight.add(priv.selRange.to);
	      }
	      Handsontable.hooks.run(instance, 'afterSelection', priv.selRange.from.row, priv.selRange.from.col, priv.selRange.to.row, priv.selRange.to.col);
	      Handsontable.hooks.run(instance, 'afterSelectionByProp', priv.selRange.from.row, datamap.colToProp(priv.selRange.from.col), priv.selRange.to.row, datamap.colToProp(priv.selRange.to.col));
	      if ((priv.selRange.from.row === 0 && priv.selRange.to.row === instance.countRows() - 1 && instance.countRows() > 1) || (priv.selRange.from.col === 0 && priv.selRange.to.col === instance.countCols() - 1 && instance.countCols() > 1)) {
	        isHeaderSelected = true;
	      }
	      if (coords.row < 0 || coords.col < 0) {
	        areCoordsPositive = false;
	      }
	      if (scrollToCell !== false && !isHeaderSelected && areCoordsPositive) {
	        if (priv.selRange.from && !selection.isMultiple()) {
	          instance.view.scrollViewport(priv.selRange.from);
	        } else {
	          instance.view.scrollViewport(coords);
	        }
	      }
	      selection.refreshBorders(null, keepEditorOpened);
	    },
	    refreshBorders: function(revertOriginal, keepEditor) {
	      if (!keepEditor) {
	        editorManager.destroyEditor(revertOriginal);
	      }
	      instance.view.render();
	      if (selection.isSelected() && !keepEditor) {
	        editorManager.prepareEditor();
	      }
	    },
	    isMultiple: function() {
	      var isMultiple = !(priv.selRange.to.col === priv.selRange.from.col && priv.selRange.to.row === priv.selRange.from.row),
	          modifier = Handsontable.hooks.run(instance, 'afterIsMultipleSelection', isMultiple);
	      if (isMultiple) {
	        return modifier;
	      }
	    },
	    transformStart: function(rowDelta, colDelta, force, keepEditorOpened) {
	      var delta = new WalkontableCellCoords(rowDelta, colDelta),
	          rowTransformDir = 0,
	          colTransformDir = 0,
	          totalRows,
	          totalCols,
	          coords,
	          fixedRowsBottom;
	      instance.runHooks('modifyTransformStart', delta);
	      totalRows = instance.countRows();
	      totalCols = instance.countCols();
	      fixedRowsBottom = instance.getSettings().fixedRowsBottom;
	      if (priv.selRange.highlight.row + rowDelta > totalRows - 1) {
	        if (force && priv.settings.minSpareRows > 0 && !(fixedRowsBottom && priv.selRange.highlight.row >= totalRows - fixedRowsBottom - 1)) {
	          instance.alter('insert_row', totalRows);
	          totalRows = instance.countRows();
	        } else if (priv.settings.autoWrapCol) {
	          delta.row = 1 - totalRows;
	          delta.col = priv.selRange.highlight.col + delta.col == totalCols - 1 ? 1 - totalCols : 1;
	        }
	      } else if (priv.settings.autoWrapCol && priv.selRange.highlight.row + delta.row < 0 && priv.selRange.highlight.col + delta.col >= 0) {
	        delta.row = totalRows - 1;
	        delta.col = priv.selRange.highlight.col + delta.col == 0 ? totalCols - 1 : -1;
	      }
	      if (priv.selRange.highlight.col + delta.col > totalCols - 1) {
	        if (force && priv.settings.minSpareCols > 0) {
	          instance.alter('insert_col', totalCols);
	          totalCols = instance.countCols();
	        } else if (priv.settings.autoWrapRow) {
	          delta.row = priv.selRange.highlight.row + delta.row == totalRows - 1 ? 1 - totalRows : 1;
	          delta.col = 1 - totalCols;
	        }
	      } else if (priv.settings.autoWrapRow && priv.selRange.highlight.col + delta.col < 0 && priv.selRange.highlight.row + delta.row >= 0) {
	        delta.row = priv.selRange.highlight.row + delta.row == 0 ? totalRows - 1 : -1;
	        delta.col = totalCols - 1;
	      }
	      coords = new WalkontableCellCoords(priv.selRange.highlight.row + delta.row, priv.selRange.highlight.col + delta.col);
	      if (coords.row < 0) {
	        rowTransformDir = -1;
	        coords.row = 0;
	      } else if (coords.row > 0 && coords.row >= totalRows) {
	        rowTransformDir = 1;
	        coords.row = totalRows - 1;
	      }
	      if (coords.col < 0) {
	        colTransformDir = -1;
	        coords.col = 0;
	      } else if (coords.col > 0 && coords.col >= totalCols) {
	        colTransformDir = 1;
	        coords.col = totalCols - 1;
	      }
	      instance.runHooks('afterModifyTransformStart', coords, rowTransformDir, colTransformDir);
	      selection.setRangeStart(coords, keepEditorOpened);
	    },
	    transformEnd: function(rowDelta, colDelta) {
	      var delta = new WalkontableCellCoords(rowDelta, colDelta),
	          rowTransformDir = 0,
	          colTransformDir = 0,
	          totalRows,
	          totalCols,
	          coords;
	      instance.runHooks('modifyTransformEnd', delta);
	      totalRows = instance.countRows();
	      totalCols = instance.countCols();
	      coords = new WalkontableCellCoords(priv.selRange.to.row + delta.row, priv.selRange.to.col + delta.col);
	      if (coords.row < 0) {
	        rowTransformDir = -1;
	        coords.row = 0;
	      } else if (coords.row > 0 && coords.row >= totalRows) {
	        rowTransformDir = 1;
	        coords.row = totalRows - 1;
	      }
	      if (coords.col < 0) {
	        colTransformDir = -1;
	        coords.col = 0;
	      } else if (coords.col > 0 && coords.col >= totalCols) {
	        colTransformDir = 1;
	        coords.col = totalCols - 1;
	      }
	      instance.runHooks('afterModifyTransformEnd', coords, rowTransformDir, colTransformDir);
	      selection.setRangeEnd(coords, true);
	    },
	    isSelected: function() {
	      return (priv.selRange !== null);
	    },
	    inInSelection: function(coords) {
	      if (!selection.isSelected()) {
	        return false;
	      }
	      return priv.selRange.includes(coords);
	    },
	    deselect: function() {
	      if (!selection.isSelected()) {
	        return;
	      }
	      instance.selection.inProgress = false;
	      priv.selRange = null;
	      instance.view.wt.selections.current.clear();
	      instance.view.wt.selections.area.clear();
	      if (priv.settings.currentRowClassName || priv.settings.currentColClassName) {
	        instance.view.wt.selections.highlight.clear();
	      }
	      editorManager.destroyEditor();
	      selection.refreshBorders();
	      Handsontable.hooks.run(instance, 'afterDeselect');
	    },
	    selectAll: function() {
	      if (!priv.settings.multiSelect) {
	        return;
	      }
	      selection.setRangeStart(new WalkontableCellCoords(0, 0));
	      selection.setRangeEnd(new WalkontableCellCoords(instance.countRows() - 1, instance.countCols() - 1), false);
	    },
	    empty: function() {
	      if (!selection.isSelected()) {
	        return;
	      }
	      var topLeft = priv.selRange.getTopLeftCorner();
	      var bottomRight = priv.selRange.getBottomRightCorner();
	      var r,
	          c,
	          changes = [];
	      for (r = topLeft.row; r <= bottomRight.row; r++) {
	        for (c = topLeft.col; c <= bottomRight.col; c++) {
	          if (!instance.getCellMeta(r, c).readOnly) {
	            changes.push([r, c, '']);
	          }
	        }
	      }
	      instance.setDataAtCell(changes);
	    }
	  };
	  this.init = function() {
	    dataSource.setData(priv.settings.data);
	    Handsontable.hooks.run(instance, 'beforeInit');
	    if (isMobileBrowser()) {
	      addClass(instance.rootElement, 'mobile');
	    }
	    this.updateSettings(priv.settings, true);
	    this.view = new TableView(this);
	    editorManager = new EditorManager(instance, priv, selection, datamap);
	    this.forceFullRender = true;
	    Handsontable.hooks.run(instance, 'init');
	    this.view.render();
	    if (typeof priv.firstRun === 'object') {
	      Handsontable.hooks.run(instance, 'afterChange', priv.firstRun[0], priv.firstRun[1]);
	      priv.firstRun = false;
	    }
	    Handsontable.hooks.run(instance, 'afterInit');
	  };
	  function ValidatorsQueue() {
	    var resolved = false;
	    return {
	      validatorsInQueue: 0,
	      valid: true,
	      addValidatorToQueue: function() {
	        this.validatorsInQueue++;
	        resolved = false;
	      },
	      removeValidatorFormQueue: function() {
	        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;
	        this.checkIfQueueIsEmpty();
	      },
	      onQueueEmpty: function(valid) {},
	      checkIfQueueIsEmpty: function() {
	        if (this.validatorsInQueue == 0 && resolved == false) {
	          resolved = true;
	          this.onQueueEmpty(this.valid);
	        }
	      }
	    };
	  }
	  function validateChanges(changes, source, callback) {
	    var waitingForValidator = new ValidatorsQueue();
	    waitingForValidator.onQueueEmpty = resolve;
	    for (var i = changes.length - 1; i >= 0; i--) {
	      if (changes[i] === null) {
	        changes.splice(i, 1);
	      } else {
	        var row = changes[i][0];
	        var col = datamap.propToCol(changes[i][1]);
	        var cellProperties = instance.getCellMeta(row, col);
	        if (cellProperties.type === 'numeric' && typeof changes[i][3] === 'string') {
	          if (changes[i][3].length > 0 && (/^-?[\d\s]*(\.|\,)?\d*$/.test(changes[i][3]) || cellProperties.format)) {
	            var len = changes[i][3].length;
	            if (typeof cellProperties.language == 'undefined') {
	              numeral.language('en');
	            } else if (changes[i][3].indexOf('.') === len - 3 && changes[i][3].indexOf(',') === -1) {
	              numeral.language('en');
	            } else {
	              numeral.language(cellProperties.language);
	            }
	            if (numeral.validate(changes[i][3])) {
	              changes[i][3] = numeral().unformat(changes[i][3]);
	            }
	          }
	        }
	        if (instance.getCellValidator(cellProperties)) {
	          waitingForValidator.addValidatorToQueue();
	          instance.validateCell(changes[i][3], cellProperties, (function(i, cellProperties) {
	            return function(result) {
	              if (typeof result !== 'boolean') {
	                throw new Error('Validation error: result is not boolean');
	              }
	              if (result === false && cellProperties.allowInvalid === false) {
	                changes.splice(i, 1);
	                cellProperties.valid = true;
	                --i;
	              }
	              waitingForValidator.removeValidatorFormQueue();
	            };
	          })(i, cellProperties), source);
	        }
	      }
	    }
	    waitingForValidator.checkIfQueueIsEmpty();
	    function resolve() {
	      var beforeChangeResult;
	      if (changes.length) {
	        beforeChangeResult = Handsontable.hooks.run(instance, 'beforeChange', changes, source);
	        if (typeof beforeChangeResult === 'function') {
	          console.warn('Your beforeChange callback returns a function. It\'s not supported since Handsontable 0.12.1 (and the returned function will not be executed).');
	        } else if (beforeChangeResult === false) {
	          changes.splice(0, changes.length);
	        }
	      }
	      callback();
	    }
	  }
	  function applyChanges(changes, source) {
	    var i = changes.length - 1;
	    if (i < 0) {
	      return;
	    }
	    for (; 0 <= i; i--) {
	      if (changes[i] === null) {
	        changes.splice(i, 1);
	        continue;
	      }
	      if (changes[i][2] == null && changes[i][3] == null) {
	        continue;
	      }
	      if (priv.settings.allowInsertRow) {
	        while (changes[i][0] > instance.countRows() - 1) {
	          datamap.createRow();
	        }
	      }
	      if (instance.dataType === 'array' && (!priv.settings.columns || priv.settings.columns.length === 0) && priv.settings.allowInsertColumn) {
	        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {
	          datamap.createCol();
	        }
	      }
	      datamap.set(changes[i][0], changes[i][1], changes[i][3]);
	    }
	    instance.forceFullRender = true;
	    grid.adjustRowsAndCols();
	    Handsontable.hooks.run(instance, 'beforeChangeRender', changes, source);
	    selection.refreshBorders(null, true);
	    instance.view.wt.wtOverlays.adjustElementsSize();
	    Handsontable.hooks.run(instance, 'afterChange', changes, source || 'edit');
	  }
	  this.validateCell = function(value, cellProperties, callback, source) {
	    var validator = instance.getCellValidator(cellProperties);
	    function done(valid) {
	      var col = cellProperties.visualCol,
	          row = cellProperties.visualRow,
	          td = instance.getCell(row, col, true);
	      if (td && td.nodeName != 'TH') {
	        instance.view.wt.wtSettings.settings.cellRenderer(row, col, td);
	      }
	      callback(valid);
	    }
	    if (Object.prototype.toString.call(validator) === '[object RegExp]') {
	      validator = (function(validator) {
	        return function(value, callback) {
	          callback(validator.test(value));
	        };
	      })(validator);
	    }
	    if (typeof validator == 'function') {
	      value = Handsontable.hooks.run(instance, 'beforeValidate', value, cellProperties.visualRow, cellProperties.prop, source);
	      instance._registerTimeout(setTimeout(function() {
	        validator.call(cellProperties, value, function(valid) {
	          valid = Handsontable.hooks.run(instance, 'afterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);
	          cellProperties.valid = valid;
	          done(valid);
	          Handsontable.hooks.run(instance, 'postAfterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);
	        });
	      }, 0));
	    } else {
	      instance._registerTimeout(setTimeout(function() {
	        cellProperties.valid = true;
	        done(cellProperties.valid);
	      }, 0));
	    }
	  };
	  function setDataInputToArray(row, propOrCol, value) {
	    if (typeof row === 'object') {
	      return row;
	    } else {
	      return [[row, propOrCol, value]];
	    }
	  }
	  this.setDataAtCell = function(row, col, value, source) {
	    var input = setDataInputToArray(row, col, value),
	        i,
	        ilen,
	        changes = [],
	        prop;
	    for (i = 0, ilen = input.length; i < ilen; i++) {
	      if (typeof input[i] !== 'object') {
	        throw new Error('Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter');
	      }
	      if (typeof input[i][1] !== 'number') {
	        throw new Error('Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`');
	      }
	      prop = datamap.colToProp(input[i][1]);
	      changes.push([input[i][0], prop, datamap.get(input[i][0], prop), input[i][2]]);
	    }
	    if (!source && typeof row === 'object') {
	      source = col;
	    }
	    validateChanges(changes, source, function() {
	      applyChanges(changes, source);
	    });
	  };
	  this.setDataAtRowProp = function(row, prop, value, source) {
	    var input = setDataInputToArray(row, prop, value),
	        i,
	        ilen,
	        changes = [];
	    for (i = 0, ilen = input.length; i < ilen; i++) {
	      changes.push([input[i][0], input[i][1], datamap.get(input[i][0], input[i][1]), input[i][2]]);
	    }
	    if (!source && typeof row === 'object') {
	      source = prop;
	    }
	    validateChanges(changes, source, function() {
	      applyChanges(changes, source);
	    });
	  };
	  this.listen = function() {
	    Handsontable.activeGuid = instance.guid;
	  };
	  this.unlisten = function() {
	    Handsontable.activeGuid = null;
	  };
	  this.isListening = function() {
	    return Handsontable.activeGuid === instance.guid;
	  };
	  this.destroyEditor = function(revertOriginal) {
	    selection.refreshBorders(revertOriginal);
	  };
	  this.populateFromArray = function(row, col, input, endRow, endCol, source, method, direction, deltas) {
	    var c;
	    if (!(typeof input === 'object' && typeof input[0] === 'object')) {
	      throw new Error('populateFromArray parameter `input` must be an array of arrays');
	    }
	    c = typeof endRow === 'number' ? new WalkontableCellCoords(endRow, endCol) : null;
	    return grid.populateFromArray(new WalkontableCellCoords(row, col), input, c, source, method, direction, deltas);
	  };
	  this.spliceCol = function(col, index, amount) {
	    return datamap.spliceCol.apply(datamap, arguments);
	  };
	  this.spliceRow = function(row, index, amount) {
	    return datamap.spliceRow.apply(datamap, arguments);
	  };
	  this.getSelected = function() {
	    if (selection.isSelected()) {
	      return [priv.selRange.from.row, priv.selRange.from.col, priv.selRange.to.row, priv.selRange.to.col];
	    }
	  };
	  this.getSelectedRange = function() {
	    if (selection.isSelected()) {
	      return priv.selRange;
	    }
	  };
	  this.render = function() {
	    if (instance.view) {
	      instance.renderCall = true;
	      instance.forceFullRender = true;
	      selection.refreshBorders(null, true);
	    }
	  };
	  this.loadData = function(data) {
	    if (typeof data === 'object' && data !== null) {
	      if (!(data.push && data.splice)) {
	        data = [data];
	      }
	    } else if (data === null) {
	      data = [];
	      var row;
	      for (var r = 0,
	          rlen = priv.settings.startRows; r < rlen; r++) {
	        row = [];
	        for (var c = 0,
	            clen = priv.settings.startCols; c < clen; c++) {
	          row.push(null);
	        }
	        data.push(row);
	      }
	    } else {
	      throw new Error('loadData only accepts array of objects or array of arrays (' + typeof data + ' given)');
	    }
	    priv.isPopulated = false;
	    GridSettings.prototype.data = data;
	    if (Array.isArray(priv.settings.dataSchema) || Array.isArray(data[0])) {
	      instance.dataType = 'array';
	    } else if (typeof priv.settings.dataSchema === 'function') {
	      instance.dataType = 'function';
	    } else {
	      instance.dataType = 'object';
	    }
	    if (datamap) {
	      datamap.destroy();
	    }
	    datamap = new DataMap(instance, priv, GridSettings);
	    dataSource.data = data;
	    dataSource.dataType = instance.dataType;
	    dataSource.colToProp = datamap.colToProp.bind(datamap);
	    dataSource.propToCol = datamap.propToCol.bind(datamap);
	    clearCellSettingCache();
	    grid.adjustRowsAndCols();
	    Handsontable.hooks.run(instance, 'afterLoadData', priv.firstRun);
	    if (priv.firstRun) {
	      priv.firstRun = [null, 'loadData'];
	    } else {
	      Handsontable.hooks.run(instance, 'afterChange', null, 'loadData');
	      instance.render();
	    }
	    priv.isPopulated = true;
	    function clearCellSettingCache() {
	      priv.cellSettings.length = 0;
	    }
	  };
	  this.getData = function(r, c, r2, c2) {
	    if (typeof r === 'undefined') {
	      return datamap.getAll();
	    } else {
	      return datamap.getRange(new WalkontableCellCoords(r, c), new WalkontableCellCoords(r2, c2), datamap.DESTINATION_RENDERER);
	    }
	  };
	  this.getCopyableText = function(startRow, startCol, endRow, endCol) {
	    return datamap.getCopyableText(new WalkontableCellCoords(startRow, startCol), new WalkontableCellCoords(endRow, endCol));
	  };
	  this.getCopyableData = function(row, column) {
	    return datamap.getCopyable(row, datamap.colToProp(column));
	  };
	  this.getSchema = function() {
	    return datamap.getSchema();
	  };
	  this.updateSettings = function(settings, init) {
	    var i,
	        clen;
	    if (typeof settings.rows !== 'undefined') {
	      throw new Error('"rows" setting is no longer supported. do you mean startRows, minRows or maxRows?');
	    }
	    if (typeof settings.cols !== 'undefined') {
	      throw new Error('"cols" setting is no longer supported. do you mean startCols, minCols or maxCols?');
	    }
	    for (i in settings) {
	      if (i === 'data') {
	        continue;
	      } else {
	        if (Handsontable.hooks.getRegistered().indexOf(i) > -1) {
	          if (typeof settings[i] === 'function' || Array.isArray(settings[i])) {
	            instance.addHook(i, settings[i]);
	          }
	        } else {
	          if (!init && settings.hasOwnProperty(i)) {
	            GridSettings.prototype[i] = settings[i];
	          }
	        }
	      }
	    }
	    if (settings.data === void 0 && priv.settings.data === void 0) {
	      instance.loadData(null);
	    } else if (settings.data !== void 0) {
	      instance.loadData(settings.data);
	    } else if (settings.columns !== void 0) {
	      datamap.createMap();
	    }
	    clen = instance.countCols();
	    if (settings.cell !== void 0 || settings.cells !== void 0 || settings.columns !== void 0) {
	      priv.cellSettings.length = 0;
	    }
	    if (clen > 0) {
	      var proto,
	          column;
	      for (i = 0; i < clen; i++) {
	        priv.columnSettings[i] = columnFactory(GridSettings, priv.columnsSettingConflicts);
	        proto = priv.columnSettings[i].prototype;
	        if (GridSettings.prototype.columns) {
	          column = GridSettings.prototype.columns[i];
	          if (column) {
	            extend(proto, column);
	            extend(proto, expandType(column));
	          }
	        }
	      }
	    }
	    if (typeof settings.cell !== 'undefined') {
	      for (i in settings.cell) {
	        if (settings.cell.hasOwnProperty(i)) {
	          var cell = settings.cell[i];
	          instance.setCellMetaObject(cell.row, cell.col, cell);
	        }
	      }
	    }
	    Handsontable.hooks.run(instance, 'afterCellMetaReset');
	    if (typeof settings.className !== 'undefined') {
	      if (GridSettings.prototype.className) {
	        removeClass(instance.rootElement, GridSettings.prototype.className);
	      }
	      if (settings.className) {
	        addClass(instance.rootElement, settings.className);
	      }
	    }
	    var currentHeight = instance.rootElement.style.height;
	    if (currentHeight !== '') {
	      currentHeight = parseInt(instance.rootElement.style.height, 10);
	    }
	    var height = settings.height;
	    if (typeof height == 'function') {
	      height = height();
	    }
	    if (init) {
	      var initialStyle = instance.rootElement.getAttribute('style');
	      if (initialStyle) {
	        instance.rootElement.setAttribute('data-initialstyle', instance.rootElement.getAttribute('style'));
	      }
	    }
	    if (height === null) {
	      var initialStyle$__24 = instance.rootElement.getAttribute('data-initialstyle');
	      if (initialStyle$__24 && (initialStyle$__24.indexOf('height') > -1 || initialStyle$__24.indexOf('overflow') > -1)) {
	        instance.rootElement.setAttribute('style', initialStyle$__24);
	      } else {
	        instance.rootElement.style.height = '';
	        instance.rootElement.style.overflow = '';
	      }
	    } else if (height !== void 0) {
	      instance.rootElement.style.height = height + 'px';
	      instance.rootElement.style.overflow = 'hidden';
	    }
	    if (typeof settings.width != 'undefined') {
	      var width = settings.width;
	      if (typeof width == 'function') {
	        width = width();
	      }
	      instance.rootElement.style.width = width + 'px';
	    }
	    if (!init) {
	      datamap.clearLengthCache();
	      Handsontable.hooks.run(instance, 'afterUpdateSettings');
	    }
	    grid.adjustRowsAndCols();
	    if (instance.view && !priv.firstRun) {
	      instance.forceFullRender = true;
	      selection.refreshBorders(null, true);
	    }
	    if (!init && instance.view && (currentHeight === '' || height === '' || height === void 0) && currentHeight !== height) {
	      instance.view.wt.wtOverlays.updateMainScrollableElements();
	    }
	  };
	  this.getValue = function() {
	    var sel = instance.getSelected();
	    if (GridSettings.prototype.getValue) {
	      if (typeof GridSettings.prototype.getValue === 'function') {
	        return GridSettings.prototype.getValue.call(instance);
	      } else if (sel) {
	        return instance.getData()[sel[0]][GridSettings.prototype.getValue];
	      }
	    } else if (sel) {
	      return instance.getDataAtCell(sel[0], sel[1]);
	    }
	  };
	  function expandType(obj) {
	    if (!obj.hasOwnProperty('type')) {
	      return;
	    }
	    var type,
	        expandedType = {};
	    if (typeof obj.type === 'object') {
	      type = obj.type;
	    } else if (typeof obj.type === 'string') {
	      type = Handsontable.cellTypes[obj.type];
	      if (type === void 0) {
	        throw new Error('You declared cell type "' + obj.type + '" as a string that is not mapped to a known object. Cell type must be an object or a string mapped to an object in Handsontable.cellTypes');
	      }
	    }
	    for (var i in type) {
	      if (type.hasOwnProperty(i) && !obj.hasOwnProperty(i)) {
	        expandedType[i] = type[i];
	      }
	    }
	    return expandedType;
	  }
	  this.getSettings = function() {
	    return priv.settings;
	  };
	  this.clear = function() {
	    selection.selectAll();
	    selection.empty();
	  };
	  this.alter = function(action, index, amount, source, keepEmptyRows) {
	    grid.alter(action, index, amount, source, keepEmptyRows);
	  };
	  this.getCell = function(row, col, topmost) {
	    return instance.view.getCellAtCoords(new WalkontableCellCoords(row, col), topmost);
	  };
	  this.getCoords = function(elem) {
	    return this.view.wt.wtTable.getCoords.call(this.view.wt.wtTable, elem);
	  };
	  this.colToProp = function(col) {
	    return datamap.colToProp(col);
	  };
	  this.propToCol = function(prop) {
	    return datamap.propToCol(prop);
	  };
	  this.getDataAtCell = function(row, col) {
	    return datamap.get(row, datamap.colToProp(col));
	  };
	  this.getDataAtRowProp = function(row, prop) {
	    return datamap.get(row, prop);
	  };
	  this.getDataAtCol = function(col) {
	    var out = [];
	    return out.concat.apply(out, datamap.getRange(new WalkontableCellCoords(0, col), new WalkontableCellCoords(priv.settings.data.length - 1, col), datamap.DESTINATION_RENDERER));
	  };
	  this.getDataAtProp = function(prop) {
	    var out = [],
	        range;
	    range = datamap.getRange(new WalkontableCellCoords(0, datamap.propToCol(prop)), new WalkontableCellCoords(priv.settings.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER);
	    return out.concat.apply(out, range);
	  };
	  this.getSourceData = function(r, c, r2, c2) {
	    var data;
	    if (r === void 0) {
	      data = dataSource.getData();
	    } else {
	      data = dataSource.getByRange(new WalkontableCellCoords(r, c), new WalkontableCellCoords(r2, c2));
	    }
	    return data;
	  };
	  this.getSourceDataAtCol = function(column) {
	    return dataSource.getAtColumn(column);
	  };
	  this.getSourceDataAtRow = function(row) {
	    return dataSource.getAtRow(row);
	  };
	  this.getSourceDataAtCell = function(row, column) {
	    return dataSource.getAtCell(row, column);
	  };
	  this.getDataAtRow = function(row) {
	    var data = datamap.getRange(new WalkontableCellCoords(row, 0), new WalkontableCellCoords(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);
	    return data[0];
	  };
	  this.getDataType = function(rowFrom, columnFrom, rowTo, columnTo) {
	    var $__21 = this;
	    var previousType = null;
	    var currentType = null;
	    if (rowFrom === void 0) {
	      rowFrom = 0;
	      rowTo = this.countRows();
	      columnFrom = 0;
	      columnTo = this.countCols();
	    }
	    if (rowTo === void 0) {
	      rowTo = rowFrom;
	    }
	    if (columnTo === void 0) {
	      columnTo = columnFrom;
	    }
	    var type = 'mixed';
	    rangeEach(Math.min(rowFrom, rowTo), Math.max(rowFrom, rowTo), (function(row) {
	      var isTypeEqual = true;
	      rangeEach(Math.min(columnFrom, columnTo), Math.max(columnFrom, columnTo), (function(column) {
	        var cellType = $__21.getCellMeta(row, column);
	        currentType = cellType.type;
	        if (previousType) {
	          isTypeEqual = previousType === currentType;
	        } else {
	          previousType = currentType;
	        }
	        return isTypeEqual;
	      }));
	      type = isTypeEqual ? currentType : 'mixed';
	      return isTypeEqual;
	    }));
	    return type;
	  };
	  this.removeCellMeta = function(row, col, key) {
	    var cellMeta = instance.getCellMeta(row, col);
	    if (cellMeta[key] != undefined) {
	      delete priv.cellSettings[row][col][key];
	    }
	  };
	  this.setCellMetaObject = function(row, col, prop) {
	    if (typeof prop === 'object') {
	      for (var key in prop) {
	        if (prop.hasOwnProperty(key)) {
	          var value = prop[key];
	          this.setCellMeta(row, col, key, value);
	        }
	      }
	    }
	  };
	  this.setCellMeta = function(row, col, key, val) {
	    if (!priv.cellSettings[row]) {
	      priv.cellSettings[row] = [];
	    }
	    if (!priv.cellSettings[row][col]) {
	      priv.cellSettings[row][col] = new priv.columnSettings[col]();
	    }
	    priv.cellSettings[row][col][key] = val;
	    Handsontable.hooks.run(instance, 'afterSetCellMeta', row, col, key, val);
	  };
	  this.getCellsMeta = function() {
	    return arrayFlatten(priv.cellSettings);
	  };
	  this.getCellMeta = function(row, col) {
	    var prop = datamap.colToProp(col),
	        cellProperties;
	    var visualRow = row;
	    var visualCol = col;
	    row = translateRowIndex(row);
	    col = translateColIndex(col);
	    if (!priv.columnSettings[col]) {
	      priv.columnSettings[col] = columnFactory(GridSettings, priv.columnsSettingConflicts);
	    }
	    if (!priv.cellSettings[row]) {
	      priv.cellSettings[row] = [];
	    }
	    if (!priv.cellSettings[row][col]) {
	      priv.cellSettings[row][col] = new priv.columnSettings[col]();
	    }
	    cellProperties = priv.cellSettings[row][col];
	    cellProperties.row = row;
	    cellProperties.col = col;
	    cellProperties.visualRow = visualRow;
	    cellProperties.visualCol = visualCol;
	    cellProperties.prop = prop;
	    cellProperties.instance = instance;
	    Handsontable.hooks.run(instance, 'beforeGetCellMeta', row, col, cellProperties);
	    extend(cellProperties, expandType(cellProperties));
	    if (cellProperties.cells) {
	      var settings = cellProperties.cells.call(cellProperties, row, col, prop);
	      if (settings) {
	        extend(cellProperties, settings);
	        extend(cellProperties, expandType(settings));
	      }
	    }
	    Handsontable.hooks.run(instance, 'afterGetCellMeta', row, col, cellProperties);
	    return cellProperties;
	  };
	  this.isColumnModificationAllowed = function() {
	    return !(instance.dataType === 'object' || instance.getSettings().columns);
	  };
	  function translateRowIndex(row) {
	    return Handsontable.hooks.run(instance, 'modifyRow', row);
	  }
	  function translateColIndex(col) {
	    return Handsontable.hooks.run(instance, 'modifyCol', col);
	  }
	  var rendererLookup = cellMethodLookupFactory('renderer');
	  this.getCellRenderer = function(row, col) {
	    var renderer = rendererLookup.call(this, row, col);
	    return getRenderer(renderer);
	  };
	  this.getCellEditor = cellMethodLookupFactory('editor');
	  this.getCellValidator = cellMethodLookupFactory('validator');
	  this.validateCells = function(callback) {
	    var waitingForValidator = new ValidatorsQueue();
	    if (callback) {
	      waitingForValidator.onQueueEmpty = callback;
	    }
	    var i = instance.countRows() - 1;
	    while (i >= 0) {
	      var j = instance.countCols() - 1;
	      while (j >= 0) {
	        waitingForValidator.addValidatorToQueue();
	        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), function(result) {
	          if (typeof result !== 'boolean') {
	            throw new Error('Validation error: result is not boolean');
	          }
	          if (result === false) {
	            waitingForValidator.valid = false;
	          }
	          waitingForValidator.removeValidatorFormQueue();
	        }, 'validateCells');
	        j--;
	      }
	      i--;
	    }
	    waitingForValidator.checkIfQueueIsEmpty();
	  };
	  this.getRowHeader = function(row) {
	    var rowHeader = priv.settings.rowHeaders;
	    if (row !== void 0) {
	      row = Handsontable.hooks.run(instance, 'modifyRowHeader', row);
	    }
	    if (row === void 0) {
	      rowHeader = [];
	      rangeEach(instance.countRows() - 1, (function(i) {
	        rowHeader.push(instance.getRowHeader(i));
	      }));
	    } else if (Array.isArray(rowHeader) && rowHeader[row] !== void 0) {
	      rowHeader = rowHeader[row];
	    } else if (typeof rowHeader === 'function') {
	      rowHeader = rowHeader(row);
	    } else if (rowHeader && typeof rowHeader !== 'string' && typeof rowHeader !== 'number') {
	      rowHeader = row + 1;
	    }
	    return rowHeader;
	  };
	  this.hasRowHeaders = function() {
	    return !!priv.settings.rowHeaders;
	  };
	  this.hasColHeaders = function() {
	    if (priv.settings.colHeaders !== void 0 && priv.settings.colHeaders !== null) {
	      return !!priv.settings.colHeaders;
	    }
	    for (var i = 0,
	        ilen = instance.countCols(); i < ilen; i++) {
	      if (instance.getColHeader(i)) {
	        return true;
	      }
	    }
	    return false;
	  };
	  this.getColHeader = function(col) {
	    col = Handsontable.hooks.run(instance, 'modifyColHeader', col);
	    if (col === void 0) {
	      var out = [];
	      for (var i = 0,
	          ilen = instance.countCols(); i < ilen; i++) {
	        out.push(instance.getColHeader(i));
	      }
	      return out;
	    } else {
	      var baseCol = col;
	      col = Handsontable.hooks.run(instance, 'modifyCol', col);
	      if (priv.settings.columns && priv.settings.columns[col] && priv.settings.columns[col].title) {
	        return priv.settings.columns[col].title;
	      } else if (Array.isArray(priv.settings.colHeaders) && priv.settings.colHeaders[col] !== void 0) {
	        return priv.settings.colHeaders[col];
	      } else if (typeof priv.settings.colHeaders === 'function') {
	        return priv.settings.colHeaders(col);
	      } else if (priv.settings.colHeaders && typeof priv.settings.colHeaders !== 'string' && typeof priv.settings.colHeaders !== 'number') {
	        return spreadsheetColumnLabel(baseCol);
	      } else {
	        return priv.settings.colHeaders;
	      }
	    }
	  };
	  this._getColWidthFromSettings = function(col) {
	    var cellProperties = instance.getCellMeta(0, col);
	    var width = cellProperties.width;
	    if (width === void 0 || width === priv.settings.width) {
	      width = cellProperties.colWidths;
	    }
	    if (width !== void 0 && width !== null) {
	      switch (typeof width) {
	        case 'object':
	          width = width[col];
	          break;
	        case 'function':
	          width = width(col);
	          break;
	      }
	      if (typeof width === 'string') {
	        width = parseInt(width, 10);
	      }
	    }
	    return width;
	  };
	  this.getColWidth = function(col) {
	    var width = instance._getColWidthFromSettings(col);
	    width = Handsontable.hooks.run(instance, 'modifyColWidth', width, col);
	    if (width === void 0) {
	      width = WalkontableViewportColumnsCalculator.DEFAULT_WIDTH;
	    }
	    return width;
	  };
	  this._getRowHeightFromSettings = function(row) {
	    var height = priv.settings.rowHeights;
	    if (height !== void 0 && height !== null) {
	      switch (typeof height) {
	        case 'object':
	          height = height[row];
	          break;
	        case 'function':
	          height = height(row);
	          break;
	      }
	      if (typeof height === 'string') {
	        height = parseInt(height, 10);
	      }
	    }
	    return height;
	  };
	  this.getRowHeight = function(row) {
	    var height = instance._getRowHeightFromSettings(row);
	    height = Handsontable.hooks.run(instance, 'modifyRowHeight', height, row);
	    return height;
	  };
	  this.countSourceRows = function() {
	    return instance.getSourceData() ? instance.getSourceData().length : 0;
	  };
	  this.countRows = function() {
	    return datamap.getLength();
	  };
	  this.countCols = function() {
	    if (instance.dataType === 'object' || instance.dataType === 'function') {
	      if (priv.settings.columns && priv.settings.columns.length) {
	        return priv.settings.columns.length;
	      } else {
	        return datamap.colToPropCache.length;
	      }
	    } else if (instance.dataType === 'array') {
	      if (priv.settings.columns && priv.settings.columns.length) {
	        return priv.settings.columns.length;
	      } else if (priv.settings.data && priv.settings.data[0] && priv.settings.data[0].length) {
	        return priv.settings.data[0].length;
	      } else {
	        return 0;
	      }
	    }
	  };
	  this.rowOffset = function() {
	    return instance.view.wt.wtTable.getFirstRenderedRow();
	  };
	  this.colOffset = function() {
	    return instance.view.wt.wtTable.getFirstRenderedColumn();
	  };
	  this.countRenderedRows = function() {
	    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedRowsCount() : -1;
	  };
	  this.countVisibleRows = function() {
	    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleRowsCount() : -1;
	  };
	  this.countRenderedCols = function() {
	    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedColumnsCount() : -1;
	  };
	  this.countVisibleCols = function() {
	    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleColumnsCount() : -1;
	  };
	  this.countEmptyRows = function(ending) {
	    var i = instance.countRows() - 1,
	        empty = 0,
	        row;
	    while (i >= 0) {
	      row = Handsontable.hooks.run(this, 'modifyRow', i);
	      if (instance.isEmptyRow(row)) {
	        empty++;
	      } else if (ending) {
	        break;
	      }
	      i--;
	    }
	    return empty;
	  };
	  this.countEmptyCols = function(ending) {
	    if (instance.countRows() < 1) {
	      return 0;
	    }
	    var i = instance.countCols() - 1,
	        empty = 0;
	    while (i >= 0) {
	      if (instance.isEmptyCol(i)) {
	        empty++;
	      } else if (ending) {
	        break;
	      }
	      i--;
	    }
	    return empty;
	  };
	  this.isEmptyRow = function(row) {
	    return priv.settings.isEmptyRow.call(instance, row);
	  };
	  this.isEmptyCol = function(col) {
	    return priv.settings.isEmptyCol.call(instance, col);
	  };
	  this.selectCell = function(row, col, endRow, endCol, scrollToCell, changeListener) {
	    var coords;
	    changeListener = typeof changeListener === 'undefined' || changeListener === true;
	    if (typeof row !== 'number' || row < 0 || row >= instance.countRows()) {
	      return false;
	    }
	    if (typeof col !== 'number' || col < 0 || col >= instance.countCols()) {
	      return false;
	    }
	    if (typeof endRow !== 'undefined') {
	      if (typeof endRow !== 'number' || endRow < 0 || endRow >= instance.countRows()) {
	        return false;
	      }
	      if (typeof endCol !== 'number' || endCol < 0 || endCol >= instance.countCols()) {
	        return false;
	      }
	    }
	    coords = new WalkontableCellCoords(row, col);
	    priv.selRange = new WalkontableCellRange(coords, coords, coords);
	    if (changeListener) {
	      instance.listen();
	    }
	    if (typeof endRow === 'undefined') {
	      selection.setRangeEnd(priv.selRange.from, scrollToCell);
	    } else {
	      selection.setRangeEnd(new WalkontableCellCoords(endRow, endCol), scrollToCell);
	    }
	    instance.selection.finish();
	    return true;
	  };
	  this.selectCellByProp = function(row, prop, endRow, endProp, scrollToCell) {
	    arguments[1] = datamap.propToCol(arguments[1]);
	    if (typeof arguments[3] !== 'undefined') {
	      arguments[3] = datamap.propToCol(arguments[3]);
	    }
	    return instance.selectCell.apply(instance, arguments);
	  };
	  this.deselectCell = function() {
	    selection.deselect();
	  };
	  this.scrollViewportTo = function(row, column) {
	    if (row !== void 0 && (row < 0 || row >= instance.countRows())) {
	      return false;
	    }
	    if (column !== void 0 && (column < 0 || column >= instance.countCols())) {
	      return false;
	    }
	    var result = false;
	    if (row !== void 0 && column !== void 0) {
	      instance.view.wt.scrollVertical(row);
	      instance.view.wt.scrollHorizontal(column);
	      result = true;
	    }
	    if (typeof row === 'number' && typeof column !== 'number') {
	      instance.view.wt.scrollVertical(row);
	      result = true;
	    }
	    if (typeof column === 'number' && typeof row !== 'number') {
	      instance.view.wt.scrollHorizontal(column);
	      result = true;
	    }
	    return result;
	  };
	  this.destroy = function() {
	    instance._clearTimeouts();
	    if (instance.view) {
	      instance.view.destroy();
	    }
	    if (dataSource) {
	      dataSource.destroy();
	    }
	    dataSource = null;
	    empty(instance.rootElement);
	    eventManager.destroy();
	    Handsontable.hooks.run(instance, 'afterDestroy');
	    Handsontable.hooks.destroy(instance);
	    for (var i in instance) {
	      if (instance.hasOwnProperty(i)) {
	        if (typeof instance[i] === 'function') {
	          instance[i] = postMortem;
	        } else if (i !== 'guid') {
	          instance[i] = null;
	        }
	      }
	    }
	    if (datamap) {
	      datamap.destroy();
	    }
	    datamap = null;
	    priv = null;
	    grid = null;
	    selection = null;
	    editorManager = null;
	    instance = null;
	    GridSettings = null;
	  };
	  function postMortem() {
	    throw new Error('This method cannot be called because this Handsontable instance has been destroyed');
	  }
	  this.getActiveEditor = function() {
	    return editorManager.getActiveEditor();
	  };
	  this.getPlugin = function(pluginName) {
	    return getPlugin(this, pluginName);
	  };
	  this.getInstance = function() {
	    return instance;
	  };
	  this.addHook = function(key, callback) {
	    Handsontable.hooks.add(key, callback, instance);
	  };
	  this.hasHook = function(key) {
	    return Handsontable.hooks.has(key, instance);
	  };
	  this.addHookOnce = function(key, callback) {
	    Handsontable.hooks.once(key, callback, instance);
	  };
	  this.removeHook = function(key, callback) {
	    Handsontable.hooks.remove(key, callback, instance);
	  };
	  this.runHooks = function(key, p1, p2, p3, p4, p5, p6) {
	    return Handsontable.hooks.run(instance, key, p1, p2, p3, p4, p5, p6);
	  };
	  this.timeouts = [];
	  this._registerTimeout = function(handle) {
	    this.timeouts.push(handle);
	  };
	  this._clearTimeouts = function() {
	    for (var i = 0,
	        ilen = this.timeouts.length; i < ilen; i++) {
	      clearTimeout(this.timeouts[i]);
	    }
	  };
	  this.version = Handsontable.version;
	  Handsontable.hooks.run(instance, 'construct');
	};
	var DefaultSettings = function() {};
	DefaultSettings.prototype = {
	  data: void 0,
	  dataSchema: void 0,
	  width: void 0,
	  height: void 0,
	  startRows: 5,
	  startCols: 5,
	  rowHeaders: void 0,
	  colHeaders: null,
	  colWidths: void 0,
	  rowHeights: void 0,
	  columns: void 0,
	  cells: void 0,
	  cell: [],
	  comments: false,
	  customBorders: false,
	  minRows: 0,
	  minCols: 0,
	  maxRows: Infinity,
	  maxCols: Infinity,
	  minSpareRows: 0,
	  minSpareCols: 0,
	  allowInsertRow: true,
	  allowInsertColumn: true,
	  allowRemoveRow: true,
	  allowRemoveColumn: true,
	  multiSelect: true,
	  fillHandle: true,
	  fixedRowsTop: 0,
	  fixedRowsBottom: 0,
	  fixedColumnsLeft: 0,
	  outsideClickDeselects: true,
	  enterBeginsEditing: true,
	  enterMoves: {
	    row: 1,
	    col: 0
	  },
	  tabMoves: {
	    row: 0,
	    col: 1
	  },
	  autoWrapRow: false,
	  autoWrapCol: false,
	  copyRowsLimit: 1000,
	  copyColsLimit: 1000,
	  pasteMode: 'overwrite',
	  persistentState: void 0,
	  currentRowClassName: void 0,
	  currentColClassName: void 0,
	  className: void 0,
	  tableClassName: void 0,
	  stretchH: 'none',
	  isEmptyRow: function(row) {
	    var col,
	        colLen,
	        value,
	        meta;
	    for (col = 0, colLen = this.countCols(); col < colLen; col++) {
	      value = this.getDataAtCell(row, col);
	      if (value !== '' && value !== null && typeof value !== 'undefined') {
	        if (typeof value === 'object') {
	          meta = this.getCellMeta(row, col);
	          return isObjectEquals(this.getSchema()[meta.prop], value);
	        }
	        return false;
	      }
	    }
	    return true;
	  },
	  isEmptyCol: function(col) {
	    var row,
	        rowLen,
	        value;
	    for (row = 0, rowLen = this.countRows(); row < rowLen; row++) {
	      value = this.getDataAtCell(row, col);
	      if (value !== '' && value !== null && typeof value !== 'undefined') {
	        return false;
	      }
	    }
	    return true;
	  },
	  observeDOMVisibility: true,
	  allowInvalid: true,
	  allowEmpty: true,
	  invalidCellClassName: 'htInvalid',
	  placeholder: false,
	  placeholderCellClassName: 'htPlaceholder',
	  readOnlyCellClassName: 'htDimmed',
	  renderer: void 0,
	  commentedCellClassName: 'htCommentCell',
	  fragmentSelection: false,
	  readOnly: false,
	  skipColumnOnPaste: false,
	  search: false,
	  type: 'text',
	  copyable: true,
	  editor: void 0,
	  autoComplete: void 0,
	  visibleRows: 10,
	  trimDropdown: true,
	  debug: false,
	  wordWrap: true,
	  noWordWrapClassName: 'htNoWrap',
	  contextMenu: void 0,
	  contextMenuCopyPaste: void 0,
	  copyPaste: void 0,
	  undo: void 0,
	  columnSorting: void 0,
	  manualColumnMove: void 0,
	  manualColumnResize: void 0,
	  manualRowMove: void 0,
	  manualRowResize: void 0,
	  mergeCells: false,
	  viewportRowRenderingOffset: 'auto',
	  viewportColumnRenderingOffset: 'auto',
	  validator: void 0,
	  disableVisualSelection: false,
	  sortIndicator: void 0,
	  manualColumnFreeze: void 0,
	  trimWhitespace: true,
	  settings: void 0,
	  source: void 0,
	  title: void 0,
	  checkedTemplate: void 0,
	  uncheckedTemplate: void 0,
	  label: void 0,
	  format: void 0,
	  language: void 0,
	  selectOptions: void 0,
	  autoColumnSize: void 0,
	  autoRowSize: void 0,
	  dateFormat: void 0,
	  correctFormat: false,
	  defaultDate: void 0,
	  strict: void 0,
	  renderAllRows: void 0,
	  preventOverflow: false,
	  bindRowsWithHeaders: void 0,
	  collapsibleColumns: void 0,
	  columnSummary: void 0,
	  dropdownMenu: void 0,
	  filters: void 0,
	  ganttChart: void 0,
	  headerTooltips: void 0,
	  hiddenColumns: void 0,
	  hiddenRows: void 0,
	  nestedHeaders: void 0,
	  trimRows: void 0,
	  rowHeaderWidth: void 0,
	  columnHeaderHeight: void 0,
	  observeChanges: void 0,
	  sortFunction: void 0,
	  sortByRelevance: true,
	  filter: true,
	  filteringCaseSensitive: false
	};
	Handsontable.DefaultSettings = DefaultSettings;

	//# 
	},{"3rdparty/walkontable/src/calculator/viewportColumns":3,"3rdparty/walkontable/src/cell/coords":5,"3rdparty/walkontable/src/cell/range":6,"3rdparty/walkontable/src/selection":18,"browser":23,"dataMap":26,"dataSource":27,"editorManager":28,"eventManager":41,"helpers/array":42,"helpers/browser":43,"helpers/data":44,"helpers/dom/element":46,"helpers/number":51,"helpers/object":52,"helpers/setting":53,"helpers/string":54,"numeral":"numeral","plugins":59,"renderers":92,"tableView":101}],26:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  DataMap: {get: function() {
	      return DataMap;
	    }},
	  __esModule: {value: true}
	});
	var $__browser__,
	    $__SheetClip__,
	    $__helpers_47_data__,
	    $__helpers_47_setting__,
	    $__helpers_47_object__,
	    $__helpers_47_array__,
	    $__utils_47_interval__,
	    $__helpers_47_number__,
	    $__multiMap__;
	var Handsontable = ($__browser__ = _dereq_("browser"), $__browser__ && $__browser__.__esModule && $__browser__ || {default: $__browser__}).default;
	var SheetClip = ($__SheetClip__ = _dereq_("SheetClip"), $__SheetClip__ && $__SheetClip__.__esModule && $__SheetClip__ || {default: $__SheetClip__}).default;
	var cellMethodLookupFactory = ($__helpers_47_data__ = _dereq_("helpers/data"), $__helpers_47_data__ && $__helpers_47_data__.__esModule && $__helpers_47_data__ || {default: $__helpers_47_data__}).cellMethodLookupFactory;
	var columnFactory = ($__helpers_47_setting__ = _dereq_("helpers/setting"), $__helpers_47_setting__ && $__helpers_47_setting__.__esModule && $__helpers_47_setting__ || {default: $__helpers_47_setting__}).columnFactory;
	var $__4 = ($__helpers_47_object__ = _dereq_("helpers/object"), $__helpers_47_object__ && $__helpers_47_object__.__esModule && $__helpers_47_object__ || {default: $__helpers_47_object__}),
	    duckSchema = $__4.duckSchema,
	    deepExtend = $__4.deepExtend,
	    deepClone = $__4.deepClone;
	var $__5 = ($__helpers_47_array__ = _dereq_("helpers/array"), $__helpers_47_array__ && $__helpers_47_array__.__esModule && $__helpers_47_array__ || {default: $__helpers_47_array__}),
	    extendArray = $__5.extendArray,
	    to2dArray = $__5.to2dArray;
	var Interval = ($__utils_47_interval__ = _dereq_("utils/interval"), $__utils_47_interval__ && $__utils_47_interval__.__esModule && $__utils_47_interval__ || {default: $__utils_47_interval__}).Interval;
	var rangeEach = ($__helpers_47_number__ = _dereq_("helpers/number"), $__helpers_47_number__ && $__helpers_47_number__.__esModule && $__helpers_47_number__ || {default: $__helpers_47_number__}).rangeEach;
	var MultiMap = ($__multiMap__ = _dereq_("multiMap"), $__multiMap__ && $__multiMap__.__esModule && $__multiMap__ || {default: $__multiMap__}).MultiMap;
	function DataMap(instance, priv, GridSettings) {
	  var $__9 = this;
	  this.instance = instance;
	  this.priv = priv;
	  this.GridSettings = GridSettings;
	  this.dataSource = this.instance.getSettings().data;
	  this.cachedLength = null;
	  this.latestSourceRowsCount = 0;
	  if (this.dataSource[0]) {
	    this.duckSchema = this.recursiveDuckSchema(this.dataSource[0]);
	  } else {
	    this.duckSchema = {};
	  }
	  this.createMap();
	  this.interval = Interval.create((function() {
	    return $__9.clearLengthCache();
	  }), '15fps');
	}
	DataMap.prototype.DESTINATION_RENDERER = 1;
	DataMap.prototype.DESTINATION_CLIPBOARD_GENERATOR = 2;
	DataMap.prototype.recursiveDuckSchema = function(object) {
	  return duckSchema(object);
	};
	DataMap.prototype.recursiveDuckColumns = function(schema, lastCol, parent) {
	  var prop,
	      i;
	  if (typeof lastCol === 'undefined') {
	    lastCol = 0;
	    parent = '';
	  }
	  if (typeof schema === 'object' && !Array.isArray(schema)) {
	    for (i in schema) {
	      if (schema.hasOwnProperty(i)) {
	        if (schema[i] === null) {
	          prop = parent + i;
	          this.colToPropCache.push(prop);
	          this.propToColCache.set(prop, lastCol);
	          lastCol++;
	        } else {
	          lastCol = this.recursiveDuckColumns(schema[i], lastCol, i + '.');
	        }
	      }
	    }
	  }
	  return lastCol;
	};
	DataMap.prototype.createMap = function() {
	  var i,
	      ilen,
	      schema = this.getSchema();
	  if (typeof schema === 'undefined') {
	    throw new Error('trying to create `columns` definition but you didnt\' provide `schema` nor `data`');
	  }
	  this.colToPropCache = [];
	  this.propToColCache = new MultiMap();
	  var columns = this.instance.getSettings().columns;
	  if (columns) {
	    for (i = 0, ilen = columns.length; i < ilen; i++) {
	      if (typeof columns[i].data != 'undefined') {
	        this.colToPropCache[i] = columns[i].data;
	        this.propToColCache.set(columns[i].data, i);
	      }
	    }
	  } else {
	    this.recursiveDuckColumns(schema);
	  }
	};
	DataMap.prototype.colToProp = function(col) {
	  col = Handsontable.hooks.run(this.instance, 'modifyCol', col);
	  if (this.colToPropCache && typeof this.colToPropCache[col] !== 'undefined') {
	    return this.colToPropCache[col];
	  }
	  return col;
	};
	DataMap.prototype.propToCol = function(prop) {
	  var col;
	  if (typeof this.propToColCache.get(prop) === 'undefined') {
	    col = prop;
	  } else {
	    col = this.propToColCache.get(prop);
	  }
	  col = Handsontable.hooks.run(this.instance, 'unmodifyCol', col);
	  return col;
	};
	DataMap.prototype.getSchema = function() {
	  var schema = this.instance.getSettings().dataSchema;
	  if (schema) {
	    if (typeof schema === 'function') {
	      return schema();
	    }
	    return schema;
	  }
	  return this.duckSchema;
	};
	DataMap.prototype.createRow = function(index, amount, createdAutomatically) {
	  var row,
	      colCount = this.instance.countCols(),
	      numberOfCreatedRows = 0,
	      currentIndex;
	  if (!amount) {
	    amount = 1;
	  }
	  if (typeof index !== 'number' || index >= this.instance.countSourceRows()) {
	    index = this.instance.countSourceRows();
	  }
	  currentIndex = index;
	  var maxRows = this.instance.getSettings().maxRows;
	  while (numberOfCreatedRows < amount && this.instance.countSourceRows() < maxRows) {
	    if (this.instance.dataType === 'array') {
	      if (this.instance.getSettings().dataSchema) {
	        row = deepClone(this.getSchema());
	      } else {
	        row = [];
	        rangeEach(colCount - 1, (function() {
	          return row.push(null);
	        }));
	      }
	    } else if (this.instance.dataType === 'function') {
	      row = this.instance.getSettings().dataSchema(index);
	    } else {
	      row = {};
	      deepExtend(row, this.getSchema());
	    }
	    if (index === this.instance.countSourceRows()) {
	      this.dataSource.push(row);
	    } else {
	      this.dataSource.splice(index, 0, row);
	    }
	    numberOfCreatedRows++;
	    currentIndex++;
	  }
	  Handsontable.hooks.run(this.instance, 'afterCreateRow', index, numberOfCreatedRows, createdAutomatically);
	  this.instance.forceFullRender = true;
	  return numberOfCreatedRows;
	};
	DataMap.prototype.createCol = function(index, amount, createdAutomatically) {
	  if (!this.instance.isColumnModificationAllowed()) {
	    throw new Error('Cannot create new column. When data source in an object, ' + 'you can only have as much columns as defined in first data row, data schema or in the \'columns\' setting.' + 'If you want to be able to add new columns, you have to use array datasource.');
	  }
	  var rlen = this.instance.countSourceRows(),
	      data = this.dataSource,
	      constructor,
	      numberOfCreatedCols = 0,
	      currentIndex;
	  if (!amount) {
	    amount = 1;
	  }
	  if (typeof index !== 'number' || index >= this.instance.countCols()) {
	    index = this.instance.countCols();
	  }
	  currentIndex = index;
	  var maxCols = this.instance.getSettings().maxCols;
	  while (numberOfCreatedCols < amount && this.instance.countCols() < maxCols) {
	    constructor = columnFactory(this.GridSettings, this.priv.columnsSettingConflicts);
	    if (typeof index !== 'number' || index >= this.instance.countCols()) {
	      for (var r = 0; r < rlen; r++) {
	        if (typeof data[r] === 'undefined') {
	          data[r] = [];
	        }
	        data[r].push(null);
	      }
	      this.priv.columnSettings.push(constructor);
	    } else {
	      for (var r = 0; r < rlen; r++) {
	        data[r].splice(currentIndex, 0, null);
	      }
	      this.priv.columnSettings.splice(currentIndex, 0, constructor);
	    }
	    numberOfCreatedCols++;
	    currentIndex++;
	  }
	  Handsontable.hooks.run(this.instance, 'afterCreateCol', index, numberOfCreatedCols, createdAutomatically);
	  this.instance.forceFullRender = true;
	  return numberOfCreatedCols;
	};
	DataMap.prototype.removeRow = function(index, amount) {
	  if (!amount) {
	    amount = 1;
	  }
	  if (typeof index !== 'number') {
	    index = -amount;
	  }
	  index = (this.instance.countSourceRows() + index) % this.instance.countSourceRows();
	  var logicRows = this.physicalRowsToLogical(index, amount);
	  var descendingLogicRows = logicRows.slice(0).sort(function(a, b) {
	    return b - a;
	  });
	  var actionWasNotCancelled = Handsontable.hooks.run(this.instance, 'beforeRemoveRow', index, amount, logicRows);
	  if (actionWasNotCancelled === false) {
	    return;
	  }
	  var data = this.dataSource;
	  var newData;
	  newData = data.filter(function(row, index) {
	    return logicRows.indexOf(index) == -1;
	  });
	  data.length = 0;
	  Array.prototype.push.apply(data, newData);
	  Handsontable.hooks.run(this.instance, 'afterRemoveRow', index, amount, logicRows);
	  this.instance.forceFullRender = true;
	};
	DataMap.prototype.removeCol = function(index, amount) {
	  if (this.instance.dataType === 'object' || this.instance.getSettings().columns) {
	    throw new Error('cannot remove column with object data source or columns option specified');
	  }
	  if (!amount) {
	    amount = 1;
	  }
	  if (typeof index !== 'number') {
	    index = -amount;
	  }
	  index = (this.instance.countCols() + index) % this.instance.countCols();
	  var logicColumns = this.physicalColumnsToLogical(index, amount);
	  var descendingLogicColumns = logicColumns.slice(0).sort(function(a, b) {
	    return b - a;
	  });
	  var actionWasNotCancelled = Handsontable.hooks.run(this.instance, 'beforeRemoveCol', index, amount, logicColumns);
	  if (actionWasNotCancelled === false) {
	    return;
	  }
	  var isTableUniform = true;
	  var removedColumnsCount = descendingLogicColumns.length;
	  var data = this.dataSource;
	  for (var c = 0; c < removedColumnsCount; c++) {
	    if (isTableUniform && logicColumns[0] !== logicColumns[c] - c) {
	      isTableUniform = false;
	    }
	  }
	  if (isTableUniform) {
	    for (var r = 0,
	        rlen = this.instance.countSourceRows(); r < rlen; r++) {
	      data[r].splice(logicColumns[0], amount);
	    }
	  } else {
	    for (var r$__10 = 0,
	        rlen$__11 = this.instance.countSourceRows(); r$__10 < rlen$__11; r$__10++) {
	      for (var c$__12 = 0; c$__12 < removedColumnsCount; c$__12++) {
	        data[r$__10].splice(descendingLogicColumns[c$__12], 1);
	      }
	    }
	    for (var c$__13 = 0; c$__13 < removedColumnsCount; c$__13++) {
	      this.priv.columnSettings.splice(logicColumns[c$__13], 1);
	    }
	  }
	  Handsontable.hooks.run(this.instance, 'afterRemoveCol', index, amount);
	  this.instance.forceFullRender = true;
	};
	DataMap.prototype.spliceCol = function(col, index, amount) {
	  var elements = 4 <= arguments.length ? [].slice.call(arguments, 3) : [];
	  var colData = this.instance.getDataAtCol(col);
	  var removed = colData.slice(index, index + amount);
	  var after = colData.slice(index + amount);
	  extendArray(elements, after);
	  var i = 0;
	  while (i < amount) {
	    elements.push(null);
	    i++;
	  }
	  to2dArray(elements);
	  this.instance.populateFromArray(index, col, elements, null, null, 'spliceCol');
	  return removed;
	};
	DataMap.prototype.spliceRow = function(row, index, amount) {
	  var elements = 4 <= arguments.length ? [].slice.call(arguments, 3) : [];
	  var rowData = this.instance.getSourceDataAtRow(row);
	  var removed = rowData.slice(index, index + amount);
	  var after = rowData.slice(index + amount);
	  extendArray(elements, after);
	  var i = 0;
	  while (i < amount) {
	    elements.push(null);
	    i++;
	  }
	  this.instance.populateFromArray(row, index, [elements], null, null, 'spliceRow');
	  return removed;
	};
	DataMap.prototype.get = function(row, prop) {
	  row = Handsontable.hooks.run(this.instance, 'modifyRow', row);
	  var dataRow = this.dataSource[row];
	  if (dataRow && dataRow.hasOwnProperty && dataRow.hasOwnProperty(prop)) {
	    return dataRow[prop];
	  } else if (typeof prop === 'string' && prop.indexOf('.') > -1) {
	    var sliced = prop.split('.');
	    var out = dataRow;
	    if (!out) {
	      return null;
	    }
	    for (var i = 0,
	        ilen = sliced.length; i < ilen; i++) {
	      out = out[sliced[i]];
	      if (typeof out === 'undefined') {
	        return null;
	      }
	    }
	    return out;
	  } else if (typeof prop === 'function') {
	    return prop(this.dataSource.slice(row, row + 1)[0]);
	  }
	  return null;
	};
	var copyableLookup = cellMethodLookupFactory('copyable', false);
	DataMap.prototype.getCopyable = function(row, prop) {
	  if (copyableLookup.call(this.instance, row, this.propToCol(prop))) {
	    return this.get(row, prop);
	  }
	  return '';
	};
	DataMap.prototype.set = function(row, prop, value, source) {
	  row = Handsontable.hooks.run(this.instance, 'modifyRow', row, source || 'datamapGet');
	  var dataRow = this.dataSource[row];
	  if (dataRow && dataRow.hasOwnProperty && dataRow.hasOwnProperty(prop)) {
	    dataRow[prop] = value;
	  } else if (typeof prop === 'string' && prop.indexOf('.') > -1) {
	    var sliced = prop.split('.');
	    var out = dataRow;
	    for (var i = 0,
	        ilen = sliced.length - 1; i < ilen; i++) {
	      if (typeof out[sliced[i]] === 'undefined') {
	        out[sliced[i]] = {};
	      }
	      out = out[sliced[i]];
	    }
	    out[sliced[i]] = value;
	  } else if (typeof prop === 'function') {
	    prop(this.dataSource.slice(row, row + 1)[0], value);
	  } else {
	    dataRow[prop] = value;
	  }
	};
	DataMap.prototype.physicalRowsToLogical = function(index, amount) {
	  var totalRows = this.instance.countSourceRows();
	  var physicRow = (totalRows + index) % totalRows;
	  var logicRows = [];
	  var rowsToRemove = amount;
	  var row;
	  while (physicRow < totalRows && rowsToRemove) {
	    row = Handsontable.hooks.run(this.instance, 'modifyRow', physicRow);
	    logicRows.push(row);
	    rowsToRemove--;
	    physicRow++;
	  }
	  return logicRows;
	};
	DataMap.prototype.physicalColumnsToLogical = function(index, amount) {
	  var totalCols = this.instance.countCols();
	  var physicalCol = (totalCols + index) % totalCols;
	  var logicalCols = [];
	  var colsToRemove = amount;
	  while (physicalCol < totalCols && colsToRemove) {
	    var col = Handsontable.hooks.run(this.instance, 'modifyCol', physicalCol);
	    logicalCols.push(col);
	    colsToRemove--;
	    physicalCol++;
	  }
	  return logicalCols;
	};
	DataMap.prototype.clear = function() {
	  for (var r = 0; r < this.instance.countSourceRows(); r++) {
	    for (var c = 0; c < this.instance.countCols(); c++) {
	      this.set(r, this.colToProp(c), '');
	    }
	  }
	};
	DataMap.prototype.clearLengthCache = function() {
	  this.cachedLength = null;
	};
	DataMap.prototype.getLength = function() {
	  var $__9 = this;
	  var length = this.instance.countSourceRows();
	  if (Handsontable.hooks.has('modifyRow', this.instance)) {
	    var reValidate = false;
	    this.interval.start();
	    if (length !== this.latestSourceRowsCount) {
	      reValidate = true;
	    }
	    this.latestSourceRowsCount = length;
	    if (this.cachedLength === null || reValidate) {
	      rangeEach(length - 1, (function(row) {
	        row = Handsontable.hooks.run($__9.instance, 'modifyRow', row);
	        if (row === null) {
	          --length;
	        }
	      }));
	      this.cachedLength = length;
	    } else {
	      length = this.cachedLength;
	    }
	  } else {
	    this.interval.stop();
	  }
	  return length;
	};
	DataMap.prototype.getAll = function() {
	  var start = {
	    row: 0,
	    col: 0
	  };
	  var end = {
	    row: Math.max(this.instance.countSourceRows() - 1, 0),
	    col: Math.max(this.instance.countCols() - 1, 0)
	  };
	  if (start.row - end.row === 0 && !this.instance.countSourceRows()) {
	    return [];
	  }
	  return this.getRange(start, end, DataMap.prototype.DESTINATION_RENDERER);
	};
	DataMap.prototype.getRange = function(start, end, destination) {
	  var r,
	      rlen,
	      c,
	      clen,
	      output = [],
	      row,
	      rowExists;
	  var getFn = destination === this.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;
	  rlen = Math.max(start.row, end.row);
	  clen = Math.max(start.col, end.col);
	  for (r = Math.min(start.row, end.row); r <= rlen; r++) {
	    row = [];
	    var physicalRow = Handsontable.hooks.run(this.instance, 'modifyRow', r);
	    for (c = Math.min(start.col, end.col); c <= clen; c++) {
	      var rowValue;
	      if (physicalRow === null) {
	        break;
	      }
	      row.push(getFn.call(this, r, this.colToProp(c)));
	    }
	    if (physicalRow !== null) {
	      output.push(row);
	    }
	  }
	  return output;
	};
	DataMap.prototype.getText = function(start, end) {
	  return SheetClip.stringify(this.getRange(start, end, this.DESTINATION_RENDERER));
	};
	DataMap.prototype.getCopyableText = function(start, end) {
	  return SheetClip.stringify(this.getRange(start, end, this.DESTINATION_CLIPBOARD_GENERATOR));
	};
	DataMap.prototype.destroy = function() {
	  this.interval.stop();
	  this.interval = null;
	  this.instance = null;
	  this.priv = null;
	  this.GridSettings = null;
	  this.dataSource = null;
	  this.cachedLength = null;
	  this.duckSchema = null;
	};
	;

	//# 
	},{"SheetClip":"SheetClip","browser":23,"helpers/array":42,"helpers/data":44,"helpers/number":51,"helpers/object":52,"helpers/setting":53,"multiMap":57,"utils/interval":103}],27:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  DataSource: {get: function() {
	      return DataSource;
	    }},
	  __esModule: {value: true}
	});
	var $__helpers_47_data__,
	    $__helpers_47_setting__,
	    $__helpers_47_object__,
	    $__helpers_47_array__,
	    $__helpers_47_number__;
	var cellMethodLookupFactory = ($__helpers_47_data__ = _dereq_("helpers/data"), $__helpers_47_data__ && $__helpers_47_data__.__esModule && $__helpers_47_data__ || {default: $__helpers_47_data__}).cellMethodLookupFactory;
	var columnFactory = ($__helpers_47_setting__ = _dereq_("helpers/setting"), $__helpers_47_setting__ && $__helpers_47_setting__.__esModule && $__helpers_47_setting__ || {default: $__helpers_47_setting__}).columnFactory;
	var $__2 = ($__helpers_47_object__ = _dereq_("helpers/object"), $__helpers_47_object__ && $__helpers_47_object__.__esModule && $__helpers_47_object__ || {default: $__helpers_47_object__}),
	    duckSchema = $__2.duckSchema,
	    deepExtend = $__2.deepExtend,
	    getProperty = $__2.getProperty;
	var $__3 = ($__helpers_47_array__ = _dereq_("helpers/array"), $__helpers_47_array__ && $__helpers_47_array__.__esModule && $__helpers_47_array__ || {default: $__helpers_47_array__}),
	    extendArray = $__3.extendArray,
	    arrayEach = $__3.arrayEach;
	var rangeEach = ($__helpers_47_number__ = _dereq_("helpers/number"), $__helpers_47_number__ && $__helpers_47_number__.__esModule && $__helpers_47_number__ || {default: $__helpers_47_number__}).rangeEach;
	var DataSource = function DataSource(hotInstance) {
	  var dataSource = arguments[1] !== (void 0) ? arguments[1] : [];
	  this.hot = hotInstance;
	  this.data = dataSource;
	  this.dataType = 'array';
	  this.colToProp = (function() {});
	  this.propToCol = (function() {});
	};
	($traceurRuntime.createClass)(DataSource, {
	  getData: function() {
	    return this.data;
	  },
	  setData: function(data) {
	    this.data = data;
	  },
	  getAtColumn: function(column) {
	    var $__5 = this;
	    var result = [];
	    arrayEach(this.data, (function(row) {
	      var property = $__5.colToProp(column);
	      if (typeof property === 'string') {
	        row = getProperty(row, property);
	      } else {
	        row = row[property];
	      }
	      result.push(row);
	    }));
	    return result;
	  },
	  getAtRow: function(row) {
	    return this.data[row];
	  },
	  getAtCell: function(row, column) {
	    return this.data[row][this.colToProp(column)];
	  },
	  getByRange: function(start, end) {
	    var $__5 = this;
	    var startRow = Math.min(start.row, end.row);
	    var startCol = Math.min(start.col, end.col);
	    var endRow = Math.max(start.row, end.row);
	    var endCol = Math.max(start.col, end.col);
	    var result = [];
	    rangeEach(startRow, endRow, (function(currentRow) {
	      var row = $__5.getAtRow(currentRow);
	      var newRow;
	      if ($__5.dataType === 'array') {
	        newRow = row.slice(startCol, endCol);
	      } else if ($__5.dataType === 'object') {
	        newRow = {};
	        rangeEach(startCol, endCol, (function(column) {
	          var prop = $__5.colToProp(column);
	          newRow[prop] = row[prop];
	        }));
	      }
	      result.push(newRow);
	    }));
	    return result;
	  },
	  destroy: function() {
	    this.data = null;
	    this.hot = null;
	  }
	}, {});
	;

	//# 
	},{"helpers/array":42,"helpers/data":44,"helpers/number":51,"helpers/object":52,"helpers/setting":53}],28:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  EditorManager: {get: function() {
	      return EditorManager;
	    }},
	  __esModule: {value: true}
	});
	var $__browser__,
	    $__3rdparty_47_walkontable_47_src_47_cell_47_coords__,
	    $__helpers_47_unicode__,
	    $__helpers_47_dom_47_event__,
	    $__editors__,
	    $__eventManager__;
	var Handsontable = ($__browser__ = _dereq_("browser"), $__browser__ && $__browser__.__esModule && $__browser__ || {default: $__browser__}).default;
	var WalkontableCellCoords = ($__3rdparty_47_walkontable_47_src_47_cell_47_coords__ = _dereq_("3rdparty/walkontable/src/cell/coords"), $__3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $__3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $__3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $__3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	var $__2 = ($__helpers_47_unicode__ = _dereq_("helpers/unicode"), $__helpers_47_unicode__ && $__helpers_47_unicode__.__esModule && $__helpers_47_unicode__ || {default: $__helpers_47_unicode__}),
	    KEY_CODES = $__2.KEY_CODES,
	    isMetaKey = $__2.isMetaKey,
	    isCtrlKey = $__2.isCtrlKey;
	var $__3 = ($__helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $__helpers_47_dom_47_event__ && $__helpers_47_dom_47_event__.__esModule && $__helpers_47_dom_47_event__ || {default: $__helpers_47_dom_47_event__}),
	    stopPropagation = $__3.stopPropagation,
	    stopImmediatePropagation = $__3.stopImmediatePropagation,
	    isImmediatePropagationStopped = $__3.isImmediatePropagationStopped;
	var getEditor = ($__editors__ = _dereq_("editors"), $__editors__ && $__editors__.__esModule && $__editors__ || {default: $__editors__}).getEditor;
	var eventManagerObject = ($__eventManager__ = _dereq_("eventManager"), $__eventManager__ && $__eventManager__.__esModule && $__eventManager__ || {default: $__eventManager__}).eventManager;
	;
	Handsontable.EditorManager = EditorManager;
	function EditorManager(instance, priv, selection) {
	  var _this = this,
	      destroyed = false,
	      eventManager,
	      activeEditor;
	  eventManager = eventManagerObject(instance);
	  function moveSelectionAfterEnter(shiftKey) {
	    var enterMoves = typeof priv.settings.enterMoves === 'function' ? priv.settings.enterMoves(event) : priv.settings.enterMoves;
	    if (shiftKey) {
	      selection.transformStart(-enterMoves.row, -enterMoves.col);
	    } else {
	      selection.transformStart(enterMoves.row, enterMoves.col, true);
	    }
	  }
	  function moveSelectionUp(shiftKey) {
	    if (shiftKey) {
	      selection.transformEnd(-1, 0);
	    } else {
	      selection.transformStart(-1, 0);
	    }
	  }
	  function moveSelectionDown(shiftKey) {
	    if (shiftKey) {
	      selection.transformEnd(1, 0);
	    } else {
	      selection.transformStart(1, 0);
	    }
	  }
	  function moveSelectionRight(shiftKey) {
	    if (shiftKey) {
	      selection.transformEnd(0, 1);
	    } else {
	      selection.transformStart(0, 1);
	    }
	  }
	  function moveSelectionLeft(shiftKey) {
	    if (shiftKey) {
	      selection.transformEnd(0, -1);
	    } else {
	      selection.transformStart(0, -1);
	    }
	  }
	  function onKeyDown(event) {
	    var ctrlDown,
	        rangeModifier;
	    if (!instance.isListening()) {
	      return;
	    }
	    Handsontable.hooks.run(instance, 'beforeKeyDown', event);
	    if (destroyed) {
	      return;
	    }
	    if (isImmediatePropagationStopped(event)) {
	      return;
	    }
	    priv.lastKeyCode = event.keyCode;
	    if (!selection.isSelected()) {
	      return;
	    }
	    ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;
	    if (activeEditor && !activeEditor.isWaiting()) {
	      if (!isMetaKey(event.keyCode) && !isCtrlKey(event.keyCode) && !ctrlDown && !_this.isEditorOpened()) {
	        _this.openEditor('', event);
	        return;
	      }
	    }
	    rangeModifier = event.shiftKey ? selection.setRangeEnd : selection.setRangeStart;
	    switch (event.keyCode) {
	      case KEY_CODES.A:
	        if (!_this.isEditorOpened() && ctrlDown) {
	          selection.selectAll();
	          event.preventDefault();
	          stopPropagation(event);
	        }
	        break;
	      case KEY_CODES.ARROW_UP:
	        if (_this.isEditorOpened() && !activeEditor.isWaiting()) {
	          _this.closeEditorAndSaveChanges(ctrlDown);
	        }
	        moveSelectionUp(event.shiftKey);
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	      case KEY_CODES.ARROW_DOWN:
	        if (_this.isEditorOpened() && !activeEditor.isWaiting()) {
	          _this.closeEditorAndSaveChanges(ctrlDown);
	        }
	        moveSelectionDown(event.shiftKey);
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	      case KEY_CODES.ARROW_RIGHT:
	        if (_this.isEditorOpened() && !activeEditor.isWaiting()) {
	          _this.closeEditorAndSaveChanges(ctrlDown);
	        }
	        moveSelectionRight(event.shiftKey);
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	      case KEY_CODES.ARROW_LEFT:
	        if (_this.isEditorOpened() && !activeEditor.isWaiting()) {
	          _this.closeEditorAndSaveChanges(ctrlDown);
	        }
	        moveSelectionLeft(event.shiftKey);
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	      case KEY_CODES.TAB:
	        var tabMoves = typeof priv.settings.tabMoves === 'function' ? priv.settings.tabMoves(event) : priv.settings.tabMoves;
	        if (event.shiftKey) {
	          selection.transformStart(-tabMoves.row, -tabMoves.col);
	        } else {
	          selection.transformStart(tabMoves.row, tabMoves.col, true);
	        }
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	      case KEY_CODES.BACKSPACE:
	      case KEY_CODES.DELETE:
	        selection.empty(event);
	        _this.prepareEditor();
	        event.preventDefault();
	        break;
	      case KEY_CODES.F2:
	        _this.openEditor(null, event);
	        if (activeEditor) {
	          activeEditor.enableFullEditMode();
	        }
	        event.preventDefault();
	        break;
	      case KEY_CODES.ENTER:
	        if (_this.isEditorOpened()) {
	          if (activeEditor && activeEditor.state !== Handsontable.EditorState.WAITING) {
	            _this.closeEditorAndSaveChanges(ctrlDown);
	          }
	          moveSelectionAfterEnter(event.shiftKey);
	        } else {
	          if (instance.getSettings().enterBeginsEditing) {
	            _this.openEditor(null, event);
	            if (activeEditor) {
	              activeEditor.enableFullEditMode();
	            }
	          } else {
	            moveSelectionAfterEnter(event.shiftKey);
	          }
	        }
	        event.preventDefault();
	        stopImmediatePropagation(event);
	        break;
	      case KEY_CODES.ESCAPE:
	        if (_this.isEditorOpened()) {
	          _this.closeEditorAndRestoreOriginalValue(ctrlDown);
	        }
	        event.preventDefault();
	        break;
	      case KEY_CODES.HOME:
	        if (event.ctrlKey || event.metaKey) {
	          rangeModifier(new WalkontableCellCoords(0, priv.selRange.from.col));
	        } else {
	          rangeModifier(new WalkontableCellCoords(priv.selRange.from.row, 0));
	        }
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	      case KEY_CODES.END:
	        if (event.ctrlKey || event.metaKey) {
	          rangeModifier(new WalkontableCellCoords(instance.countRows() - 1, priv.selRange.from.col));
	        } else {
	          rangeModifier(new WalkontableCellCoords(priv.selRange.from.row, instance.countCols() - 1));
	        }
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	      case KEY_CODES.PAGE_UP:
	        selection.transformStart(-instance.countVisibleRows(), 0);
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	      case KEY_CODES.PAGE_DOWN:
	        selection.transformStart(instance.countVisibleRows(), 0);
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	    }
	  }
	  function init() {
	    instance.addHook('afterDocumentKeyDown', onKeyDown);
	    eventManager.addEventListener(document.documentElement, 'keydown', function(event) {
	      instance.runHooks('afterDocumentKeyDown', event);
	    });
	    function onDblClick(event, coords, elem) {
	      if (elem.nodeName == 'TD') {
	        _this.openEditor();
	        if (activeEditor) {
	          activeEditor.enableFullEditMode();
	        }
	      }
	    }
	    instance.view.wt.update('onCellDblClick', onDblClick);
	    instance.addHook('afterDestroy', function() {
	      destroyed = true;
	    });
	  }
	  this.destroyEditor = function(revertOriginal) {
	    this.closeEditor(revertOriginal);
	  };
	  this.getActiveEditor = function() {
	    return activeEditor;
	  };
	  this.prepareEditor = function() {
	    var row,
	        col,
	        prop,
	        td,
	        originalValue,
	        cellProperties,
	        editorClass;
	    if (activeEditor && activeEditor.isWaiting()) {
	      this.closeEditor(false, false, function(dataSaved) {
	        if (dataSaved) {
	          _this.prepareEditor();
	        }
	      });
	      return;
	    }
	    row = priv.selRange.highlight.row;
	    col = priv.selRange.highlight.col;
	    prop = instance.colToProp(col);
	    td = instance.getCell(row, col);
	    originalValue = instance.getDataAtCell(row, col);
	    cellProperties = instance.getCellMeta(row, col);
	    editorClass = instance.getCellEditor(cellProperties);
	    if (editorClass) {
	      activeEditor = Handsontable.editors.getEditor(editorClass, instance);
	      activeEditor.prepare(row, col, prop, td, originalValue, cellProperties);
	    } else {
	      activeEditor = void 0;
	    }
	  };
	  this.isEditorOpened = function() {
	    return activeEditor && activeEditor.isOpened();
	  };
	  this.openEditor = function(initialValue, event) {
	    if (activeEditor && !activeEditor.cellProperties.readOnly) {
	      activeEditor.beginEditing(initialValue, event);
	    } else if (activeEditor && activeEditor.cellProperties.readOnly) {
	      if (event && event.keyCode === KEY_CODES.ENTER) {
	        moveSelectionAfterEnter();
	      }
	    }
	  };
	  this.closeEditor = function(restoreOriginalValue, ctrlDown, callback) {
	    if (activeEditor) {
	      activeEditor.finishEditing(restoreOriginalValue, ctrlDown, callback);
	    } else {
	      if (callback) {
	        callback(false);
	      }
	    }
	  };
	  this.closeEditorAndSaveChanges = function(ctrlDown) {
	    return this.closeEditor(false, ctrlDown);
	  };
	  this.closeEditorAndRestoreOriginalValue = function(ctrlDown) {
	    return this.closeEditor(true, ctrlDown);
	  };
	  init();
	}

	//# 
	},{"3rdparty/walkontable/src/cell/coords":5,"browser":23,"editors":29,"eventManager":41,"helpers/dom/event":47,"helpers/unicode":55}],29:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  registerEditor: {get: function() {
	      return registerEditor;
	    }},
	  getEditor: {get: function() {
	      return getEditor;
	    }},
	  hasEditor: {get: function() {
	      return hasEditor;
	    }},
	  getEditorConstructor: {get: function() {
	      return getEditorConstructor;
	    }},
	  __esModule: {value: true}
	});
	var $__browser__,
	    $__helpers_47_string__;
	var Handsontable = ($__browser__ = _dereq_("browser"), $__browser__ && $__browser__.__esModule && $__browser__ || {default: $__browser__}).default;
	var toUpperCaseFirst = ($__helpers_47_string__ = _dereq_("helpers/string"), $__helpers_47_string__ && $__helpers_47_string__.__esModule && $__helpers_47_string__ || {default: $__helpers_47_string__}).toUpperCaseFirst;
	;
	var registeredEditorNames = {},
	    registeredEditorClasses = new WeakMap();
	Handsontable.editors = Handsontable.editors || {};
	Handsontable.editors.registerEditor = registerEditor;
	Handsontable.editors.getEditor = getEditor;
	function RegisteredEditor(editorClass) {
	  var Clazz,
	      instances;
	  instances = {};
	  Clazz = editorClass;
	  this.getConstructor = function() {
	    return editorClass;
	  };
	  this.getInstance = function(hotInstance) {
	    if (!(hotInstance.guid in instances)) {
	      instances[hotInstance.guid] = new Clazz(hotInstance);
	    }
	    return instances[hotInstance.guid];
	  };
	}
	function registerEditor(editorName, editorClass) {
	  var editor = new RegisteredEditor(editorClass);
	  if (typeof editorName === 'string') {
	    registeredEditorNames[editorName] = editor;
	    Handsontable.editors[toUpperCaseFirst(editorName) + 'Editor'] = editorClass;
	  }
	  registeredEditorClasses.set(editorClass, editor);
	}
	function getEditor(editorName, hotInstance) {
	  var editor;
	  if (typeof editorName == 'function') {
	    if (!(registeredEditorClasses.get(editorName))) {
	      registerEditor(null, editorName);
	    }
	    editor = registeredEditorClasses.get(editorName);
	  } else if (typeof editorName == 'string') {
	    editor = registeredEditorNames[editorName];
	  } else {
	    throw Error('Only strings and functions can be passed as "editor" parameter ');
	  }
	  if (!editor) {
	    throw Error('No editor registered under name "' + editorName + '"');
	  }
	  return editor.getInstance(hotInstance);
	}
	function getEditorConstructor(editorName) {
	  var editor;
	  if (typeof editorName == 'string') {
	    editor = registeredEditorNames[editorName];
	  } else {
	    throw Error('Only strings and functions can be passed as "editor" parameter ');
	  }
	  if (!editor) {
	    throw Error('No editor registered under name "' + editorName + '"');
	  }
	  return editor.getConstructor();
	}
	function hasEditor(editorName) {
	  return registeredEditorNames[editorName] ? true : false;
	}

	//# 
	},{"browser":23,"helpers/string":54}],30:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  BaseEditor: {get: function() {
	      return BaseEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $___46__46__47_helpers_47_mixed__,
	    $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var stringify = ($___46__46__47_helpers_47_mixed__ = _dereq_("helpers/mixed"), $___46__46__47_helpers_47_mixed__ && $___46__46__47_helpers_47_mixed__.__esModule && $___46__46__47_helpers_47_mixed__ || {default: $___46__46__47_helpers_47_mixed__}).stringify;
	var WalkontableCellCoords = ($___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ = _dereq_("3rdparty/walkontable/src/cell/coords"), $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	;
	Handsontable.editors = Handsontable.editors || {};
	Handsontable.editors.BaseEditor = BaseEditor;
	Handsontable.EditorState = {
	  VIRGIN: 'STATE_VIRGIN',
	  EDITING: 'STATE_EDITING',
	  WAITING: 'STATE_WAITING',
	  FINISHED: 'STATE_FINISHED'
	};
	function BaseEditor(instance) {
	  this.instance = instance;
	  this.state = Handsontable.EditorState.VIRGIN;
	  this._opened = false;
	  this._fullEditMode = false;
	  this._closeCallback = null;
	  this.init();
	}
	BaseEditor.prototype._fireCallbacks = function(result) {
	  if (this._closeCallback) {
	    this._closeCallback(result);
	    this._closeCallback = null;
	  }
	};
	BaseEditor.prototype.init = function() {};
	BaseEditor.prototype.getValue = function() {
	  throw Error('Editor getValue() method unimplemented');
	};
	BaseEditor.prototype.setValue = function(newValue) {
	  throw Error('Editor setValue() method unimplemented');
	};
	BaseEditor.prototype.open = function() {
	  throw Error('Editor open() method unimplemented');
	};
	BaseEditor.prototype.close = function() {
	  throw Error('Editor close() method unimplemented');
	};
	BaseEditor.prototype.prepare = function(row, col, prop, td, originalValue, cellProperties) {
	  this.TD = td;
	  this.row = row;
	  this.col = col;
	  this.prop = prop;
	  this.originalValue = originalValue;
	  this.cellProperties = cellProperties;
	  if (this.instance.view.isMouseDown() && document.activeElement && document.activeElement !== document.body) {
	    document.activeElement.blur();
	  } else if (!document.activeElement) {
	    document.body.focus();
	  }
	  this.state = Handsontable.EditorState.VIRGIN;
	};
	BaseEditor.prototype.extend = function() {
	  var baseClass = this.constructor;
	  function Editor() {
	    baseClass.apply(this, arguments);
	  }
	  function inherit(Child, Parent) {
	    function Bridge() {}
	    Bridge.prototype = Parent.prototype;
	    Child.prototype = new Bridge();
	    Child.prototype.constructor = Child;
	    return Child;
	  }
	  return inherit(Editor, baseClass);
	};
	BaseEditor.prototype.saveValue = function(val, ctrlDown) {
	  var sel,
	      tmp;
	  if (ctrlDown) {
	    sel = this.instance.getSelected();
	    if (sel[0] > sel[2]) {
	      tmp = sel[0];
	      sel[0] = sel[2];
	      sel[2] = tmp;
	    }
	    if (sel[1] > sel[3]) {
	      tmp = sel[1];
	      sel[1] = sel[3];
	      sel[3] = tmp;
	    }
	    this.instance.populateFromArray(sel[0], sel[1], val, sel[2], sel[3], 'edit');
	  } else {
	    this.instance.populateFromArray(this.row, this.col, val, null, null, 'edit');
	  }
	};
	BaseEditor.prototype.beginEditing = function(initialValue, event) {
	  if (this.state != Handsontable.EditorState.VIRGIN) {
	    return;
	  }
	  this.instance.view.scrollViewport(new WalkontableCellCoords(this.row, this.col));
	  this.instance.view.render();
	  this.state = Handsontable.EditorState.EDITING;
	  initialValue = typeof initialValue == 'string' ? initialValue : this.originalValue;
	  this.setValue(stringify(initialValue));
	  this.open(event);
	  this._opened = true;
	  this.focus();
	  this.instance.view.render();
	};
	BaseEditor.prototype.finishEditing = function(restoreOriginalValue, ctrlDown, callback) {
	  var _this = this,
	      val;
	  if (callback) {
	    var previousCloseCallback = this._closeCallback;
	    this._closeCallback = function(result) {
	      if (previousCloseCallback) {
	        previousCloseCallback(result);
	      }
	      callback(result);
	    };
	  }
	  if (this.isWaiting()) {
	    return;
	  }
	  if (this.state == Handsontable.EditorState.VIRGIN) {
	    this.instance._registerTimeout(setTimeout(function() {
	      _this._fireCallbacks(true);
	    }, 0));
	    return;
	  }
	  if (this.state == Handsontable.EditorState.EDITING) {
	    if (restoreOriginalValue) {
	      this.cancelChanges();
	      this.instance.view.render();
	      return;
	    }
	    var value = this.getValue();
	    if (this.instance.getSettings().trimWhitespace) {
	      val = [[typeof value === 'string' ? String.prototype.trim.call(value || '') : value]];
	    } else {
	      val = [[value]];
	    }
	    this.state = Handsontable.EditorState.WAITING;
	    this.saveValue(val, ctrlDown);
	    if (this.instance.getCellValidator(this.cellProperties)) {
	      this.instance.addHookOnce('postAfterValidate', function(result) {
	        _this.state = Handsontable.EditorState.FINISHED;
	        _this.discardEditor(result);
	      });
	    } else {
	      this.state = Handsontable.EditorState.FINISHED;
	      this.discardEditor(true);
	    }
	  }
	};
	BaseEditor.prototype.cancelChanges = function() {
	  this.state = Handsontable.EditorState.FINISHED;
	  this.discardEditor();
	};
	BaseEditor.prototype.discardEditor = function(result) {
	  if (this.state !== Handsontable.EditorState.FINISHED) {
	    return;
	  }
	  if (result === false && this.cellProperties.allowInvalid !== true) {
	    this.instance.selectCell(this.row, this.col);
	    this.focus();
	    this.state = Handsontable.EditorState.EDITING;
	    this._fireCallbacks(false);
	  } else {
	    this.close();
	    this._opened = false;
	    this._fullEditMode = false;
	    this.state = Handsontable.EditorState.VIRGIN;
	    this._fireCallbacks(true);
	  }
	};
	BaseEditor.prototype.enableFullEditMode = function() {
	  this._fullEditMode = true;
	};
	BaseEditor.prototype.isInFullEditMode = function() {
	  return this._fullEditMode;
	};
	BaseEditor.prototype.isOpened = function() {
	  return this._opened;
	};
	BaseEditor.prototype.isWaiting = function() {
	  return this.state === Handsontable.EditorState.WAITING;
	};
	BaseEditor.prototype.checkEditorSection = function() {
	  var totalRows = this.instance.countRows();
	  var section = '';
	  if (this.row < this.instance.getSettings().fixedRowsTop) {
	    if (this.col < this.instance.getSettings().fixedColumnsLeft) {
	      section = 'top-left-corner';
	    } else {
	      section = 'top';
	    }
	  } else if (this.instance.getSettings().fixedRowsBottom && this.row >= totalRows - this.instance.getSettings().fixedRowsBottom) {
	    if (this.col < this.instance.getSettings().fixedColumnsLeft) {
	      section = 'bottom-left-corner';
	    } else {
	      section = 'bottom';
	    }
	  } else {
	    if (this.col < this.instance.getSettings().fixedColumnsLeft) {
	      section = 'left';
	    }
	  }
	  return section;
	};

	//# 
	},{"3rdparty/walkontable/src/cell/coords":5,"browser":23,"helpers/mixed":50}],31:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  AutocompleteEditor: {get: function() {
	      return AutocompleteEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $___46__46__47_helpers_47_unicode__,
	    $___46__46__47_helpers_47_mixed__,
	    $___46__46__47_helpers_47_array__,
	    $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_editors__,
	    $__handsontableEditor__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var $__1 = ($___46__46__47_helpers_47_unicode__ = _dereq_("helpers/unicode"), $___46__46__47_helpers_47_unicode__ && $___46__46__47_helpers_47_unicode__.__esModule && $___46__46__47_helpers_47_unicode__ || {default: $___46__46__47_helpers_47_unicode__}),
	    KEY_CODES = $__1.KEY_CODES,
	    isPrintableChar = $__1.isPrintableChar;
	var stringify = ($___46__46__47_helpers_47_mixed__ = _dereq_("helpers/mixed"), $___46__46__47_helpers_47_mixed__ && $___46__46__47_helpers_47_mixed__.__esModule && $___46__46__47_helpers_47_mixed__ || {default: $___46__46__47_helpers_47_mixed__}).stringify;
	var pivot = ($___46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47_helpers_47_array__ && $___46__46__47_helpers_47_array__.__esModule && $___46__46__47_helpers_47_array__ || {default: $___46__46__47_helpers_47_array__}).pivot;
	var $__4 = ($___46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__4.addClass,
	    getCaretPosition = $__4.getCaretPosition,
	    getScrollbarWidth = $__4.getScrollbarWidth,
	    getSelectionEndPosition = $__4.getSelectionEndPosition,
	    outerWidth = $__4.outerWidth,
	    outerHeight = $__4.outerHeight,
	    offset = $__4.offset,
	    getTrimmingContainer = $__4.getTrimmingContainer,
	    setCaretPosition = $__4.setCaretPosition;
	var registerEditor = ($___46__46__47_editors__ = _dereq_("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}).registerEditor;
	var HandsontableEditor = ($__handsontableEditor__ = _dereq_("handsontableEditor"), $__handsontableEditor__ && $__handsontableEditor__.__esModule && $__handsontableEditor__ || {default: $__handsontableEditor__}).HandsontableEditor;
	var AutocompleteEditor = HandsontableEditor.prototype.extend();
	AutocompleteEditor.prototype.init = function() {
	  HandsontableEditor.prototype.init.apply(this, arguments);
	  this.query = null;
	  this.choices = [];
	};
	AutocompleteEditor.prototype.createElements = function() {
	  HandsontableEditor.prototype.createElements.apply(this, arguments);
	  addClass(this.htContainer, 'autocompleteEditor');
	  addClass(this.htContainer, window.navigator.platform.indexOf('Mac') === -1 ? '' : 'htMacScroll');
	};
	var skipOne = false;
	function onBeforeKeyDown(event) {
	  skipOne = false;
	  var editor = this.getActiveEditor();
	  if (isPrintableChar(event.keyCode) || event.keyCode === KEY_CODES.BACKSPACE || event.keyCode === KEY_CODES.DELETE || event.keyCode === KEY_CODES.INSERT) {
	    var timeOffset = 0;
	    if (event.keyCode === KEY_CODES.C && (event.ctrlKey || event.metaKey)) {
	      return;
	    }
	    if (!editor.isOpened()) {
	      timeOffset += 10;
	    }
	    if (editor.htEditor) {
	      editor.instance._registerTimeout(setTimeout(function() {
	        editor.queryChoices(editor.TEXTAREA.value);
	        skipOne = true;
	      }, timeOffset));
	    }
	  }
	}
	AutocompleteEditor.prototype.prepare = function() {
	  this.instance.addHook('beforeKeyDown', onBeforeKeyDown);
	  HandsontableEditor.prototype.prepare.apply(this, arguments);
	};
	AutocompleteEditor.prototype.open = function() {
	  this.TEXTAREA_PARENT.style.overflow = 'auto';
	  HandsontableEditor.prototype.open.apply(this, arguments);
	  this.TEXTAREA_PARENT.style.overflow = '';
	  var choicesListHot = this.htEditor.getInstance();
	  var _this = this;
	  var trimDropdown = this.cellProperties.trimDropdown === void 0 ? true : this.cellProperties.trimDropdown;
	  this.TEXTAREA.style.visibility = 'visible';
	  this.focus();
	  choicesListHot.updateSettings({
	    colWidths: trimDropdown ? [outerWidth(this.TEXTAREA) - 2] : void 0,
	    width: trimDropdown ? outerWidth(this.TEXTAREA) + getScrollbarWidth() + 2 : void 0,
	    afterRenderer: function(TD, row, col, prop, value) {
	      var caseSensitive = this.getCellMeta(row, col).filteringCaseSensitive === true;
	      var indexOfMatch;
	      var match;
	      value = stringify(value);
	      if (value) {
	        indexOfMatch = caseSensitive ? value.indexOf(this.query) : value.toLowerCase().indexOf(_this.query.toLowerCase());
	        if (indexOfMatch != -1) {
	          match = value.substr(indexOfMatch, _this.query.length);
	          TD.innerHTML = value.replace(match, '<strong>' + match + '</strong>');
	        }
	      }
	    },
	    autoColumnSize: true,
	    modifyColWidth: function(width, col) {
	      var autoWidths = this.getPlugin('autoColumnSize').widths;
	      if (autoWidths[col]) {
	        width = autoWidths[col];
	      }
	      return trimDropdown ? width : width + 15;
	    }
	  });
	  this.htEditor.view.wt.wtTable.holder.parentNode.style['padding-right'] = getScrollbarWidth() + 2 + 'px';
	  if (skipOne) {
	    skipOne = false;
	  }
	  _this.instance._registerTimeout(setTimeout(function() {
	    _this.queryChoices(_this.TEXTAREA.value);
	  }, 0));
	};
	AutocompleteEditor.prototype.close = function() {
	  HandsontableEditor.prototype.close.apply(this, arguments);
	};
	AutocompleteEditor.prototype.queryChoices = function(query) {
	  this.query = query;
	  var source = this.cellProperties.source;
	  var hasFilter = this.cellProperties.filter;
	  var filteringCaseSensitive = this.cellProperties.filteringCaseSensitive;
	  if (typeof source == 'function') {
	    var _this = this;
	    source.call(this.cellProperties, query, function(choices) {
	      _this.updateChoicesList(choices);
	    });
	  } else if (Array.isArray(source)) {
	    var choices;
	    if (!query || hasFilter === false) {
	      choices = source;
	    } else {
	      var lowerCaseQuery = query.toLowerCase();
	      choices = source.filter(function(choice) {
	        if (filteringCaseSensitive) {
	          return choice.indexOf(query) != -1;
	        } else {
	          return choice.toLowerCase().indexOf(lowerCaseQuery) != -1;
	        }
	      });
	    }
	    this.updateChoicesList(choices);
	  } else {
	    this.updateChoicesList([]);
	  }
	};
	AutocompleteEditor.prototype.updateChoicesList = function(choices) {
	  var pos = getCaretPosition(this.TEXTAREA);
	  var endPos = getSelectionEndPosition(this.TEXTAREA);
	  var sortByRelevanceSetting = this.cellProperties.sortByRelevance;
	  var filterSetting = this.cellProperties.filter;
	  var orderByRelevance = null;
	  var highlightIndex = null;
	  if (sortByRelevanceSetting) {
	    orderByRelevance = AutocompleteEditor.sortByRelevance(this.getValue(), choices, this.cellProperties.filteringCaseSensitive);
	  }
	  if (filterSetting === false) {
	    if (orderByRelevance) {
	      highlightIndex = orderByRelevance[0];
	    } else {
	      highlightIndex = 0;
	    }
	  } else {
	    var sorted = [];
	    for (var i = 0,
	        choicesCount = choices.length; i < choicesCount; i++) {
	      if (orderByRelevance) {
	        sorted.push(choices[orderByRelevance[i]]);
	      } else {
	        sorted.push(choices[i]);
	      }
	    }
	    highlightIndex = 0;
	    choices = sorted;
	  }
	  this.choices = choices;
	  this.htEditor.loadData(pivot([choices]));
	  this.updateDropdownHeight();
	  this.flipDropdownIfNeeded();
	  if (this.cellProperties.strict === true) {
	    this.highlightBestMatchingChoice(highlightIndex);
	  }
	  this.instance.listen();
	  this.TEXTAREA.focus();
	  setCaretPosition(this.TEXTAREA, pos, (pos === endPos ? void 0 : endPos));
	};
	AutocompleteEditor.prototype.flipDropdownIfNeeded = function() {
	  var textareaOffset = offset(this.TEXTAREA);
	  var textareaHeight = outerHeight(this.TEXTAREA);
	  var dropdownHeight = this.getDropdownHeight();
	  var trimmingContainer = getTrimmingContainer(this.instance.view.wt.wtTable.TABLE);
	  var containerOffset = {
	    row: 0,
	    col: 0
	  };
	  if (trimmingContainer !== window) {
	    containerOffset = offset(trimmingContainer);
	  }
	  var spaceBelow = containerOffset.top + (trimmingContainer.scrollHeight - trimmingContainer.scrollTop);
	  var spaceAbove = containerOffset.top + trimmingContainer.scrollHeight;
	  var flipNeeded = (textareaOffset.top + textareaHeight + dropdownHeight > spaceBelow);
	  if (flipNeeded && spaceAbove > spaceBelow) {
	    this.flipDropdown(dropdownHeight);
	  } else {
	    this.unflipDropdown();
	  }
	};
	AutocompleteEditor.prototype.flipDropdown = function(dropdownHeight) {
	  var dropdownStyle = this.htEditor.rootElement.style;
	  dropdownStyle.position = 'absolute';
	  dropdownStyle.top = -dropdownHeight + 'px';
	  this.htEditor.flipped = true;
	};
	AutocompleteEditor.prototype.unflipDropdown = function() {
	  var dropdownStyle = this.htEditor.rootElement.style;
	  if (dropdownStyle.position === 'absolute') {
	    dropdownStyle.position = '';
	    dropdownStyle.top = '';
	  }
	  this.htEditor.flipped = void 0;
	};
	AutocompleteEditor.prototype.updateDropdownHeight = function() {
	  var currentDropdownWidth = this.htEditor.getColWidth(0) + getScrollbarWidth() + 2;
	  var trimDropdown = this.cellProperties.trimDropdown;
	  this.htEditor.updateSettings({
	    height: this.getDropdownHeight(),
	    width: trimDropdown ? void 0 : currentDropdownWidth
	  });
	  this.htEditor.view.wt.wtTable.alignOverlaysWithTrimmingContainer();
	};
	AutocompleteEditor.prototype.finishEditing = function(restoreOriginalValue) {
	  if (!restoreOriginalValue) {
	    this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
	  }
	  HandsontableEditor.prototype.finishEditing.apply(this, arguments);
	};
	AutocompleteEditor.prototype.highlightBestMatchingChoice = function(index) {
	  if (typeof index === 'number') {
	    this.htEditor.selectCell(index, 0);
	  } else {
	    this.htEditor.deselectCell();
	  }
	};
	AutocompleteEditor.sortByRelevance = function(value, choices, caseSensitive) {
	  var choicesRelevance = [];
	  var currentItem;
	  var valueLength = value.length;
	  var valueIndex;
	  var charsLeft;
	  var result = [];
	  var i;
	  var choicesCount = choices.length;
	  if (valueLength === 0) {
	    for (i = 0; i < choicesCount; i++) {
	      result.push(i);
	    }
	    return result;
	  }
	  for (i = 0; i < choicesCount; i++) {
	    currentItem = stringify(choices[i]);
	    if (caseSensitive) {
	      valueIndex = currentItem.indexOf(value);
	    } else {
	      valueIndex = currentItem.toLowerCase().indexOf(value.toLowerCase());
	    }
	    if (valueIndex == -1) {
	      continue;
	    }
	    charsLeft = currentItem.length - valueIndex - valueLength;
	    choicesRelevance.push({
	      baseIndex: i,
	      index: valueIndex,
	      charsLeft: charsLeft,
	      value: currentItem
	    });
	  }
	  choicesRelevance.sort(function(a, b) {
	    if (b.index === -1) {
	      return -1;
	    }
	    if (a.index === -1) {
	      return 1;
	    }
	    if (a.index < b.index) {
	      return -1;
	    } else if (b.index < a.index) {
	      return 1;
	    } else if (a.index === b.index) {
	      if (a.charsLeft < b.charsLeft) {
	        return -1;
	      } else if (a.charsLeft > b.charsLeft) {
	        return 1;
	      } else {
	        return 0;
	      }
	    }
	  });
	  for (i = 0, choicesCount = choicesRelevance.length; i < choicesCount; i++) {
	    result.push(choicesRelevance[i].baseIndex);
	  }
	  return result;
	};
	AutocompleteEditor.prototype.getDropdownHeight = function() {
	  var firstRowHeight = this.htEditor.getInstance().getRowHeight(0) || 23;
	  var visibleRows = this.cellProperties.visibleRows;
	  return this.choices.length >= visibleRows ? visibleRows * firstRowHeight : this.choices.length * firstRowHeight + 8;
	};
	AutocompleteEditor.prototype.allowKeyEventPropagation = function(keyCode) {
	  var selected = {row: this.htEditor.getSelectedRange() ? this.htEditor.getSelectedRange().from.row : -1};
	  var allowed = false;
	  if (keyCode === KEY_CODES.ARROW_DOWN && selected.row > 0 && selected.row < this.htEditor.countRows() - 1) {
	    allowed = true;
	  }
	  if (keyCode === KEY_CODES.ARROW_UP && selected.row > -1) {
	    allowed = true;
	  }
	  return allowed;
	};
	;
	registerEditor('autocomplete', AutocompleteEditor);

	//# 
	},{"browser":23,"editors":29,"handsontableEditor":35,"helpers/array":42,"helpers/dom/element":46,"helpers/mixed":50,"helpers/unicode":55}],32:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  CheckboxEditor: {get: function() {
	      return CheckboxEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $___46__46__47_editors__,
	    $___95_baseEditor__,
	    $___46__46__47_helpers_47_dom_47_element__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var registerEditor = ($___46__46__47_editors__ = _dereq_("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}).registerEditor;
	var BaseEditor = ($___95_baseEditor__ = _dereq_("_baseEditor"), $___95_baseEditor__ && $___95_baseEditor__.__esModule && $___95_baseEditor__ || {default: $___95_baseEditor__}).BaseEditor;
	var hasClass = ($___46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}).hasClass;
	var CheckboxEditor = function CheckboxEditor() {
	  $traceurRuntime.superConstructor($CheckboxEditor).apply(this, arguments);
	};
	var $CheckboxEditor = CheckboxEditor;
	($traceurRuntime.createClass)(CheckboxEditor, {
	  beginEditing: function(initialValue, event) {
	    if (event === void 0) {
	      var checkbox = this.TD.querySelector('input[type="checkbox"]');
	      if (!hasClass(checkbox, 'htBadValue')) {
	        checkbox.click();
	      }
	    }
	  },
	  finishEditing: function() {},
	  init: function() {},
	  open: function() {},
	  close: function() {},
	  getValue: function() {},
	  setValue: function() {},
	  focus: function() {}
	}, {}, BaseEditor);
	;
	registerEditor('checkbox', CheckboxEditor);

	//# 
	},{"_baseEditor":30,"browser":23,"editors":29,"helpers/dom/element":46}],33:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  DateEditor: {get: function() {
	      return DateEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_helpers_47_object__,
	    $___46__46__47_eventManager__,
	    $___46__46__47_editors__,
	    $___46__46__47_helpers_47_unicode__,
	    $___46__46__47_helpers_47_dom_47_event__,
	    $__textEditor__,
	    $__moment__,
	    $__pikaday__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var $__1 = ($___46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__1.addClass,
	    outerHeight = $__1.outerHeight;
	var deepExtend = ($___46__46__47_helpers_47_object__ = _dereq_("helpers/object"), $___46__46__47_helpers_47_object__ && $___46__46__47_helpers_47_object__.__esModule && $___46__46__47_helpers_47_object__ || {default: $___46__46__47_helpers_47_object__}).deepExtend;
	var EventManager = ($___46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47_eventManager__ && $___46__46__47_eventManager__.__esModule && $___46__46__47_eventManager__ || {default: $___46__46__47_eventManager__}).EventManager;
	var $__4 = ($___46__46__47_editors__ = _dereq_("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}),
	    getEditor = $__4.getEditor,
	    registerEditor = $__4.registerEditor;
	var isMetaKey = ($___46__46__47_helpers_47_unicode__ = _dereq_("helpers/unicode"), $___46__46__47_helpers_47_unicode__ && $___46__46__47_helpers_47_unicode__.__esModule && $___46__46__47_helpers_47_unicode__ || {default: $___46__46__47_helpers_47_unicode__}).isMetaKey;
	var stopPropagation = ($___46__46__47_helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $___46__46__47_helpers_47_dom_47_event__ && $___46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47_helpers_47_dom_47_event__}).stopPropagation;
	var TextEditor = ($__textEditor__ = _dereq_("textEditor"), $__textEditor__ && $__textEditor__.__esModule && $__textEditor__ || {default: $__textEditor__}).TextEditor;
	var moment = ($__moment__ = _dereq_("moment"), $__moment__ && $__moment__.__esModule && $__moment__ || {default: $__moment__}).default;
	var Pikaday = ($__pikaday__ = _dereq_("pikaday"), $__pikaday__ && $__pikaday__.__esModule && $__pikaday__ || {default: $__pikaday__}).default;
	Handsontable.editors = Handsontable.editors || {};
	Handsontable.editors.DateEditor = DateEditor;
	var DateEditor = function DateEditor(hotInstance) {
	  this.$datePicker = null;
	  this.datePicker = null;
	  this.datePickerStyle = null;
	  this.defaultDateFormat = 'DD/MM/YYYY';
	  this.isCellEdited = false;
	  this.parentDestroyed = false;
	  $traceurRuntime.superConstructor($DateEditor).call(this, hotInstance);
	};
	var $DateEditor = DateEditor;
	($traceurRuntime.createClass)(DateEditor, {
	  init: function() {
	    var $__10 = this;
	    if (typeof moment !== 'function') {
	      throw new Error('You need to include moment.js to your project.');
	    }
	    if (typeof Pikaday !== 'function') {
	      throw new Error('You need to include Pikaday to your project.');
	    }
	    $traceurRuntime.superGet(this, $DateEditor.prototype, "init").call(this);
	    this.instance.addHook('afterDestroy', (function() {
	      $__10.parentDestroyed = true;
	      $__10.destroyElements();
	    }));
	  },
	  createElements: function() {
	    $traceurRuntime.superGet(this, $DateEditor.prototype, "createElements").call(this);
	    this.datePicker = document.createElement('DIV');
	    this.datePickerStyle = this.datePicker.style;
	    this.datePickerStyle.position = 'absolute';
	    this.datePickerStyle.top = 0;
	    this.datePickerStyle.left = 0;
	    this.datePickerStyle.zIndex = 9999;
	    addClass(this.datePicker, 'htDatepickerHolder');
	    document.body.appendChild(this.datePicker);
	    this.$datePicker = new Pikaday(this.getDatePickerConfig());
	    var eventManager = new EventManager(this);
	    eventManager.addEventListener(this.datePicker, 'mousedown', (function(event) {
	      return stopPropagation(event);
	    }));
	    this.hideDatepicker();
	  },
	  destroyElements: function() {
	    this.$datePicker.destroy();
	  },
	  prepare: function(row, col, prop, td, originalValue, cellProperties) {
	    this._opened = false;
	    $traceurRuntime.superGet(this, $DateEditor.prototype, "prepare").call(this, row, col, prop, td, originalValue, cellProperties);
	  },
	  open: function() {
	    var event = arguments[0] !== (void 0) ? arguments[0] : null;
	    $traceurRuntime.superGet(this, $DateEditor.prototype, "open").call(this);
	    this.showDatepicker(event);
	  },
	  close: function() {
	    var $__10 = this;
	    this._opened = false;
	    this.instance._registerTimeout(setTimeout((function() {
	      $__10.instance.selection.refreshBorders();
	    }), 0));
	    $traceurRuntime.superGet(this, $DateEditor.prototype, "close").call(this);
	  },
	  finishEditing: function() {
	    var isCancelled = arguments[0] !== (void 0) ? arguments[0] : false;
	    var ctrlDown = arguments[1] !== (void 0) ? arguments[1] : false;
	    if (isCancelled) {
	      var value = this.originalValue;
	      if (value !== void 0) {
	        this.setValue(value);
	      }
	    }
	    this.hideDatepicker();
	    $traceurRuntime.superGet(this, $DateEditor.prototype, "finishEditing").call(this, isCancelled, ctrlDown);
	  },
	  showDatepicker: function(event) {
	    this.$datePicker.config(this.getDatePickerConfig());
	    var offset = this.TD.getBoundingClientRect();
	    var dateFormat = this.cellProperties.dateFormat || this.defaultDateFormat;
	    var datePickerConfig = this.$datePicker.config();
	    var dateStr;
	    var isMouseDown = this.instance.view.isMouseDown();
	    var isMeta = event ? isMetaKey(event.keyCode) : false;
	    this.datePickerStyle.top = (window.pageYOffset + offset.top + outerHeight(this.TD)) + 'px';
	    this.datePickerStyle.left = (window.pageXOffset + offset.left) + 'px';
	    this.$datePicker._onInputFocus = function() {};
	    datePickerConfig.format = dateFormat;
	    if (this.originalValue) {
	      dateStr = this.originalValue;
	      if (moment(dateStr, dateFormat, true).isValid()) {
	        this.$datePicker.setMoment(moment(dateStr, dateFormat), true);
	      }
	      if (this.getValue() !== this.originalValue) {
	        this.setValue(this.originalValue);
	      }
	      if (!isMeta && !isMouseDown) {
	        this.setValue('');
	      }
	    } else {
	      if (this.cellProperties.defaultDate) {
	        dateStr = this.cellProperties.defaultDate;
	        datePickerConfig.defaultDate = dateStr;
	        if (moment(dateStr, dateFormat, true).isValid()) {
	          this.$datePicker.setMoment(moment(dateStr, dateFormat), true);
	        }
	        if (!isMeta && !isMouseDown) {
	          this.setValue('');
	        }
	      } else {
	        this.$datePicker.gotoToday();
	      }
	    }
	    this.datePickerStyle.display = 'block';
	    this.$datePicker.show();
	  },
	  hideDatepicker: function() {
	    this.datePickerStyle.display = 'none';
	    this.$datePicker.hide();
	  },
	  getDatePickerConfig: function() {
	    var $__10 = this;
	    var htInput = this.TEXTAREA;
	    var options = {};
	    if (this.cellProperties && this.cellProperties.datePickerConfig) {
	      deepExtend(options, this.cellProperties.datePickerConfig);
	    }
	    var origOnSelect = options.onSelect;
	    var origOnClose = options.onClose;
	    options.field = htInput;
	    options.trigger = htInput;
	    options.container = this.datePicker;
	    options.bound = false;
	    options.format = options.format || this.defaultDateFormat;
	    options.reposition = options.reposition || false;
	    options.onSelect = (function(dateStr) {
	      if (!isNaN(dateStr.getTime())) {
	        dateStr = moment(dateStr).format($__10.cellProperties.dateFormat || $__10.defaultDateFormat);
	      }
	      $__10.setValue(dateStr);
	      $__10.hideDatepicker();
	      if (origOnSelect) {
	        origOnSelect();
	      }
	    });
	    options.onClose = (function() {
	      if (!$__10.parentDestroyed) {
	        $__10.finishEditing(false);
	      }
	      if (origOnClose) {
	        origOnClose();
	      }
	    });
	    return options;
	  }
	}, {}, TextEditor);
	;
	registerEditor('date', DateEditor);

	//# 
	},{"browser":23,"editors":29,"eventManager":41,"helpers/dom/element":46,"helpers/dom/event":47,"helpers/object":52,"helpers/unicode":55,"moment":"moment","pikaday":"pikaday","textEditor":40}],34:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  DropdownEditor: {get: function() {
	      return DropdownEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $___46__46__47_editors__,
	    $__autocompleteEditor__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var $__1 = ($___46__46__47_editors__ = _dereq_("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}),
	    getEditor = $__1.getEditor,
	    registerEditor = $__1.registerEditor,
	    getEditorConstructor = $__1.getEditorConstructor;
	var AutocompleteEditor = ($__autocompleteEditor__ = _dereq_("autocompleteEditor"), $__autocompleteEditor__ && $__autocompleteEditor__.__esModule && $__autocompleteEditor__ || {default: $__autocompleteEditor__}).AutocompleteEditor;
	var DropdownEditor = function DropdownEditor() {
	  $traceurRuntime.superConstructor($DropdownEditor).apply(this, arguments);
	};
	var $DropdownEditor = DropdownEditor;
	($traceurRuntime.createClass)(DropdownEditor, {prepare: function(row, col, prop, td, originalValue, cellProperties) {
	    $traceurRuntime.superGet(this, $DropdownEditor.prototype, "prepare").call(this, row, col, prop, td, originalValue, cellProperties);
	    this.cellProperties.filter = false;
	    this.cellProperties.strict = true;
	  }}, {}, AutocompleteEditor);
	Handsontable.hooks.add('beforeValidate', function(value, row, col, source) {
	  var cellMeta = this.getCellMeta(row, this.propToCol(col));
	  if (cellMeta.editor === Handsontable.editors.DropdownEditor) {
	    if (cellMeta.strict === void 0) {
	      cellMeta.filter = false;
	      cellMeta.strict = true;
	    }
	  }
	});
	;
	registerEditor('dropdown', DropdownEditor);

	//# 
	},{"autocompleteEditor":31,"browser":23,"editors":29}],35:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  HandsontableEditor: {get: function() {
	      return HandsontableEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $___46__46__47_helpers_47_unicode__,
	    $___46__46__47_helpers_47_object__,
	    $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47_editors__,
	    $__textEditor__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var KEY_CODES = ($___46__46__47_helpers_47_unicode__ = _dereq_("helpers/unicode"), $___46__46__47_helpers_47_unicode__ && $___46__46__47_helpers_47_unicode__.__esModule && $___46__46__47_helpers_47_unicode__ || {default: $___46__46__47_helpers_47_unicode__}).KEY_CODES;
	var extend = ($___46__46__47_helpers_47_object__ = _dereq_("helpers/object"), $___46__46__47_helpers_47_object__ && $___46__46__47_helpers_47_object__.__esModule && $___46__46__47_helpers_47_object__ || {default: $___46__46__47_helpers_47_object__}).extend;
	var setCaretPosition = ($___46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}).setCaretPosition;
	var $__4 = ($___46__46__47_helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $___46__46__47_helpers_47_dom_47_event__ && $___46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47_helpers_47_dom_47_event__}),
	    stopImmediatePropagation = $__4.stopImmediatePropagation,
	    isImmediatePropagationStopped = $__4.isImmediatePropagationStopped;
	var $__5 = ($___46__46__47_editors__ = _dereq_("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}),
	    getEditor = $__5.getEditor,
	    registerEditor = $__5.registerEditor;
	var TextEditor = ($__textEditor__ = _dereq_("textEditor"), $__textEditor__ && $__textEditor__.__esModule && $__textEditor__ || {default: $__textEditor__}).TextEditor;
	var HandsontableEditor = TextEditor.prototype.extend();
	HandsontableEditor.prototype.createElements = function() {
	  TextEditor.prototype.createElements.apply(this, arguments);
	  var DIV = document.createElement('DIV');
	  DIV.className = 'handsontableEditor';
	  this.TEXTAREA_PARENT.appendChild(DIV);
	  this.htContainer = DIV;
	  this.assignHooks();
	};
	HandsontableEditor.prototype.prepare = function(td, row, col, prop, value, cellProperties) {
	  TextEditor.prototype.prepare.apply(this, arguments);
	  var parent = this;
	  var options = {
	    startRows: 0,
	    startCols: 0,
	    minRows: 0,
	    minCols: 0,
	    className: 'listbox',
	    copyPaste: false,
	    autoColumnSize: false,
	    autoRowSize: false,
	    readOnly: true,
	    fillHandle: false,
	    afterOnCellMouseDown: function() {
	      var value = this.getValue();
	      if (value !== void 0) {
	        parent.setValue(value);
	      }
	      parent.instance.destroyEditor();
	    }
	  };
	  if (this.cellProperties.handsontable) {
	    extend(options, cellProperties.handsontable);
	  }
	  this.htOptions = options;
	};
	var onBeforeKeyDown = function(event) {
	  if (isImmediatePropagationStopped(event)) {
	    return;
	  }
	  var editor = this.getActiveEditor();
	  var innerHOT = editor.htEditor.getInstance();
	  var rowToSelect;
	  if (event.keyCode == KEY_CODES.ARROW_DOWN) {
	    if (!innerHOT.getSelected() && !innerHOT.flipped) {
	      rowToSelect = 0;
	    } else if (innerHOT.getSelected()) {
	      if (innerHOT.flipped) {
	        rowToSelect = innerHOT.getSelected()[0] + 1;
	      } else if (!innerHOT.flipped) {
	        var selectedRow = innerHOT.getSelected()[0];
	        var lastRow = innerHOT.countRows() - 1;
	        rowToSelect = Math.min(lastRow, selectedRow + 1);
	      }
	    }
	  } else if (event.keyCode == KEY_CODES.ARROW_UP) {
	    if (!innerHOT.getSelected() && innerHOT.flipped) {
	      rowToSelect = innerHOT.countRows() - 1;
	    } else if (innerHOT.getSelected()) {
	      if (innerHOT.flipped) {
	        var selectedRow = innerHOT.getSelected()[0];
	        rowToSelect = Math.max(0, selectedRow - 1);
	      } else {
	        var selectedRow = innerHOT.getSelected()[0];
	        rowToSelect = selectedRow - 1;
	      }
	    }
	  }
	  if (rowToSelect !== void 0) {
	    if (rowToSelect < 0 || (innerHOT.flipped && rowToSelect > innerHOT.countRows() - 1)) {
	      innerHOT.deselectCell();
	    } else {
	      innerHOT.selectCell(rowToSelect, 0);
	    }
	    if (innerHOT.getData().length) {
	      event.preventDefault();
	      stopImmediatePropagation(event);
	      editor.instance.listen();
	      editor.TEXTAREA.focus();
	    }
	  }
	};
	HandsontableEditor.prototype.open = function() {
	  this.instance.addHook('beforeKeyDown', onBeforeKeyDown);
	  TextEditor.prototype.open.apply(this, arguments);
	  if (this.htEditor) {
	    this.htEditor.destroy();
	  }
	  this.htEditor = new Handsontable(this.htContainer, this.htOptions);
	  if (this.cellProperties.strict) {
	    this.htEditor.selectCell(0, 0);
	    this.TEXTAREA.style.visibility = 'hidden';
	  } else {
	    this.htEditor.deselectCell();
	    this.TEXTAREA.style.visibility = 'visible';
	  }
	  setCaretPosition(this.TEXTAREA, 0, this.TEXTAREA.value.length);
	};
	HandsontableEditor.prototype.close = function() {
	  this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
	  this.instance.listen();
	  TextEditor.prototype.close.apply(this, arguments);
	};
	HandsontableEditor.prototype.focus = function() {
	  this.instance.listen();
	  TextEditor.prototype.focus.apply(this, arguments);
	};
	HandsontableEditor.prototype.beginEditing = function(initialValue) {
	  var onBeginEditing = this.instance.getSettings().onBeginEditing;
	  if (onBeginEditing && onBeginEditing() === false) {
	    return;
	  }
	  TextEditor.prototype.beginEditing.apply(this, arguments);
	};
	HandsontableEditor.prototype.finishEditing = function(isCancelled, ctrlDown) {
	  if (this.htEditor && this.htEditor.isListening()) {
	    this.instance.listen();
	  }
	  if (this.htEditor && this.htEditor.getSelected()) {
	    var value = this.htEditor.getInstance().getValue();
	    if (value !== void 0) {
	      this.setValue(value);
	    }
	  }
	  return TextEditor.prototype.finishEditing.apply(this, arguments);
	};
	HandsontableEditor.prototype.assignHooks = function() {
	  var _this = this;
	  this.instance.addHook('afterDestroy', function() {
	    if (_this.htEditor) {
	      _this.htEditor.destroy();
	    }
	  });
	};
	;
	registerEditor('handsontable', HandsontableEditor);

	//# 
	},{"browser":23,"editors":29,"helpers/dom/element":46,"helpers/dom/event":47,"helpers/object":52,"helpers/unicode":55,"textEditor":40}],36:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  MobileTextEditor: {get: function() {
	      return MobileTextEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $___46__46__47_helpers_47_unicode__,
	    $___46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_editors__,
	    $___95_baseEditor__,
	    $___46__46__47_eventManager__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var KEY_CODES = ($___46__46__47_helpers_47_unicode__ = _dereq_("helpers/unicode"), $___46__46__47_helpers_47_unicode__ && $___46__46__47_helpers_47_unicode__.__esModule && $___46__46__47_helpers_47_unicode__ || {default: $___46__46__47_helpers_47_unicode__}).KEY_CODES;
	var $__2 = ($___46__46__47_helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $___46__46__47_helpers_47_dom_47_event__ && $___46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47_helpers_47_dom_47_event__}),
	    stopImmediatePropagation = $__2.stopImmediatePropagation,
	    isImmediatePropagationStopped = $__2.isImmediatePropagationStopped;
	var $__3 = ($___46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__3.addClass,
	    getScrollLeft = $__3.getScrollLeft,
	    getScrollTop = $__3.getScrollTop,
	    hasClass = $__3.hasClass,
	    isChildOf = $__3.isChildOf,
	    offset = $__3.offset,
	    outerHeight = $__3.outerHeight,
	    outerWidth = $__3.outerWidth,
	    removeClass = $__3.removeClass,
	    setCaretPosition = $__3.setCaretPosition;
	var $__4 = ($___46__46__47_editors__ = _dereq_("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}),
	    getEditor = $__4.getEditor,
	    registerEditor = $__4.registerEditor;
	var BaseEditor = ($___95_baseEditor__ = _dereq_("_baseEditor"), $___95_baseEditor__ && $___95_baseEditor__.__esModule && $___95_baseEditor__ || {default: $___95_baseEditor__}).BaseEditor;
	var eventManagerObject = ($___46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47_eventManager__ && $___46__46__47_eventManager__.__esModule && $___46__46__47_eventManager__ || {default: $___46__46__47_eventManager__}).eventManager;
	var MobileTextEditor = BaseEditor.prototype.extend(),
	    domDimensionsCache = {};
	var createControls = function() {
	  this.controls = {};
	  this.controls.leftButton = document.createElement('DIV');
	  this.controls.leftButton.className = 'leftButton';
	  this.controls.rightButton = document.createElement('DIV');
	  this.controls.rightButton.className = 'rightButton';
	  this.controls.upButton = document.createElement('DIV');
	  this.controls.upButton.className = 'upButton';
	  this.controls.downButton = document.createElement('DIV');
	  this.controls.downButton.className = 'downButton';
	  for (var button in this.controls) {
	    if (this.controls.hasOwnProperty(button)) {
	      this.positionControls.appendChild(this.controls[button]);
	    }
	  }
	};
	MobileTextEditor.prototype.valueChanged = function() {
	  return this.initValue != this.getValue();
	};
	MobileTextEditor.prototype.init = function() {
	  var that = this;
	  this.eventManager = eventManagerObject(this.instance);
	  this.createElements();
	  this.bindEvents();
	  this.instance.addHook('afterDestroy', function() {
	    that.destroy();
	  });
	};
	MobileTextEditor.prototype.getValue = function() {
	  return this.TEXTAREA.value;
	};
	MobileTextEditor.prototype.setValue = function(newValue) {
	  this.initValue = newValue;
	  this.TEXTAREA.value = newValue;
	};
	MobileTextEditor.prototype.createElements = function() {
	  this.editorContainer = document.createElement('DIV');
	  this.editorContainer.className = 'htMobileEditorContainer';
	  this.cellPointer = document.createElement('DIV');
	  this.cellPointer.className = 'cellPointer';
	  this.moveHandle = document.createElement('DIV');
	  this.moveHandle.className = 'moveHandle';
	  this.inputPane = document.createElement('DIV');
	  this.inputPane.className = 'inputs';
	  this.positionControls = document.createElement('DIV');
	  this.positionControls.className = 'positionControls';
	  this.TEXTAREA = document.createElement('TEXTAREA');
	  addClass(this.TEXTAREA, 'handsontableInput');
	  this.inputPane.appendChild(this.TEXTAREA);
	  this.editorContainer.appendChild(this.cellPointer);
	  this.editorContainer.appendChild(this.moveHandle);
	  this.editorContainer.appendChild(this.inputPane);
	  this.editorContainer.appendChild(this.positionControls);
	  createControls.call(this);
	  document.body.appendChild(this.editorContainer);
	};
	MobileTextEditor.prototype.onBeforeKeyDown = function(event) {
	  var instance = this;
	  var that = instance.getActiveEditor();
	  if (event.target !== that.TEXTAREA || isImmediatePropagationStopped(event)) {
	    return;
	  }
	  switch (event.keyCode) {
	    case KEY_CODES.ENTER:
	      that.close();
	      event.preventDefault();
	      break;
	    case KEY_CODES.BACKSPACE:
	      stopImmediatePropagation(event);
	      break;
	  }
	};
	MobileTextEditor.prototype.open = function() {
	  this.instance.addHook('beforeKeyDown', this.onBeforeKeyDown);
	  addClass(this.editorContainer, 'active');
	  removeClass(this.cellPointer, 'hidden');
	  this.updateEditorPosition();
	};
	MobileTextEditor.prototype.focus = function() {
	  this.TEXTAREA.focus();
	  setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);
	};
	MobileTextEditor.prototype.close = function() {
	  this.TEXTAREA.blur();
	  this.instance.removeHook('beforeKeyDown', this.onBeforeKeyDown);
	  removeClass(this.editorContainer, 'active');
	};
	MobileTextEditor.prototype.scrollToView = function() {
	  var coords = this.instance.getSelectedRange().highlight;
	  this.instance.view.scrollViewport(coords);
	};
	MobileTextEditor.prototype.hideCellPointer = function() {
	  if (!hasClass(this.cellPointer, 'hidden')) {
	    addClass(this.cellPointer, 'hidden');
	  }
	};
	MobileTextEditor.prototype.updateEditorPosition = function(x, y) {
	  if (x && y) {
	    x = parseInt(x, 10);
	    y = parseInt(y, 10);
	    this.editorContainer.style.top = y + 'px';
	    this.editorContainer.style.left = x + 'px';
	  } else {
	    var selection = this.instance.getSelected(),
	        selectedCell = this.instance.getCell(selection[0], selection[1]);
	    if (!domDimensionsCache.cellPointer) {
	      domDimensionsCache.cellPointer = {
	        height: outerHeight(this.cellPointer),
	        width: outerWidth(this.cellPointer)
	      };
	    }
	    if (!domDimensionsCache.editorContainer) {
	      domDimensionsCache.editorContainer = {width: outerWidth(this.editorContainer)};
	    }
	    if (selectedCell !== undefined) {
	      var scrollLeft = this.instance.view.wt.wtOverlays.leftOverlay.trimmingContainer == window ? 0 : getScrollLeft(this.instance.view.wt.wtOverlays.leftOverlay.holder);
	      var scrollTop = this.instance.view.wt.wtOverlays.topOverlay.trimmingContainer == window ? 0 : getScrollTop(this.instance.view.wt.wtOverlays.topOverlay.holder);
	      var selectedCellOffset = offset(selectedCell),
	          selectedCellWidth = outerWidth(selectedCell),
	          currentScrollPosition = {
	            x: scrollLeft,
	            y: scrollTop
	          };
	      this.editorContainer.style.top = parseInt(selectedCellOffset.top + outerHeight(selectedCell) - currentScrollPosition.y + domDimensionsCache.cellPointer.height, 10) + 'px';
	      this.editorContainer.style.left = parseInt((window.innerWidth / 2) - (domDimensionsCache.editorContainer.width / 2), 10) + 'px';
	      if (selectedCellOffset.left + selectedCellWidth / 2 > parseInt(this.editorContainer.style.left, 10) + domDimensionsCache.editorContainer.width) {
	        this.editorContainer.style.left = window.innerWidth - domDimensionsCache.editorContainer.width + 'px';
	      } else if (selectedCellOffset.left + selectedCellWidth / 2 < parseInt(this.editorContainer.style.left, 10) + 20) {
	        this.editorContainer.style.left = 0 + 'px';
	      }
	      this.cellPointer.style.left = parseInt(selectedCellOffset.left - (domDimensionsCache.cellPointer.width / 2) - offset(this.editorContainer).left + (selectedCellWidth / 2) - currentScrollPosition.x, 10) + 'px';
	    }
	  }
	};
	MobileTextEditor.prototype.updateEditorData = function() {
	  var selected = this.instance.getSelected(),
	      selectedValue = this.instance.getDataAtCell(selected[0], selected[1]);
	  this.row = selected[0];
	  this.col = selected[1];
	  this.setValue(selectedValue);
	  this.updateEditorPosition();
	};
	MobileTextEditor.prototype.prepareAndSave = function() {
	  var val;
	  if (!this.valueChanged()) {
	    return true;
	  }
	  if (this.instance.getSettings().trimWhitespace) {
	    val = [[String.prototype.trim.call(this.getValue())]];
	  } else {
	    val = [[this.getValue()]];
	  }
	  this.saveValue(val);
	};
	MobileTextEditor.prototype.bindEvents = function() {
	  var that = this;
	  this.eventManager.addEventListener(this.controls.leftButton, 'touchend', function(event) {
	    that.prepareAndSave();
	    that.instance.selection.transformStart(0, -1, null, true);
	    that.updateEditorData();
	    event.preventDefault();
	  });
	  this.eventManager.addEventListener(this.controls.rightButton, 'touchend', function(event) {
	    that.prepareAndSave();
	    that.instance.selection.transformStart(0, 1, null, true);
	    that.updateEditorData();
	    event.preventDefault();
	  });
	  this.eventManager.addEventListener(this.controls.upButton, 'touchend', function(event) {
	    that.prepareAndSave();
	    that.instance.selection.transformStart(-1, 0, null, true);
	    that.updateEditorData();
	    event.preventDefault();
	  });
	  this.eventManager.addEventListener(this.controls.downButton, 'touchend', function(event) {
	    that.prepareAndSave();
	    that.instance.selection.transformStart(1, 0, null, true);
	    that.updateEditorData();
	    event.preventDefault();
	  });
	  this.eventManager.addEventListener(this.moveHandle, 'touchstart', function(event) {
	    if (event.touches.length == 1) {
	      var touch = event.touches[0],
	          onTouchPosition = {
	            x: that.editorContainer.offsetLeft,
	            y: that.editorContainer.offsetTop
	          },
	          onTouchOffset = {
	            x: touch.pageX - onTouchPosition.x,
	            y: touch.pageY - onTouchPosition.y
	          };
	      that.eventManager.addEventListener(this, 'touchmove', function(event) {
	        var touch = event.touches[0];
	        that.updateEditorPosition(touch.pageX - onTouchOffset.x, touch.pageY - onTouchOffset.y);
	        that.hideCellPointer();
	        event.preventDefault();
	      });
	    }
	  });
	  this.eventManager.addEventListener(document.body, 'touchend', function(event) {
	    if (!isChildOf(event.target, that.editorContainer) && !isChildOf(event.target, that.instance.rootElement)) {
	      that.close();
	    }
	  });
	  this.eventManager.addEventListener(this.instance.view.wt.wtOverlays.leftOverlay.holder, 'scroll', function(event) {
	    if (that.instance.view.wt.wtOverlays.leftOverlay.trimmingContainer != window) {
	      that.hideCellPointer();
	    }
	  });
	  this.eventManager.addEventListener(this.instance.view.wt.wtOverlays.topOverlay.holder, 'scroll', function(event) {
	    if (that.instance.view.wt.wtOverlays.topOverlay.trimmingContainer != window) {
	      that.hideCellPointer();
	    }
	  });
	};
	MobileTextEditor.prototype.destroy = function() {
	  this.eventManager.clear();
	  this.editorContainer.parentNode.removeChild(this.editorContainer);
	};
	;
	registerEditor('mobile', MobileTextEditor);

	//# 
	},{"_baseEditor":30,"browser":23,"editors":29,"eventManager":41,"helpers/dom/element":46,"helpers/dom/event":47,"helpers/unicode":55}],37:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  NumericEditor: {get: function() {
	      return NumericEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $__numeral__,
	    $___46__46__47_editors__,
	    $__textEditor__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var numeral = ($__numeral__ = _dereq_("numeral"), $__numeral__ && $__numeral__.__esModule && $__numeral__ || {default: $__numeral__}).default;
	var $__2 = ($___46__46__47_editors__ = _dereq_("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}),
	    getEditor = $__2.getEditor,
	    registerEditor = $__2.registerEditor;
	var TextEditor = ($__textEditor__ = _dereq_("textEditor"), $__textEditor__ && $__textEditor__.__esModule && $__textEditor__ || {default: $__textEditor__}).TextEditor;
	var NumericEditor = function NumericEditor() {
	  $traceurRuntime.superConstructor($NumericEditor).apply(this, arguments);
	};
	var $NumericEditor = NumericEditor;
	($traceurRuntime.createClass)(NumericEditor, {beginEditing: function(initialValue) {
	    if (typeof initialValue === 'undefined' && this.originalValue) {
	      if (typeof this.cellProperties.language !== 'undefined') {
	        numeral.language(this.cellProperties.language);
	      }
	      var decimalDelimiter = numeral.languageData().delimiters.decimal;
	      initialValue = ('' + this.originalValue).replace('.', decimalDelimiter);
	    }
	    $traceurRuntime.superGet(this, $NumericEditor.prototype, "beginEditing").call(this, initialValue);
	  }}, {}, TextEditor);
	;
	registerEditor('numeric', NumericEditor);

	//# 
	},{"browser":23,"editors":29,"numeral":"numeral","textEditor":40}],38:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  PasswordEditor: {get: function() {
	      return PasswordEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_editors__,
	    $__textEditor__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var empty = ($___46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}).empty;
	var $__2 = ($___46__46__47_editors__ = _dereq_("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}),
	    getEditor = $__2.getEditor,
	    registerEditor = $__2.registerEditor;
	var TextEditor = ($__textEditor__ = _dereq_("textEditor"), $__textEditor__ && $__textEditor__.__esModule && $__textEditor__ || {default: $__textEditor__}).TextEditor;
	var PasswordEditor = function PasswordEditor() {
	  $traceurRuntime.superConstructor($PasswordEditor).apply(this, arguments);
	};
	var $PasswordEditor = PasswordEditor;
	($traceurRuntime.createClass)(PasswordEditor, {createElements: function() {
	    $traceurRuntime.superGet(this, $PasswordEditor.prototype, "createElements").call(this);
	    this.TEXTAREA = document.createElement('input');
	    this.TEXTAREA.setAttribute('type', 'password');
	    this.TEXTAREA.className = 'handsontableInput';
	    this.textareaStyle = this.TEXTAREA.style;
	    this.textareaStyle.width = 0;
	    this.textareaStyle.height = 0;
	    empty(this.TEXTAREA_PARENT);
	    this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
	  }}, {}, TextEditor);
	;
	registerEditor('password', PasswordEditor);

	//# 
	},{"browser":23,"editors":29,"helpers/dom/element":46,"textEditor":40}],39:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  SelectEditor: {get: function() {
	      return SelectEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47_helpers_47_unicode__,
	    $___46__46__47_editors__,
	    $___95_baseEditor__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var $__1 = ($___46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__1.addClass,
	    empty = $__1.empty,
	    fastInnerHTML = $__1.fastInnerHTML,
	    getComputedStyle = $__1.getComputedStyle,
	    getCssTransform = $__1.getCssTransform,
	    getScrollableElement = $__1.getScrollableElement,
	    offset = $__1.offset,
	    outerHeight = $__1.outerHeight,
	    outerWidth = $__1.outerWidth,
	    resetCssTransform = $__1.resetCssTransform;
	var stopImmediatePropagation = ($___46__46__47_helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $___46__46__47_helpers_47_dom_47_event__ && $___46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47_helpers_47_dom_47_event__}).stopImmediatePropagation;
	var KEY_CODES = ($___46__46__47_helpers_47_unicode__ = _dereq_("helpers/unicode"), $___46__46__47_helpers_47_unicode__ && $___46__46__47_helpers_47_unicode__.__esModule && $___46__46__47_helpers_47_unicode__ || {default: $___46__46__47_helpers_47_unicode__}).KEY_CODES;
	var $__4 = ($___46__46__47_editors__ = _dereq_("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}),
	    getEditor = $__4.getEditor,
	    registerEditor = $__4.registerEditor;
	var BaseEditor = ($___95_baseEditor__ = _dereq_("_baseEditor"), $___95_baseEditor__ && $___95_baseEditor__.__esModule && $___95_baseEditor__ || {default: $___95_baseEditor__}).BaseEditor;
	var SelectEditor = BaseEditor.prototype.extend();
	SelectEditor.prototype.init = function() {
	  this.select = document.createElement('SELECT');
	  addClass(this.select, 'htSelectEditor');
	  this.select.style.display = 'none';
	  this.instance.rootElement.appendChild(this.select);
	  this.registerHooks();
	};
	SelectEditor.prototype.registerHooks = function() {
	  var $__6 = this;
	  this.instance.addHook('afterScrollHorizontally', (function() {
	    return $__6.refreshDimensions();
	  }));
	  this.instance.addHook('afterScrollVertically', (function() {
	    return $__6.refreshDimensions();
	  }));
	  this.instance.addHook('afterColumnResize', (function() {
	    return $__6.refreshDimensions();
	  }));
	  this.instance.addHook('afterRowResize', (function() {
	    return $__6.refreshDimensions();
	  }));
	};
	SelectEditor.prototype.prepare = function() {
	  BaseEditor.prototype.prepare.apply(this, arguments);
	  var selectOptions = this.cellProperties.selectOptions;
	  var options;
	  if (typeof selectOptions == 'function') {
	    options = this.prepareOptions(selectOptions(this.row, this.col, this.prop));
	  } else {
	    options = this.prepareOptions(selectOptions);
	  }
	  empty(this.select);
	  for (var option in options) {
	    if (options.hasOwnProperty(option)) {
	      var optionElement = document.createElement('OPTION');
	      optionElement.value = option;
	      fastInnerHTML(optionElement, options[option]);
	      this.select.appendChild(optionElement);
	    }
	  }
	};
	SelectEditor.prototype.prepareOptions = function(optionsToPrepare) {
	  var preparedOptions = {};
	  if (Array.isArray(optionsToPrepare)) {
	    for (var i = 0,
	        len = optionsToPrepare.length; i < len; i++) {
	      preparedOptions[optionsToPrepare[i]] = optionsToPrepare[i];
	    }
	  } else if (typeof optionsToPrepare == 'object') {
	    preparedOptions = optionsToPrepare;
	  }
	  return preparedOptions;
	};
	SelectEditor.prototype.getValue = function() {
	  return this.select.value;
	};
	SelectEditor.prototype.setValue = function(value) {
	  this.select.value = value;
	};
	var onBeforeKeyDown = function(event) {
	  var instance = this;
	  var editor = instance.getActiveEditor();
	  switch (event.keyCode) {
	    case KEY_CODES.ARROW_UP:
	      var previousOptionIndex = editor.select.selectedIndex - 1;
	      if (previousOptionIndex >= 0) {
	        editor.select[previousOptionIndex].selected = true;
	      }
	      stopImmediatePropagation(event);
	      event.preventDefault();
	      break;
	    case KEY_CODES.ARROW_DOWN:
	      var nextOptionIndex = editor.select.selectedIndex + 1;
	      if (nextOptionIndex <= editor.select.length - 1) {
	        editor.select[nextOptionIndex].selected = true;
	      }
	      stopImmediatePropagation(event);
	      event.preventDefault();
	      break;
	  }
	};
	SelectEditor.prototype.open = function() {
	  this._opened = true;
	  this.refreshDimensions();
	  this.select.style.display = '';
	  this.instance.addHook('beforeKeyDown', onBeforeKeyDown);
	};
	SelectEditor.prototype.close = function() {
	  this._opened = false;
	  this.select.style.display = 'none';
	  this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
	};
	SelectEditor.prototype.focus = function() {
	  this.select.focus();
	};
	SelectEditor.prototype.refreshDimensions = function() {
	  if (this.state !== Handsontable.EditorState.EDITING) {
	    return;
	  }
	  this.TD = this.getEditedCell();
	  if (!this.TD) {
	    this.close();
	    return;
	  }
	  var width = outerWidth(this.TD) + 1,
	      height = outerHeight(this.TD) + 1,
	      currentOffset = offset(this.TD),
	      containerOffset = offset(this.instance.rootElement),
	      scrollableContainer = getScrollableElement(this.TD),
	      editTop = currentOffset.top - containerOffset.top - 1 - (scrollableContainer.scrollTop || 0),
	      editLeft = currentOffset.left - containerOffset.left - 1 - (scrollableContainer.scrollLeft || 0),
	      editorSection = this.checkEditorSection(),
	      cssTransformOffset;
	  var settings = this.instance.getSettings();
	  var rowHeadersCount = settings.rowHeaders ? 1 : 0;
	  var colHeadersCount = settings.colHeaders ? 1 : 0;
	  switch (editorSection) {
	    case 'top':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.holder.parentNode);
	      break;
	    case 'left':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.holder.parentNode);
	      break;
	    case 'top-left-corner':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.holder.parentNode);
	      break;
	    case 'bottom-left-corner':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.holder.parentNode);
	      break;
	    case 'bottom':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.bottomOverlay.clone.wtTable.holder.parentNode);
	      break;
	  }
	  if (this.instance.getSelected()[0] === 0) {
	    editTop += 1;
	  }
	  if (this.instance.getSelected()[1] === 0) {
	    editLeft += 1;
	  }
	  var selectStyle = this.select.style;
	  if (cssTransformOffset && cssTransformOffset != -1) {
	    selectStyle[cssTransformOffset[0]] = cssTransformOffset[1];
	  } else {
	    resetCssTransform(this.select);
	  }
	  var cellComputedStyle = getComputedStyle(this.TD);
	  if (parseInt(cellComputedStyle.borderTopWidth, 10) > 0) {
	    height -= 1;
	  }
	  if (parseInt(cellComputedStyle.borderLeftWidth, 10) > 0) {
	    width -= 1;
	  }
	  selectStyle.height = height + 'px';
	  selectStyle.minWidth = width + 'px';
	  selectStyle.top = editTop + 'px';
	  selectStyle.left = editLeft + 'px';
	  selectStyle.margin = '0px';
	};
	SelectEditor.prototype.getEditedCell = function() {
	  var editorSection = this.checkEditorSection(),
	      editedCell;
	  switch (editorSection) {
	    case 'top':
	      editedCell = this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.getCell({
	        row: this.row,
	        col: this.col
	      });
	      this.select.style.zIndex = 101;
	      break;
	    case 'corner':
	      editedCell = this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell({
	        row: this.row,
	        col: this.col
	      });
	      this.select.style.zIndex = 103;
	      break;
	    case 'left':
	      editedCell = this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.getCell({
	        row: this.row,
	        col: this.col
	      });
	      this.select.style.zIndex = 102;
	      break;
	    default:
	      editedCell = this.instance.getCell(this.row, this.col);
	      this.select.style.zIndex = '';
	      break;
	  }
	  return editedCell != -1 && editedCell != -2 ? editedCell : void 0;
	};
	;
	registerEditor('select', SelectEditor);

	//# 
	},{"_baseEditor":30,"browser":23,"editors":29,"helpers/dom/element":46,"helpers/dom/event":47,"helpers/unicode":55}],40:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  TextEditor: {get: function() {
	      return TextEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $___46__46__47_helpers_47_dom_47_element__,
	    $__autoResize__,
	    $___95_baseEditor__,
	    $___46__46__47_eventManager__,
	    $___46__46__47_editors__,
	    $___46__46__47_helpers_47_unicode__,
	    $___46__46__47_helpers_47_dom_47_event__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var $__1 = ($___46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__1.addClass,
	    getCaretPosition = $__1.getCaretPosition,
	    getComputedStyle = $__1.getComputedStyle,
	    getCssTransform = $__1.getCssTransform,
	    getScrollableElement = $__1.getScrollableElement,
	    getScrollbarWidth = $__1.getScrollbarWidth,
	    innerWidth = $__1.innerWidth,
	    offset = $__1.offset,
	    resetCssTransform = $__1.resetCssTransform,
	    setCaretPosition = $__1.setCaretPosition,
	    hasVerticalScrollbar = $__1.hasVerticalScrollbar,
	    hasHorizontalScrollbar = $__1.hasHorizontalScrollbar;
	var autoResize = ($__autoResize__ = _dereq_("autoResize"), $__autoResize__ && $__autoResize__.__esModule && $__autoResize__ || {default: $__autoResize__}).default;
	var BaseEditor = ($___95_baseEditor__ = _dereq_("_baseEditor"), $___95_baseEditor__ && $___95_baseEditor__.__esModule && $___95_baseEditor__ || {default: $___95_baseEditor__}).BaseEditor;
	var eventManagerObject = ($___46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47_eventManager__ && $___46__46__47_eventManager__.__esModule && $___46__46__47_eventManager__ || {default: $___46__46__47_eventManager__}).eventManager;
	var $__5 = ($___46__46__47_editors__ = _dereq_("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}),
	    getEditor = $__5.getEditor,
	    registerEditor = $__5.registerEditor;
	var KEY_CODES = ($___46__46__47_helpers_47_unicode__ = _dereq_("helpers/unicode"), $___46__46__47_helpers_47_unicode__ && $___46__46__47_helpers_47_unicode__.__esModule && $___46__46__47_helpers_47_unicode__ || {default: $___46__46__47_helpers_47_unicode__}).KEY_CODES;
	var $__7 = ($___46__46__47_helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $___46__46__47_helpers_47_dom_47_event__ && $___46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47_helpers_47_dom_47_event__}),
	    stopPropagation = $__7.stopPropagation,
	    stopImmediatePropagation = $__7.stopImmediatePropagation,
	    isImmediatePropagationStopped = $__7.isImmediatePropagationStopped;
	var TextEditor = BaseEditor.prototype.extend();
	TextEditor.prototype.init = function() {
	  var that = this;
	  this.createElements();
	  this.eventManager = eventManagerObject(this);
	  this.bindEvents();
	  this.autoResize = autoResize();
	  this.instance.addHook('afterDestroy', function() {
	    that.destroy();
	  });
	};
	TextEditor.prototype.getValue = function() {
	  return this.TEXTAREA.value;
	};
	TextEditor.prototype.setValue = function(newValue) {
	  this.TEXTAREA.value = newValue;
	};
	var onBeforeKeyDown = function onBeforeKeyDown(event) {
	  var instance = this,
	      that = instance.getActiveEditor(),
	      ctrlDown;
	  ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;
	  if (event.target !== that.TEXTAREA || isImmediatePropagationStopped(event)) {
	    return;
	  }
	  if (event.keyCode === 17 || event.keyCode === 224 || event.keyCode === 91 || event.keyCode === 93) {
	    stopImmediatePropagation(event);
	    return;
	  }
	  switch (event.keyCode) {
	    case KEY_CODES.ARROW_RIGHT:
	      if (that.isInFullEditMode()) {
	        if ((!that.isWaiting() && !that.allowKeyEventPropagation) || (!that.isWaiting() && that.allowKeyEventPropagation && !that.allowKeyEventPropagation(event.keyCode))) {
	          stopImmediatePropagation(event);
	        }
	      }
	      break;
	    case KEY_CODES.ARROW_LEFT:
	      if (that.isInFullEditMode()) {
	        if ((!that.isWaiting() && !that.allowKeyEventPropagation) || (!that.isWaiting() && that.allowKeyEventPropagation && !that.allowKeyEventPropagation(event.keyCode))) {
	          stopImmediatePropagation(event);
	        }
	      }
	      break;
	    case KEY_CODES.ARROW_UP:
	    case KEY_CODES.ARROW_DOWN:
	      if (that.isInFullEditMode()) {
	        if ((!that.isWaiting() && !that.allowKeyEventPropagation) || (!that.isWaiting() && that.allowKeyEventPropagation && !that.allowKeyEventPropagation(event.keyCode))) {
	          stopImmediatePropagation(event);
	        }
	      }
	      break;
	    case KEY_CODES.ENTER:
	      var selected = that.instance.getSelected();
	      var isMultipleSelection = !(selected[0] === selected[2] && selected[1] === selected[3]);
	      if ((ctrlDown && !isMultipleSelection) || event.altKey) {
	        if (that.isOpened()) {
	          var caretPosition = getCaretPosition(that.TEXTAREA),
	              value = that.getValue();
	          var newValue = value.slice(0, caretPosition) + '\n' + value.slice(caretPosition);
	          that.setValue(newValue);
	          setCaretPosition(that.TEXTAREA, caretPosition + 1);
	        } else {
	          that.beginEditing(that.originalValue + '\n');
	        }
	        stopImmediatePropagation(event);
	      }
	      event.preventDefault();
	      break;
	    case KEY_CODES.A:
	    case KEY_CODES.X:
	    case KEY_CODES.C:
	    case KEY_CODES.V:
	      if (ctrlDown) {
	        stopImmediatePropagation(event);
	      }
	      break;
	    case KEY_CODES.BACKSPACE:
	    case KEY_CODES.DELETE:
	    case KEY_CODES.HOME:
	    case KEY_CODES.END:
	      stopImmediatePropagation(event);
	      break;
	  }
	  if ([KEY_CODES.ARROW_UP, KEY_CODES.ARROW_RIGHT, KEY_CODES.ARROW_DOWN, KEY_CODES.ARROW_LEFT].indexOf(event.keyCode) === -1) {
	    that.autoResize.resize(String.fromCharCode(event.keyCode));
	  }
	};
	TextEditor.prototype.open = function() {
	  this.refreshDimensions();
	  this.instance.addHook('beforeKeyDown', onBeforeKeyDown);
	};
	TextEditor.prototype.close = function(tdOutside) {
	  this.textareaParentStyle.display = 'none';
	  this.autoResize.unObserve();
	  if (document.activeElement === this.TEXTAREA) {
	    this.instance.listen();
	  }
	  this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
	};
	TextEditor.prototype.focus = function() {
	  this.TEXTAREA.focus();
	  setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);
	};
	TextEditor.prototype.createElements = function() {
	  this.TEXTAREA = document.createElement('TEXTAREA');
	  addClass(this.TEXTAREA, 'handsontableInput');
	  this.textareaStyle = this.TEXTAREA.style;
	  this.textareaStyle.width = 0;
	  this.textareaStyle.height = 0;
	  this.TEXTAREA_PARENT = document.createElement('DIV');
	  addClass(this.TEXTAREA_PARENT, 'handsontableInputHolder');
	  this.textareaParentStyle = this.TEXTAREA_PARENT.style;
	  this.textareaParentStyle.top = 0;
	  this.textareaParentStyle.left = 0;
	  this.textareaParentStyle.display = 'none';
	  this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
	  this.instance.rootElement.appendChild(this.TEXTAREA_PARENT);
	  var that = this;
	  this.instance._registerTimeout(setTimeout(function() {
	    that.refreshDimensions();
	  }, 0));
	};
	TextEditor.prototype.getEditedCell = function() {
	  var editorSection = this.checkEditorSection(),
	      editedCell;
	  switch (editorSection) {
	    case 'top':
	      editedCell = this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.getCell({
	        row: this.row,
	        col: this.col
	      });
	      this.textareaParentStyle.zIndex = 101;
	      break;
	    case 'top-left-corner':
	      editedCell = this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell({
	        row: this.row,
	        col: this.col
	      });
	      this.textareaParentStyle.zIndex = 103;
	      break;
	    case 'bottom-left-corner':
	      editedCell = this.instance.view.wt.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.getCell({
	        row: this.row,
	        col: this.col
	      });
	      this.textareaParentStyle.zIndex = 103;
	      break;
	    case 'left':
	      editedCell = this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.getCell({
	        row: this.row,
	        col: this.col
	      });
	      this.textareaParentStyle.zIndex = 102;
	      break;
	    case 'bottom':
	      editedCell = this.instance.view.wt.wtOverlays.bottomOverlay.clone.wtTable.getCell({
	        row: this.row,
	        col: this.col
	      });
	      this.textareaParentStyle.zIndex = 102;
	      break;
	    default:
	      editedCell = this.instance.getCell(this.row, this.col);
	      this.textareaParentStyle.zIndex = '';
	      break;
	  }
	  return editedCell != -1 && editedCell != -2 ? editedCell : void 0;
	};
	TextEditor.prototype.refreshDimensions = function() {
	  if (this.state !== Handsontable.EditorState.EDITING) {
	    return;
	  }
	  this.TD = this.getEditedCell();
	  if (!this.TD) {
	    this.close(true);
	    return;
	  }
	  var currentOffset = offset(this.TD),
	      containerOffset = offset(this.instance.rootElement),
	      scrollableContainer = getScrollableElement(this.TD),
	      totalRowsCount = this.instance.countRows(),
	      editTop = currentOffset.top - containerOffset.top - 1 - (scrollableContainer.scrollTop || 0),
	      editLeft = currentOffset.left - containerOffset.left - 1 - (scrollableContainer.scrollLeft || 0),
	      settings = this.instance.getSettings(),
	      rowHeadersCount = this.instance.hasRowHeaders(),
	      colHeadersCount = this.instance.hasColHeaders(),
	      editorSection = this.checkEditorSection(),
	      backgroundColor = this.TD.style.backgroundColor,
	      cssTransformOffset;
	  switch (editorSection) {
	    case 'top':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.holder.parentNode);
	      break;
	    case 'left':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.holder.parentNode);
	      break;
	    case 'top-left-corner':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.holder.parentNode);
	      break;
	    case 'bottom-left-corner':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.holder.parentNode);
	      break;
	    case 'bottom':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.bottomOverlay.clone.wtTable.holder.parentNode);
	      break;
	  }
	  if (colHeadersCount && this.instance.getSelected()[0] === 0 || (settings.fixedRowsBottom && this.instance.getSelected()[0] === totalRowsCount - settings.fixedRowsBottom)) {
	    editTop += 1;
	  }
	  if (this.instance.getSelected()[1] === 0) {
	    editLeft += 1;
	  }
	  if (cssTransformOffset && cssTransformOffset != -1) {
	    this.textareaParentStyle[cssTransformOffset[0]] = cssTransformOffset[1];
	  } else {
	    resetCssTransform(this.TEXTAREA_PARENT);
	  }
	  this.textareaParentStyle.top = editTop + 'px';
	  this.textareaParentStyle.left = editLeft + 'px';
	  var firstRowOffset = this.instance.view.wt.wtViewport.rowsRenderCalculator.startPosition;
	  var firstColumnOffset = this.instance.view.wt.wtViewport.columnsRenderCalculator.startPosition;
	  var horizontalScrollPosition = this.instance.view.wt.wtOverlays.leftOverlay.getScrollPosition();
	  var verticalScrollPosition = this.instance.view.wt.wtOverlays.topOverlay.getScrollPosition();
	  var scrollbarWidth = getScrollbarWidth();
	  var cellTopOffset = this.TD.offsetTop + firstRowOffset - verticalScrollPosition;
	  var cellLeftOffset = this.TD.offsetLeft + firstColumnOffset - horizontalScrollPosition;
	  var width = innerWidth(this.TD) - 8;
	  var actualVerticalScrollbarWidth = hasVerticalScrollbar(scrollableContainer) ? scrollbarWidth : 0;
	  var actualHorizontalScrollbarWidth = hasHorizontalScrollbar(scrollableContainer) ? scrollbarWidth : 0;
	  var maxWidth = this.instance.view.maximumVisibleElementWidth(cellLeftOffset) - 9 - actualVerticalScrollbarWidth;
	  var height = this.TD.scrollHeight + 1;
	  var maxHeight = Math.max(this.instance.view.maximumVisibleElementHeight(cellTopOffset) - actualHorizontalScrollbarWidth, 23);
	  var cellComputedStyle = getComputedStyle(this.TD);
	  this.TEXTAREA.style.fontSize = cellComputedStyle.fontSize;
	  this.TEXTAREA.style.fontFamily = cellComputedStyle.fontFamily;
	  this.TEXTAREA.style.backgroundColor = '';
	  this.TEXTAREA.style.backgroundColor = backgroundColor ? backgroundColor : getComputedStyle(this.TEXTAREA).backgroundColor;
	  this.autoResize.init(this.TEXTAREA, {
	    minHeight: Math.min(height, maxHeight),
	    maxHeight: maxHeight,
	    minWidth: Math.min(width, maxWidth),
	    maxWidth: maxWidth
	  }, true);
	  this.textareaParentStyle.display = 'block';
	};
	TextEditor.prototype.bindEvents = function() {
	  var editor = this;
	  this.eventManager.addEventListener(this.TEXTAREA, 'cut', function(event) {
	    stopPropagation(event);
	  });
	  this.eventManager.addEventListener(this.TEXTAREA, 'paste', function(event) {
	    stopPropagation(event);
	  });
	  this.instance.addHook('afterScrollHorizontally', function() {
	    editor.refreshDimensions();
	  });
	  this.instance.addHook('afterScrollVertically', function() {
	    editor.refreshDimensions();
	  });
	  this.instance.addHook('afterColumnResize', function() {
	    editor.refreshDimensions();
	    editor.focus();
	  });
	  this.instance.addHook('afterRowResize', function() {
	    editor.refreshDimensions();
	    editor.focus();
	  });
	  this.instance.addHook('afterDestroy', function() {
	    editor.eventManager.destroy();
	  });
	};
	TextEditor.prototype.destroy = function() {
	  this.eventManager.destroy();
	};
	;
	registerEditor('text', TextEditor);

	//# 
	},{"_baseEditor":30,"autoResize":"autoResize","browser":23,"editors":29,"eventManager":41,"helpers/dom/element":46,"helpers/dom/event":47,"helpers/unicode":55}],41:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  EventManager: {get: function() {
	      return EventManager;
	    }},
	  eventManager: {get: function() {
	      return eventManager;
	    }},
	  __esModule: {value: true}
	});
	var $__browser__,
	    $__helpers_47_dom_47_element__,
	    $__helpers_47_feature__,
	    $__helpers_47_dom_47_event__;
	var Handsontable = ($__browser__ = _dereq_("browser"), $__browser__ && $__browser__.__esModule && $__browser__ || {default: $__browser__}).default;
	var $__1 = ($__helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $__helpers_47_dom_47_element__ && $__helpers_47_dom_47_element__.__esModule && $__helpers_47_dom_47_element__ || {default: $__helpers_47_dom_47_element__}),
	    polymerWrap = $__1.polymerWrap,
	    closest = $__1.closest;
	var isWebComponentSupportedNatively = ($__helpers_47_feature__ = _dereq_("helpers/feature"), $__helpers_47_feature__ && $__helpers_47_feature__.__esModule && $__helpers_47_feature__ || {default: $__helpers_47_feature__}).isWebComponentSupportedNatively;
	var _stopImmediatePropagation = ($__helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $__helpers_47_dom_47_event__ && $__helpers_47_dom_47_event__.__esModule && $__helpers_47_dom_47_event__ || {default: $__helpers_47_dom_47_event__}).stopImmediatePropagation;
	var EventManager = function EventManager() {
	  var context = arguments[0] !== (void 0) ? arguments[0] : null;
	  this.context = context || this;
	  if (!this.context.eventListeners) {
	    this.context.eventListeners = [];
	  }
	};
	($traceurRuntime.createClass)(EventManager, {
	  addEventListener: function(element, eventName, callback) {
	    var $__4 = this;
	    var context = this.context;
	    function callbackProxy(event) {
	      event = extendEvent(context, event);
	      callback.call(this, event);
	    }
	    this.context.eventListeners.push({
	      element: element,
	      event: eventName,
	      callback: callback,
	      callbackProxy: callbackProxy
	    });
	    if (window.addEventListener) {
	      element.addEventListener(eventName, callbackProxy, false);
	    } else {
	      element.attachEvent('on' + eventName, callbackProxy);
	    }
	    Handsontable.countEventManagerListeners++;
	    return (function() {
	      $__4.removeEventListener(element, eventName, callback);
	    });
	  },
	  removeEventListener: function(element, eventName, callback) {
	    var len = this.context.eventListeners.length;
	    var tmpEvent;
	    while (len--) {
	      tmpEvent = this.context.eventListeners[len];
	      if (tmpEvent.event == eventName && tmpEvent.element == element) {
	        if (callback && callback != tmpEvent.callback) {
	          continue;
	        }
	        this.context.eventListeners.splice(len, 1);
	        if (tmpEvent.element.removeEventListener) {
	          tmpEvent.element.removeEventListener(tmpEvent.event, tmpEvent.callbackProxy, false);
	        } else {
	          tmpEvent.element.detachEvent('on' + tmpEvent.event, tmpEvent.callbackProxy);
	        }
	        Handsontable.countEventManagerListeners--;
	      }
	    }
	  },
	  clearEvents: function() {
	    if (!this.context) {
	      return;
	    }
	    var len = this.context.eventListeners.length;
	    while (len--) {
	      var event = this.context.eventListeners[len];
	      if (event) {
	        this.removeEventListener(event.element, event.event, event.callback);
	      }
	    }
	  },
	  clear: function() {
	    this.clearEvents();
	  },
	  destroy: function() {
	    this.clearEvents();
	    this.context = null;
	  },
	  fireEvent: function(element, eventName) {
	    var options = {
	      bubbles: true,
	      cancelable: (eventName !== 'mousemove'),
	      view: window,
	      detail: 0,
	      screenX: 0,
	      screenY: 0,
	      clientX: 1,
	      clientY: 1,
	      ctrlKey: false,
	      altKey: false,
	      shiftKey: false,
	      metaKey: false,
	      button: 0,
	      relatedTarget: undefined
	    };
	    var event;
	    if (document.createEvent) {
	      event = document.createEvent('MouseEvents');
	      event.initMouseEvent(eventName, options.bubbles, options.cancelable, options.view, options.detail, options.screenX, options.screenY, options.clientX, options.clientY, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.button, options.relatedTarget || document.body.parentNode);
	    } else {
	      event = document.createEventObject();
	    }
	    if (element.dispatchEvent) {
	      element.dispatchEvent(event);
	    } else {
	      element.fireEvent('on' + eventName, event);
	    }
	  }
	}, {});
	function extendEvent(context, event) {
	  var componentName = 'HOT-TABLE';
	  var isHotTableSpotted;
	  var fromElement;
	  var realTarget;
	  var target;
	  var len;
	  var nativeStopImmediatePropagation;
	  event.isTargetWebComponent = false;
	  event.realTarget = event.target;
	  nativeStopImmediatePropagation = event.stopImmediatePropagation;
	  event.stopImmediatePropagation = function() {
	    nativeStopImmediatePropagation.apply(this);
	    _stopImmediatePropagation(this);
	  };
	  if (!Handsontable.eventManager.isHotTableEnv) {
	    return event;
	  }
	  event = polymerWrap(event);
	  len = event.path ? event.path.length : 0;
	  while (len--) {
	    if (event.path[len].nodeName === componentName) {
	      isHotTableSpotted = true;
	    } else if (isHotTableSpotted && event.path[len].shadowRoot) {
	      target = event.path[len];
	      break;
	    }
	    if (len === 0 && !target) {
	      target = event.path[len];
	    }
	  }
	  if (!target) {
	    target = event.target;
	  }
	  event.isTargetWebComponent = true;
	  if (isWebComponentSupportedNatively()) {
	    event.realTarget = event.srcElement || event.toElement;
	  } else if (context instanceof Handsontable.Core || context instanceof Walkontable) {
	    if (context instanceof Handsontable.Core) {
	      fromElement = context.view ? context.view.wt.wtTable.TABLE : null;
	    } else if (context instanceof Walkontable) {
	      fromElement = context.wtTable.TABLE.parentNode.parentNode;
	    }
	    realTarget = closest(event.target, [componentName], fromElement);
	    if (realTarget) {
	      event.realTarget = fromElement.querySelector(componentName) || event.target;
	    } else {
	      event.realTarget = event.target;
	    }
	  }
	  Object.defineProperty(event, 'target', {
	    get: function() {
	      return polymerWrap(target);
	    },
	    enumerable: true,
	    configurable: true
	  });
	  return event;
	}
	;
	Handsontable.countEventManagerListeners = 0;
	Handsontable.eventManager = eventManager;
	function eventManager(context) {
	  return new EventManager(context);
	}

	//# 
	},{"browser":23,"helpers/dom/element":46,"helpers/dom/event":47,"helpers/feature":48}],42:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  to2dArray: {get: function() {
	      return to2dArray;
	    }},
	  extendArray: {get: function() {
	      return extendArray;
	    }},
	  pivot: {get: function() {
	      return pivot;
	    }},
	  arrayReduce: {get: function() {
	      return arrayReduce;
	    }},
	  arrayFilter: {get: function() {
	      return arrayFilter;
	    }},
	  arrayMap: {get: function() {
	      return arrayMap;
	    }},
	  arrayEach: {get: function() {
	      return arrayEach;
	    }},
	  arraySum: {get: function() {
	      return arraySum;
	    }},
	  arrayMax: {get: function() {
	      return arrayMax;
	    }},
	  arrayMin: {get: function() {
	      return arrayMin;
	    }},
	  arrayAvg: {get: function() {
	      return arrayAvg;
	    }},
	  arrayFlatten: {get: function() {
	      return arrayFlatten;
	    }},
	  arrayUnique: {get: function() {
	      return arrayUnique;
	    }},
	  __esModule: {value: true}
	});
	function to2dArray(arr) {
	  var i = 0,
	      ilen = arr.length;
	  while (i < ilen) {
	    arr[i] = [arr[i]];
	    i++;
	  }
	}
	function extendArray(arr, extension) {
	  var i = 0,
	      ilen = extension.length;
	  while (i < ilen) {
	    arr.push(extension[i]);
	    i++;
	  }
	}
	function pivot(arr) {
	  var pivotedArr = [];
	  if (!arr || arr.length === 0 || !arr[0] || arr[0].length === 0) {
	    return pivotedArr;
	  }
	  var rowCount = arr.length;
	  var colCount = arr[0].length;
	  for (var i = 0; i < rowCount; i++) {
	    for (var j = 0; j < colCount; j++) {
	      if (!pivotedArr[j]) {
	        pivotedArr[j] = [];
	      }
	      pivotedArr[j][i] = arr[i][j];
	    }
	  }
	  return pivotedArr;
	}
	function arrayReduce(array, iteratee, accumulator, initFromArray) {
	  var index = -1,
	      length = array.length;
	  if (initFromArray && length) {
	    accumulator = array[++index];
	  }
	  while (++index < length) {
	    accumulator = iteratee(accumulator, array[index], index, array);
	  }
	  return accumulator;
	}
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array.length,
	      resIndex = -1,
	      result = [];
	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[++resIndex] = value;
	    }
	  }
	  return result;
	}
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array.length,
	      resIndex = -1,
	      result = [];
	  while (++index < length) {
	    var value = array[index];
	    result[++resIndex] = iteratee(value, index, array);
	  }
	  return result;
	}
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array.length;
	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}
	function arraySum(array) {
	  return arrayReduce(array, (function(a, b) {
	    return (a + b);
	  }), 0);
	}
	function arrayMax(array) {
	  return arrayReduce(array, (function(a, b) {
	    return (a > b ? a : b);
	  }), Array.isArray(array) ? array[0] : void 0);
	}
	function arrayMin(array) {
	  return arrayReduce(array, (function(a, b) {
	    return (a < b ? a : b);
	  }), Array.isArray(array) ? array[0] : void 0);
	}
	function arrayAvg(array) {
	  if (!array.length) {
	    return 0;
	  }
	  return arraySum(array) / array.length;
	}
	function arrayFlatten(array) {
	  return arrayReduce(array, (function(initial, value) {
	    return initial.concat(Array.isArray(value) ? arrayFlatten(value) : value);
	  }), []);
	}
	function arrayUnique(array) {
	  var unique = [];
	  arrayEach(array, (function(value) {
	    if (unique.indexOf(value) === -1) {
	      unique.push(value);
	    }
	  }));
	  return unique;
	}

	//# 
	},{}],43:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  isIE8: {get: function() {
	      return isIE8;
	    }},
	  isIE9: {get: function() {
	      return isIE9;
	    }},
	  isSafari: {get: function() {
	      return isSafari;
	    }},
	  isChrome: {get: function() {
	      return isChrome;
	    }},
	  isMobileBrowser: {get: function() {
	      return isMobileBrowser;
	    }},
	  __esModule: {value: true}
	});
	var _isIE8 = !(document.createTextNode('test').textContent);
	function isIE8() {
	  return _isIE8;
	}
	var _isIE9 = !!(document.documentMode);
	function isIE9() {
	  return _isIE9;
	}
	var _isSafari = (/Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor));
	function isSafari() {
	  return _isSafari;
	}
	var _isChrome = (/Chrome/.test(navigator.userAgent) && /Google/.test(navigator.vendor));
	function isChrome() {
	  return _isChrome;
	}
	function isMobileBrowser(userAgent) {
	  if (!userAgent) {
	    userAgent = navigator.userAgent;
	  }
	  return (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent));
	}

	//# 
	},{}],44:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  spreadsheetColumnLabel: {get: function() {
	      return spreadsheetColumnLabel;
	    }},
	  createSpreadsheetData: {get: function() {
	      return createSpreadsheetData;
	    }},
	  createSpreadsheetObjectData: {get: function() {
	      return createSpreadsheetObjectData;
	    }},
	  createEmptySpreadsheetData: {get: function() {
	      return createEmptySpreadsheetData;
	    }},
	  translateRowsToColumns: {get: function() {
	      return translateRowsToColumns;
	    }},
	  cellMethodLookupFactory: {get: function() {
	      return cellMethodLookupFactory;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $__object__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var getPrototypeOf = ($__object__ = _dereq_("object"), $__object__ && $__object__.__esModule && $__object__ || {default: $__object__}).getPrototypeOf;
	function spreadsheetColumnLabel(index) {
	  var dividend = index + 1;
	  var columnLabel = '';
	  var modulo;
	  while (dividend > 0) {
	    modulo = (dividend - 1) % 26;
	    columnLabel = String.fromCharCode(65 + modulo) + columnLabel;
	    dividend = parseInt((dividend - modulo) / 26, 10);
	  }
	  return columnLabel;
	}
	function createSpreadsheetData(rowCount, colCount) {
	  rowCount = typeof rowCount === 'number' ? rowCount : 100;
	  colCount = typeof colCount === 'number' ? colCount : 4;
	  var rows = [],
	      i,
	      j;
	  for (i = 0; i < rowCount; i++) {
	    var row = [];
	    for (j = 0; j < colCount; j++) {
	      row.push(spreadsheetColumnLabel(j) + (i + 1));
	    }
	    rows.push(row);
	  }
	  return rows;
	}
	function createSpreadsheetObjectData(rowCount, colCount) {
	  rowCount = typeof rowCount === 'number' ? rowCount : 100;
	  colCount = typeof colCount === 'number' ? colCount : 4;
	  var rows = [],
	      i,
	      j;
	  for (i = 0; i < rowCount; i++) {
	    var row = {};
	    for (j = 0; j < colCount; j++) {
	      row['prop' + j] = spreadsheetColumnLabel(j) + (i + 1);
	    }
	    rows.push(row);
	  }
	  return rows;
	}
	function createEmptySpreadsheetData(rows, columns) {
	  var data = [];
	  var row;
	  for (var i = 0; i < rows; i++) {
	    row = [];
	    for (var j = 0; j < columns; j++) {
	      row.push('');
	    }
	    data.push(row);
	  }
	  return data;
	}
	function translateRowsToColumns(input) {
	  var i,
	      ilen,
	      j,
	      jlen,
	      output = [],
	      olen = 0;
	  for (i = 0, ilen = input.length; i < ilen; i++) {
	    for (j = 0, jlen = input[i].length; j < jlen; j++) {
	      if (j == olen) {
	        output.push([]);
	        olen++;
	      }
	      output[j].push(input[i][j]);
	    }
	  }
	  return output;
	}
	function cellMethodLookupFactory(methodName, allowUndefined) {
	  allowUndefined = typeof allowUndefined == 'undefined' ? true : allowUndefined;
	  return function cellMethodLookup(row, col) {
	    return (function getMethodFromProperties(properties) {
	      if (!properties) {
	        return;
	      } else if (properties.hasOwnProperty(methodName) && properties[methodName] !== void 0) {
	        return properties[methodName];
	      } else if (properties.hasOwnProperty('type') && properties.type) {
	        var type;
	        if (typeof properties.type != 'string') {
	          throw new Error('Cell type must be a string ');
	        }
	        type = translateTypeNameToObject(properties.type);
	        if (type.hasOwnProperty(methodName)) {
	          return type[methodName];
	        } else if (allowUndefined) {
	          return;
	        }
	      }
	      return getMethodFromProperties(getPrototypeOf(properties));
	    })(typeof row == 'number' ? this.getCellMeta(row, col) : row);
	  };
	  function translateTypeNameToObject(typeName) {
	    var type = Handsontable.cellTypes[typeName];
	    if (typeof type == 'undefined') {
	      throw new Error('You declared cell type "' + typeName + '" as a string that is not mapped to a known object. ' + 'Cell type must be an object or a string mapped to an object in Handsontable.cellTypes');
	    }
	    return type;
	  }
	}

	//# 
	},{"browser":23,"object":52}],45:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  getNormalizedDate: {get: function() {
	      return getNormalizedDate;
	    }},
	  __esModule: {value: true}
	});
	function getNormalizedDate(dateString) {
	  var nativeDate = new Date(dateString);
	  if (!isNaN(new Date(dateString + 'T00:00').getDate())) {
	    return new Date(nativeDate.getTime() + nativeDate.getTimezoneOffset() * 60000);
	  }
	  return nativeDate;
	}

	//# 
	},{}],46:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  closest: {get: function() {
	      return closest;
	    }},
	  isChildOf: {get: function() {
	      return isChildOf;
	    }},
	  isChildOfWebComponentTable: {get: function() {
	      return isChildOfWebComponentTable;
	    }},
	  polymerWrap: {get: function() {
	      return polymerWrap;
	    }},
	  polymerUnwrap: {get: function() {
	      return polymerUnwrap;
	    }},
	  index: {get: function() {
	      return index;
	    }},
	  overlayContainsElement: {get: function() {
	      return overlayContainsElement;
	    }},
	  hasClass: {get: function() {
	      return hasClass;
	    }},
	  addClass: {get: function() {
	      return addClass;
	    }},
	  removeClass: {get: function() {
	      return removeClass;
	    }},
	  removeTextNodes: {get: function() {
	      return removeTextNodes;
	    }},
	  empty: {get: function() {
	      return empty;
	    }},
	  HTML_CHARACTERS: {get: function() {
	      return HTML_CHARACTERS;
	    }},
	  fastInnerHTML: {get: function() {
	      return fastInnerHTML;
	    }},
	  fastInnerText: {get: function() {
	      return fastInnerText;
	    }},
	  isVisible: {get: function() {
	      return isVisible;
	    }},
	  offset: {get: function() {
	      return offset;
	    }},
	  getWindowScrollTop: {get: function() {
	      return getWindowScrollTop;
	    }},
	  getWindowScrollLeft: {get: function() {
	      return getWindowScrollLeft;
	    }},
	  getScrollTop: {get: function() {
	      return getScrollTop;
	    }},
	  getScrollLeft: {get: function() {
	      return getScrollLeft;
	    }},
	  getScrollableElement: {get: function() {
	      return getScrollableElement;
	    }},
	  getTrimmingContainer: {get: function() {
	      return getTrimmingContainer;
	    }},
	  getStyle: {get: function() {
	      return getStyle;
	    }},
	  getComputedStyle: {get: function() {
	      return getComputedStyle;
	    }},
	  outerWidth: {get: function() {
	      return outerWidth;
	    }},
	  outerHeight: {get: function() {
	      return outerHeight;
	    }},
	  innerHeight: {get: function() {
	      return innerHeight;
	    }},
	  innerWidth: {get: function() {
	      return innerWidth;
	    }},
	  addEvent: {get: function() {
	      return addEvent;
	    }},
	  removeEvent: {get: function() {
	      return removeEvent;
	    }},
	  getCaretPosition: {get: function() {
	      return getCaretPosition;
	    }},
	  getSelectionEndPosition: {get: function() {
	      return getSelectionEndPosition;
	    }},
	  getSelectionText: {get: function() {
	      return getSelectionText;
	    }},
	  setCaretPosition: {get: function() {
	      return setCaretPosition;
	    }},
	  getScrollbarWidth: {get: function() {
	      return getScrollbarWidth;
	    }},
	  hasVerticalScrollbar: {get: function() {
	      return hasVerticalScrollbar;
	    }},
	  hasHorizontalScrollbar: {get: function() {
	      return hasHorizontalScrollbar;
	    }},
	  setOverlayPosition: {get: function() {
	      return setOverlayPosition;
	    }},
	  getCssTransform: {get: function() {
	      return getCssTransform;
	    }},
	  resetCssTransform: {get: function() {
	      return resetCssTransform;
	    }},
	  isInput: {get: function() {
	      return isInput;
	    }},
	  isOutsideInput: {get: function() {
	      return isOutsideInput;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $___46__46__47_feature__;
	var $__0 = ($___46__46__47_browser__ = _dereq_("../browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}),
	    isIE8 = $__0.isIE8,
	    isIE9 = $__0.isIE9,
	    isSafari = $__0.isSafari;
	var hasCaptionProblem = ($___46__46__47_feature__ = _dereq_("../feature"), $___46__46__47_feature__ && $___46__46__47_feature__.__esModule && $___46__46__47_feature__ || {default: $___46__46__47_feature__}).hasCaptionProblem;
	function closest(element, nodes, until) {
	  while (element != null && element !== until) {
	    if (element.nodeType === Node.ELEMENT_NODE && (nodes.indexOf(element.nodeName) > -1 || nodes.indexOf(element) > -1)) {
	      return element;
	    }
	    if (element.host && element.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
	      element = element.host;
	    } else {
	      element = element.parentNode;
	    }
	  }
	  return null;
	}
	function isChildOf(child, parent) {
	  var node = child.parentNode;
	  var queriedParents = [];
	  if (typeof parent === 'string') {
	    queriedParents = Array.prototype.slice.call(document.querySelectorAll(parent), 0);
	  } else {
	    queriedParents.push(parent);
	  }
	  while (node != null) {
	    if (queriedParents.indexOf(node) > -1) {
	      return true;
	    }
	    node = node.parentNode;
	  }
	  return false;
	}
	function isChildOfWebComponentTable(element) {
	  var hotTableName = 'hot-table',
	      result = false,
	      parentNode;
	  parentNode = polymerWrap(element);
	  function isHotTable(element) {
	    return element.nodeType === Node.ELEMENT_NODE && element.nodeName === hotTableName.toUpperCase();
	  }
	  while (parentNode != null) {
	    if (isHotTable(parentNode)) {
	      result = true;
	      break;
	    } else if (parentNode.host && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
	      result = isHotTable(parentNode.host);
	      if (result) {
	        break;
	      }
	      parentNode = parentNode.host;
	    }
	    parentNode = parentNode.parentNode;
	  }
	  return result;
	}
	function polymerWrap(element) {
	  return typeof Polymer !== 'undefined' && typeof wrap === 'function' ? wrap(element) : element;
	}
	function polymerUnwrap(element) {
	  return typeof Polymer !== 'undefined' && typeof unwrap === 'function' ? unwrap(element) : element;
	}
	function index(element) {
	  var i = 0;
	  if (element.previousSibling) {
	    while (element = element.previousSibling) {
	      ++i;
	    }
	  }
	  return i;
	}
	function overlayContainsElement(overlayType, element) {
	  var overlayElement = document.querySelector('.ht_clone_' + overlayType);
	  return overlayElement ? overlayElement.contains(element) : null;
	}
	var classListSupport = document.documentElement.classList ? true : false;
	var _hasClass,
	    _addClass,
	    _removeClass;
	function filterEmptyClassNames(classNames) {
	  var len = 0,
	      result = [];
	  if (!classNames || !classNames.length) {
	    return result;
	  }
	  while (classNames[len]) {
	    result.push(classNames[len]);
	    len++;
	  }
	  return result;
	}
	if (classListSupport) {
	  var isSupportMultipleClassesArg = (function() {
	    var element = document.createElement('div');
	    element.classList.add('test', 'test2');
	    return element.classList.contains('test2');
	  }());
	  _hasClass = function _hasClass(element, className) {
	    if (className === '') {
	      return false;
	    }
	    return element.classList.contains(className);
	  };
	  _addClass = function _addClass(element, className) {
	    var len = 0;
	    if (typeof className === 'string') {
	      className = className.split(' ');
	    }
	    className = filterEmptyClassNames(className);
	    if (isSupportMultipleClassesArg) {
	      element.classList.add.apply(element.classList, className);
	    } else {
	      while (className && className[len]) {
	        element.classList.add(className[len]);
	        len++;
	      }
	    }
	  };
	  _removeClass = function _removeClass(element, className) {
	    var len = 0;
	    if (typeof className === 'string') {
	      className = className.split(' ');
	    }
	    className = filterEmptyClassNames(className);
	    if (isSupportMultipleClassesArg) {
	      element.classList.remove.apply(element.classList, className);
	    } else {
	      while (className && className[len]) {
	        element.classList.remove(className[len]);
	        len++;
	      }
	    }
	  };
	} else {
	  var createClassNameRegExp = function createClassNameRegExp(className) {
	    return new RegExp('(\\s|^)' + className + '(\\s|$)');
	  };
	  _hasClass = function _hasClass(element, className) {
	    return element.className.match(createClassNameRegExp(className)) ? true : false;
	  };
	  _addClass = function _addClass(element, className) {
	    var len = 0,
	        _className = element.className;
	    if (typeof className === 'string') {
	      className = className.split(' ');
	    }
	    if (_className === '') {
	      _className = className.join(' ');
	    } else {
	      while (className && className[len]) {
	        if (!createClassNameRegExp(className[len]).test(_className)) {
	          _className += ' ' + className[len];
	        }
	        len++;
	      }
	    }
	    element.className = _className;
	  };
	  _removeClass = function _removeClass(element, className) {
	    var len = 0,
	        _className = element.className;
	    if (typeof className === 'string') {
	      className = className.split(' ');
	    }
	    while (className && className[len]) {
	      _className = _className.replace(createClassNameRegExp(className[len]), ' ').trim();
	      len++;
	    }
	    if (element.className !== _className) {
	      element.className = _className;
	    }
	  };
	}
	function hasClass(element, className) {
	  return _hasClass(element, className);
	}
	function addClass(element, className) {
	  return _addClass(element, className);
	}
	function removeClass(element, className) {
	  return _removeClass(element, className);
	}
	function removeTextNodes(element, parent) {
	  if (element.nodeType === 3) {
	    parent.removeChild(element);
	  } else if (['TABLE', 'THEAD', 'TBODY', 'TFOOT', 'TR'].indexOf(element.nodeName) > -1) {
	    var childs = element.childNodes;
	    for (var i = childs.length - 1; i >= 0; i--) {
	      removeTextNodes(childs[i], element);
	    }
	  }
	}
	function empty(element) {
	  var child;
	  while (child = element.lastChild) {
	    element.removeChild(child);
	  }
	}
	var HTML_CHARACTERS = /(<(.*)>|&(.*);)/;
	function fastInnerHTML(element, content) {
	  if (HTML_CHARACTERS.test(content)) {
	    element.innerHTML = content;
	  } else {
	    fastInnerText(element, content);
	  }
	}
	var textContextSupport = document.createTextNode('test').textContent ? true : false;
	function fastInnerText(element, content) {
	  var child = element.firstChild;
	  if (child && child.nodeType === 3 && child.nextSibling === null) {
	    if (textContextSupport) {
	      child.textContent = content;
	    } else {
	      child.data = content;
	    }
	  } else {
	    empty(element);
	    element.appendChild(document.createTextNode(content));
	  }
	}
	function isVisible(elem) {
	  var next = elem;
	  while (polymerUnwrap(next) !== document.documentElement) {
	    if (next === null) {
	      return false;
	    } else if (next.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
	      if (next.host) {
	        if (next.host.impl) {
	          return isVisible(next.host.impl);
	        } else if (next.host) {
	          return isVisible(next.host);
	        } else {
	          throw new Error('Lost in Web Components world');
	        }
	      } else {
	        return false;
	      }
	    } else if (next.style.display === 'none') {
	      return false;
	    }
	    next = next.parentNode;
	  }
	  return true;
	}
	function offset(elem) {
	  var offsetLeft,
	      offsetTop,
	      lastElem,
	      docElem,
	      box;
	  docElem = document.documentElement;
	  if (hasCaptionProblem() && elem.firstChild && elem.firstChild.nodeName === 'CAPTION') {
	    box = elem.getBoundingClientRect();
	    return {
	      top: box.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
	      left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
	    };
	  }
	  offsetLeft = elem.offsetLeft;
	  offsetTop = elem.offsetTop;
	  lastElem = elem;
	  while (elem = elem.offsetParent) {
	    if (elem === document.body) {
	      break;
	    }
	    offsetLeft += elem.offsetLeft;
	    offsetTop += elem.offsetTop;
	    lastElem = elem;
	  }
	  if (lastElem && lastElem.style.position === 'fixed') {
	    offsetLeft += window.pageXOffset || docElem.scrollLeft;
	    offsetTop += window.pageYOffset || docElem.scrollTop;
	  }
	  return {
	    left: offsetLeft,
	    top: offsetTop
	  };
	}
	function getWindowScrollTop() {
	  var res = window.scrollY;
	  if (res === void 0) {
	    res = document.documentElement.scrollTop;
	  }
	  return res;
	}
	function getWindowScrollLeft() {
	  var res = window.scrollX;
	  if (res === void 0) {
	    res = document.documentElement.scrollLeft;
	  }
	  return res;
	}
	function getScrollTop(element) {
	  if (element === window) {
	    return getWindowScrollTop();
	  } else {
	    return element.scrollTop;
	  }
	}
	function getScrollLeft(element) {
	  if (element === window) {
	    return getWindowScrollLeft();
	  } else {
	    return element.scrollLeft;
	  }
	}
	function getScrollableElement(element) {
	  var el = element.parentNode,
	      props = ['auto', 'scroll'],
	      overflow,
	      overflowX,
	      overflowY,
	      computedStyle = '',
	      computedOverflow = '',
	      computedOverflowY = '',
	      computedOverflowX = '';
	  while (el && el.style && document.body !== el) {
	    overflow = el.style.overflow;
	    overflowX = el.style.overflowX;
	    overflowY = el.style.overflowY;
	    if (overflow == 'scroll' || overflowX == 'scroll' || overflowY == 'scroll') {
	      return el;
	    } else if (window.getComputedStyle) {
	      computedStyle = window.getComputedStyle(el);
	      computedOverflow = computedStyle.getPropertyValue('overflow');
	      computedOverflowY = computedStyle.getPropertyValue('overflow-y');
	      computedOverflowX = computedStyle.getPropertyValue('overflow-x');
	      if (computedOverflow === 'scroll' || computedOverflowX === 'scroll' || computedOverflowY === 'scroll') {
	        return el;
	      }
	    }
	    if (el.clientHeight <= el.scrollHeight && (props.indexOf(overflowY) !== -1 || props.indexOf(overflow) !== -1 || props.indexOf(computedOverflow) !== -1 || props.indexOf(computedOverflowY) !== -1)) {
	      return el;
	    }
	    if (el.clientWidth <= el.scrollWidth && (props.indexOf(overflowX) !== -1 || props.indexOf(overflow) !== -1 || props.indexOf(computedOverflow) !== -1 || props.indexOf(computedOverflowX) !== -1)) {
	      return el;
	    }
	    el = el.parentNode;
	  }
	  return window;
	}
	function getTrimmingContainer(base) {
	  var el = base.parentNode;
	  while (el && el.style && document.body !== el) {
	    if (el.style.overflow !== 'visible' && el.style.overflow !== '') {
	      return el;
	    } else if (window.getComputedStyle) {
	      var computedStyle = window.getComputedStyle(el);
	      if (computedStyle.getPropertyValue('overflow') !== 'visible' && computedStyle.getPropertyValue('overflow') !== '') {
	        return el;
	      }
	    }
	    el = el.parentNode;
	  }
	  return window;
	}
	function getStyle(element, prop) {
	  if (!element) {
	    return;
	  } else if (element === window) {
	    if (prop === 'width') {
	      return window.innerWidth + 'px';
	    } else if (prop === 'height') {
	      return window.innerHeight + 'px';
	    }
	    return;
	  }
	  var styleProp = element.style[prop],
	      computedStyle;
	  if (styleProp !== '' && styleProp !== void 0) {
	    return styleProp;
	  } else {
	    computedStyle = getComputedStyle(element);
	    if (computedStyle[prop] !== '' && computedStyle[prop] !== void 0) {
	      return computedStyle[prop];
	    }
	    return void 0;
	  }
	}
	function getComputedStyle(element) {
	  return element.currentStyle || document.defaultView.getComputedStyle(element);
	}
	function outerWidth(element) {
	  return element.offsetWidth;
	}
	function outerHeight(elem) {
	  if (hasCaptionProblem() && elem.firstChild && elem.firstChild.nodeName === 'CAPTION') {
	    return elem.offsetHeight + elem.firstChild.offsetHeight;
	  } else {
	    return elem.offsetHeight;
	  }
	}
	function innerHeight(element) {
	  return element.clientHeight || element.innerHeight;
	}
	function innerWidth(element) {
	  return element.clientWidth || element.innerWidth;
	}
	function addEvent(element, event, callback) {
	  if (window.addEventListener) {
	    element.addEventListener(event, callback, false);
	  } else {
	    element.attachEvent('on' + event, callback);
	  }
	}
	function removeEvent(element, event, callback) {
	  if (window.removeEventListener) {
	    element.removeEventListener(event, callback, false);
	  } else {
	    element.detachEvent('on' + event, callback);
	  }
	}
	function getCaretPosition(el) {
	  if (el.selectionStart) {
	    return el.selectionStart;
	  } else if (document.selection) {
	    el.focus();
	    var r = document.selection.createRange();
	    if (r == null) {
	      return 0;
	    }
	    var re = el.createTextRange();
	    var rc = re.duplicate();
	    re.moveToBookmark(r.getBookmark());
	    rc.setEndPoint('EndToStart', re);
	    return rc.text.length;
	  }
	  return 0;
	}
	function getSelectionEndPosition(el) {
	  if (el.selectionEnd) {
	    return el.selectionEnd;
	  } else if (document.selection) {
	    var r = document.selection.createRange();
	    if (r == null) {
	      return 0;
	    }
	    var re = el.createTextRange();
	    return re.text.indexOf(r.text) + r.text.length;
	  }
	}
	function getSelectionText() {
	  var text = '';
	  if (window.getSelection) {
	    text = window.getSelection().toString();
	  } else if (document.selection && document.selection.type !== 'Control') {
	    text = document.selection.createRange().text;
	  }
	  return text;
	}
	function setCaretPosition(element, pos, endPos) {
	  if (endPos === void 0) {
	    endPos = pos;
	  }
	  if (element.setSelectionRange) {
	    element.focus();
	    try {
	      element.setSelectionRange(pos, endPos);
	    } catch (err) {
	      var elementParent = element.parentNode;
	      var parentDisplayValue = elementParent.style.display;
	      elementParent.style.display = 'block';
	      element.setSelectionRange(pos, endPos);
	      elementParent.style.display = parentDisplayValue;
	    }
	  } else if (element.createTextRange) {
	    var range = element.createTextRange();
	    range.collapse(true);
	    range.moveEnd('character', endPos);
	    range.moveStart('character', pos);
	    range.select();
	  }
	}
	var cachedScrollbarWidth;
	function walkontableCalculateScrollbarWidth() {
	  var inner = document.createElement('p');
	  inner.style.width = '100%';
	  inner.style.height = '200px';
	  var outer = document.createElement('div');
	  outer.style.position = 'absolute';
	  outer.style.top = '0px';
	  outer.style.left = '0px';
	  outer.style.visibility = 'hidden';
	  outer.style.width = '200px';
	  outer.style.height = '150px';
	  outer.style.overflow = 'hidden';
	  outer.appendChild(inner);
	  (document.body || document.documentElement).appendChild(outer);
	  var w1 = inner.offsetWidth;
	  outer.style.overflow = 'scroll';
	  var w2 = inner.offsetWidth;
	  if (w1 == w2) {
	    w2 = outer.clientWidth;
	  }
	  (document.body || document.documentElement).removeChild(outer);
	  return (w1 - w2);
	}
	function getScrollbarWidth() {
	  if (cachedScrollbarWidth === void 0) {
	    cachedScrollbarWidth = walkontableCalculateScrollbarWidth();
	  }
	  return cachedScrollbarWidth;
	}
	function hasVerticalScrollbar(element) {
	  return element.offsetWidth !== element.clientWidth;
	}
	function hasHorizontalScrollbar(element) {
	  return element.offsetHeight !== element.clientHeight;
	}
	function setOverlayPosition(overlayElem, left, top) {
	  if (isIE8() || isIE9()) {
	    overlayElem.style.top = top;
	    overlayElem.style.left = left;
	  } else if (isSafari()) {
	    overlayElem.style['-webkit-transform'] = 'translate3d(' + left + ',' + top + ',0)';
	  } else {
	    overlayElem.style.transform = 'translate3d(' + left + ',' + top + ',0)';
	  }
	}
	function getCssTransform(element) {
	  var transform;
	  if (element.style.transform && (transform = element.style.transform) !== '') {
	    return ['transform', transform];
	  } else if (element.style['-webkit-transform'] && (transform = element.style['-webkit-transform']) !== '') {
	    return ['-webkit-transform', transform];
	  }
	  return -1;
	}
	function resetCssTransform(element) {
	  if (element.style.transform && element.style.transform !== '') {
	    element.style.transform = '';
	  } else if (element.style['-webkit-transform'] && element.style['-webkit-transform'] !== '') {
	    element.style['-webkit-transform'] = '';
	  }
	}
	function isInput(element) {
	  var inputs = ['INPUT', 'SELECT', 'TEXTAREA'];
	  return element && (inputs.indexOf(element.nodeName) > -1 || element.contentEditable === 'true');
	}
	function isOutsideInput(element) {
	  return isInput(element) && element.className.indexOf('handsontableInput') == -1 && element.className.indexOf('copyPaste') == -1;
	}

	//# 
	},{"../browser":43,"../feature":48}],47:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  stopImmediatePropagation: {get: function() {
	      return stopImmediatePropagation;
	    }},
	  isImmediatePropagationStopped: {get: function() {
	      return isImmediatePropagationStopped;
	    }},
	  stopPropagation: {get: function() {
	      return stopPropagation;
	    }},
	  pageX: {get: function() {
	      return pageX;
	    }},
	  pageY: {get: function() {
	      return pageY;
	    }},
	  __esModule: {value: true}
	});
	var $__element__;
	var $__0 = ($__element__ = _dereq_("element"), $__element__ && $__element__.__esModule && $__element__ || {default: $__element__}),
	    getWindowScrollTop = $__0.getWindowScrollTop,
	    getWindowScrollLeft = $__0.getWindowScrollLeft;
	function stopImmediatePropagation(event) {
	  event.isImmediatePropagationEnabled = false;
	  event.cancelBubble = true;
	}
	function isImmediatePropagationStopped(event) {
	  return event.isImmediatePropagationEnabled === false;
	}
	function stopPropagation(event) {
	  if (typeof event.stopPropagation === 'function') {
	    event.stopPropagation();
	  } else {
	    event.cancelBubble = true;
	  }
	}
	function pageX(event) {
	  if (event.pageX) {
	    return event.pageX;
	  }
	  return event.clientX + getWindowScrollLeft();
	}
	function pageY(event) {
	  if (event.pageY) {
	    return event.pageY;
	  }
	  return event.clientY + getWindowScrollTop();
	}

	//# 
	},{"element":46}],48:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  requestAnimationFrame: {get: function() {
	      return requestAnimationFrame;
	    }},
	  cancelAnimationFrame: {get: function() {
	      return cancelAnimationFrame;
	    }},
	  isTouchSupported: {get: function() {
	      return isTouchSupported;
	    }},
	  isWebComponentSupportedNatively: {get: function() {
	      return isWebComponentSupportedNatively;
	    }},
	  hasCaptionProblem: {get: function() {
	      return hasCaptionProblem;
	    }},
	  getComparisonFunction: {get: function() {
	      return getComparisonFunction;
	    }},
	  __esModule: {value: true}
	});
	var lastTime = 0;
	var vendors = ['ms', 'moz', 'webkit', 'o'];
	var _requestAnimationFrame = window.requestAnimationFrame;
	var _cancelAnimationFrame = window.cancelAnimationFrame;
	for (var x = 0; x < vendors.length && !_requestAnimationFrame; ++x) {
	  _requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
	  _cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
	}
	if (!_requestAnimationFrame) {
	  _requestAnimationFrame = function(callback) {
	    var currTime = new Date().getTime();
	    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
	    var id = window.setTimeout(function() {
	      callback(currTime + timeToCall);
	    }, timeToCall);
	    lastTime = currTime + timeToCall;
	    return id;
	  };
	}
	if (!_cancelAnimationFrame) {
	  _cancelAnimationFrame = function(id) {
	    clearTimeout(id);
	  };
	}
	function requestAnimationFrame(callback) {
	  return _requestAnimationFrame.call(window, callback);
	}
	function cancelAnimationFrame(id) {
	  _cancelAnimationFrame.call(window, id);
	}
	function isTouchSupported() {
	  return ('ontouchstart' in window);
	}
	function isWebComponentSupportedNatively() {
	  var test = document.createElement('div');
	  return test.createShadowRoot && test.createShadowRoot.toString().match(/\[native code\]/) ? true : false;
	}
	var _hasCaptionProblem;
	function detectCaptionProblem() {
	  var TABLE = document.createElement('TABLE');
	  TABLE.style.borderSpacing = 0;
	  TABLE.style.borderWidth = 0;
	  TABLE.style.padding = 0;
	  var TBODY = document.createElement('TBODY');
	  TABLE.appendChild(TBODY);
	  TBODY.appendChild(document.createElement('TR'));
	  TBODY.firstChild.appendChild(document.createElement('TD'));
	  TBODY.firstChild.firstChild.innerHTML = '<tr><td>t<br>t</td></tr>';
	  var CAPTION = document.createElement('CAPTION');
	  CAPTION.innerHTML = 'c<br>c<br>c<br>c';
	  CAPTION.style.padding = 0;
	  CAPTION.style.margin = 0;
	  TABLE.insertBefore(CAPTION, TBODY);
	  document.body.appendChild(TABLE);
	  _hasCaptionProblem = (TABLE.offsetHeight < 2 * TABLE.lastChild.offsetHeight);
	  document.body.removeChild(TABLE);
	}
	function hasCaptionProblem() {
	  if (_hasCaptionProblem === void 0) {
	    detectCaptionProblem();
	  }
	  return _hasCaptionProblem;
	}
	var comparisonFunction;
	function getComparisonFunction(language) {
	  var options = arguments[1] !== (void 0) ? arguments[1] : {};
	  if (comparisonFunction) {
	    return comparisonFunction;
	  }
	  if (typeof Intl === 'object') {
	    comparisonFunction = new Intl.Collator(language, options).compare;
	  } else if (typeof String.prototype.localeCompare === 'function') {
	    comparisonFunction = (function(a, b) {
	      return (a + '').localeCompare(b);
	    });
	  } else {
	    comparisonFunction = (function(a, b) {
	      if (a === b) {
	        return 0;
	      }
	      return a > b ? -1 : 1;
	    });
	  }
	  return comparisonFunction;
	}

	//# 
	},{}],49:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  proxy: {get: function() {
	      return proxy;
	    }},
	  throttle: {get: function() {
	      return throttle;
	    }},
	  throttleAfterHits: {get: function() {
	      return throttleAfterHits;
	    }},
	  debounce: {get: function() {
	      return debounce;
	    }},
	  pipe: {get: function() {
	      return pipe;
	    }},
	  partial: {get: function() {
	      return partial;
	    }},
	  curry: {get: function() {
	      return curry;
	    }},
	  curryRight: {get: function() {
	      return curryRight;
	    }},
	  __esModule: {value: true}
	});
	var $__array__;
	var arrayReduce = ($__array__ = _dereq_("array"), $__array__ && $__array__.__esModule && $__array__ || {default: $__array__}).arrayReduce;
	function proxy(func, context) {
	  return function() {
	    return func.apply(context, arguments);
	  };
	}
	function throttle(func) {
	  var wait = arguments[1] !== (void 0) ? arguments[1] : 200;
	  var lastCalled = 0;
	  var result = {lastCallThrottled: true};
	  var lastTimer = null;
	  function _throttle() {
	    var $__1 = this;
	    var args = arguments;
	    var stamp = Date.now();
	    var needCall = false;
	    result.lastCallThrottled = true;
	    if (!lastCalled) {
	      lastCalled = stamp;
	      needCall = true;
	    }
	    var remaining = wait - (stamp - lastCalled);
	    if (needCall) {
	      result.lastCallThrottled = false;
	      func.apply(this, args);
	    } else {
	      if (lastTimer) {
	        clearTimeout(lastTimer);
	      }
	      lastTimer = setTimeout((function() {
	        result.lastCallThrottled = false;
	        func.apply($__1, args);
	        lastCalled = 0;
	        lastTimer = void 0;
	      }), remaining);
	    }
	    return result;
	  }
	  return _throttle;
	}
	function throttleAfterHits(func) {
	  var wait = arguments[1] !== (void 0) ? arguments[1] : 200;
	  var hits = arguments[2] !== (void 0) ? arguments[2] : 10;
	  var funcThrottle = throttle(func, wait);
	  var remainHits = hits;
	  function _clearHits() {
	    remainHits = hits;
	  }
	  function _throttleAfterHits() {
	    if (remainHits) {
	      remainHits--;
	      return func.apply(this, arguments);
	    }
	    return funcThrottle.apply(this, arguments);
	  }
	  _throttleAfterHits.clearHits = _clearHits;
	  return _throttleAfterHits;
	}
	function debounce(func) {
	  var wait = arguments[1] !== (void 0) ? arguments[1] : 200;
	  var lastTimer = null;
	  var result;
	  function _debounce() {
	    var $__1 = this;
	    var args = arguments;
	    if (lastTimer) {
	      clearTimeout(lastTimer);
	    }
	    lastTimer = setTimeout((function() {
	      result = func.apply($__1, args);
	    }), wait);
	    return result;
	  }
	  return _debounce;
	}
	function pipe() {
	  for (var functions = [],
	      $__2 = 0; $__2 < arguments.length; $__2++)
	    functions[$__2] = arguments[$__2];
	  var $__5 = functions,
	      firstFunc = $__5[0],
	      restFunc = Array.prototype.slice.call($__5, 1);
	  return function _pipe() {
	    return arrayReduce(restFunc, (function(acc, fn) {
	      return fn(acc);
	    }), firstFunc.apply(this, arguments));
	  };
	}
	function partial(func) {
	  for (var params = [],
	      $__3 = 1; $__3 < arguments.length; $__3++)
	    params[$__3 - 1] = arguments[$__3];
	  return function _partial() {
	    for (var restParams = [],
	        $__4 = 0; $__4 < arguments.length; $__4++)
	      restParams[$__4] = arguments[$__4];
	    return func.apply(this, params.concat(restParams));
	  };
	}
	function curry(func) {
	  var argsLength = func.length;
	  function given(argsSoFar) {
	    return function _curry() {
	      for (var params = [],
	          $__4 = 0; $__4 < arguments.length; $__4++)
	        params[$__4] = arguments[$__4];
	      var passedArgsSoFar = argsSoFar.concat(params);
	      var result;
	      if (passedArgsSoFar.length >= argsLength) {
	        result = func.apply(this, passedArgsSoFar);
	      } else {
	        result = given(passedArgsSoFar);
	      }
	      return result;
	    };
	  }
	  return given([]);
	}
	function curryRight(func) {
	  var argsLength = func.length;
	  function given(argsSoFar) {
	    return function _curry() {
	      for (var params = [],
	          $__4 = 0; $__4 < arguments.length; $__4++)
	        params[$__4] = arguments[$__4];
	      var passedArgsSoFar = argsSoFar.concat(params.reverse());
	      var result;
	      if (passedArgsSoFar.length >= argsLength) {
	        result = func.apply(this, passedArgsSoFar);
	      } else {
	        result = given(passedArgsSoFar);
	      }
	      return result;
	    };
	  }
	  return given([]);
	}

	//# 
	},{"array":42}],50:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  stringify: {get: function() {
	      return stringify;
	    }},
	  __esModule: {value: true}
	});
	function stringify(value) {
	  switch (typeof value) {
	    case 'string':
	    case 'number':
	      return value + '';
	    case 'object':
	      if (value === null) {
	        return '';
	      } else {
	        return value.toString();
	      }
	      break;
	    case 'undefined':
	      return '';
	    default:
	      return value.toString();
	  }
	}

	//# 
	},{}],51:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  isNumeric: {get: function() {
	      return isNumeric;
	    }},
	  rangeEach: {get: function() {
	      return rangeEach;
	    }},
	  rangeEachReverse: {get: function() {
	      return rangeEachReverse;
	    }},
	  valueAccordingPercent: {get: function() {
	      return valueAccordingPercent;
	    }},
	  __esModule: {value: true}
	});
	function isNumeric(n) {
	  var t = typeof n;
	  return t == 'number' ? !isNaN(n) && isFinite(n) : t == 'string' ? !n.length ? false : n.length == 1 ? /\d/.test(n) : /^\s*[+-]?\s*(?:(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?)|(?:0x[a-f\d]+))\s*$/i.test(n) : t == 'object' ? !!n && typeof n.valueOf() == 'number' && !(n instanceof Date) : false;
	}
	function rangeEach(rangeFrom, rangeTo, iteratee) {
	  var index = -1;
	  if (typeof rangeTo === 'function') {
	    iteratee = rangeTo;
	    rangeTo = rangeFrom;
	  } else {
	    index = rangeFrom - 1;
	  }
	  while (++index <= rangeTo) {
	    if (iteratee(index) === false) {
	      break;
	    }
	  }
	}
	function rangeEachReverse(rangeFrom, rangeTo, iteratee) {
	  var index = rangeFrom + 1;
	  if (typeof rangeTo === 'function') {
	    iteratee = rangeTo;
	    rangeTo = 0;
	  }
	  while (--index >= rangeTo) {
	    if (iteratee(index) === false) {
	      break;
	    }
	  }
	}
	function valueAccordingPercent(value, percent) {
	  percent = parseInt(percent.toString().replace('%', ''), 10);
	  percent = parseInt(value * percent / 100);
	  return percent;
	}

	//# 
	},{}],52:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  duckSchema: {get: function() {
	      return duckSchema;
	    }},
	  inherit: {get: function() {
	      return inherit;
	    }},
	  extend: {get: function() {
	      return extend;
	    }},
	  deepExtend: {get: function() {
	      return deepExtend;
	    }},
	  deepClone: {get: function() {
	      return deepClone;
	    }},
	  clone: {get: function() {
	      return clone;
	    }},
	  mixin: {get: function() {
	      return mixin;
	    }},
	  isObjectEquals: {get: function() {
	      return isObjectEquals;
	    }},
	  isObject: {get: function() {
	      return isObject;
	    }},
	  getPrototypeOf: {get: function() {
	      return getPrototypeOf;
	    }},
	  defineGetter: {get: function() {
	      return defineGetter;
	    }},
	  objectEach: {get: function() {
	      return objectEach;
	    }},
	  getProperty: {get: function() {
	      return getProperty;
	    }},
	  __esModule: {value: true}
	});
	var $__array__;
	var arrayEach = ($__array__ = _dereq_("array"), $__array__ && $__array__.__esModule && $__array__ || {default: $__array__}).arrayEach;
	function duckSchema(object) {
	  var schema;
	  if (Array.isArray(object)) {
	    schema = [];
	  } else {
	    schema = {};
	    objectEach(object, function(value, key) {
	      if (value && typeof value === 'object' && !Array.isArray(value)) {
	        schema[key] = duckSchema(value);
	      } else if (Array.isArray(value)) {
	        if (value.length && typeof value[0] === 'object' && !Array.isArray(value[0])) {
	          schema[key] = [duckSchema(value[0])];
	        } else {
	          schema[key] = [];
	        }
	      } else {
	        schema[key] = null;
	      }
	    });
	  }
	  return schema;
	}
	function inherit(Child, Parent) {
	  Parent.prototype.constructor = Parent;
	  Child.prototype = new Parent();
	  Child.prototype.constructor = Child;
	  return Child;
	}
	function extend(target, extension) {
	  objectEach(extension, function(value, key) {
	    target[key] = value;
	  });
	  return target;
	}
	function deepExtend(target, extension) {
	  objectEach(extension, function(value, key) {
	    if (extension[key] && typeof extension[key] === 'object') {
	      if (!target[key]) {
	        if (Array.isArray(extension[key])) {
	          target[key] = [];
	        } else if (Object.prototype.toString.call(extension[key]) === '[object Date]') {
	          target[key] = extension[key];
	        } else {
	          target[key] = {};
	        }
	      }
	      deepExtend(target[key], extension[key]);
	    } else {
	      target[key] = extension[key];
	    }
	  });
	}
	function deepClone(obj) {
	  if (typeof obj === 'object') {
	    return JSON.parse(JSON.stringify(obj));
	  }
	  return obj;
	}
	function clone(object) {
	  var result = {};
	  objectEach(object, (function(value, key) {
	    result[key] = value;
	  }));
	  return result;
	}
	function mixin(Base) {
	  for (var mixins = [],
	      $__1 = 1; $__1 < arguments.length; $__1++)
	    mixins[$__1 - 1] = arguments[$__1];
	  if (!Base.MIXINS) {
	    Base.MIXINS = [];
	  }
	  arrayEach(mixins, (function(mixin) {
	    Base.MIXINS.push(mixin.MIXIN_NAME);
	    objectEach(mixin, (function(value, key) {
	      if (Base.prototype[key] !== void 0) {
	        throw new Error(("Mixin conflict. Property '" + key + "' already exist and cannot be overwritten."));
	      }
	      if (typeof value === 'function') {
	        Base.prototype[key] = value;
	      } else {
	        var getter = function _getter(propertyName, initialValue) {
	          propertyName = '_' + propertyName;
	          var initValue = (function(value) {
	            if (Array.isArray(value) || isObject(value)) {
	              value = deepClone(value);
	            }
	            return value;
	          });
	          return function() {
	            if (this[propertyName] === void 0) {
	              this[propertyName] = initValue(initialValue);
	            }
	            return this[propertyName];
	          };
	        };
	        var setter = function _setter(propertyName) {
	          propertyName = '_' + propertyName;
	          return function(value) {
	            this[propertyName] = value;
	          };
	        };
	        Object.defineProperty(Base.prototype, key, {
	          get: getter(key, value),
	          set: setter(key),
	          configurable: true
	        });
	      }
	    }));
	  }));
	  return Base;
	}
	function isObjectEquals(object1, object2) {
	  return JSON.stringify(object1) === JSON.stringify(object2);
	}
	function isObject(obj) {
	  return Object.prototype.toString.call(obj) == '[object Object]';
	}
	function getPrototypeOf(obj) {
	  var prototype;
	  if (typeof obj.__proto__ == 'object') {
	    prototype = obj.__proto__;
	  } else {
	    var oldConstructor,
	        constructor = obj.constructor;
	    if (typeof obj.constructor == 'function') {
	      oldConstructor = constructor;
	      if (delete obj.constructor) {
	        constructor = obj.constructor;
	        obj.constructor = oldConstructor;
	      }
	    }
	    prototype = constructor ? constructor.prototype : null;
	  }
	  return prototype;
	}
	function defineGetter(object, property, value, options) {
	  options.value = value;
	  options.writable = options.writable !== false;
	  options.enumerable = options.enumerable !== false;
	  options.configurable = options.configurable !== false;
	  Object.defineProperty(object, property, options);
	}
	function objectEach(object, iteratee) {
	  for (var key in object) {
	    if (!object.hasOwnProperty || (object.hasOwnProperty && object.hasOwnProperty(key))) {
	      if (iteratee(object[key], key, object) === false) {
	        break;
	      }
	    }
	  }
	  return object;
	}
	function getProperty(object, name) {
	  var names = name.split('.');
	  var result = object;
	  objectEach(names, (function(name) {
	    result = result[name];
	    if (result === void 0) {
	      result = void 0;
	      return false;
	    }
	  }));
	  return result;
	}

	//# 
	},{"array":42}],53:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  columnFactory: {get: function() {
	      return columnFactory;
	    }},
	  __esModule: {value: true}
	});
	var $__object__;
	var inherit = ($__object__ = _dereq_("object"), $__object__ && $__object__.__esModule && $__object__ || {default: $__object__}).inherit;
	function columnFactory(GridSettings, conflictList) {
	  function ColumnSettings() {}
	  ;
	  inherit(ColumnSettings, GridSettings);
	  for (var i = 0,
	      len = conflictList.length; i < len; i++) {
	    ColumnSettings.prototype[conflictList[i]] = void 0;
	  }
	  return ColumnSettings;
	}

	//# 
	},{"object":52}],54:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  toUpperCaseFirst: {get: function() {
	      return toUpperCaseFirst;
	    }},
	  startsWith: {get: function() {
	      return startsWith;
	    }},
	  endsWith: {get: function() {
	      return endsWith;
	    }},
	  equalsIgnoreCase: {get: function() {
	      return equalsIgnoreCase;
	    }},
	  randomString: {get: function() {
	      return randomString;
	    }},
	  isPercentValue: {get: function() {
	      return isPercentValue;
	    }},
	  substitute: {get: function() {
	      return substitute;
	    }},
	  padStart: {get: function() {
	      return padStart;
	    }},
	  __esModule: {value: true}
	});
	var $__mixed__,
	    $__number__;
	var stringify = ($__mixed__ = _dereq_("mixed"), $__mixed__ && $__mixed__.__esModule && $__mixed__ || {default: $__mixed__}).stringify;
	var rangeEach = ($__number__ = _dereq_("number"), $__number__ && $__number__.__esModule && $__number__ || {default: $__number__}).rangeEach;
	function toUpperCaseFirst(string) {
	  return string[0].toUpperCase() + string.substr(1);
	}
	function startsWith(string, needle) {
	  var result = true;
	  rangeEach(needle.length - 1, (function(index) {
	    if (string.charAt(index) !== needle.charAt(index)) {
	      result = false;
	      return false;
	    }
	  }));
	  return result;
	}
	function endsWith(string, needle) {
	  var result = true;
	  var needleLength = needle.length - 1;
	  var stringLength = string.length - 1;
	  rangeEach(needleLength, (function(index) {
	    var stringIndex = stringLength - index;
	    var needleIndex = needleLength - index;
	    if (string.charAt(stringIndex) !== needle.charAt(needleIndex)) {
	      result = false;
	      return false;
	    }
	  }));
	  return result;
	}
	function equalsIgnoreCase() {
	  for (var strings = [],
	      $__2 = 0; $__2 < arguments.length; $__2++)
	    strings[$__2] = arguments[$__2];
	  var unique = [];
	  var length = strings.length;
	  while (length--) {
	    var string = stringify(strings[length]).toLowerCase();
	    if (unique.indexOf(string) === -1) {
	      unique.push(string);
	    }
	  }
	  return unique.length === 1;
	}
	function randomString() {
	  function s4() {
	    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
	  }
	  return s4() + s4() + s4() + s4();
	}
	function isPercentValue(value) {
	  return /^([0-9][0-9]?\%$)|(^100\%$)/.test(value);
	}
	function substitute(template) {
	  var variables = arguments[1] !== (void 0) ? arguments[1] : {};
	  return (template + '').replace(/(?:\\)?\[([^\[\]]+)]/g, function(match, name) {
	    if (match.charAt(0) === '\\') {
	      return match.substr(1, match.length - 1);
	    }
	    return variables[name] === void 0 ? '' : variables[name];
	  });
	}
	function padStart(string, maxLength) {
	  var fillString = arguments[2] !== (void 0) ? arguments[2] : ' ';
	  string = string + '';
	  if (string.length >= maxLength) {
	    return string;
	  }
	  fillString = String(fillString);
	  var fillStringLength = fillString.length;
	  if (!fillStringLength) {
	    fillString = ' ';
	  }
	  var fillLen = maxLength - string.length;
	  var timesToRepeat = Math.ceil(fillLen / fillString.length);
	  var truncatedString = '';
	  rangeEach(timesToRepeat, (function(index) {
	    truncatedString += fillString;
	  }));
	  truncatedString = truncatedString.slice(0, fillLen);
	  return truncatedString + string;
	}
	;

	//# 
	},{"mixed":50,"number":51}],55:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  KEY_CODES: {get: function() {
	      return KEY_CODES;
	    }},
	  isPrintableChar: {get: function() {
	      return isPrintableChar;
	    }},
	  isMetaKey: {get: function() {
	      return isMetaKey;
	    }},
	  isCtrlKey: {get: function() {
	      return isCtrlKey;
	    }},
	  isKey: {get: function() {
	      return isKey;
	    }},
	  __esModule: {value: true}
	});
	var $__array__;
	var arrayEach = ($__array__ = _dereq_("array"), $__array__ && $__array__.__esModule && $__array__ || {default: $__array__}).arrayEach;
	var KEY_CODES = {
	  MOUSE_LEFT: 1,
	  MOUSE_RIGHT: 3,
	  MOUSE_MIDDLE: 2,
	  BACKSPACE: 8,
	  COMMA: 188,
	  INSERT: 45,
	  DELETE: 46,
	  END: 35,
	  ENTER: 13,
	  ESCAPE: 27,
	  CONTROL_LEFT: 91,
	  COMMAND_LEFT: 17,
	  COMMAND_RIGHT: 93,
	  ALT: 18,
	  HOME: 36,
	  PAGE_DOWN: 34,
	  PAGE_UP: 33,
	  PERIOD: 190,
	  SPACE: 32,
	  SHIFT: 16,
	  CAPS_LOCK: 20,
	  TAB: 9,
	  ARROW_RIGHT: 39,
	  ARROW_LEFT: 37,
	  ARROW_UP: 38,
	  ARROW_DOWN: 40,
	  F1: 112,
	  F2: 113,
	  F3: 114,
	  F4: 115,
	  F5: 116,
	  F6: 117,
	  F7: 118,
	  F8: 119,
	  F9: 120,
	  F10: 121,
	  F11: 122,
	  F12: 123,
	  A: 65,
	  X: 88,
	  C: 67,
	  V: 86
	};
	function isPrintableChar(keyCode) {
	  return ((keyCode == 32) || (keyCode >= 48 && keyCode <= 57) || (keyCode >= 96 && keyCode <= 111) || (keyCode >= 186 && keyCode <= 192) || (keyCode >= 219 && keyCode <= 222) || keyCode >= 226 || (keyCode >= 65 && keyCode <= 90));
	}
	function isMetaKey(keyCode) {
	  var metaKeys = [KEY_CODES.ARROW_DOWN, KEY_CODES.ARROW_UP, KEY_CODES.ARROW_LEFT, KEY_CODES.ARROW_RIGHT, KEY_CODES.HOME, KEY_CODES.END, KEY_CODES.DELETE, KEY_CODES.BACKSPACE, KEY_CODES.F1, KEY_CODES.F2, KEY_CODES.F3, KEY_CODES.F4, KEY_CODES.F5, KEY_CODES.F6, KEY_CODES.F7, KEY_CODES.F8, KEY_CODES.F9, KEY_CODES.F10, KEY_CODES.F11, KEY_CODES.F12, KEY_CODES.TAB, KEY_CODES.PAGE_DOWN, KEY_CODES.PAGE_UP, KEY_CODES.ENTER, KEY_CODES.ESCAPE, KEY_CODES.SHIFT, KEY_CODES.CAPS_LOCK, KEY_CODES.ALT];
	  return metaKeys.indexOf(keyCode) !== -1;
	}
	function isCtrlKey(keyCode) {
	  return [KEY_CODES.CONTROL_LEFT, 224, KEY_CODES.COMMAND_LEFT, KEY_CODES.COMMAND_RIGHT].indexOf(keyCode) !== -1;
	}
	function isKey(keyCode, baseCode) {
	  var keys = baseCode.split('|');
	  var result = false;
	  arrayEach(keys, function(key) {
	    if (keyCode === KEY_CODES[key]) {
	      result = true;
	      return false;
	    }
	  });
	  return result;
	}

	//# 
	},{"array":42}],56:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  localHooks: {get: function() {
	      return localHooks;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $___46__46__47_helpers_47_array__,
	    $___46__46__47_helpers_47_object__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var arrayEach = ($___46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47_helpers_47_array__ && $___46__46__47_helpers_47_array__.__esModule && $___46__46__47_helpers_47_array__ || {default: $___46__46__47_helpers_47_array__}).arrayEach;
	var defineGetter = ($___46__46__47_helpers_47_object__ = _dereq_("helpers/object"), $___46__46__47_helpers_47_object__ && $___46__46__47_helpers_47_object__.__esModule && $___46__46__47_helpers_47_object__ || {default: $___46__46__47_helpers_47_object__}).defineGetter;
	var MIXIN_NAME = 'localHooks';
	var localHooks = {
	  _localHooks: Object.create(null),
	  addLocalHook: function(key, callback) {
	    if (!this._localHooks[key]) {
	      this._localHooks[key] = [];
	    }
	    this._localHooks[key].push(callback);
	  },
	  runLocalHooks: function(key) {
	    for (var params = [],
	        $__4 = 1; $__4 < arguments.length; $__4++)
	      params[$__4 - 1] = arguments[$__4];
	    var $__3 = this;
	    if (this._localHooks[key]) {
	      arrayEach(this._localHooks[key], (function(callback) {
	        return callback.apply($__3, params);
	      }));
	    }
	  },
	  clearLocalHooks: function() {
	    this._localHooks = {};
	  }
	};
	defineGetter(localHooks, 'MIXIN_NAME', MIXIN_NAME, {
	  writable: false,
	  enumerable: false
	});
	;
	Handsontable.utils.localHooks = localHooks;

	//# 
	},{"browser":23,"helpers/array":42,"helpers/object":52}],57:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  MultiMap: {get: function() {
	      return MultiMap;
	    }},
	  __esModule: {value: true}
	});
	;
	window.MultiMap = MultiMap;
	function MultiMap() {
	  var map = {
	    arrayMap: [],
	    weakMap: new WeakMap()
	  };
	  return {
	    get: function(key) {
	      if (canBeAnArrayMapKey(key)) {
	        return map.arrayMap[key];
	      } else if (canBeAWeakMapKey(key)) {
	        return map.weakMap.get(key);
	      }
	    },
	    set: function(key, value) {
	      if (canBeAnArrayMapKey(key)) {
	        map.arrayMap[key] = value;
	      } else if (canBeAWeakMapKey(key)) {
	        map.weakMap.set(key, value);
	      } else {
	        throw new Error('Invalid key type');
	      }
	    },
	    delete: function(key) {
	      if (canBeAnArrayMapKey(key)) {
	        delete map.arrayMap[key];
	      } else if (canBeAWeakMapKey(key)) {
	        map.weakMap.delete(key);
	      }
	    }
	  };
	  function canBeAnArrayMapKey(obj) {
	    return obj !== null && !isNaNSymbol(obj) && (typeof obj == 'string' || typeof obj == 'number');
	  }
	  function canBeAWeakMapKey(obj) {
	    return obj !== null && (typeof obj == 'object' || typeof obj == 'function');
	  }
	  function isNaNSymbol(obj) {
	    return obj !== obj;
	  }
	}

	//# 
	},{}],58:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  Hooks: {get: function() {
	      return Hooks;
	    }},
	  __esModule: {value: true}
	});
	var $__helpers_47_array__,
	    $__helpers_47_object__;
	var REGISTERED_HOOKS = ['afterCellMetaReset', 'afterChange', 'afterChangesObserved', 'afterContextMenuDefaultOptions', 'afterContextMenuHide', 'afterContextMenuShow', 'afterCopyLimit', 'afterCreateCol', 'afterCreateRow', 'afterDeselect', 'afterDestroy', 'afterDocumentKeyDown', 'afterGetCellMeta', 'afterGetColHeader', 'afterGetRowHeader', 'afterInit', 'afterLoadData', 'afterMomentumScroll', 'afterOnCellCornerMouseDown', 'afterOnCellMouseDown', 'afterOnCellMouseOver', 'afterRemoveCol', 'afterRemoveRow', 'afterRender', 'beforeRenderer', 'afterRenderer', 'afterScrollHorizontally', 'afterScrollVertically', 'afterSelection', 'afterSelectionByProp', 'afterSelectionEnd', 'afterSelectionEndByProp', 'afterSetCellMeta', 'afterUpdateSettings', 'afterValidate', 'beforeAutofill', 'beforeCellAlignment', 'beforeChange', 'beforeChangeRender', 'beforeDrawBorders', 'beforeGetCellMeta', 'beforeInit', 'beforeInitWalkontable', 'beforeKeyDown', 'beforeOnCellMouseDown', 'beforeOnCellMouseOver', 'beforeRemoveCol', 'beforeRemoveRow', 'beforeRender', 'beforeSetRangeEnd', 'beforeTouchScroll', 'beforeValidate', 'construct', 'init', 'modifyCol', 'unmodifyCol', 'modifyColHeader', 'modifyColWidth', 'modifyRow', 'modifyRowHeader', 'modifyRowHeight', 'persistentStateLoad', 'persistentStateReset', 'persistentStateSave', 'beforeColumnSort', 'afterColumnSort', 'afterAutofillApplyValues', 'modifyCopyableRange', 'beforeColumnMove', 'afterColumnMove', 'beforeRowMove', 'afterRowMove', 'beforeColumnResize', 'afterColumnResize', 'beforeRowResize', 'afterRowResize', 'afterGetColumnHeaderRenderers', 'afterGetRowHeaderRenderers', 'beforeStretchingColumnWidth', 'beforeFilter', 'afterFilter', 'modifyColumnHeaderHeight'];
	var arrayEach = ($__helpers_47_array__ = _dereq_("helpers/array"), $__helpers_47_array__ && $__helpers_47_array__.__esModule && $__helpers_47_array__ || {default: $__helpers_47_array__}).arrayEach;
	var objectEach = ($__helpers_47_object__ = _dereq_("helpers/object"), $__helpers_47_object__ && $__helpers_47_object__.__esModule && $__helpers_47_object__ || {default: $__helpers_47_object__}).objectEach;
	var Hooks = function Hooks() {
	  this.globalBucket = this.createEmptyBucket();
	};
	($traceurRuntime.createClass)(Hooks, {
	  createEmptyBucket: function() {
	    var bucket = Object.create(null);
	    arrayEach(REGISTERED_HOOKS, (function(hook) {
	      return (bucket[hook] = []);
	    }));
	    return bucket;
	  },
	  getBucket: function() {
	    var context = arguments[0] !== (void 0) ? arguments[0] : null;
	    if (context) {
	      if (!context.pluginHookBucket) {
	        context.pluginHookBucket = this.createEmptyBucket();
	      }
	      return context.pluginHookBucket;
	    }
	    return this.globalBucket;
	  },
	  add: function(key, callback) {
	    var context = arguments[2] !== (void 0) ? arguments[2] : null;
	    var $__2 = this;
	    if (Array.isArray(callback)) {
	      arrayEach(callback, (function(c) {
	        return $__2.add(key, c, context);
	      }));
	    } else {
	      var bucket = this.getBucket(context);
	      if (typeof bucket[key] === 'undefined') {
	        this.register(key);
	        bucket[key] = [];
	      }
	      callback.skip = false;
	      if (bucket[key].indexOf(callback) === -1) {
	        bucket[key].push(callback);
	      }
	    }
	    return this;
	  },
	  once: function(key, callback) {
	    var context = arguments[2] !== (void 0) ? arguments[2] : null;
	    var $__2 = this;
	    if (Array.isArray(callback)) {
	      arrayEach(callback, (function(c) {
	        return $__2.once(key, c, context);
	      }));
	    } else {
	      callback.runOnce = true;
	      this.add(key, callback, context);
	    }
	  },
	  remove: function(key, callback) {
	    var context = arguments[2] !== (void 0) ? arguments[2] : null;
	    var bucket = this.getBucket(context);
	    if (typeof bucket[key] !== 'undefined') {
	      if (bucket[key].indexOf(callback) >= 0) {
	        callback.skip = true;
	        return true;
	      }
	    }
	    return false;
	  },
	  has: function(key) {
	    var context = arguments[1] !== (void 0) ? arguments[1] : null;
	    var bucket = this.getBucket(context);
	    return bucket[key] !== void 0 && bucket[key].length ? true : false;
	  },
	  run: function(context, key, p1, p2, p3, p4, p5, p6) {
	    {
	      var globalHandlers = this.globalBucket[key];
	      var index = -1;
	      var length = globalHandlers ? globalHandlers.length : 0;
	      if (length) {
	        while (++index < length) {
	          if (!globalHandlers[index] || globalHandlers[index].skip) {
	            continue;
	          }
	          var res = globalHandlers[index].call(context, p1, p2, p3, p4, p5, p6);
	          if (res !== void 0) {
	            p1 = res;
	          }
	          if (globalHandlers[index] && globalHandlers[index].runOnce) {
	            this.remove(key, globalHandlers[index]);
	          }
	        }
	      }
	    }
	    {
	      var localHandlers = this.getBucket(context)[key];
	      var index$__4 = -1;
	      var length$__5 = localHandlers ? localHandlers.length : 0;
	      if (length$__5) {
	        while (++index$__4 < length$__5) {
	          if (!localHandlers[index$__4] || localHandlers[index$__4].skip) {
	            continue;
	          }
	          var res$__6 = localHandlers[index$__4].call(context, p1, p2, p3, p4, p5, p6);
	          if (res$__6 !== void 0) {
	            p1 = res$__6;
	          }
	          if (localHandlers[index$__4] && localHandlers[index$__4].runOnce) {
	            this.remove(key, localHandlers[index$__4], context);
	          }
	        }
	      }
	    }
	    return p1;
	  },
	  destroy: function() {
	    var context = arguments[0] !== (void 0) ? arguments[0] : null;
	    objectEach(this.getBucket(context), (function(value, key, bucket) {
	      return (bucket[key].length = 0);
	    }));
	  },
	  register: function(key) {
	    if (!this.isRegistered(key)) {
	      REGISTERED_HOOKS.push(key);
	    }
	  },
	  deregister: function(key) {
	    if (this.isRegistered(key)) {
	      REGISTERED_HOOKS.splice(REGISTERED_HOOKS.indexOf(key), 1);
	    }
	  },
	  isRegistered: function(key) {
	    return REGISTERED_HOOKS.indexOf(key) >= 0;
	  },
	  getRegistered: function() {
	    return REGISTERED_HOOKS;
	  }
	}, {});
	;

	//# 
	},{"helpers/array":42,"helpers/object":52}],59:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  registerPlugin: {get: function() {
	      return registerPlugin;
	    }},
	  getPlugin: {get: function() {
	      return getPlugin;
	    }},
	  getRegistredPluginNames: {get: function() {
	      return getRegistredPluginNames;
	    }},
	  getPluginName: {get: function() {
	      return getPluginName;
	    }},
	  __esModule: {value: true}
	});
	var $__browser__,
	    $__helpers_47_object__,
	    $__helpers_47_string__;
	var Handsontable = ($__browser__ = _dereq_("browser"), $__browser__ && $__browser__.__esModule && $__browser__ || {default: $__browser__}).default;
	var objectEach = ($__helpers_47_object__ = _dereq_("helpers/object"), $__helpers_47_object__ && $__helpers_47_object__.__esModule && $__helpers_47_object__ || {default: $__helpers_47_object__}).objectEach;
	var toUpperCaseFirst = ($__helpers_47_string__ = _dereq_("helpers/string"), $__helpers_47_string__ && $__helpers_47_string__.__esModule && $__helpers_47_string__ || {default: $__helpers_47_string__}).toUpperCaseFirst;
	var registeredPlugins = new WeakMap();
	function registerPlugin(pluginName, PluginClass) {
	  pluginName = toUpperCaseFirst(pluginName);
	  Handsontable.plugins[pluginName] = PluginClass;
	  Handsontable.hooks.add('construct', function() {
	    var holder;
	    if (!registeredPlugins.has(this)) {
	      registeredPlugins.set(this, {});
	    }
	    holder = registeredPlugins.get(this);
	    if (!holder[pluginName]) {
	      holder[pluginName] = new PluginClass(this);
	    }
	  });
	  Handsontable.hooks.add('afterDestroy', function() {
	    if (registeredPlugins.has(this)) {
	      var pluginsHolder = registeredPlugins.get(this);
	      objectEach(pluginsHolder, (function(plugin) {
	        return plugin.destroy();
	      }));
	      registeredPlugins.delete(this);
	    }
	  });
	}
	function getPlugin(instance, pluginName) {
	  if (typeof pluginName != 'string') {
	    throw Error('Only strings can be passed as "plugin" parameter');
	  }
	  var _pluginName = toUpperCaseFirst(pluginName);
	  if (!registeredPlugins.has(instance) || !registeredPlugins.get(instance)[_pluginName]) {
	    return void 0;
	  }
	  return registeredPlugins.get(instance)[_pluginName];
	}
	function getRegistredPluginNames(hotInstance) {
	  return registeredPlugins.has(hotInstance) ? Object.keys(registeredPlugins.get(hotInstance)) : [];
	}
	function getPluginName(hotInstance, plugin) {
	  var pluginName = null;
	  if (registeredPlugins.has(hotInstance)) {
	    objectEach(registeredPlugins.get(hotInstance), (function(pluginInstance, name) {
	      if (pluginInstance === plugin) {
	        pluginName = name;
	      }
	    }));
	  }
	  return pluginName;
	}
	;

	//# 
	},{"browser":23,"helpers/object":52,"helpers/string":54}],60:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  default: {get: function() {
	      return $__default;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $___46__46__47_helpers_47_object__,
	    $___46__46__47_helpers_47_array__,
	    $___46__46__47_plugins__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var $__1 = ($___46__46__47_helpers_47_object__ = _dereq_("helpers/object"), $___46__46__47_helpers_47_object__ && $___46__46__47_helpers_47_object__.__esModule && $___46__46__47_helpers_47_object__ || {default: $___46__46__47_helpers_47_object__}),
	    defineGetter = $__1.defineGetter,
	    objectEach = $__1.objectEach;
	var arrayEach = ($___46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47_helpers_47_array__ && $___46__46__47_helpers_47_array__.__esModule && $___46__46__47_helpers_47_array__ || {default: $___46__46__47_helpers_47_array__}).arrayEach;
	var $__3 = ($___46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47_plugins__ && $___46__46__47_plugins__.__esModule && $___46__46__47_plugins__ || {default: $___46__46__47_plugins__}),
	    getRegistredPluginNames = $__3.getRegistredPluginNames,
	    getPluginName = $__3.getPluginName;
	var privatePool = new WeakMap();
	var initializedPlugins = null;
	var BasePlugin = function BasePlugin(hotInstance) {
	  var $__4 = this;
	  defineGetter(this, 'hot', hotInstance, {writable: false});
	  privatePool.set(this, {hooks: {}});
	  initializedPlugins = null;
	  this.pluginName = null;
	  this.pluginsInitializedCallbacks = [];
	  this.isPluginsReady = false;
	  this.enabled = false;
	  this.initialized = false;
	  this.hot.addHook('afterPluginsInitialized', (function() {
	    return $__4.onAfterPluginsInitialized();
	  }));
	  this.hot.addHook('afterUpdateSettings', (function() {
	    return $__4.onUpdateSettings();
	  }));
	  this.hot.addHook('beforeInit', (function() {
	    return $__4.init();
	  }));
	};
	($traceurRuntime.createClass)(BasePlugin, {
	  init: function() {
	    this.pluginName = getPluginName(this.hot, this);
	    if (this.isEnabled && this.isEnabled()) {
	      this.enablePlugin();
	    }
	    if (!initializedPlugins) {
	      initializedPlugins = getRegistredPluginNames(this.hot);
	    }
	    if (initializedPlugins.indexOf(this.pluginName) >= 0) {
	      initializedPlugins.splice(initializedPlugins.indexOf(this.pluginName), 1);
	    }
	    if (!initializedPlugins.length) {
	      this.hot.runHooks('afterPluginsInitialized');
	    }
	    this.initialized = true;
	  },
	  enablePlugin: function() {
	    this.enabled = true;
	  },
	  disablePlugin: function() {
	    if (this.eventManager) {
	      this.eventManager.clear();
	    }
	    this.clearHooks();
	    this.enabled = false;
	  },
	  addHook: function(name, callback) {
	    var hooks = privatePool.get(this).hooks[name] = (privatePool.get(this).hooks[name] || []);
	    this.hot.addHook(name, callback);
	    hooks.push(callback);
	    privatePool.get(this).hooks[name] = hooks;
	  },
	  removeHooks: function(name) {
	    var $__4 = this;
	    arrayEach(privatePool.get(this).hooks[name] || [], (function(callback) {
	      $__4.hot.removeHook(name, callback);
	    }));
	  },
	  clearHooks: function() {
	    var $__4 = this;
	    var hooks = privatePool.get(this).hooks;
	    objectEach(hooks, (function(callbacks, name) {
	      return $__4.removeHooks(name);
	    }));
	    hooks.length = 0;
	  },
	  callOnPluginsReady: function(callback) {
	    if (this.isPluginsReady) {
	      callback();
	    } else {
	      this.pluginsInitializedCallbacks.push(callback);
	    }
	  },
	  onAfterPluginsInitialized: function() {
	    arrayEach(this.pluginsInitializedCallbacks, (function(callback) {
	      return callback();
	    }));
	    this.pluginsInitializedCallbacks.length = 0;
	    this.isPluginsReady = true;
	  },
	  onUpdateSettings: function() {
	    if (this.isEnabled) {
	      if (this.enabled && !this.isEnabled()) {
	        this.disablePlugin();
	      }
	      if (!this.enabled && this.isEnabled()) {
	        this.enablePlugin();
	      }
	      if (this.enabled && this.isEnabled()) {
	        this.updatePlugin();
	      }
	    }
	  },
	  updatePlugin: function() {},
	  destroy: function() {
	    var $__4 = this;
	    if (this.eventManager) {
	      this.eventManager.destroy();
	    }
	    this.clearHooks();
	    objectEach(this, (function(value, property) {
	      if (property !== 'hot') {
	        $__4[property] = null;
	      }
	    }));
	    delete this.hot;
	  }
	}, {});
	var $__default = BasePlugin;
	Handsontable.plugins.BasePlugin = BasePlugin;

	//# 
	},{"browser":23,"helpers/array":42,"helpers/object":52,"plugins":59}],61:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  AutoColumnSize: {get: function() {
	      return AutoColumnSize;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__95_base__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47_helpers_47_feature__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_utils_47_ghostTable__,
	    $___46__46__47__46__46__47_helpers_47_object__,
	    $___46__46__47__46__46__47_helpers_47_number__,
	    $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__46__46__47_utils_47_samplesGenerator__,
	    $___46__46__47__46__46__47_helpers_47_string__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__;
	var BasePlugin = ($___46__46__47__95_base__ = _dereq_("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var $__1 = ($___46__46__47__46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}),
	    arrayEach = $__1.arrayEach,
	    arrayFilter = $__1.arrayFilter;
	var $__2 = ($___46__46__47__46__46__47_helpers_47_feature__ = _dereq_("helpers/feature"), $___46__46__47__46__46__47_helpers_47_feature__ && $___46__46__47__46__46__47_helpers_47_feature__.__esModule && $___46__46__47__46__46__47_helpers_47_feature__ || {default: $___46__46__47__46__46__47_helpers_47_feature__}),
	    cancelAnimationFrame = $__2.cancelAnimationFrame,
	    requestAnimationFrame = $__2.requestAnimationFrame;
	var isVisible = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}).isVisible;
	var GhostTable = ($___46__46__47__46__46__47_utils_47_ghostTable__ = _dereq_("utils/ghostTable"), $___46__46__47__46__46__47_utils_47_ghostTable__ && $___46__46__47__46__46__47_utils_47_ghostTable__.__esModule && $___46__46__47__46__46__47_utils_47_ghostTable__ || {default: $___46__46__47__46__46__47_utils_47_ghostTable__}).GhostTable;
	var $__5 = ($___46__46__47__46__46__47_helpers_47_object__ = _dereq_("helpers/object"), $___46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47_helpers_47_object__}),
	    isObject = $__5.isObject,
	    objectEach = $__5.objectEach;
	var $__6 = ($___46__46__47__46__46__47_helpers_47_number__ = _dereq_("helpers/number"), $___46__46__47__46__46__47_helpers_47_number__ && $___46__46__47__46__46__47_helpers_47_number__.__esModule && $___46__46__47__46__46__47_helpers_47_number__ || {default: $___46__46__47__46__46__47_helpers_47_number__}),
	    valueAccordingPercent = $__6.valueAccordingPercent,
	    rangeEach = $__6.rangeEach;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var SamplesGenerator = ($___46__46__47__46__46__47_utils_47_samplesGenerator__ = _dereq_("utils/samplesGenerator"), $___46__46__47__46__46__47_utils_47_samplesGenerator__ && $___46__46__47__46__46__47_utils_47_samplesGenerator__.__esModule && $___46__46__47__46__46__47_utils_47_samplesGenerator__ || {default: $___46__46__47__46__46__47_utils_47_samplesGenerator__}).SamplesGenerator;
	var isPercentValue = ($___46__46__47__46__46__47_helpers_47_string__ = _dereq_("helpers/string"), $___46__46__47__46__46__47_helpers_47_string__ && $___46__46__47__46__46__47_helpers_47_string__.__esModule && $___46__46__47__46__46__47_helpers_47_string__ || {default: $___46__46__47__46__46__47_helpers_47_string__}).isPercentValue;
	var WalkontableViewportColumnsCalculator = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__ = _dereq_("3rdparty/walkontable/src/calculator/viewportColumns"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__}).WalkontableViewportColumnsCalculator;
	var AutoColumnSize = function AutoColumnSize(hotInstance) {
	  var $__11 = this;
	  $traceurRuntime.superConstructor($AutoColumnSize).call(this, hotInstance);
	  this.widths = [];
	  this.ghostTable = new GhostTable(this.hot);
	  this.samplesGenerator = new SamplesGenerator((function(row, col) {
	    return $__11.hot.getDataAtCell(row, col);
	  }));
	  this.firstCalculation = true;
	  this.inProgress = false;
	  this.addHook('beforeColumnResize', (function(col, size, isDblClick) {
	    return $__11.onBeforeColumnResize(col, size, isDblClick);
	  }));
	};
	var $AutoColumnSize = AutoColumnSize;
	($traceurRuntime.createClass)(AutoColumnSize, {
	  isEnabled: function() {
	    return this.hot.getSettings().autoColumnSize !== false && !this.hot.getSettings().colWidths;
	  },
	  enablePlugin: function() {
	    var $__11 = this;
	    if (this.enabled) {
	      return;
	    }
	    var setting = this.hot.getSettings().autoColumnSize;
	    var samplingRatio = setting && setting.hasOwnProperty('samplingRatio') ? this.hot.getSettings().autoColumnSize.samplingRatio : void 0;
	    if (samplingRatio && !isNaN(samplingRatio)) {
	      this.samplesGenerator.customSampleCount = parseInt(samplingRatio, 10);
	    }
	    if (setting && setting.useHeaders != null) {
	      this.ghostTable.setSetting('useHeaders', setting.useHeaders);
	    }
	    this.addHook('afterLoadData', (function() {
	      return $__11.onAfterLoadData();
	    }));
	    this.addHook('beforeChange', (function(changes) {
	      return $__11.onBeforeChange(changes);
	    }));
	    this.addHook('beforeRender', (function(force) {
	      return $__11.onBeforeRender(force);
	    }));
	    this.addHook('modifyColWidth', (function(width, col) {
	      return $__11.getColumnWidth(col, width);
	    }));
	    $traceurRuntime.superGet(this, $AutoColumnSize.prototype, "enablePlugin").call(this);
	  },
	  disablePlugin: function() {
	    $traceurRuntime.superGet(this, $AutoColumnSize.prototype, "disablePlugin").call(this);
	  },
	  calculateColumnsWidth: function() {
	    var colRange = arguments[0] !== (void 0) ? arguments[0] : {
	      from: 0,
	      to: this.hot.countCols() - 1
	    };
	    var rowRange = arguments[1] !== (void 0) ? arguments[1] : {
	      from: 0,
	      to: this.hot.countRows() - 1
	    };
	    var force = arguments[2] !== (void 0) ? arguments[2] : false;
	    var $__11 = this;
	    if (typeof colRange === 'number') {
	      colRange = {
	        from: colRange,
	        to: colRange
	      };
	    }
	    if (typeof rowRange === 'number') {
	      rowRange = {
	        from: rowRange,
	        to: rowRange
	      };
	    }
	    rangeEach(colRange.from, colRange.to, (function(col) {
	      if (force || ($__11.widths[col] === void 0 && !$__11.hot._getColWidthFromSettings(col))) {
	        var samples = $__11.samplesGenerator.generateColumnSamples(col, rowRange);
	        samples.forEach((function(sample, col) {
	          return $__11.ghostTable.addColumn(col, sample);
	        }));
	      }
	    }));
	    if (this.ghostTable.columns.length) {
	      this.ghostTable.getWidths((function(col, width) {
	        return $__11.widths[col] = width;
	      }));
	      this.ghostTable.clean();
	    }
	  },
	  calculateAllColumnsWidth: function() {
	    var rowRange = arguments[0] !== (void 0) ? arguments[0] : {
	      from: 0,
	      to: this.hot.countRows() - 1
	    };
	    var $__11 = this;
	    var current = 0;
	    var length = this.hot.countCols() - 1;
	    var timer = null;
	    this.inProgress = true;
	    var loop = (function() {
	      if (!$__11.hot) {
	        cancelAnimationFrame(timer);
	        $__11.inProgress = false;
	        return;
	      }
	      $__11.calculateColumnsWidth({
	        from: current,
	        to: Math.min(current + $AutoColumnSize.CALCULATION_STEP, length)
	      }, rowRange);
	      current = current + $AutoColumnSize.CALCULATION_STEP + 1;
	      if (current < length) {
	        timer = requestAnimationFrame(loop);
	      } else {
	        cancelAnimationFrame(timer);
	        $__11.inProgress = false;
	        $__11.hot.view.wt.wtOverlays.adjustElementsSize(true);
	        if ($__11.hot.view.wt.wtOverlays.leftOverlay.needFullRender) {
	          $__11.hot.view.wt.wtOverlays.leftOverlay.clone.draw();
	        }
	      }
	    });
	    if (this.firstCalculation && this.getSyncCalculationLimit()) {
	      this.calculateColumnsWidth({
	        from: 0,
	        to: this.getSyncCalculationLimit()
	      }, rowRange);
	      this.firstCalculation = false;
	      current = this.getSyncCalculationLimit() + 1;
	    }
	    if (current < length) {
	      loop();
	    } else {
	      this.inProgress = false;
	    }
	  },
	  recalculateAllColumnsWidth: function() {
	    if (this.hot.view && isVisible(this.hot.view.wt.wtTable.TABLE)) {
	      this.clearCache();
	      this.calculateAllColumnsWidth();
	    }
	  },
	  getSyncCalculationLimit: function() {
	    var limit = $AutoColumnSize.SYNC_CALCULATION_LIMIT;
	    var colsLimit = this.hot.countCols() - 1;
	    if (isObject(this.hot.getSettings().autoColumnSize)) {
	      limit = this.hot.getSettings().autoColumnSize.syncLimit;
	      if (isPercentValue(limit)) {
	        limit = valueAccordingPercent(colsLimit, limit);
	      } else {
	        limit = limit >> 0;
	      }
	    }
	    return Math.min(limit, colsLimit);
	  },
	  getColumnWidth: function(col) {
	    var defaultWidth = arguments[1];
	    var keepMinimum = arguments[2] !== (void 0) ? arguments[2] : true;
	    var width = defaultWidth;
	    if (width === void 0) {
	      width = this.widths[col];
	      if (keepMinimum && typeof width === 'number') {
	        width = Math.max(width, WalkontableViewportColumnsCalculator.DEFAULT_WIDTH);
	      }
	    }
	    return width;
	  },
	  getFirstVisibleColumn: function() {
	    var wot = this.hot.view.wt;
	    if (wot.wtViewport.columnsVisibleCalculator) {
	      return wot.wtTable.getFirstVisibleColumn();
	    }
	    if (wot.wtViewport.columnsRenderCalculator) {
	      return wot.wtTable.getFirstRenderedColumn();
	    }
	    return -1;
	  },
	  getLastVisibleColumn: function() {
	    var wot = this.hot.view.wt;
	    if (wot.wtViewport.columnsVisibleCalculator) {
	      return wot.wtTable.getLastVisibleColumn();
	    }
	    if (wot.wtViewport.columnsRenderCalculator) {
	      return wot.wtTable.getLastRenderedColumn();
	    }
	    return -1;
	  },
	  clearCache: function() {
	    this.widths.length = 0;
	  },
	  isNeedRecalculate: function() {
	    return arrayFilter(this.widths, (function(item) {
	      return (item === void 0);
	    })).length ? true : false;
	  },
	  onBeforeRender: function() {
	    var force = this.hot.renderCall;
	    var rowsCount = this.hot.countRows();
	    if (!rowsCount) {
	      return;
	    }
	    this.calculateColumnsWidth({
	      from: this.getFirstVisibleColumn(),
	      to: this.getLastVisibleColumn()
	    }, void 0, force);
	    if (this.isNeedRecalculate() && !this.inProgress) {
	      this.calculateAllColumnsWidth();
	    }
	  },
	  onAfterLoadData: function() {
	    var $__11 = this;
	    if (this.hot.view) {
	      this.recalculateAllColumnsWidth();
	    } else {
	      setTimeout((function() {
	        if ($__11.hot) {
	          $__11.recalculateAllColumnsWidth();
	        }
	      }), 0);
	    }
	  },
	  onBeforeChange: function(changes) {
	    var $__11 = this;
	    arrayEach(changes, (function(data) {
	      return $__11.widths[$__11.hot.propToCol(data[1])] = void 0;
	    }));
	  },
	  onBeforeColumnResize: function(col, size, isDblClick) {
	    if (isDblClick) {
	      this.calculateColumnsWidth(col, void 0, true);
	      size = this.getColumnWidth(col, void 0, false);
	    }
	    return size;
	  },
	  destroy: function() {
	    this.ghostTable.clean();
	    $traceurRuntime.superGet(this, $AutoColumnSize.prototype, "destroy").call(this);
	  }
	}, {
	  get CALCULATION_STEP() {
	    return 50;
	  },
	  get SYNC_CALCULATION_LIMIT() {
	    return 50;
	  }
	}, BasePlugin);
	;
	registerPlugin('autoColumnSize', AutoColumnSize);

	//# 
	},{"3rdparty/walkontable/src/calculator/viewportColumns":3,"_base":60,"helpers/array":42,"helpers/dom/element":46,"helpers/feature":48,"helpers/number":51,"helpers/object":52,"helpers/string":54,"plugins":59,"utils/ghostTable":102,"utils/samplesGenerator":104}],62:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  AutoRowSize: {get: function() {
	      return AutoRowSize;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__95_base__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47_helpers_47_feature__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_utils_47_ghostTable__,
	    $___46__46__47__46__46__47_helpers_47_object__,
	    $___46__46__47__46__46__47_helpers_47_number__,
	    $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__46__46__47_utils_47_samplesGenerator__,
	    $___46__46__47__46__46__47_helpers_47_string__;
	var BasePlugin = ($___46__46__47__95_base__ = _dereq_("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var $__1 = ($___46__46__47__46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}),
	    arrayEach = $__1.arrayEach,
	    arrayFilter = $__1.arrayFilter;
	var $__2 = ($___46__46__47__46__46__47_helpers_47_feature__ = _dereq_("helpers/feature"), $___46__46__47__46__46__47_helpers_47_feature__ && $___46__46__47__46__46__47_helpers_47_feature__.__esModule && $___46__46__47__46__46__47_helpers_47_feature__ || {default: $___46__46__47__46__46__47_helpers_47_feature__}),
	    cancelAnimationFrame = $__2.cancelAnimationFrame,
	    requestAnimationFrame = $__2.requestAnimationFrame;
	var isVisible = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}).isVisible;
	var GhostTable = ($___46__46__47__46__46__47_utils_47_ghostTable__ = _dereq_("utils/ghostTable"), $___46__46__47__46__46__47_utils_47_ghostTable__ && $___46__46__47__46__46__47_utils_47_ghostTable__.__esModule && $___46__46__47__46__46__47_utils_47_ghostTable__ || {default: $___46__46__47__46__46__47_utils_47_ghostTable__}).GhostTable;
	var $__5 = ($___46__46__47__46__46__47_helpers_47_object__ = _dereq_("helpers/object"), $___46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47_helpers_47_object__}),
	    isObject = $__5.isObject,
	    objectEach = $__5.objectEach;
	var $__6 = ($___46__46__47__46__46__47_helpers_47_number__ = _dereq_("helpers/number"), $___46__46__47__46__46__47_helpers_47_number__ && $___46__46__47__46__46__47_helpers_47_number__.__esModule && $___46__46__47__46__46__47_helpers_47_number__ || {default: $___46__46__47__46__46__47_helpers_47_number__}),
	    valueAccordingPercent = $__6.valueAccordingPercent,
	    rangeEach = $__6.rangeEach;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var SamplesGenerator = ($___46__46__47__46__46__47_utils_47_samplesGenerator__ = _dereq_("utils/samplesGenerator"), $___46__46__47__46__46__47_utils_47_samplesGenerator__ && $___46__46__47__46__46__47_utils_47_samplesGenerator__.__esModule && $___46__46__47__46__46__47_utils_47_samplesGenerator__ || {default: $___46__46__47__46__46__47_utils_47_samplesGenerator__}).SamplesGenerator;
	var isPercentValue = ($___46__46__47__46__46__47_helpers_47_string__ = _dereq_("helpers/string"), $___46__46__47__46__46__47_helpers_47_string__ && $___46__46__47__46__46__47_helpers_47_string__.__esModule && $___46__46__47__46__46__47_helpers_47_string__ || {default: $___46__46__47__46__46__47_helpers_47_string__}).isPercentValue;
	var AutoRowSize = function AutoRowSize(hotInstance) {
	  var $__10 = this;
	  $traceurRuntime.superConstructor($AutoRowSize).call(this, hotInstance);
	  this.heights = [];
	  this.ghostTable = new GhostTable(this.hot);
	  this.samplesGenerator = new SamplesGenerator((function(row, col) {
	    if (row >= 0) {
	      return $__10.hot.getDataAtCell(row, col);
	    } else if (row === -1) {
	      return $__10.hot.getColHeader(col);
	    } else {
	      return null;
	    }
	  }));
	  this.firstCalculation = true;
	  this.inProgress = false;
	  this.addHook('beforeRowResize', (function(row, size, isDblClick) {
	    return $__10.onBeforeRowResize(row, size, isDblClick);
	  }));
	};
	var $AutoRowSize = AutoRowSize;
	($traceurRuntime.createClass)(AutoRowSize, {
	  isEnabled: function() {
	    return this.hot.getSettings().autoRowSize === true || isObject(this.hot.getSettings().autoRowSize);
	  },
	  enablePlugin: function() {
	    var $__10 = this;
	    if (this.enabled) {
	      return;
	    }
	    var setting = this.hot.getSettings().autoRowSize;
	    var samplingRatio = setting && setting.hasOwnProperty('samplingRatio') ? this.hot.getSettings().autoRowSize.samplingRatio : void 0;
	    if (samplingRatio && !isNaN(samplingRatio)) {
	      this.samplesGenerator.customSampleCount = parseInt(samplingRatio, 10);
	    }
	    this.addHook('afterLoadData', (function() {
	      return $__10.onAfterLoadData();
	    }));
	    this.addHook('beforeChange', (function(changes) {
	      return $__10.onBeforeChange(changes);
	    }));
	    this.addHook('beforeColumnMove', (function() {
	      return $__10.recalculateAllRowsHeight();
	    }));
	    this.addHook('beforeColumnResize', (function() {
	      return $__10.recalculateAllRowsHeight();
	    }));
	    this.addHook('beforeColumnSort', (function() {
	      return $__10.clearCache();
	    }));
	    this.addHook('beforeRender', (function(force) {
	      return $__10.onBeforeRender(force);
	    }));
	    this.addHook('beforeRowMove', (function(rowStart, rowEnd) {
	      return $__10.onBeforeRowMove(rowStart, rowEnd);
	    }));
	    this.addHook('modifyRowHeight', (function(height, row) {
	      return $__10.getRowHeight(row, height);
	    }));
	    this.addHook('modifyColumnHeaderHeight', (function() {
	      return $__10.getColumnHeaderHeight();
	    }));
	    $traceurRuntime.superGet(this, $AutoRowSize.prototype, "enablePlugin").call(this);
	  },
	  disablePlugin: function() {
	    $traceurRuntime.superGet(this, $AutoRowSize.prototype, "disablePlugin").call(this);
	  },
	  calculateRowsHeight: function() {
	    var rowRange = arguments[0] !== (void 0) ? arguments[0] : {
	      from: 0,
	      to: this.hot.countRows() - 1
	    };
	    var colRange = arguments[1] !== (void 0) ? arguments[1] : {
	      from: 0,
	      to: this.hot.countCols() - 1
	    };
	    var force = arguments[2] !== (void 0) ? arguments[2] : false;
	    var $__10 = this;
	    if (typeof rowRange === 'number') {
	      rowRange = {
	        from: rowRange,
	        to: rowRange
	      };
	    }
	    if (typeof colRange === 'number') {
	      colRange = {
	        from: colRange,
	        to: colRange
	      };
	    }
	    if (this.hot.getColHeader(0) !== null) {
	      var samples = this.samplesGenerator.generateRowSamples(-1, colRange);
	      this.ghostTable.addColumnHeadersRow(samples.get(-1));
	    }
	    rangeEach(rowRange.from, rowRange.to, (function(row) {
	      if (force || $__10.heights[row] === void 0) {
	        var samples = $__10.samplesGenerator.generateRowSamples(row, colRange);
	        samples.forEach((function(sample, row) {
	          return $__10.ghostTable.addRow(row, sample);
	        }));
	      }
	    }));
	    if (this.ghostTable.rows.length) {
	      this.ghostTable.getHeights((function(row, height) {
	        return $__10.heights[row] = height;
	      }));
	      this.ghostTable.clean();
	    }
	  },
	  calculateAllRowsHeight: function() {
	    var colRange = arguments[0] !== (void 0) ? arguments[0] : {
	      from: 0,
	      to: this.hot.countCols() - 1
	    };
	    var $__10 = this;
	    var current = 0;
	    var length = this.hot.countRows() - 1;
	    var timer = null;
	    this.inProgress = true;
	    var loop = (function() {
	      if (!$__10.hot) {
	        cancelAnimationFrame(timer);
	        $__10.inProgress = false;
	        return;
	      }
	      $__10.calculateRowsHeight({
	        from: current,
	        to: Math.min(current + $AutoRowSize.CALCULATION_STEP, length)
	      }, colRange);
	      current = current + $AutoRowSize.CALCULATION_STEP + 1;
	      if (current < length) {
	        timer = requestAnimationFrame(loop);
	      } else {
	        cancelAnimationFrame(timer);
	        $__10.inProgress = false;
	        $__10.hot.view.wt.wtOverlays.adjustElementsSize(true);
	        if ($__10.hot.view.wt.wtOverlays.leftOverlay.needFullRender) {
	          $__10.hot.view.wt.wtOverlays.leftOverlay.clone.draw();
	        }
	      }
	    });
	    if (this.firstCalculation && this.getSyncCalculationLimit()) {
	      this.calculateRowsHeight({
	        from: 0,
	        to: this.getSyncCalculationLimit()
	      }, colRange);
	      this.firstCalculation = false;
	      current = this.getSyncCalculationLimit() + 1;
	    }
	    if (current < length) {
	      loop();
	    } else {
	      this.inProgress = false;
	    }
	  },
	  recalculateAllRowsHeight: function() {
	    if (isVisible(this.hot.view.wt.wtTable.TABLE)) {
	      this.clearCache();
	      this.calculateAllRowsHeight();
	    }
	  },
	  getSyncCalculationLimit: function() {
	    var limit = $AutoRowSize.SYNC_CALCULATION_LIMIT;
	    var rowsLimit = this.hot.countRows() - 1;
	    if (isObject(this.hot.getSettings().autoRowSize)) {
	      limit = this.hot.getSettings().autoRowSize.syncLimit;
	      if (isPercentValue(limit)) {
	        limit = valueAccordingPercent(rowsLimit, limit);
	      } else {
	        limit = limit >> 0;
	      }
	    }
	    return Math.min(limit, rowsLimit);
	  },
	  getRowHeight: function(row) {
	    var defaultHeight = arguments[1];
	    var height = defaultHeight;
	    if (this.heights[row] !== void 0 && this.heights[row] > (defaultHeight || 0)) {
	      height = this.heights[row];
	    }
	    return height;
	  },
	  getColumnHeaderHeight: function() {
	    return this.heights[-1];
	  },
	  getFirstVisibleRow: function() {
	    var wot = this.hot.view.wt;
	    if (wot.wtViewport.rowsVisibleCalculator) {
	      return wot.wtTable.getFirstVisibleRow();
	    }
	    if (wot.wtViewport.rowsRenderCalculator) {
	      return wot.wtTable.getFirstRenderedRow();
	    }
	    return -1;
	  },
	  getLastVisibleRow: function() {
	    var wot = this.hot.view.wt;
	    if (wot.wtViewport.rowsVisibleCalculator) {
	      return wot.wtTable.getLastVisibleRow();
	    }
	    if (wot.wtViewport.rowsRenderCalculator) {
	      return wot.wtTable.getLastRenderedRow();
	    }
	    return -1;
	  },
	  clearCache: function() {
	    this.heights.length = 0;
	    this.heights[-1] = void 0;
	  },
	  clearCacheByRange: function(range) {
	    var $__10 = this;
	    if (typeof range === 'number') {
	      range = {
	        from: range,
	        to: range
	      };
	    }
	    rangeEach(Math.min(range.from, range.to), Math.max(range.from, range.to), (function(row) {
	      return $__10.heights[row] = void 0;
	    }));
	  },
	  isNeedRecalculate: function() {
	    return arrayFilter(this.heights, (function(item) {
	      return (item === void 0);
	    })).length ? true : false;
	  },
	  onBeforeRender: function() {
	    var force = this.hot.renderCall;
	    this.calculateRowsHeight({
	      from: this.getFirstVisibleRow(),
	      to: this.getLastVisibleRow()
	    }, void 0, force);
	    var fixedRowsBottom = this.hot.getSettings().fixedRowsBottom;
	    if (fixedRowsBottom) {
	      var totalRows = this.hot.countRows() - 1;
	      this.calculateRowsHeight({
	        from: totalRows - fixedRowsBottom,
	        to: totalRows
	      });
	    }
	    if (this.isNeedRecalculate() && !this.inProgress) {
	      this.calculateAllRowsHeight();
	    }
	  },
	  onBeforeRowMove: function(from, to) {
	    this.clearCacheByRange({
	      from: from,
	      to: to
	    });
	    this.calculateAllRowsHeight();
	  },
	  onBeforeRowResize: function(row, size, isDblClick) {
	    if (isDblClick) {
	      this.calculateRowsHeight(row, void 0, true);
	      size = this.getRowHeight(row);
	    }
	    return size;
	  },
	  onAfterLoadData: function() {
	    var $__10 = this;
	    if (this.hot.view) {
	      this.recalculateAllRowsHeight();
	    } else {
	      setTimeout((function() {
	        if ($__10.hot) {
	          $__10.recalculateAllRowsHeight();
	        }
	      }), 0);
	    }
	  },
	  onBeforeChange: function(changes) {
	    var range = null;
	    if (changes.length === 1) {
	      range = changes[0][0];
	    } else if (changes.length > 1) {
	      range = {
	        from: changes[0][0],
	        to: changes[changes.length - 1][0]
	      };
	    }
	    if (range !== null) {
	      this.clearCacheByRange(range);
	    }
	  },
	  destroy: function() {
	    this.ghostTable.clean();
	    $traceurRuntime.superGet(this, $AutoRowSize.prototype, "destroy").call(this);
	  }
	}, {
	  get CALCULATION_STEP() {
	    return 50;
	  },
	  get SYNC_CALCULATION_LIMIT() {
	    return 500;
	  }
	}, BasePlugin);
	;
	registerPlugin('autoRowSize', AutoRowSize);

	//# 
	},{"_base":60,"helpers/array":42,"helpers/dom/element":46,"helpers/feature":48,"helpers/number":51,"helpers/object":52,"helpers/string":54,"plugins":59,"utils/ghostTable":102,"utils/samplesGenerator":104}],63:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  Autofill: {get: function() {
	      return Autofill;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var $__1 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    offset = $__1.offset,
	    outerHeight = $__1.outerHeight,
	    outerWidth = $__1.outerWidth;
	var eventManagerObject = ($___46__46__47__46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).eventManager;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var WalkontableCellCoords = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ = _dereq_("3rdparty/walkontable/src/cell/coords"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	;
	function getDeltas(start, end, data, direction) {
	  var rlength = data.length,
	      clength = data ? data[0].length : 0,
	      deltas = [],
	      arr = [],
	      diffRow,
	      diffCol,
	      startValue,
	      endValue,
	      delta;
	  diffRow = end.row - start.row;
	  diffCol = end.col - start.col;
	  if (['down', 'up'].indexOf(direction) !== -1) {
	    for (var col = 0; col <= diffCol; col++) {
	      startValue = parseInt(data[0][col], 10);
	      endValue = parseInt(data[rlength - 1][col], 10);
	      delta = (direction === 'down' ? (endValue - startValue) : (startValue - endValue)) / (rlength - 1) || 0;
	      arr.push(delta);
	    }
	    deltas.push(arr);
	  }
	  if (['right', 'left'].indexOf(direction) !== -1) {
	    for (var row = 0; row <= diffRow; row++) {
	      startValue = parseInt(data[row][0], 10);
	      endValue = parseInt(data[row][clength - 1], 10);
	      delta = (direction === 'right' ? (endValue - startValue) : (startValue - endValue)) / (clength - 1) || 0;
	      arr = [];
	      arr.push(delta);
	      deltas.push(arr);
	    }
	  }
	  return deltas;
	}
	function Autofill(instance) {
	  var _this = this,
	      mouseDownOnCellCorner = false,
	      wtOnCellCornerMouseDown,
	      wtOnCellMouseOver,
	      eventManager;
	  this.instance = instance;
	  this.addingStarted = false;
	  eventManager = eventManagerObject(instance);
	  function mouseUpCallback(event) {
	    if (!instance.autofill) {
	      return true;
	    }
	    if (instance.autofill.handle && instance.autofill.handle.isDragged) {
	      if (instance.autofill.handle.isDragged > 1) {
	        instance.autofill.apply();
	      }
	      instance.autofill.handle.isDragged = 0;
	      mouseDownOnCellCorner = false;
	    }
	  }
	  function mouseMoveCallback(event) {
	    var tableBottom,
	        tableRight;
	    if (!_this.instance.autofill) {
	      return false;
	    }
	    tableBottom = offset(_this.instance.table).top - (window.pageYOffset || document.documentElement.scrollTop) + outerHeight(_this.instance.table);
	    tableRight = offset(_this.instance.table).left - (window.pageXOffset || document.documentElement.scrollLeft) + outerWidth(_this.instance.table);
	    if (_this.addingStarted === false && _this.instance.autofill.handle.isDragged > 0 && event.clientY > tableBottom && event.clientX <= tableRight) {
	      _this.instance.mouseDragOutside = true;
	      _this.addingStarted = true;
	    } else {
	      _this.instance.mouseDragOutside = false;
	    }
	    if (_this.instance.mouseDragOutside && settings('autoInsertRow')) {
	      setTimeout(function() {
	        _this.addingStarted = false;
	        _this.instance.alter('insert_row');
	      }, 200);
	    }
	  }
	  eventManager.addEventListener(document, 'mouseup', mouseUpCallback);
	  eventManager.addEventListener(document, 'mousemove', mouseMoveCallback);
	  wtOnCellCornerMouseDown = this.instance.view.wt.wtSettings.settings.onCellCornerMouseDown;
	  this.instance.view.wt.wtSettings.settings.onCellCornerMouseDown = function(event) {
	    instance.autofill.handle.isDragged = 1;
	    mouseDownOnCellCorner = true;
	    wtOnCellCornerMouseDown(event);
	  };
	  wtOnCellMouseOver = this.instance.view.wt.wtSettings.settings.onCellMouseOver;
	  this.instance.view.wt.wtSettings.settings.onCellMouseOver = function(event, coords, TD, wt) {
	    if (instance.autofill && mouseDownOnCellCorner && !instance.view.isMouseDown() && instance.autofill.handle && instance.autofill.handle.isDragged) {
	      instance.autofill.handle.isDragged++;
	      instance.autofill.showBorder(coords);
	      instance.autofill.checkIfNewRowNeeded();
	    }
	    wtOnCellMouseOver(event, coords, TD, wt);
	  };
	  this.instance.view.wt.wtSettings.settings.onCellCornerDblClick = function() {
	    instance.autofill.selectAdjacent();
	  };
	}
	Autofill.prototype.init = function() {
	  this.handle = {};
	};
	Autofill.prototype.disable = function() {
	  this.handle.disabled = true;
	};
	Autofill.prototype.selectAdjacent = function() {
	  var select,
	      data,
	      r,
	      maxR,
	      c;
	  if (this.instance.selection.isMultiple()) {
	    select = this.instance.view.wt.selections.area.getCorners();
	  } else {
	    select = this.instance.view.wt.selections.current.getCorners();
	  }
	  data = this.instance.getData();
	  rows: for (r = select[2] + 1; r < this.instance.countRows(); r++) {
	    for (c = select[1]; c <= select[3]; c++) {
	      if (data[r][c]) {
	        break rows;
	      }
	    }
	    if (!!data[r][select[1] - 1] || !!data[r][select[3] + 1]) {
	      maxR = r;
	    }
	  }
	  if (maxR) {
	    this.instance.view.wt.selections.fill.clear();
	    this.instance.view.wt.selections.fill.add(new WalkontableCellCoords(select[0], select[1]));
	    this.instance.view.wt.selections.fill.add(new WalkontableCellCoords(maxR, select[3]));
	    this.apply();
	  }
	};
	Autofill.prototype.apply = function() {
	  var drag,
	      select,
	      start,
	      end,
	      _data,
	      direction,
	      deltas,
	      selRange;
	  this.handle.isDragged = 0;
	  if (this.instance.view.wt.selections.fill.isEmpty()) {
	    return;
	  }
	  drag = this.instance.view.wt.selections.fill.getCorners();
	  this.instance.view.wt.selections.fill.clear();
	  if (this.instance.selection.isMultiple()) {
	    select = this.instance.view.wt.selections.area.getCorners();
	  } else {
	    select = this.instance.view.wt.selections.current.getCorners();
	  }
	  Handsontable.hooks.run(this.instance, 'afterAutofillApplyValues', select, drag);
	  if (drag[0] === select[0] && drag[1] < select[1]) {
	    direction = 'left';
	    start = new WalkontableCellCoords(drag[0], drag[1]);
	    end = new WalkontableCellCoords(drag[2], select[1] - 1);
	  } else if (drag[0] === select[0] && drag[3] > select[3]) {
	    direction = 'right';
	    start = new WalkontableCellCoords(drag[0], select[3] + 1);
	    end = new WalkontableCellCoords(drag[2], drag[3]);
	  } else if (drag[0] < select[0] && drag[1] === select[1]) {
	    direction = 'up';
	    start = new WalkontableCellCoords(drag[0], drag[1]);
	    end = new WalkontableCellCoords(select[0] - 1, drag[3]);
	  } else if (drag[2] > select[2] && drag[1] === select[1]) {
	    direction = 'down';
	    start = new WalkontableCellCoords(select[2] + 1, drag[1]);
	    end = new WalkontableCellCoords(drag[2], drag[3]);
	  }
	  if (start && start.row > -1 && start.col > -1) {
	    selRange = {
	      from: this.instance.getSelectedRange().from,
	      to: this.instance.getSelectedRange().to
	    };
	    _data = this.instance.getData(selRange.from.row, selRange.from.col, selRange.to.row, selRange.to.col);
	    deltas = getDeltas(start, end, _data, direction);
	    Handsontable.hooks.run(this.instance, 'beforeAutofill', start, end, _data);
	    this.instance.populateFromArray(start.row, start.col, _data, end.row, end.col, 'autofill', null, direction, deltas);
	    this.instance.selection.setRangeStart(new WalkontableCellCoords(drag[0], drag[1]));
	    this.instance.selection.setRangeEnd(new WalkontableCellCoords(drag[2], drag[3]));
	  } else {
	    this.instance.selection.refreshBorders();
	  }
	};
	Autofill.prototype.showBorder = function(coords) {
	  var topLeft = this.instance.getSelectedRange().getTopLeftCorner(),
	      bottomRight = this.instance.getSelectedRange().getBottomRightCorner();
	  if (settings('direction') !== 'horizontal' && (bottomRight.row < coords.row || topLeft.row > coords.row)) {
	    coords = new WalkontableCellCoords(coords.row, bottomRight.col);
	  } else if (settings('direction') !== 'vertical') {
	    coords = new WalkontableCellCoords(bottomRight.row, coords.col);
	  } else {
	    return;
	  }
	  this.instance.view.wt.selections.fill.clear();
	  this.instance.view.wt.selections.fill.add(this.instance.getSelectedRange().from);
	  this.instance.view.wt.selections.fill.add(this.instance.getSelectedRange().to);
	  this.instance.view.wt.selections.fill.add(coords);
	  this.instance.view.render();
	};
	Autofill.prototype.checkIfNewRowNeeded = function() {
	  var fillCorners,
	      selection,
	      tableRows = this.instance.countRows(),
	      that = this;
	  if (this.instance.view.wt.selections.fill.cellRange && this.addingStarted === false && settings('autoInsertRow')) {
	    selection = this.instance.getSelected();
	    fillCorners = this.instance.view.wt.selections.fill.getCorners();
	    if (selection[2] < tableRows - 1 && fillCorners[2] === tableRows - 1) {
	      this.addingStarted = true;
	      this.instance._registerTimeout(setTimeout(function() {
	        that.instance.alter('insert_row');
	        that.addingStarted = false;
	      }, 200));
	    }
	  }
	};
	Handsontable.hooks.add('afterInit', function() {
	  var autofill = new Autofill(this);
	  settings = settingsFactory(this.getSettings().fillHandle);
	  if (settings('fillHandle') !== void 0) {
	    if (autofill.handle && settings('fillHandle') === false) {
	      autofill.disable();
	    } else if (!autofill.handle && settings('fillHandle') !== false) {
	      this.autofill = autofill;
	      this.autofill.init();
	    }
	  }
	});
	var settings;
	function settingsFactory(settings) {
	  return function(key) {
	    var result;
	    if (key === 'direction') {
	      if (typeof settings === 'string') {
	        result = settings;
	      } else if (typeof settings === 'object' && settings[key] !== void 0) {
	        result = settings[key];
	      } else {
	        result = true;
	      }
	    } else if (key === 'autoInsertRow') {
	      if (typeof settings === 'object' && settings[key] !== void 0) {
	        result = settings[key];
	      } else {
	        result = true;
	      }
	    } else if (key === 'fillHandle') {
	      result = settings ? true : false;
	    }
	    return result;
	  };
	}
	Handsontable.Autofill = Autofill;

	//# 
	},{"3rdparty/walkontable/src/cell/coords":5,"browser":23,"eventManager":41,"helpers/dom/element":46,"plugins":59}],64:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ColumnSorting: {get: function() {
	      return ColumnSorting;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__95_base__,
	    $___46__46__47__46__46__47_plugins__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var $__1 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__1.addClass,
	    closest = $__1.closest,
	    hasClass = $__1.hasClass,
	    index = $__1.index,
	    removeClass = $__1.removeClass;
	var $__2 = ($___46__46__47__46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}),
	    arrayEach = $__2.arrayEach,
	    arrayMap = $__2.arrayMap,
	    arrayReduce = $__2.arrayReduce;
	var eventManagerObject = ($___46__46__47__46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).eventManager;
	var BasePlugin = ($___46__46__47__95_base__ = _dereq_("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	Handsontable.hooks.register('beforeColumnSort');
	Handsontable.hooks.register('afterColumnSort');
	var ColumnSorting = function ColumnSorting(hotInstance) {
	  $traceurRuntime.superConstructor($ColumnSorting).call(this, hotInstance);
	  this.sortIndicators = [];
	  this.lastSortedColumn = null;
	};
	var $ColumnSorting = ColumnSorting;
	($traceurRuntime.createClass)(ColumnSorting, {
	  isEnabled: function() {
	    return !!(this.hot.getSettings().columnSorting);
	  },
	  enablePlugin: function() {
	    var $__6 = this;
	    if (this.enabled) {
	      return;
	    }
	    var _this = this;
	    this.hot.sortIndex = [];
	    this.hot.sort = function() {
	      var args = Array.prototype.slice.call(arguments);
	      return _this.sortByColumn.apply(_this, args);
	    };
	    if (typeof this.hot.getSettings().observeChanges === 'undefined') {
	      this.enableObserveChangesPlugin();
	    }
	    this.bindColumnSortingAfterClick();
	    this.addHook('afterTrimRow', (function(row) {
	      return $__6.sort();
	    }));
	    this.addHook('afterUntrimRow', (function(row) {
	      return $__6.sort();
	    }));
	    this.addHook('modifyRow', (function(row) {
	      return $__6.translateRow(row);
	    }));
	    this.addHook('afterUpdateSettings', (function() {
	      return $__6.onAfterUpdateSettings();
	    }));
	    this.addHook('afterGetColHeader', (function(col, TH) {
	      return $__6.getColHeader(col, TH);
	    }));
	    this.addHook('afterCreateRow', function() {
	      _this.afterCreateRow.apply(_this, arguments);
	    });
	    this.addHook('afterRemoveRow', function() {
	      _this.afterRemoveRow.apply(_this, arguments);
	    });
	    this.addHook('afterInit', (function() {
	      return $__6.sortBySettings();
	    }));
	    this.addHook('afterLoadData', (function() {
	      $__6.hot.sortIndex = [];
	      if ($__6.hot.view) {
	        $__6.sortBySettings();
	      }
	    }));
	    if (this.hot.view) {
	      this.sortBySettings();
	    }
	    $traceurRuntime.superGet(this, $ColumnSorting.prototype, "enablePlugin").call(this);
	  },
	  disablePlugin: function() {
	    this.hot.sort = void 0;
	    $traceurRuntime.superGet(this, $ColumnSorting.prototype, "disablePlugin").call(this);
	  },
	  onAfterUpdateSettings: function() {
	    this.sortBySettings();
	  },
	  sortBySettings: function() {
	    var sortingSettings = this.hot.getSettings().columnSorting;
	    var loadedSortingState = this.loadSortingState();
	    var sortingColumn;
	    var sortingOrder;
	    if (typeof loadedSortingState === 'undefined') {
	      sortingColumn = sortingSettings.column;
	      sortingOrder = sortingSettings.sortOrder;
	    } else {
	      sortingColumn = loadedSortingState.sortColumn;
	      sortingOrder = loadedSortingState.sortOrder;
	    }
	    if (typeof sortingColumn === 'number') {
	      this.lastSortedColumn = sortingColumn;
	      this.sortByColumn(sortingColumn, sortingOrder);
	    }
	  },
	  setSortingColumn: function(col, order) {
	    if (typeof col == 'undefined') {
	      this.hot.sortColumn = void 0;
	      this.hot.sortOrder = void 0;
	      return;
	    } else if (this.hot.sortColumn === col && typeof order == 'undefined') {
	      if (this.hot.sortOrder === false) {
	        this.hot.sortOrder = void 0;
	      } else {
	        this.hot.sortOrder = !this.hot.sortOrder;
	      }
	    } else {
	      this.hot.sortOrder = typeof order === 'undefined' ? true : order;
	    }
	    this.hot.sortColumn = col;
	  },
	  sortByColumn: function(col, order) {
	    this.setSortingColumn(col, order);
	    if (typeof this.hot.sortColumn == 'undefined') {
	      return;
	    }
	    var allowSorting = Handsontable.hooks.run(this.hot, 'beforeColumnSort', this.hot.sortColumn, this.hot.sortOrder);
	    if (allowSorting !== false) {
	      this.sort();
	    }
	    this.updateOrderClass();
	    this.updateSortIndicator();
	    this.hot.render();
	    this.saveSortingState();
	    Handsontable.hooks.run(this.hot, 'afterColumnSort', this.hot.sortColumn, this.hot.sortOrder);
	  },
	  saveSortingState: function() {
	    var sortingState = {};
	    if (typeof this.hot.sortColumn != 'undefined') {
	      sortingState.sortColumn = this.hot.sortColumn;
	    }
	    if (typeof this.hot.sortOrder != 'undefined') {
	      sortingState.sortOrder = this.hot.sortOrder;
	    }
	    if (sortingState.hasOwnProperty('sortColumn') || sortingState.hasOwnProperty('sortOrder')) {
	      Handsontable.hooks.run(this.hot, 'persistentStateSave', 'columnSorting', sortingState);
	    }
	  },
	  loadSortingState: function() {
	    var storedState = {};
	    Handsontable.hooks.run(this.hot, 'persistentStateLoad', 'columnSorting', storedState);
	    return storedState.value;
	  },
	  updateOrderClass: function() {
	    var orderClass;
	    if (this.hot.sortOrder === true) {
	      orderClass = 'ascending';
	    } else if (this.hot.sortOrder === false) {
	      orderClass = 'descending';
	    }
	    this.sortOrderClass = orderClass;
	  },
	  bindColumnSortingAfterClick: function() {
	    var $__6 = this;
	    if (this.bindedSortEvent) {
	      return;
	    }
	    var eventManager = eventManagerObject(this.hot),
	        _this = this;
	    this.bindedSortEvent = true;
	    eventManager.addEventListener(this.hot.rootElement, 'click', (function(e) {
	      if (hasClass(e.target, 'columnSorting')) {
	        var col = getColumn(e.target);
	        if (col !== $__6.lastSortedColumn) {
	          $__6.hot.sortOrder = true;
	        }
	        $__6.lastSortedColumn = col;
	        $__6.sortByColumn(col);
	      }
	    }));
	    function countRowHeaders() {
	      var tr = _this.hot.view.TBODY.querySelector('tr');
	      var length = 1;
	      if (tr) {
	        length = tr.querySelectorAll('th').length;
	      }
	      return length;
	    }
	    function getColumn(target) {
	      var TH = closest(target, 'TH');
	      return _this.hot.view.wt.wtTable.getFirstRenderedColumn() + index(TH) - countRowHeaders();
	    }
	  },
	  enableObserveChangesPlugin: function() {
	    var _this = this;
	    this.hot._registerTimeout(setTimeout(function() {
	      _this.hot.updateSettings({observeChanges: true});
	    }, 0));
	  },
	  defaultSort: function(sortOrder) {
	    return function(a, b) {
	      if (typeof a[1] == 'string') {
	        a[1] = a[1].toLowerCase();
	      }
	      if (typeof b[1] == 'string') {
	        b[1] = b[1].toLowerCase();
	      }
	      if (a[1] === b[1]) {
	        return 0;
	      }
	      if (a[1] === null || a[1] === '') {
	        return 1;
	      }
	      if (b[1] === null || b[1] === '') {
	        return -1;
	      }
	      if (isNaN(a[1]) && !isNaN(b[1])) {
	        return sortOrder ? 1 : -1;
	      } else if (!isNaN(a[1]) && isNaN(b[1])) {
	        return sortOrder ? -1 : 1;
	      }
	      if (a[1] < b[1]) {
	        return sortOrder ? -1 : 1;
	      }
	      if (a[1] > b[1]) {
	        return sortOrder ? 1 : -1;
	      }
	      return 0;
	    };
	  },
	  dateSort: function(sortOrder) {
	    return function(a, b) {
	      if (a[1] === b[1]) {
	        return 0;
	      }
	      if (a[1] === null || a[1] === '') {
	        return 1;
	      }
	      if (b[1] === null || b[1] === '') {
	        return -1;
	      }
	      var aDate = new Date(a[1]);
	      var bDate = new Date(b[1]);
	      if (aDate < bDate) {
	        return sortOrder ? -1 : 1;
	      }
	      if (aDate > bDate) {
	        return sortOrder ? 1 : -1;
	      }
	      return 0;
	    };
	  },
	  numericSort: function(sortOrder) {
	    return function(a, b) {
	      var parsedA = parseFloat(a[1]);
	      var parsedB = parseFloat(b[1]);
	      if (parsedA === parsedB || (isNaN(parsedA) && isNaN(parsedB))) {
	        return 0;
	      }
	      if (isNaN(parsedA)) {
	        return 1;
	      }
	      if (isNaN(parsedB)) {
	        return -1;
	      }
	      if (parsedA < parsedB) {
	        return sortOrder ? -1 : 1;
	      } else if (parsedA > parsedB) {
	        return sortOrder ? 1 : -1;
	      }
	      return 0;
	    };
	  },
	  sort: function() {
	    if (typeof this.hot.sortOrder == 'undefined') {
	      this.hot.sortIndex.length = 0;
	      return;
	    }
	    var colMeta,
	        sortFunction;
	    this.hot.sortingEnabled = false;
	    this.hot.sortIndex.length = 0;
	    for (var i = 0,
	        ilen = this.hot.countRows() - this.hot.getSettings().minSpareRows; i < ilen; i++) {
	      this.hot.sortIndex.push([i, this.hot.getDataAtCell(i, this.hot.sortColumn)]);
	    }
	    colMeta = this.hot.getCellMeta(0, this.hot.sortColumn);
	    if (colMeta.sortFunction) {
	      sortFunction = colMeta.sortFunction;
	    } else {
	      switch (colMeta.type) {
	        case 'date':
	          sortFunction = this.dateSort;
	          break;
	        case 'numeric':
	          sortFunction = this.numericSort;
	          break;
	        default:
	          sortFunction = this.defaultSort;
	      }
	    }
	    this.hot.sortIndex.sort(sortFunction(this.hot.sortOrder));
	    for (var i$__8 = this.hot.sortIndex.length; i$__8 < this.hot.countRows(); i$__8++) {
	      this.hot.sortIndex.push([i$__8, this.hot.getDataAtCell(i$__8, this.hot.sortColumn)]);
	    }
	    this.hot.sortingEnabled = true;
	  },
	  updateSortIndicator: function() {
	    if (typeof this.hot.sortOrder == 'undefined') {
	      return;
	    }
	    var colMeta = this.hot.getCellMeta(0, this.hot.sortColumn);
	    this.sortIndicators[this.hot.sortColumn] = colMeta.sortIndicator;
	  },
	  translateRow: function(row) {
	    if (this.hot.sortingEnabled && (typeof this.hot.sortOrder !== 'undefined') && this.hot.sortIndex && this.hot.sortIndex.length && this.hot.sortIndex[row]) {
	      return this.hot.sortIndex[row][0];
	    }
	    return row;
	  },
	  untranslateRow: function(row) {
	    if (this.hot.sortingEnabled && this.hot.sortIndex && this.hot.sortIndex.length) {
	      for (var i = 0; i < this.hot.sortIndex.length; i++) {
	        if (this.hot.sortIndex[i][0] == row) {
	          return i;
	        }
	      }
	    }
	  },
	  getColHeader: function(col, TH) {
	    var headerLink = TH.querySelector('.colHeader');
	    var colspan = TH.getAttribute('colspan');
	    var TRs = TH.parentNode.parentNode.childNodes;
	    var headerLevel = Array.prototype.indexOf.call(TRs, TH.parentNode);
	    headerLevel = headerLevel - TRs.length;
	    if (!headerLink) {
	      return;
	    }
	    if (this.hot.getSettings().columnSorting && col >= 0 && headerLevel === -1) {
	      addClass(headerLink, 'columnSorting');
	    }
	    removeClass(headerLink, 'descending');
	    removeClass(headerLink, 'ascending');
	    if (this.sortIndicators[col]) {
	      if (col === this.hot.sortColumn) {
	        if (this.sortOrderClass === 'ascending') {
	          addClass(headerLink, 'ascending');
	        } else if (this.sortOrderClass === 'descending') {
	          addClass(headerLink, 'descending');
	        }
	      }
	    }
	  },
	  isSorted: function() {
	    return typeof this.hot.sortColumn != 'undefined';
	  },
	  afterCreateRow: function(index, amount) {
	    if (!this.isSorted()) {
	      return;
	    }
	    for (var i = 0; i < this.hot.sortIndex.length; i++) {
	      if (this.hot.sortIndex[i][0] >= index) {
	        this.hot.sortIndex[i][0] += amount;
	      }
	    }
	    for (var i = 0; i < amount; i++) {
	      this.hot.sortIndex.splice(index + i, 0, [index + i, this.hot.getSourceData()[index + i][this.hot.sortColumn + this.hot.colOffset()]]);
	    }
	    this.saveSortingState();
	  },
	  afterRemoveRow: function(index, amount) {
	    if (!this.isSorted()) {
	      return;
	    }
	    var removedRows = this.hot.sortIndex.splice(index, amount);
	    removedRows = arrayMap(removedRows, (function(row) {
	      return row[0];
	    }));
	    function countRowShift(logicalRow) {
	      return arrayReduce(removedRows, (function(count, removedLogicalRow) {
	        if (logicalRow > removedLogicalRow) {
	          count++;
	        }
	        return count;
	      }), 0);
	    }
	    this.hot.sortIndex = arrayMap(this.hot.sortIndex, (function(logicalRow, physicalRow) {
	      var rowShift = countRowShift(logicalRow[0]);
	      if (rowShift) {
	        logicalRow[0] -= rowShift;
	      }
	      return logicalRow;
	    }));
	    this.saveSortingState();
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('columnSorting', ColumnSorting);

	//# 
	},{"_base":60,"browser":23,"eventManager":41,"helpers/array":42,"helpers/dom/element":46,"plugins":59}],65:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  CommentEditor: {get: function() {
	      return CommentEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_dom_47_element__;
	var addClass = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}).addClass;
	var CommentEditor = function CommentEditor() {
	  this.editor = this.createEditor();
	  this.editorStyle = this.editor.style;
	  this.editorStyle.position = 'absolute';
	  this.editorStyle.zIndex = 100;
	  this.hide();
	};
	var $CommentEditor = CommentEditor;
	($traceurRuntime.createClass)(CommentEditor, {
	  setPosition: function(x, y) {
	    this.editorStyle.left = x + 'px';
	    this.editorStyle.top = y + 'px';
	  },
	  show: function() {
	    this.editorStyle.display = 'block';
	  },
	  hide: function() {
	    this.editorStyle.display = 'none';
	  },
	  isVisible: function() {
	    return this.editorStyle.display === 'block';
	  },
	  setValue: function() {
	    var value = arguments[0] !== (void 0) ? arguments[0] : '';
	    value = value || '';
	    this.getInputElement().value = value;
	  },
	  getValue: function() {
	    return this.getInputElement().value;
	  },
	  isFocused: function() {
	    return document.activeElement === this.getInputElement();
	  },
	  focus: function() {
	    this.getInputElement().focus();
	  },
	  createEditor: function() {
	    var container = document.querySelector('.' + $CommentEditor.CLASS_EDITOR_CONTAINER);
	    var editor;
	    var textArea;
	    if (!container) {
	      container = document.createElement('div');
	      addClass(container, $CommentEditor.CLASS_EDITOR_CONTAINER);
	      document.body.appendChild(container);
	    }
	    editor = document.createElement('div');
	    addClass(editor, $CommentEditor.CLASS_EDITOR);
	    textArea = document.createElement('textarea');
	    addClass(textArea, $CommentEditor.CLASS_INPUT);
	    editor.appendChild(textArea);
	    container.appendChild(editor);
	    return editor;
	  },
	  getInputElement: function() {
	    return this.editor.querySelector('.' + $CommentEditor.CLASS_INPUT);
	  },
	  destroy: function() {
	    this.editor.parentNode.removeChild(this.editor);
	    this.editor = null;
	    this.editorStyle = null;
	  }
	}, {
	  get CLASS_EDITOR_CONTAINER() {
	    return 'htCommentsContainer';
	  },
	  get CLASS_EDITOR() {
	    return 'htComments';
	  },
	  get CLASS_INPUT() {
	    return 'htCommentTextArea';
	  },
	  get CLASS_CELL() {
	    return 'htCommentCell';
	  }
	});
	;

	//# 
	},{"helpers/dom/element":46}],66:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  Comments: {get: function() {
	      return Comments;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__,
	    $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__95_base__,
	    $__commentEditor__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var $__1 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__1.addClass,
	    closest = $__1.closest,
	    getWindowScrollLeft = $__1.getWindowScrollLeft,
	    getWindowScrollTop = $__1.getWindowScrollTop,
	    hasClass = $__1.hasClass,
	    offset = $__1.offset;
	var EventManager = ($___46__46__47__46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).EventManager;
	var WalkontableCellCoords = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ = _dereq_("3rdparty/walkontable/src/cell/coords"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	var $__4 = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}),
	    registerPlugin = $__4.registerPlugin,
	    getPlugin = $__4.getPlugin;
	var BasePlugin = ($___46__46__47__95_base__ = _dereq_("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var CommentEditor = ($__commentEditor__ = _dereq_("commentEditor"), $__commentEditor__ && $__commentEditor__.__esModule && $__commentEditor__ || {default: $__commentEditor__}).CommentEditor;
	var Comments = function Comments(hotInstance) {
	  $traceurRuntime.superConstructor($Comments).call(this, hotInstance);
	  this.editor = null;
	  this.eventManager = null;
	  this.range = {};
	  this.mouseDown = false;
	  this.contextMenuEvent = false;
	  this.timer = null;
	};
	var $Comments = Comments;
	($traceurRuntime.createClass)(Comments, {
	  isEnabled: function() {
	    return this.hot.getSettings().comments;
	  },
	  enablePlugin: function() {
	    var $__7 = this;
	    if (this.enabled) {
	      return;
	    }
	    if (!this.editor) {
	      this.editor = new CommentEditor();
	    }
	    if (!this.eventManager) {
	      this.eventManager = new EventManager(this);
	    }
	    this.addHook('afterContextMenuDefaultOptions', (function(options) {
	      return $__7.addToContextMenu(options);
	    }));
	    this.addHook('afterRenderer', (function(TD, row, col, prop, value, cellProperties) {
	      return $__7.onAfterRenderer(TD, cellProperties);
	    }));
	    this.addHook('afterScrollHorizontally', (function() {
	      return $__7.refreshEditorPosition();
	    }));
	    this.addHook('afterScrollVertically', (function() {
	      return $__7.refreshEditorPosition();
	    }));
	    this.addHook('afterColumnResize', (function() {
	      return $__7.refreshEditorPosition();
	    }));
	    this.addHook('afterRowResize', (function() {
	      return $__7.refreshEditorPosition();
	    }));
	    this.registerListeners();
	    $traceurRuntime.superGet(this, $Comments.prototype, "enablePlugin").call(this);
	  },
	  disablePlugin: function() {
	    $traceurRuntime.superGet(this, $Comments.prototype, "disablePlugin").call(this);
	  },
	  registerListeners: function() {
	    var $__7 = this;
	    this.eventManager.addEventListener(document, 'mouseover', (function(event) {
	      return $__7.onMouseOver(event);
	    }));
	    this.eventManager.addEventListener(document, 'mousedown', (function(event) {
	      return $__7.onMouseDown(event);
	    }));
	    this.eventManager.addEventListener(document, 'mousemove', (function(event) {
	      return $__7.onMouseMove(event);
	    }));
	    this.eventManager.addEventListener(document, 'mouseup', (function(event) {
	      return $__7.onMouseUp(event);
	    }));
	    this.eventManager.addEventListener(this.editor.getInputElement(), 'blur', (function(event) {
	      return $__7.onEditorBlur(event);
	    }));
	  },
	  setRange: function(range) {
	    this.range = range;
	  },
	  clearRange: function() {
	    this.range = {};
	  },
	  targetIsCellWithComment: function(event) {
	    return hasClass(event.target, 'htCommentCell') && closest(event.target, [this.hot.rootElement]) ? true : false;
	  },
	  targetIsCommentTextArea: function(event) {
	    return this.editor.getInputElement() === event.target;
	  },
	  saveComment: function() {
	    if (!this.range.from) {
	      throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
	    }
	    var comment = this.editor.getValue();
	    var row = this.range.from.row;
	    var col = this.range.from.col;
	    this.hot.setCellMeta(row, col, 'comment', comment);
	    this.hot.render();
	  },
	  saveCommentAtCell: function(row, col) {
	    this.setRange({from: new WalkontableCellCoords(row, col)});
	    this.saveComment();
	  },
	  removeComment: function() {
	    if (!this.range.from) {
	      throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
	    }
	    this.hot.removeCellMeta(this.range.from.row, this.range.from.col, 'comment');
	    this.hot.render();
	    this.hide();
	  },
	  removeCommentAtCell: function(row, col) {
	    this.setRange({from: new WalkontableCellCoords(row, col)});
	    this.removeComment();
	  },
	  show: function() {
	    if (!this.range.from) {
	      throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
	    }
	    var meta = this.hot.getCellMeta(this.range.from.row, this.range.from.col);
	    this.refreshEditorPosition(true);
	    this.editor.setValue(meta.comment || '');
	    this.editor.show();
	    return true;
	  },
	  showAtCell: function(row, col) {
	    this.setRange({from: new WalkontableCellCoords(row, col)});
	    return this.show();
	  },
	  hide: function() {
	    this.editor.hide();
	  },
	  refreshEditorPosition: function() {
	    var force = arguments[0] !== (void 0) ? arguments[0] : false;
	    if (!force && (!this.range.from || !this.editor.isVisible())) {
	      return;
	    }
	    var TD = this.hot.view.wt.wtTable.getCell(this.range.from);
	    var cellOffset = offset(TD);
	    var lastColWidth = this.hot.getColWidth(this.range.from.col);
	    var cellTopOffset = cellOffset.top;
	    var cellLeftOffset = cellOffset.left;
	    var verticalCompensation = 0;
	    var horizontalCompensation = 0;
	    if (this.hot.view.wt.wtViewport.hasVerticalScroll()) {
	      cellTopOffset = cellTopOffset - this.hot.view.wt.wtOverlays.topOverlay.getScrollPosition();
	      verticalCompensation = 20;
	    }
	    if (this.hot.view.wt.wtViewport.hasHorizontalScroll()) {
	      cellLeftOffset = cellLeftOffset - this.hot.view.wt.wtOverlays.leftOverlay.getScrollPosition();
	      horizontalCompensation = 20;
	    }
	    var x = cellLeftOffset + lastColWidth;
	    var y = cellTopOffset;
	    var rect = this.hot.view.wt.wtTable.holder.getBoundingClientRect();
	    var holderPos = {
	      left: rect.left + getWindowScrollLeft() + horizontalCompensation,
	      right: rect.right + getWindowScrollLeft() - 15,
	      top: rect.top + getWindowScrollTop() + verticalCompensation,
	      bottom: rect.bottom + getWindowScrollTop()
	    };
	    if (x <= holderPos.left || x > holderPos.right || y <= holderPos.top || y > holderPos.bottom) {
	      this.hide();
	    } else {
	      this.editor.setPosition(x, y);
	    }
	  },
	  onMouseDown: function(event) {
	    this.mouseDown = true;
	    if (!this.hot.view || !this.hot.view.wt) {
	      return;
	    }
	    if (!this.contextMenuEvent && !this.targetIsCommentTextArea(event) && !this.targetIsCellWithComment(event)) {
	      this.hide();
	    }
	    this.contextMenuEvent = false;
	  },
	  onMouseOver: function(event) {
	    if (this.mouseDown || this.editor.isFocused()) {
	      return;
	    }
	    if (this.targetIsCellWithComment(event)) {
	      var coordinates = this.hot.view.wt.wtTable.getCoords(event.target);
	      var range = {from: new WalkontableCellCoords(coordinates.row, coordinates.col)};
	      this.setRange(range);
	      this.show();
	    } else if (!this.targetIsCommentTextArea(event) && !this.editor.isFocused()) {
	      this.hide();
	    }
	  },
	  onMouseMove: function(event) {
	    var $__7 = this;
	    if (this.targetIsCommentTextArea(event)) {
	      this.mouseDown = true;
	      clearTimeout(this.timer);
	      this.timer = setTimeout((function() {
	        $__7.mouseDown = false;
	      }), 200);
	    }
	  },
	  onMouseUp: function(event) {
	    this.mouseDown = false;
	  },
	  onAfterRenderer: function(TD, cellProperties) {
	    if (cellProperties.comment) {
	      addClass(TD, cellProperties.commentedCellClassName);
	    }
	  },
	  onEditorBlur: function(event) {
	    this.saveComment();
	  },
	  checkSelectionCommentsConsistency: function() {
	    var selected = this.hot.getSelectedRange();
	    if (!selected) {
	      return false;
	    }
	    var hasComment = false;
	    var cell = selected.from;
	    if (this.hot.getCellMeta(cell.row, cell.col).comment) {
	      hasComment = true;
	    }
	    return hasComment;
	  },
	  onContextMenuAddComment: function() {
	    var $__7 = this;
	    var coords = this.hot.getSelectedRange();
	    this.contextMenuEvent = true;
	    this.setRange({from: coords.from});
	    this.show();
	    setTimeout((function() {
	      if ($__7.hot) {
	        $__7.hot.deselectCell();
	        $__7.editor.focus();
	      }
	    }), 10);
	  },
	  onContextMenuRemoveComment: function(key, selection) {
	    this.contextMenuEvent = true;
	    this.removeCommentAtCell(selection.start.row, selection.start.col);
	  },
	  addToContextMenu: function(defaultOptions) {
	    var $__7 = this;
	    defaultOptions.items.push(Handsontable.plugins.ContextMenu.SEPARATOR, {
	      key: 'commentsAddEdit',
	      name: (function() {
	        return $__7.checkSelectionCommentsConsistency() ? 'Edit Comment' : 'Add Comment';
	      }),
	      callback: (function() {
	        return $__7.onContextMenuAddComment();
	      }),
	      disabled: function() {
	        return this.getSelected() ? false : true;
	      }
	    }, {
	      key: 'commentsRemove',
	      name: function() {
	        return 'Delete Comment';
	      },
	      callback: (function(key, selection) {
	        return $__7.onContextMenuRemoveComment(key, selection);
	      }),
	      disabled: (function() {
	        return !$__7.checkSelectionCommentsConsistency();
	      })
	    });
	  },
	  destroy: function() {
	    if (this.editor) {
	      this.editor.destroy();
	    }
	    $traceurRuntime.superGet(this, $Comments.prototype, "destroy").call(this);
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('comments', Comments);

	//# 
	},{"3rdparty/walkontable/src/cell/coords":5,"_base":60,"browser":23,"commentEditor":65,"eventManager":41,"helpers/dom/element":46,"plugins":59}],67:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  CommandExecutor: {get: function() {
	      return CommandExecutor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_array__;
	var arrayEach = ($___46__46__47__46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}).arrayEach;
	var CommandExecutor = function CommandExecutor(hotInstance) {
	  this.hot = hotInstance;
	  this.commands = {};
	  this.commonCallback = null;
	};
	($traceurRuntime.createClass)(CommandExecutor, {
	  registerCommand: function(name, commandDescriptor) {
	    this.commands[name] = commandDescriptor;
	  },
	  setCommonCallback: function(callback) {
	    this.commonCallback = callback;
	  },
	  execute: function(commandName) {
	    for (var params = [],
	        $__3 = 1; $__3 < arguments.length; $__3++)
	      params[$__3 - 1] = arguments[$__3];
	    var $__1 = this;
	    var commandSplit = commandName.split(':');
	    commandName = commandSplit[0];
	    var subCommandName = commandSplit.length === 2 ? commandSplit[1] : null;
	    var command = this.commands[commandName];
	    if (!command) {
	      throw new Error(("Menu command '" + commandName + "' not exists."));
	    }
	    if (subCommandName && command.submenu) {
	      command = findSubCommand(subCommandName, command.submenu.items);
	    }
	    if (command.disabled === true) {
	      return;
	    }
	    if (typeof command.disabled == 'function' && command.disabled.call(this.hot) === true) {
	      return;
	    }
	    if (command.hasOwnProperty('submenu')) {
	      return;
	    }
	    var callbacks = [];
	    if (typeof command.callback === 'function') {
	      callbacks.push(command.callback);
	    }
	    if (typeof this.commonCallback === 'function') {
	      callbacks.push(this.commonCallback);
	    }
	    params.unshift(commandSplit.join(':'));
	    arrayEach(callbacks, (function(callback) {
	      return callback.apply($__1.hot, params);
	    }));
	  }
	}, {});
	function findSubCommand(subCommandName, subCommands) {
	  var command;
	  arrayEach(subCommands, (function(cmd) {
	    var cmds = cmd.key ? cmd.key.split(':') : null;
	    if (Array.isArray(cmds) && cmds[1] === subCommandName) {
	      command = cmd;
	      return false;
	    }
	  }));
	  return command;
	}
	;

	//# 
	},{"helpers/array":42}],68:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ContextMenu: {get: function() {
	      return ContextMenu;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__95_base__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $__commandExecutor__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $__itemsFactory__,
	    $__menu__,
	    $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $__predefinedItems__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var BasePlugin = ($___46__46__47__95_base__ = _dereq_("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var arrayEach = ($___46__46__47__46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}).arrayEach;
	var CommandExecutor = ($__commandExecutor__ = _dereq_("commandExecutor"), $__commandExecutor__ && $__commandExecutor__.__esModule && $__commandExecutor__ || {default: $__commandExecutor__}).CommandExecutor;
	var EventManager = ($___46__46__47__46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).EventManager;
	var hasClass = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}).hasClass;
	var ItemsFactory = ($__itemsFactory__ = _dereq_("itemsFactory"), $__itemsFactory__ && $__itemsFactory__.__esModule && $__itemsFactory__ || {default: $__itemsFactory__}).ItemsFactory;
	var Menu = ($__menu__ = _dereq_("menu"), $__menu__ && $__menu__.__esModule && $__menu__ || {default: $__menu__}).Menu;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var $__9 = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}),
	    stopPropagation = $__9.stopPropagation,
	    pageX = $__9.pageX,
	    pageY = $__9.pageY;
	var $__10 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    getWindowScrollLeft = $__10.getWindowScrollLeft,
	    getWindowScrollTop = $__10.getWindowScrollTop;
	var $__11 = ($__predefinedItems__ = _dereq_("predefinedItems"), $__predefinedItems__ && $__predefinedItems__.__esModule && $__predefinedItems__ || {default: $__predefinedItems__}),
	    ROW_ABOVE = $__11.ROW_ABOVE,
	    ROW_BELOW = $__11.ROW_BELOW,
	    COLUMN_LEFT = $__11.COLUMN_LEFT,
	    COLUMN_RIGHT = $__11.COLUMN_RIGHT,
	    REMOVE_ROW = $__11.REMOVE_ROW,
	    REMOVE_COLUMN = $__11.REMOVE_COLUMN,
	    UNDO = $__11.UNDO,
	    REDO = $__11.REDO,
	    READ_ONLY = $__11.READ_ONLY,
	    ALIGNMENT = $__11.ALIGNMENT,
	    SEPARATOR = $__11.SEPARATOR;
	var ContextMenu = function ContextMenu(hotInstance) {
	  $traceurRuntime.superConstructor($ContextMenu).call(this, hotInstance);
	  this.eventManager = new EventManager(this);
	  this.commandExecutor = new CommandExecutor(this.hot);
	  this.itemsFactory = null;
	  this.menu = null;
	};
	var $ContextMenu = ContextMenu;
	($traceurRuntime.createClass)(ContextMenu, {
	  isEnabled: function() {
	    return this.hot.getSettings().contextMenu;
	  },
	  enablePlugin: function() {
	    var $__12 = this;
	    if (this.enabled) {
	      return;
	    }
	    this.itemsFactory = new ItemsFactory(this.hot, $ContextMenu.DEFAULT_ITEMS);
	    var settings = this.hot.getSettings().contextMenu;
	    var predefinedItems = {items: this.itemsFactory.getItems(settings)};
	    this.registerEvents();
	    if (typeof settings.callback === 'function') {
	      this.commandExecutor.setCommonCallback(settings.callback);
	    }
	    $traceurRuntime.superGet(this, $ContextMenu.prototype, "enablePlugin").call(this);
	    this.callOnPluginsReady((function() {
	      $__12.hot.runHooks('afterContextMenuDefaultOptions', predefinedItems);
	      $__12.itemsFactory.setPredefinedItems(predefinedItems.items);
	      var menuItems = $__12.itemsFactory.getItems(settings);
	      $__12.menu = new Menu($__12.hot, {
	        className: 'htContextMenu',
	        keepInViewport: true
	      });
	      $__12.menu.setMenuItems(menuItems);
	      $__12.menu.addLocalHook('afterOpen', (function() {
	        return $__12.onMenuAfterOpen();
	      }));
	      $__12.menu.addLocalHook('afterClose', (function() {
	        return $__12.onMenuAfterClose();
	      }));
	      $__12.menu.addLocalHook('executeCommand', (function() {
	        for (var params = [],
	            $__14 = 0; $__14 < arguments.length; $__14++)
	          params[$__14] = arguments[$__14];
	        return $__12.executeCommand.apply($__12, params);
	      }));
	      arrayEach(menuItems, (function(command) {
	        return $__12.commandExecutor.registerCommand(command.key, command);
	      }));
	    }));
	  },
	  updatePlugin: function() {
	    this.disablePlugin();
	    this.enablePlugin();
	    $traceurRuntime.superGet(this, $ContextMenu.prototype, "updatePlugin").call(this);
	  },
	  disablePlugin: function() {
	    this.close();
	    if (this.menu) {
	      this.menu.destroy();
	      this.menu = null;
	    }
	    $traceurRuntime.superGet(this, $ContextMenu.prototype, "disablePlugin").call(this);
	  },
	  registerEvents: function() {
	    var $__12 = this;
	    this.eventManager.addEventListener(this.hot.rootElement, 'contextmenu', (function(event) {
	      return $__12.onContextMenu(event);
	    }));
	  },
	  open: function(event) {
	    if (!this.menu) {
	      return;
	    }
	    this.menu.open();
	    this.menu.setPosition({
	      top: parseInt(pageY(event), 10) - getWindowScrollTop(),
	      left: parseInt(pageX(event), 10) - getWindowScrollLeft()
	    });
	    this.menu.hotMenu.isHotTableEnv = this.hot.isHotTableEnv;
	    Handsontable.eventManager.isHotTableEnv = this.hot.isHotTableEnv;
	  },
	  close: function() {
	    if (!this.menu) {
	      return;
	    }
	    this.menu.close();
	  },
	  executeCommand: function() {
	    for (var params = [],
	        $__14 = 0; $__14 < arguments.length; $__14++)
	      params[$__14] = arguments[$__14];
	    this.commandExecutor.execute.apply(this.commandExecutor, params);
	  },
	  onContextMenu: function(event) {
	    var settings = this.hot.getSettings();
	    var showRowHeaders = settings.rowHeaders;
	    var showColHeaders = settings.colHeaders;
	    function isValidElement(element) {
	      return element.nodeName === 'TD' || element.parentNode.nodeName === 'TD';
	    }
	    var element = event.realTarget;
	    this.close();
	    event.preventDefault();
	    stopPropagation(event);
	    if (!(showRowHeaders || showColHeaders)) {
	      if (!isValidElement(element) && !(hasClass(element, 'current') && hasClass(element, 'wtBorder'))) {
	        return;
	      }
	    } else if (showRowHeaders && showColHeaders) {
	      var containsCornerHeader = element.parentNode.querySelectorAll('.cornerHeader').length > 0;
	      if (containsCornerHeader) {
	        return;
	      }
	    }
	    this.open(event);
	  },
	  onMenuAfterOpen: function() {
	    this.hot.runHooks('afterContextMenuShow', this);
	  },
	  onMenuAfterClose: function() {
	    this.hot.listen();
	    this.hot.runHooks('afterContextMenuHide', this);
	  },
	  destroy: function() {
	    this.close();
	    if (this.menu) {
	      this.menu.destroy();
	    }
	    $traceurRuntime.superGet(this, $ContextMenu.prototype, "destroy").call(this);
	  }
	}, {get DEFAULT_ITEMS() {
	    return [ROW_ABOVE, ROW_BELOW, SEPARATOR, COLUMN_LEFT, COLUMN_RIGHT, SEPARATOR, REMOVE_ROW, REMOVE_COLUMN, SEPARATOR, UNDO, REDO, SEPARATOR, READ_ONLY, SEPARATOR, ALIGNMENT];
	  }}, BasePlugin);
	ContextMenu.SEPARATOR = {name: SEPARATOR};
	Handsontable.hooks.register('afterContextMenuDefaultOptions');
	Handsontable.hooks.register('afterContextMenuShow');
	Handsontable.hooks.register('afterContextMenuHide');
	Handsontable.hooks.register('afterContextMenuExecute');
	;
	registerPlugin('contextMenu', ContextMenu);

	//# 
	},{"_base":60,"browser":23,"commandExecutor":67,"eventManager":41,"helpers/array":42,"helpers/dom/element":46,"helpers/dom/event":47,"itemsFactory":70,"menu":71,"plugins":59,"predefinedItems":72}],69:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  Cursor: {get: function() {
	      return Cursor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var $__1 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    getWindowScrollLeft = $__1.getWindowScrollLeft,
	    getWindowScrollTop = $__1.getWindowScrollTop;
	var $__2 = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}),
	    pageX = $__2.pageX,
	    pageY = $__2.pageY;
	var Cursor = function Cursor(object) {
	  var windowScrollTop = getWindowScrollTop();
	  var windowScrollLeft = getWindowScrollLeft();
	  var top,
	      topRelative;
	  var left,
	      leftRelative;
	  var cellHeight,
	      cellWidth;
	  this.type = this.getSourceType(object);
	  if (this.type === 'literal') {
	    top = parseInt(object.top, 10);
	    left = parseInt(object.left, 10);
	    cellHeight = object.height || 0;
	    cellWidth = object.width || 0;
	    topRelative = top;
	    leftRelative = left;
	    top = top + windowScrollTop;
	    left = left + windowScrollLeft;
	  } else if (this.type === 'event') {
	    top = parseInt(pageY(object), 10);
	    left = parseInt(pageX(object), 10);
	    cellHeight = object.target.clientHeight;
	    cellWidth = object.target.clientWidth;
	    topRelative = top - windowScrollTop;
	    leftRelative = left - windowScrollLeft;
	  }
	  this.top = top;
	  this.topRelative = topRelative;
	  this.left = left;
	  this.leftRelative = leftRelative;
	  this.scrollTop = windowScrollTop;
	  this.scrollLeft = windowScrollLeft;
	  this.cellHeight = cellHeight;
	  this.cellWidth = cellWidth;
	};
	($traceurRuntime.createClass)(Cursor, {
	  getSourceType: function(object) {
	    var type = 'literal';
	    if (object instanceof Event) {
	      type = 'event';
	    }
	    return type;
	  },
	  fitsAbove: function(element) {
	    return this.topRelative >= element.offsetHeight;
	  },
	  fitsBelow: function(element) {
	    var viewportHeight = arguments[1] !== (void 0) ? arguments[1] : window.innerHeight;
	    return this.topRelative + element.offsetHeight <= viewportHeight;
	  },
	  fitsOnRight: function(element) {
	    var viewportWidth = arguments[1] !== (void 0) ? arguments[1] : window.innerWidth;
	    return this.leftRelative + this.cellWidth + element.offsetWidth <= viewportWidth;
	  },
	  fitsOnLeft: function(element) {
	    return this.leftRelative >= element.offsetWidth;
	  }
	}, {});
	;
	Handsontable.plugins.utils = Handsontable.plugins.utils || {};
	Handsontable.plugins.utils.Cursor = Cursor;

	//# 
	},{"browser":23,"helpers/dom/element":46,"helpers/dom/event":47}],70:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ItemsFactory: {get: function() {
	      return ItemsFactory;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_object__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $__predefinedItems__;
	var $__0 = ($___46__46__47__46__46__47_helpers_47_object__ = _dereq_("helpers/object"), $___46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47_helpers_47_object__}),
	    objectEach = $__0.objectEach,
	    isObject = $__0.isObject,
	    extend = $__0.extend;
	var arrayEach = ($___46__46__47__46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}).arrayEach;
	var $__2 = ($__predefinedItems__ = _dereq_("predefinedItems"), $__predefinedItems__ && $__predefinedItems__.__esModule && $__predefinedItems__ || {default: $__predefinedItems__}),
	    SEPARATOR = $__2.SEPARATOR,
	    ITEMS = $__2.ITEMS,
	    predefinedItems = $__2.predefinedItems;
	var ItemsFactory = function ItemsFactory(hotInstance) {
	  var orderPattern = arguments[1] !== (void 0) ? arguments[1] : null;
	  this.hot = hotInstance;
	  this.predefinedItems = predefinedItems();
	  this.defaultOrderPattern = orderPattern;
	};
	($traceurRuntime.createClass)(ItemsFactory, {
	  setPredefinedItems: function(predefinedItems) {
	    var $__3 = this;
	    var items = {};
	    this.defaultOrderPattern.length = 0;
	    objectEach(predefinedItems, (function(value, key) {
	      var menuItemKey = '';
	      if (value.name === SEPARATOR) {
	        items[SEPARATOR] = value;
	        menuItemKey = SEPARATOR;
	      } else if (isNaN(parseInt(key, 10))) {
	        value.key = value.key === void 0 ? key : value.key;
	        items[key] = value;
	        menuItemKey = value.key;
	      } else {
	        items[value.key] = value;
	        menuItemKey = value.key;
	      }
	      $__3.defaultOrderPattern.push(menuItemKey);
	    }));
	    this.predefinedItems = items;
	  },
	  getItems: function() {
	    var pattern = arguments[0] !== (void 0) ? arguments[0] : null;
	    return getItems(pattern, this.defaultOrderPattern, this.predefinedItems);
	  }
	}, {});
	function getItems() {
	  var pattern = arguments[0] !== (void 0) ? arguments[0] : null;
	  var defaultPattern = arguments[1] !== (void 0) ? arguments[1] : [];
	  var items = arguments[2] !== (void 0) ? arguments[2] : {};
	  var result = [];
	  if (pattern && pattern.items) {
	    pattern = pattern.items;
	  } else if (!Array.isArray(pattern)) {
	    pattern = defaultPattern;
	  }
	  if (isObject(pattern)) {
	    objectEach(pattern, (function(value, key) {
	      var item = items[typeof value === 'string' ? value : key];
	      if (!item) {
	        item = value;
	      }
	      if (isObject(value)) {
	        extend(item, value);
	      } else if (typeof item === 'string') {
	        item = {name: item};
	      }
	      if (item.key === void 0) {
	        item.key = key;
	      }
	      result.push(item);
	    }));
	  } else {
	    arrayEach(pattern, (function(name, key) {
	      var item = items[name];
	      if (!item && ITEMS.indexOf(name) >= 0) {
	        return;
	      }
	      if (!item) {
	        item = {
	          name: name,
	          key: key + ''
	        };
	      }
	      if (isObject(name)) {
	        extend(item, name);
	      }
	      if (item.key === void 0) {
	        item.key = key;
	      }
	      result.push(item);
	    }));
	  }
	  return result;
	}
	;

	//# 
	},{"helpers/array":42,"helpers/object":52,"predefinedItems":72}],71:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  Menu: {get: function() {
	      return Menu;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $__cursor__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_helpers_47_object__,
	    $___46__46__47__46__46__47_helpers_47_function__,
	    $__utils__,
	    $___46__46__47__46__46__47_helpers_47_unicode__,
	    $___46__46__47__46__46__47_mixins_47_localHooks__,
	    $__predefinedItems__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var $__1 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__1.addClass,
	    empty = $__1.empty,
	    fastInnerHTML = $__1.fastInnerHTML,
	    getScrollbarWidth = $__1.getScrollbarWidth,
	    isChildOf = $__1.isChildOf,
	    removeClass = $__1.removeClass;
	var $__2 = ($___46__46__47__46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}),
	    arrayEach = $__2.arrayEach,
	    arrayFilter = $__2.arrayFilter,
	    arrayReduce = $__2.arrayReduce;
	var Cursor = ($__cursor__ = _dereq_("cursor"), $__cursor__ && $__cursor__.__esModule && $__cursor__ || {default: $__cursor__}).Cursor;
	var EventManager = ($___46__46__47__46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).EventManager;
	var mixin = ($___46__46__47__46__46__47_helpers_47_object__ = _dereq_("helpers/object"), $___46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47_helpers_47_object__}).mixin;
	var debounce = ($___46__46__47__46__46__47_helpers_47_function__ = _dereq_("helpers/function"), $___46__46__47__46__46__47_helpers_47_function__ && $___46__46__47__46__46__47_helpers_47_function__.__esModule && $___46__46__47__46__46__47_helpers_47_function__ || {default: $___46__46__47__46__46__47_helpers_47_function__}).debounce;
	var $__7 = ($__utils__ = _dereq_("utils"), $__utils__ && $__utils__.__esModule && $__utils__ || {default: $__utils__}),
	    filterSeparators = $__7.filterSeparators,
	    hasSubMenu = $__7.hasSubMenu,
	    isDisabled = $__7.isDisabled,
	    isItemHidden = $__7.isItemHidden,
	    isSeparator = $__7.isSeparator,
	    isSelectionDisabled = $__7.isSelectionDisabled,
	    normalizeSelection = $__7.normalizeSelection;
	var KEY_CODES = ($___46__46__47__46__46__47_helpers_47_unicode__ = _dereq_("helpers/unicode"), $___46__46__47__46__46__47_helpers_47_unicode__ && $___46__46__47__46__46__47_helpers_47_unicode__.__esModule && $___46__46__47__46__46__47_helpers_47_unicode__ || {default: $___46__46__47__46__46__47_helpers_47_unicode__}).KEY_CODES;
	var localHooks = ($___46__46__47__46__46__47_mixins_47_localHooks__ = _dereq_("mixins/localHooks"), $___46__46__47__46__46__47_mixins_47_localHooks__ && $___46__46__47__46__46__47_mixins_47_localHooks__.__esModule && $___46__46__47__46__46__47_mixins_47_localHooks__ || {default: $___46__46__47__46__46__47_mixins_47_localHooks__}).localHooks;
	var SEPARATOR = ($__predefinedItems__ = _dereq_("predefinedItems"), $__predefinedItems__ && $__predefinedItems__.__esModule && $__predefinedItems__ || {default: $__predefinedItems__}).SEPARATOR;
	var stopImmediatePropagation = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}).stopImmediatePropagation;
	var Menu = function Menu(hotInstance, options) {
	  this.hot = hotInstance;
	  this.options = options || {
	    parent: null,
	    name: null,
	    className: '',
	    keepInViewport: true,
	    standalone: false
	  };
	  this.eventManager = new EventManager(this);
	  this.container = this.createContainer(this.options.name);
	  this.hotMenu = null;
	  this.hotSubMenus = {};
	  this.parentMenu = this.options.parent || null;
	  this.menuItems = null;
	  this.origOutsideClickDeselects = null;
	  this.offset = {
	    above: 0,
	    below: 0,
	    left: 0,
	    right: 0
	  };
	  this._afterScrollCallback = null;
	  this.registerEvents();
	};
	var $Menu = Menu;
	($traceurRuntime.createClass)(Menu, {
	  registerEvents: function() {
	    var $__12 = this;
	    this.eventManager.addEventListener(document.documentElement, 'mousedown', (function(event) {
	      return $__12.onDocumentMouseDown(event);
	    }));
	  },
	  setMenuItems: function(menuItems) {
	    this.menuItems = menuItems;
	  },
	  setOffset: function(area) {
	    var offset = arguments[1] !== (void 0) ? arguments[1] : 0;
	    this.offset[area] = offset;
	  },
	  isSubMenu: function() {
	    return this.parentMenu !== null;
	  },
	  open: function() {
	    var $__12 = this;
	    this.container.removeAttribute('style');
	    this.container.style.display = 'block';
	    var delayedOpenSubMenu = debounce((function(row) {
	      return $__12.openSubMenu(row);
	    }), 300);
	    var filteredItems = arrayFilter(this.menuItems, (function(item) {
	      return isItemHidden(item, $__12.hot);
	    }));
	    filteredItems = filterSeparators(filteredItems, SEPARATOR);
	    var settings = {
	      data: filteredItems,
	      colHeaders: false,
	      colWidths: [200],
	      autoRowSize: false,
	      readOnly: true,
	      copyPaste: false,
	      columns: [{
	        data: 'name',
	        renderer: (function(hot, TD, row, col, prop, value) {
	          return $__12.menuItemRenderer(hot, TD, row, col, prop, value);
	        })
	      }],
	      renderAllRows: true,
	      fragmentSelection: 'cell',
	      disableVisualSelection: 'area',
	      beforeKeyDown: (function(event) {
	        return $__12.onBeforeKeyDown(event);
	      }),
	      afterOnCellMouseOver: (function(event, coords, TD) {
	        if ($__12.isAllSubMenusClosed()) {
	          delayedOpenSubMenu(coords.row);
	        } else {
	          $__12.openSubMenu(coords.row);
	        }
	      })
	    };
	    this.origOutsideClickDeselects = this.hot.getSettings().outsideClickDeselects;
	    this.hot.getSettings().outsideClickDeselects = false;
	    this.hotMenu = new Handsontable.Core(this.container, settings);
	    this.hotMenu.addHook('afterInit', (function() {
	      return $__12.onAfterInit();
	    }));
	    this.hotMenu.init();
	    this.hotMenu.listen();
	    this.blockMainTableCallbacks();
	    this.runLocalHooks('afterOpen');
	  },
	  close: function() {
	    var closeParent = arguments[0] !== (void 0) ? arguments[0] : false;
	    if (!this.isOpened()) {
	      return;
	    }
	    if (closeParent && this.parentMenu) {
	      this.parentMenu.close();
	    } else {
	      this.closeAllSubMenus();
	      this.container.style.display = 'none';
	      this.releaseMainTableCallbacks();
	      this.hotMenu.destroy();
	      this.hotMenu = null;
	      this.hot.getSettings().outsideClickDeselects = this.origOutsideClickDeselects;
	      this.runLocalHooks('afterClose');
	    }
	  },
	  openSubMenu: function(row) {
	    if (!this.hotMenu) {
	      return false;
	    }
	    var cell = this.hotMenu.getCell(row, 0);
	    this.closeAllSubMenus();
	    if (!cell || !hasSubMenu(cell)) {
	      return false;
	    }
	    var dataItem = this.hotMenu.getSourceDataAtRow(row);
	    var subMenu = new $Menu(this.hot, {
	      parent: this,
	      name: dataItem.name,
	      className: this.options.className,
	      keepInViewport: true
	    });
	    subMenu.setMenuItems(dataItem.submenu.items);
	    subMenu.open();
	    subMenu.setPosition(cell.getBoundingClientRect());
	    this.hotSubMenus[dataItem.key] = subMenu;
	    return subMenu;
	  },
	  closeSubMenu: function(row) {
	    var dataItem = this.hotMenu.getSourceDataAtRow(row);
	    var menus = this.hotSubMenus[dataItem.key];
	    if (menus) {
	      menus.destroy();
	      delete this.hotSubMenus[dataItem.key];
	    }
	  },
	  closeAllSubMenus: function() {
	    var $__12 = this;
	    arrayEach(this.hotMenu.getData(), (function(value, row) {
	      return $__12.closeSubMenu(row);
	    }));
	  },
	  isAllSubMenusClosed: function() {
	    return Object.keys(this.hotSubMenus).length === 0;
	  },
	  destroy: function() {
	    this.clearLocalHooks();
	    this.close();
	    this.parentMenu = null;
	    this.eventManager.destroy();
	  },
	  isOpened: function() {
	    return this.hotMenu !== null;
	  },
	  executeCommand: function(event) {
	    if (!this.isOpened() || !this.hotMenu.getSelected()) {
	      return;
	    }
	    var selectedItem = this.hotMenu.getSourceDataAtRow(this.hotMenu.getSelected()[0]);
	    this.runLocalHooks('select', selectedItem, event);
	    if (selectedItem.isCommand === false || selectedItem.name === SEPARATOR) {
	      return;
	    }
	    var selRange = this.hot.getSelectedRange();
	    var normalizedSelection = selRange ? normalizeSelection(selRange) : {};
	    this.runLocalHooks('executeCommand', selectedItem.key, normalizedSelection, event);
	    if (this.isSubMenu()) {
	      this.parentMenu.runLocalHooks('executeCommand', selectedItem.key, normalizedSelection, event);
	    }
	    if (!(selectedItem.disabled === true || typeof selectedItem.disabled === 'function' && selectedItem.disabled.call(this.hot) === true || selectedItem.submenu)) {
	      this.close(true);
	    }
	  },
	  setPosition: function(coords) {
	    var cursor = new Cursor(coords);
	    if (this.options.keepInViewport) {
	      if (cursor.fitsBelow(this.container)) {
	        this.setPositionBelowCursor(cursor);
	      } else if (cursor.fitsAbove(this.container)) {
	        this.setPositionAboveCursor(cursor);
	      } else {
	        this.setPositionBelowCursor(cursor);
	      }
	      if (cursor.fitsOnRight(this.container)) {
	        this.setPositionOnRightOfCursor(cursor);
	      } else {
	        this.setPositionOnLeftOfCursor(cursor);
	      }
	    } else {
	      this.setPositionBelowCursor(cursor);
	      this.setPositionOnRightOfCursor(cursor);
	    }
	  },
	  setPositionAboveCursor: function(cursor) {
	    var top = this.offset.above + cursor.top - this.container.offsetHeight;
	    if (this.isSubMenu()) {
	      top = cursor.top + cursor.cellHeight - this.container.offsetHeight + 3;
	    }
	    this.container.style.top = top + 'px';
	  },
	  setPositionBelowCursor: function(cursor) {
	    var top = this.offset.below + cursor.top;
	    if (this.isSubMenu()) {
	      top = cursor.top - 1;
	    }
	    this.container.style.top = top + 'px';
	  },
	  setPositionOnRightOfCursor: function(cursor) {
	    var left;
	    if (this.isSubMenu()) {
	      left = 1 + cursor.left + cursor.cellWidth;
	    } else {
	      left = this.offset.right + 1 + cursor.left;
	    }
	    this.container.style.left = left + 'px';
	  },
	  setPositionOnLeftOfCursor: function(cursor) {
	    var left = this.offset.left + cursor.left - this.container.offsetWidth + getScrollbarWidth() + 4;
	    this.container.style.left = left + 'px';
	  },
	  selectFirstCell: function() {
	    var cell = this.hotMenu.getCell(0, 0);
	    if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
	      this.selectNextCell(0, 0);
	    } else {
	      this.hotMenu.selectCell(0, 0);
	    }
	  },
	  selectLastCell: function() {
	    var lastRow = this.hotMenu.countRows() - 1;
	    var cell = this.hotMenu.getCell(lastRow, 0);
	    if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
	      this.selectPrevCell(lastRow, 0);
	    } else {
	      this.hotMenu.selectCell(lastRow, 0);
	    }
	  },
	  selectNextCell: function(row, col) {
	    var nextRow = row + 1;
	    var cell = nextRow < this.hotMenu.countRows() ? this.hotMenu.getCell(nextRow, col) : null;
	    if (!cell) {
	      return;
	    }
	    if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
	      this.selectNextCell(nextRow, col);
	    } else {
	      this.hotMenu.selectCell(nextRow, col);
	    }
	  },
	  selectPrevCell: function(row, col) {
	    var prevRow = row - 1;
	    var cell = prevRow >= 0 ? this.hotMenu.getCell(prevRow, col) : null;
	    if (!cell) {
	      return;
	    }
	    if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
	      this.selectPrevCell(prevRow, col);
	    } else {
	      this.hotMenu.selectCell(prevRow, col);
	    }
	  },
	  menuItemRenderer: function(hot, TD, row, col, prop, value) {
	    var $__12 = this;
	    var item = hot.getSourceDataAtRow(row);
	    var wrapper = document.createElement('div');
	    var isSubMenu = (function(item) {
	      return item.hasOwnProperty('submenu');
	    });
	    var itemIsSeparator = (function(item) {
	      return new RegExp(SEPARATOR, 'i').test(item.name);
	    });
	    var itemIsDisabled = (function(item) {
	      return item.disabled === true || (typeof item.disabled == 'function' && item.disabled.call($__12.hot) === true);
	    });
	    var itemIsSelectionDisabled = (function(item) {
	      return item.disableSelection;
	    });
	    if (typeof value === 'function') {
	      value = value.call(this.hot);
	    }
	    empty(TD);
	    addClass(wrapper, 'htItemWrapper');
	    TD.appendChild(wrapper);
	    if (itemIsSeparator(item)) {
	      addClass(TD, 'htSeparator');
	    } else if (typeof item.renderer === 'function') {
	      addClass(TD, 'htCustomMenuRenderer');
	      TD.appendChild(item.renderer(hot, wrapper, row, col, prop, value));
	    } else {
	      fastInnerHTML(wrapper, value);
	    }
	    if (itemIsDisabled(item)) {
	      addClass(TD, 'htDisabled');
	      this.eventManager.addEventListener(TD, 'mouseenter', (function() {
	        return hot.deselectCell();
	      }));
	    } else if (itemIsSelectionDisabled(item)) {
	      addClass(TD, 'htSelectionDisabled');
	      this.eventManager.addEventListener(TD, 'mouseenter', (function() {
	        return hot.deselectCell();
	      }));
	    } else if (isSubMenu(item)) {
	      addClass(TD, 'htSubmenu');
	      if (itemIsSelectionDisabled(item)) {
	        this.eventManager.addEventListener(TD, 'mouseenter', (function() {
	          return hot.deselectCell();
	        }));
	      } else {
	        this.eventManager.addEventListener(TD, 'mouseenter', (function() {
	          return hot.selectCell(row, col, void 0, void 0, void 0, false);
	        }));
	      }
	    } else {
	      removeClass(TD, 'htSubmenu');
	      removeClass(TD, 'htDisabled');
	      if (itemIsSelectionDisabled(item)) {
	        this.eventManager.addEventListener(TD, 'mouseenter', (function() {
	          return hot.deselectCell();
	        }));
	      } else {
	        this.eventManager.addEventListener(TD, 'mouseenter', (function() {
	          return hot.selectCell(row, col, void 0, void 0, void 0, false);
	        }));
	      }
	    }
	  },
	  createContainer: function() {
	    var name = arguments[0] !== (void 0) ? arguments[0] : null;
	    if (name) {
	      name = name.replace(/ /g, '_');
	      name = this.options.className + 'Sub_' + name;
	    }
	    var container;
	    if (name) {
	      container = document.querySelector('.' + this.options.className + '.' + name);
	    } else {
	      container = document.querySelector('.' + this.options.className);
	    }
	    if (!container) {
	      container = document.createElement('div');
	      addClass(container, 'htMenu ' + this.options.className);
	      if (name) {
	        addClass(container, name);
	      }
	      document.getElementsByTagName('body')[0].appendChild(container);
	    }
	    return container;
	  },
	  blockMainTableCallbacks: function() {
	    this._afterScrollCallback = function() {};
	    this.hot.addHook('afterScrollVertically', this._afterScrollCallback);
	    this.hot.addHook('afterScrollHorizontally', this._afterScrollCallback);
	  },
	  releaseMainTableCallbacks: function() {
	    if (this._afterScrollCallback) {
	      this.hot.removeHook('afterScrollVertically', this._afterScrollCallback);
	      this.hot.removeHook('afterScrollHorizontally', this._afterScrollCallback);
	      this._afterScrollCallback = null;
	    }
	  },
	  onBeforeKeyDown: function(event) {
	    var selection = this.hotMenu.getSelected();
	    var stopEvent = false;
	    switch (event.keyCode) {
	      case KEY_CODES.ESCAPE:
	        this.close();
	        stopEvent = true;
	        break;
	      case KEY_CODES.ENTER:
	        if (selection) {
	          if (this.hotMenu.getSourceDataAtRow(selection[0]).submenu) {
	            stopEvent = true;
	          } else {
	            this.executeCommand(event);
	            this.close(true);
	          }
	        }
	        break;
	      case KEY_CODES.ARROW_DOWN:
	        if (selection) {
	          this.selectNextCell(selection[0], selection[1]);
	        } else {
	          this.selectFirstCell();
	        }
	        stopEvent = true;
	        break;
	      case KEY_CODES.ARROW_UP:
	        if (selection) {
	          this.selectPrevCell(selection[0], selection[1]);
	        } else {
	          this.selectLastCell();
	        }
	        stopEvent = true;
	        break;
	      case KEY_CODES.ARROW_RIGHT:
	        if (selection) {
	          var menu = this.openSubMenu(selection[0]);
	          if (menu) {
	            menu.selectFirstCell();
	          }
	        }
	        stopEvent = true;
	        break;
	      case KEY_CODES.ARROW_LEFT:
	        if (selection && this.isSubMenu()) {
	          this.close();
	          if (this.parentMenu) {
	            this.parentMenu.hotMenu.listen();
	          }
	          stopEvent = true;
	        }
	        break;
	    }
	    if (stopEvent) {
	      event.preventDefault();
	      stopImmediatePropagation(event);
	    }
	  },
	  onAfterInit: function() {
	    var data = this.hotMenu.getSettings().data;
	    var hiderStyle = this.hotMenu.view.wt.wtTable.hider.style;
	    var holderStyle = this.hotMenu.view.wt.wtTable.holder.style;
	    var currentHiderWidth = parseInt(hiderStyle.width, 10);
	    var realHeight = arrayReduce(data, (function(accumulator, value) {
	      return accumulator + (value.name === SEPARATOR ? 1 : 26);
	    }), 0);
	    holderStyle.width = currentHiderWidth + 22 + 'px';
	    holderStyle.height = realHeight + 4 + 'px';
	  },
	  onDocumentMouseDown: function(event) {
	    if (!this.isOpened()) {
	      return;
	    }
	    if (this.container && isChildOf(event.target, this.container)) {
	      this.executeCommand(event);
	    }
	    if (this.options.standalone && this.hotMenu && !isChildOf(event.target, this.hotMenu.rootElement)) {
	      this.close(true);
	    } else if ((this.isAllSubMenusClosed() || this.isSubMenu()) && (!isChildOf(event.target, '.htMenu') && isChildOf(event.target, document))) {
	      this.close(true);
	    }
	  }
	}, {});
	mixin(Menu, localHooks);
	;

	//# 
	},{"browser":23,"cursor":69,"eventManager":41,"helpers/array":42,"helpers/dom/element":46,"helpers/dom/event":47,"helpers/function":49,"helpers/object":52,"helpers/unicode":55,"mixins/localHooks":56,"predefinedItems":72,"utils":73}],72:[function(_dereq_,module,exports){
	"use strict";
	var $__4;
	Object.defineProperties(exports, {
	  ROW_ABOVE: {get: function() {
	      return ROW_ABOVE;
	    }},
	  ROW_BELOW: {get: function() {
	      return ROW_BELOW;
	    }},
	  COLUMN_LEFT: {get: function() {
	      return COLUMN_LEFT;
	    }},
	  COLUMN_RIGHT: {get: function() {
	      return COLUMN_RIGHT;
	    }},
	  CLEAR_COLUMN: {get: function() {
	      return CLEAR_COLUMN;
	    }},
	  REMOVE_ROW: {get: function() {
	      return REMOVE_ROW;
	    }},
	  REMOVE_COLUMN: {get: function() {
	      return REMOVE_COLUMN;
	    }},
	  UNDO: {get: function() {
	      return UNDO;
	    }},
	  REDO: {get: function() {
	      return REDO;
	    }},
	  READ_ONLY: {get: function() {
	      return READ_ONLY;
	    }},
	  ALIGNMENT: {get: function() {
	      return ALIGNMENT;
	    }},
	  SEPARATOR: {get: function() {
	      return SEPARATOR;
	    }},
	  ITEMS: {get: function() {
	      return ITEMS;
	    }},
	  predefinedItems: {get: function() {
	      return predefinedItems;
	    }},
	  addItem: {get: function() {
	      return addItem;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_object__,
	    $___46__46__47__46__46__47_helpers_47_number__,
	    $__utils__;
	var $__0 = ($___46__46__47__46__46__47_helpers_47_object__ = _dereq_("helpers/object"), $___46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47_helpers_47_object__}),
	    objectEach = $__0.objectEach,
	    clone = $__0.clone;
	var rangeEach = ($___46__46__47__46__46__47_helpers_47_number__ = _dereq_("helpers/number"), $___46__46__47__46__46__47_helpers_47_number__ && $___46__46__47__46__46__47_helpers_47_number__.__esModule && $___46__46__47__46__46__47_helpers_47_number__ || {default: $___46__46__47__46__46__47_helpers_47_number__}).rangeEach;
	var $__2 = ($__utils__ = _dereq_("utils"), $__utils__ && $__utils__.__esModule && $__utils__ || {default: $__utils__}),
	    align = $__2.align,
	    getAlignmentClasses = $__2.getAlignmentClasses,
	    getValidSelection = $__2.getValidSelection,
	    checkSelectionConsistency = $__2.checkSelectionConsistency,
	    markLabelAsSelected = $__2.markLabelAsSelected;
	var ROW_ABOVE = 'row_above';
	var ROW_BELOW = 'row_below';
	var COLUMN_LEFT = 'col_left';
	var COLUMN_RIGHT = 'col_right';
	var CLEAR_COLUMN = 'clear_column';
	var REMOVE_ROW = 'remove_row';
	var REMOVE_COLUMN = 'remove_col';
	var UNDO = 'undo';
	var REDO = 'redo';
	var READ_ONLY = 'make_read_only';
	var ALIGNMENT = 'alignment';
	var SEPARATOR = '---------';
	var ITEMS = [ROW_ABOVE, ROW_BELOW, COLUMN_LEFT, COLUMN_RIGHT, CLEAR_COLUMN, REMOVE_ROW, REMOVE_COLUMN, UNDO, REDO, READ_ONLY, ALIGNMENT, SEPARATOR];
	function predefinedItems() {
	  var items = {};
	  objectEach(_predefinedItems, (function(value, key) {
	    return items[key] = clone(value);
	  }));
	  return items;
	}
	function addItem(key, item) {
	  if (ITEMS.indexOf(key) === -1) {
	    _predefinedItems[key] = item;
	  }
	}
	var _predefinedItems = ($__4 = {}, Object.defineProperty($__4, SEPARATOR, {
	  value: {name: SEPARATOR},
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, ROW_ABOVE, {
	  value: {
	    key: ROW_ABOVE,
	    name: 'Insert row above',
	    callback: function(key, selection) {
	      this.alter('insert_row', selection.start.row);
	    },
	    disabled: function() {
	      var selected = getValidSelection(this);
	      if (!selected || this.countRows() >= this.getSettings().maxRows) {
	        return true;
	      }
	      var rowCount = this.countRows();
	      var entireColumnSelection = [0, selected[1], rowCount - 1, selected[1]];
	      return (entireColumnSelection.join(',') === selected.join(',')) && rowCount > 1;
	    },
	    hidden: function() {
	      return !this.getSettings().allowInsertRow;
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, ROW_BELOW, {
	  value: {
	    key: ROW_BELOW,
	    name: 'Insert row below',
	    callback: function(key, selection) {
	      this.alter('insert_row', selection.end.row + 1);
	    },
	    disabled: function() {
	      var selected = getValidSelection(this);
	      if (!selected || this.countRows() >= this.getSettings().maxRows) {
	        return true;
	      }
	      var rowCount = this.countRows();
	      var entireColumnSelection = [0, selected[1], rowCount - 1, selected[1]];
	      return (entireColumnSelection.join(',') === selected.join(',')) && rowCount > 1;
	    },
	    hidden: function() {
	      return !this.getSettings().allowInsertRow;
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, COLUMN_LEFT, {
	  value: {
	    key: COLUMN_LEFT,
	    name: 'Insert column on the left',
	    callback: function(key, selection) {
	      this.alter('insert_col', selection.start.col);
	    },
	    disabled: function() {
	      var selected = getValidSelection(this);
	      if (!selected) {
	        return true;
	      }
	      if (!this.isColumnModificationAllowed()) {
	        return true;
	      }
	      var entireRowSelection = [selected[0], 0, selected[0], this.countCols() - 1];
	      var rowSelected = entireRowSelection.join(',') == selected.join(',');
	      var onlyOneColumn = this.countCols() == 1;
	      return selected[1] < 0 || this.countCols() >= this.getSettings().maxCols || (!onlyOneColumn && rowSelected);
	    },
	    hidden: function() {
	      return !this.getSettings().allowInsertColumn;
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, COLUMN_RIGHT, {
	  value: {
	    key: COLUMN_RIGHT,
	    name: 'Insert column on the right',
	    callback: function(key, selection) {
	      this.alter('insert_col', selection.end.col + 1);
	    },
	    disabled: function() {
	      var selected = getValidSelection(this);
	      if (!selected) {
	        return true;
	      }
	      if (!this.isColumnModificationAllowed()) {
	        return true;
	      }
	      var entireRowSelection = [selected[0], 0, selected[0], this.countCols() - 1];
	      var rowSelected = entireRowSelection.join(',') == selected.join(',');
	      var onlyOneColumn = this.countCols() == 1;
	      return selected[1] < 0 || this.countCols() >= this.getSettings().maxCols || (!onlyOneColumn && rowSelected);
	    },
	    hidden: function() {
	      return !this.getSettings().allowInsertColumn;
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, CLEAR_COLUMN, {
	  value: {
	    key: CLEAR_COLUMN,
	    name: 'Clear column',
	    callback: function(key, selection) {
	      var column = selection.start.col;
	      if (this.countRows()) {
	        this.populateFromArray(0, column, [[null]], Math.max(selection.start.row, selection.end.row), column);
	      }
	    },
	    disabled: function() {
	      var selected = getValidSelection(this);
	      if (!selected) {
	        return true;
	      }
	      var entireRowSelection = [selected[0], 0, selected[0], this.countCols() - 1];
	      var rowSelected = entireRowSelection.join(',') == selected.join(',');
	      return selected[1] < 0 || this.countCols() >= this.getSettings().maxCols || rowSelected;
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, REMOVE_ROW, {
	  value: {
	    key: REMOVE_ROW,
	    name: 'Remove row',
	    callback: function(key, selection) {
	      var amount = selection.end.row - selection.start.row + 1;
	      this.alter('remove_row', selection.start.row, amount);
	    },
	    disabled: function() {
	      var selected = getValidSelection(this);
	      if (!selected || this.selection.selectedHeader.cols) {
	        return true;
	      }
	      var entireColumnSelection = [0, selected[1], this.countRows() - 1, selected[1]];
	      return entireColumnSelection.join(',') === selected.join(',');
	    },
	    hidden: function() {
	      return !this.getSettings().allowRemoveRow;
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, REMOVE_COLUMN, {
	  value: {
	    key: REMOVE_COLUMN,
	    name: 'Remove column',
	    callback: function(key, selection) {
	      var amount = selection.end.col - selection.start.col + 1;
	      this.alter('remove_col', selection.start.col, amount);
	    },
	    disabled: function() {
	      var selected = getValidSelection(this);
	      if (!selected || this.selection.selectedHeader.rows) {
	        return true;
	      }
	      if (!this.isColumnModificationAllowed()) {
	        return true;
	      }
	      var entireRowSelection = [selected[0], 0, selected[0], this.countCols() - 1];
	      var rowSelected = entireRowSelection.join(',') == selected.join(',');
	      return (selected[1] < 0 || rowSelected);
	    },
	    hidden: function() {
	      return !this.getSettings().allowRemoveColumn;
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, UNDO, {
	  value: {
	    key: UNDO,
	    name: 'Undo',
	    callback: function() {
	      this.undo();
	    },
	    disabled: function() {
	      return this.undoRedo && !this.undoRedo.isUndoAvailable();
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, REDO, {
	  value: {
	    key: REDO,
	    name: 'Redo',
	    callback: function() {
	      this.redo();
	    },
	    disabled: function() {
	      return this.undoRedo && !this.undoRedo.isRedoAvailable();
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, READ_ONLY, {
	  value: {
	    key: READ_ONLY,
	    name: function() {
	      var $__3 = this;
	      var label = 'Read only';
	      var atLeastOneReadOnly = checkSelectionConsistency(this.getSelectedRange(), (function(row, col) {
	        return $__3.getCellMeta(row, col).readOnly;
	      }));
	      if (atLeastOneReadOnly) {
	        label = markLabelAsSelected(label);
	      }
	      return label;
	    },
	    callback: function() {
	      var $__3 = this;
	      var range = this.getSelectedRange();
	      var atLeastOneReadOnly = checkSelectionConsistency(range, (function(row, col) {
	        return $__3.getCellMeta(row, col).readOnly;
	      }));
	      range.forAll((function(row, col) {
	        $__3.getCellMeta(row, col).readOnly = atLeastOneReadOnly ? false : true;
	      }));
	      this.render();
	    },
	    disabled: function() {
	      return this.getSelectedRange() ? false : true;
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, ALIGNMENT, {
	  value: {
	    key: ALIGNMENT,
	    name: 'Alignment',
	    disabled: function() {
	      return this.getSelectedRange() ? false : true;
	    },
	    submenu: {items: [{
	        key: (ALIGNMENT + ":left"),
	        name: function() {
	          var $__3 = this;
	          var label = 'Left';
	          var hasClass = checkSelectionConsistency(this.getSelectedRange(), (function(row, col) {
	            var className = $__3.getCellMeta(row, col).className;
	            if (className && className.indexOf('htLeft') !== -1) {
	              return true;
	            }
	          }));
	          if (hasClass) {
	            label = markLabelAsSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var $__3 = this;
	          var range = this.getSelectedRange();
	          var stateBefore = getAlignmentClasses(range, (function(row, col) {
	            return $__3.getCellMeta(row, col).className;
	          }));
	          var type = 'horizontal';
	          var alignment = 'htLeft';
	          this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
	          align(range, type, alignment, (function(row, col) {
	            return $__3.getCellMeta(row, col);
	          }));
	          this.render();
	        },
	        disabled: false
	      }, {
	        key: (ALIGNMENT + ":center"),
	        name: function() {
	          var $__3 = this;
	          var label = 'Center';
	          var hasClass = checkSelectionConsistency(this.getSelectedRange(), (function(row, col) {
	            var className = $__3.getCellMeta(row, col).className;
	            if (className && className.indexOf('htCenter') !== -1) {
	              return true;
	            }
	          }));
	          if (hasClass) {
	            label = markLabelAsSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var $__3 = this;
	          var range = this.getSelectedRange();
	          var stateBefore = getAlignmentClasses(range, (function(row, col) {
	            return $__3.getCellMeta(row, col).className;
	          }));
	          var type = 'horizontal';
	          var alignment = 'htCenter';
	          this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
	          align(range, type, alignment, (function(row, col) {
	            return $__3.getCellMeta(row, col);
	          }));
	          this.render();
	        },
	        disabled: false
	      }, {
	        key: (ALIGNMENT + ":right"),
	        name: function() {
	          var $__3 = this;
	          var label = 'Right';
	          var hasClass = checkSelectionConsistency(this.getSelectedRange(), (function(row, col) {
	            var className = $__3.getCellMeta(row, col).className;
	            if (className && className.indexOf('htRight') !== -1) {
	              return true;
	            }
	          }));
	          if (hasClass) {
	            label = markLabelAsSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var $__3 = this;
	          var range = this.getSelectedRange();
	          var stateBefore = getAlignmentClasses(range, (function(row, col) {
	            return $__3.getCellMeta(row, col).className;
	          }));
	          var type = 'horizontal';
	          var alignment = 'htRight';
	          this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
	          align(range, type, alignment, (function(row, col) {
	            return $__3.getCellMeta(row, col);
	          }));
	          this.render();
	        },
	        disabled: false
	      }, {
	        key: (ALIGNMENT + ":justify"),
	        name: function() {
	          var $__3 = this;
	          var label = 'Justify';
	          var hasClass = checkSelectionConsistency(this.getSelectedRange(), (function(row, col) {
	            var className = $__3.getCellMeta(row, col).className;
	            if (className && className.indexOf('htJustify') !== -1) {
	              return true;
	            }
	          }));
	          if (hasClass) {
	            label = markLabelAsSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var $__3 = this;
	          var range = this.getSelectedRange();
	          var stateBefore = getAlignmentClasses(range, (function(row, col) {
	            return $__3.getCellMeta(row, col).className;
	          }));
	          var type = 'horizontal';
	          var alignment = 'htJustify';
	          this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
	          align(range, type, alignment, (function(row, col) {
	            return $__3.getCellMeta(row, col);
	          }));
	          this.render();
	        },
	        disabled: false
	      }, {name: SEPARATOR}, {
	        key: (ALIGNMENT + ":top"),
	        name: function() {
	          var $__3 = this;
	          var label = 'Top';
	          var hasClass = checkSelectionConsistency(this.getSelectedRange(), (function(row, col) {
	            var className = $__3.getCellMeta(row, col).className;
	            if (className && className.indexOf('htTop') !== -1) {
	              return true;
	            }
	          }));
	          if (hasClass) {
	            label = markLabelAsSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var $__3 = this;
	          var range = this.getSelectedRange();
	          var stateBefore = getAlignmentClasses(range, (function(row, col) {
	            return $__3.getCellMeta(row, col).className;
	          }));
	          var type = 'vertical';
	          var alignment = 'htTop';
	          this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
	          align(range, type, alignment, (function(row, col) {
	            return $__3.getCellMeta(row, col);
	          }));
	          this.render();
	        },
	        disabled: false
	      }, {
	        key: (ALIGNMENT + ":middle"),
	        name: function() {
	          var $__3 = this;
	          var label = 'Middle';
	          var hasClass = checkSelectionConsistency(this.getSelectedRange(), (function(row, col) {
	            var className = $__3.getCellMeta(row, col).className;
	            if (className && className.indexOf('htMiddle') !== -1) {
	              return true;
	            }
	          }));
	          if (hasClass) {
	            label = markLabelAsSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var $__3 = this;
	          var range = this.getSelectedRange();
	          var stateBefore = getAlignmentClasses(range, (function(row, col) {
	            return $__3.getCellMeta(row, col).className;
	          }));
	          var type = 'vertical';
	          var alignment = 'htMiddle';
	          this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
	          align(range, type, alignment, (function(row, col) {
	            return $__3.getCellMeta(row, col);
	          }));
	          this.render();
	        },
	        disabled: false
	      }, {
	        key: (ALIGNMENT + ":bottom"),
	        name: function() {
	          var $__3 = this;
	          var label = 'Bottom';
	          var hasClass = checkSelectionConsistency(this.getSelectedRange(), (function(row, col) {
	            var className = $__3.getCellMeta(row, col).className;
	            if (className && className.indexOf('htBottom') !== -1) {
	              return true;
	            }
	          }));
	          if (hasClass) {
	            label = markLabelAsSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var $__3 = this;
	          var range = this.getSelectedRange();
	          var stateBefore = getAlignmentClasses(range, (function(row, col) {
	            return $__3.getCellMeta(row, col).className;
	          }));
	          var type = 'vertical';
	          var alignment = 'htBottom';
	          this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
	          align(range, type, alignment, (function(row, col) {
	            return $__3.getCellMeta(row, col);
	          }));
	          this.render();
	        },
	        disabled: false
	      }]}
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), $__4);

	//# 
	},{"helpers/number":51,"helpers/object":52,"utils":73}],73:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  normalizeSelection: {get: function() {
	      return normalizeSelection;
	    }},
	  isSeparator: {get: function() {
	      return isSeparator;
	    }},
	  hasSubMenu: {get: function() {
	      return hasSubMenu;
	    }},
	  isDisabled: {get: function() {
	      return isDisabled;
	    }},
	  isSelectionDisabled: {get: function() {
	      return isSelectionDisabled;
	    }},
	  getValidSelection: {get: function() {
	      return getValidSelection;
	    }},
	  prepareVerticalAlignClass: {get: function() {
	      return prepareVerticalAlignClass;
	    }},
	  prepareHorizontalAlignClass: {get: function() {
	      return prepareHorizontalAlignClass;
	    }},
	  getAlignmentClasses: {get: function() {
	      return getAlignmentClasses;
	    }},
	  align: {get: function() {
	      return align;
	    }},
	  checkSelectionConsistency: {get: function() {
	      return checkSelectionConsistency;
	    }},
	  markLabelAsSelected: {get: function() {
	      return markLabelAsSelected;
	    }},
	  isItemHidden: {get: function() {
	      return isItemHidden;
	    }},
	  filterSeparators: {get: function() {
	      return filterSeparators;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $__predefinedItems__;
	var arrayEach = ($___46__46__47__46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}).arrayEach;
	var hasClass = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}).hasClass;
	var SEPARATOR = ($__predefinedItems__ = _dereq_("predefinedItems"), $__predefinedItems__ && $__predefinedItems__.__esModule && $__predefinedItems__ || {default: $__predefinedItems__}).SEPARATOR;
	function normalizeSelection(selRange) {
	  return {
	    start: selRange.getTopLeftCorner(),
	    end: selRange.getBottomRightCorner()
	  };
	}
	function isSeparator(cell) {
	  return hasClass(cell, 'htSeparator');
	}
	function hasSubMenu(cell) {
	  return hasClass(cell, 'htSubmenu');
	}
	function isDisabled(cell) {
	  return hasClass(cell, 'htDisabled');
	}
	function isSelectionDisabled(cell) {
	  return hasClass(cell, 'htSelectionDisabled');
	}
	function getValidSelection(hot) {
	  var selected = hot.getSelected();
	  if (!selected) {
	    return null;
	  }
	  if (selected[0] < 0) {
	    return null;
	  }
	  return selected;
	}
	function prepareVerticalAlignClass(className, alignment) {
	  if (className.indexOf(alignment) != -1) {
	    return className;
	  }
	  className = className.replace('htTop', '').replace('htMiddle', '').replace('htBottom', '').replace('  ', '');
	  className += ' ' + alignment;
	  return className;
	}
	function prepareHorizontalAlignClass(className, alignment) {
	  if (className.indexOf(alignment) != -1) {
	    return className;
	  }
	  className = className.replace('htLeft', '').replace('htCenter', '').replace('htRight', '').replace('htJustify', '').replace('  ', '');
	  className += ' ' + alignment;
	  return className;
	}
	function getAlignmentClasses(range, callback) {
	  var classes = {};
	  for (var row = range.from.row; row <= range.to.row; row++) {
	    for (var col = range.from.col; col <= range.to.col; col++) {
	      if (!classes[row]) {
	        classes[row] = [];
	      }
	      classes[row][col] = callback(row, col);
	    }
	  }
	  return classes;
	}
	function align(range, type, alignment, cellDescriptor) {
	  if (range.from.row == range.to.row && range.from.col == range.to.col) {
	    applyAlignClassName(range.from.row, range.from.col, type, alignment, cellDescriptor);
	  } else {
	    for (var row = range.from.row; row <= range.to.row; row++) {
	      for (var col = range.from.col; col <= range.to.col; col++) {
	        applyAlignClassName(row, col, type, alignment, cellDescriptor);
	      }
	    }
	  }
	}
	function applyAlignClassName(row, col, type, alignment, cellDescriptor) {
	  var cellMeta = cellDescriptor(row, col);
	  var className = alignment;
	  if (cellMeta.className) {
	    if (type === 'vertical') {
	      className = prepareVerticalAlignClass(cellMeta.className, alignment);
	    } else {
	      className = prepareHorizontalAlignClass(cellMeta.className, alignment);
	    }
	  }
	  cellMeta.className = className;
	}
	function checkSelectionConsistency(range, comparator) {
	  var result = false;
	  if (range) {
	    range.forAll(function(row, col) {
	      if (comparator(row, col)) {
	        result = true;
	        return false;
	      }
	    });
	  }
	  return result;
	}
	function markLabelAsSelected(label) {
	  return '<span class="selected">' + String.fromCharCode(10003) + '</span>' + label;
	}
	function isItemHidden(item, instance) {
	  return !item.hidden || !(typeof item.hidden == 'function' && item.hidden.call(instance));
	}
	function shiftSeparators(items, separator) {
	  var result = items.slice(0);
	  for (var i = 0; i < result.length; ) {
	    if (result[i].name === separator) {
	      result.shift();
	    } else {
	      break;
	    }
	  }
	  return result;
	}
	function popSeparators(items, separator) {
	  var result = items.slice(0);
	  result.reverse();
	  result = shiftSeparators(result, separator);
	  result.reverse();
	  return result;
	}
	function removeDuplicatedSeparators(items) {
	  var result = [];
	  arrayEach(items, (function(value, index) {
	    if (index > 0) {
	      if (result[result.length - 1].name !== value.name) {
	        result.push(value);
	      }
	    } else {
	      result.push(value);
	    }
	  }));
	  return result;
	}
	function filterSeparators(items) {
	  var separator = arguments[1] !== (void 0) ? arguments[1] : SEPARATOR;
	  var result = items.slice(0);
	  result = shiftSeparators(result, separator);
	  result = popSeparators(result, separator);
	  result = removeDuplicatedSeparators(result);
	  return result;
	}

	//# 
	},{"helpers/array":42,"helpers/dom/element":46,"predefinedItems":72}],74:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ContextMenuCopyPaste: {get: function() {
	      return ContextMenuCopyPaste;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__95_base__,
	    $__zeroclipboard__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var removeClass = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}).removeClass;
	var arrayEach = ($___46__46__47__46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}).arrayEach;
	var EventManager = ($___46__46__47__46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).EventManager;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var BasePlugin = ($___46__46__47__95_base__ = _dereq_("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var ZeroClipboard = ($__zeroclipboard__ = _dereq_("zeroclipboard"), $__zeroclipboard__ && $__zeroclipboard__.__esModule && $__zeroclipboard__ || {default: $__zeroclipboard__}).default;
	var ContextMenuCopyPaste = function ContextMenuCopyPaste(hotInstance) {
	  $traceurRuntime.superConstructor($ContextMenuCopyPaste).call(this, hotInstance);
	  this.eventManager = new EventManager(this);
	  this.swfPath = null;
	  this.outsideClickDeselectsCache = null;
	};
	var $ContextMenuCopyPaste = ContextMenuCopyPaste;
	($traceurRuntime.createClass)(ContextMenuCopyPaste, {
	  isEnabled: function() {
	    return this.hot.getSettings().contextMenuCopyPaste;
	  },
	  enablePlugin: function() {
	    var $__7 = this;
	    if (this.enabled) {
	      return;
	    }
	    if (typeof this.hot.getSettings().contextMenuCopyPaste === 'object') {
	      this.swfPath = this.hot.getSettings().contextMenuCopyPaste.swfPath;
	    }
	    if (typeof ZeroClipboard === 'undefined') {
	      console.error('To be able to use the Copy/Paste feature from the context menu, you need to manually include ZeroClipboard.js file to your website.');
	    }
	    try {
	      new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
	    } catch (exception) {
	      if (typeof navigator.mimeTypes['application/x-shockwave-flash'] == 'undefined') {
	        console.error('To be able to use the Copy/Paste feature from the context menu, your browser needs to have Flash Plugin installed.');
	      }
	    }
	    if (this.swfPath) {
	      ZeroClipboard.config({swfPath: this.swfPath});
	    }
	    this.hot.addHook('afterContextMenuShow', (function() {
	      return $__7.onAfterContextMenuShow();
	    }));
	    this.hot.addHook('afterContextMenuDefaultOptions', (function(options) {
	      return $__7.onAfterContextMenuDefaultOptions(options);
	    }));
	    this.registerEvents();
	    $traceurRuntime.superGet(this, $ContextMenuCopyPaste.prototype, "enablePlugin").call(this);
	  },
	  disablePlugin: function() {
	    $traceurRuntime.superGet(this, $ContextMenuCopyPaste.prototype, "disablePlugin").call(this);
	  },
	  registerEvents: function() {
	    var $__7 = this;
	    this.eventManager.addEventListener(document, 'mouseenter', (function() {
	      return $__7.removeCurrentClass();
	    }));
	    this.eventManager.addEventListener(document, 'mouseleave', (function() {
	      return $__7.removeZeroClipboardClass();
	    }));
	  },
	  getCopyValue: function() {
	    this.hot.copyPaste.setCopyableText();
	    return this.hot.copyPaste.copyPasteInstance.elTextarea.value;
	  },
	  onAfterContextMenuDefaultOptions: function(defaultOptions) {
	    defaultOptions.items.unshift({
	      key: 'copy',
	      name: 'Copy'
	    }, {
	      key: 'paste',
	      name: 'Paste',
	      callback: function() {
	        this.copyPaste.triggerPaste();
	      }
	    }, Handsontable.plugins.ContextMenu.SEPARATOR);
	  },
	  onAfterContextMenuShow: function() {
	    var $__7 = this;
	    var contextMenu = this.hot.getPlugin('contextMenu');
	    var data = contextMenu.menu.hotMenu.getSourceData();
	    arrayEach(data, (function(item, index) {
	      if (item.key === 'copy') {
	        var zeroClipboardInstance = new ZeroClipboard(contextMenu.menu.hotMenu.getCell(index, 0));
	        zeroClipboardInstance.off();
	        zeroClipboardInstance.on('copy', (function(event) {
	          var clipboard = event.clipboardData;
	          clipboard.setData('text/plain', $__7.getCopyValue());
	          $__7.hot.getSettings().outsideClickDeselects = $__7.outsideClickDeselectsCache;
	        }));
	        return false;
	      }
	    }));
	  },
	  removeCurrentClass: function() {
	    var contextMenu = this.hot.getPlugin('contextMenu');
	    if (contextMenu.menu.isOpened()) {
	      var element = contextMenu.menu.hotMenu.rootElement.querySelector('td.current');
	      if (element) {
	        removeClass(element, 'current');
	      }
	    }
	    this.outsideClickDeselectsCache = this.hot.getSettings().outsideClickDeselects;
	    this.hot.getSettings().outsideClickDeselects = false;
	  },
	  removeZeroClipboardClass: function() {
	    var contextMenu = this.hot.getPlugin('contextMenu');
	    if (contextMenu.menu.isOpened()) {
	      var element = contextMenu.menu.hotMenu.rootElement.querySelector('td.zeroclipboard-is-hover');
	      if (element) {
	        removeClass(element, 'zeroclipboard-is-hover');
	      }
	    }
	    this.hot.getSettings().outsideClickDeselects = this.outsideClickDeselectsCache;
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('contextMenuCopyPaste', ContextMenuCopyPaste);

	//# 
	},{"_base":60,"browser":23,"eventManager":41,"helpers/array":42,"helpers/dom/element":46,"plugins":59,"zeroclipboard":"zeroclipboard"}],75:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  CopyPastePlugin: {get: function() {
	      return CopyPastePlugin;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_browser__,
	    $__copyPaste__,
	    $__SheetClip__,
	    $___46__46__47__46__46__47_helpers_47_unicode__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47_helpers_47_number__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_helpers_47_function__,
	    $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var copyPaste = ($__copyPaste__ = _dereq_("copyPaste"), $__copyPaste__ && $__copyPaste__.__esModule && $__copyPaste__ || {default: $__copyPaste__}).default;
	var SheetClip = ($__SheetClip__ = _dereq_("SheetClip"), $__SheetClip__ && $__SheetClip__.__esModule && $__SheetClip__ || {default: $__SheetClip__}).default;
	var $__3 = ($___46__46__47__46__46__47_helpers_47_unicode__ = _dereq_("helpers/unicode"), $___46__46__47__46__46__47_helpers_47_unicode__ && $___46__46__47__46__46__47_helpers_47_unicode__.__esModule && $___46__46__47__46__46__47_helpers_47_unicode__ || {default: $___46__46__47__46__46__47_helpers_47_unicode__}),
	    KEY_CODES = $__3.KEY_CODES,
	    isCtrlKey = $__3.isCtrlKey;
	var arrayEach = ($___46__46__47__46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}).arrayEach;
	var rangeEach = ($___46__46__47__46__46__47_helpers_47_number__ = _dereq_("helpers/number"), $___46__46__47__46__46__47_helpers_47_number__ && $___46__46__47__46__46__47_helpers_47_number__.__esModule && $___46__46__47__46__46__47_helpers_47_number__ || {default: $___46__46__47__46__46__47_helpers_47_number__}).rangeEach;
	var $__6 = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}),
	    stopImmediatePropagation = $__6.stopImmediatePropagation,
	    isImmediatePropagationStopped = $__6.isImmediatePropagationStopped;
	var getSelectionText = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}).getSelectionText;
	var proxy = ($___46__46__47__46__46__47_helpers_47_function__ = _dereq_("helpers/function"), $___46__46__47__46__46__47_helpers_47_function__ && $___46__46__47__46__46__47_helpers_47_function__.__esModule && $___46__46__47__46__46__47_helpers_47_function__ || {default: $___46__46__47__46__46__47_helpers_47_function__}).proxy;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var WalkontableCellCoords = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ = _dereq_("3rdparty/walkontable/src/cell/coords"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	var WalkontableCellRange = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ = _dereq_("3rdparty/walkontable/src/cell/range"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__}).WalkontableCellRange;
	function CopyPastePlugin(instance) {
	  var _this = this;
	  this.copyPasteInstance = copyPaste();
	  this.copyPasteInstance.onCut(onCut);
	  this.copyPasteInstance.onPaste(onPaste);
	  this.onPaste = onPaste;
	  instance.addHook('beforeKeyDown', onBeforeKeyDown);
	  function onCut() {
	    if (!instance.isListening()) {
	      return;
	    }
	    instance.selection.empty();
	  }
	  function onPaste(str) {
	    var input,
	        inputArray,
	        selected,
	        coordsFrom,
	        coordsTo,
	        cellRange,
	        topLeftCorner,
	        bottomRightCorner,
	        areaStart,
	        areaEnd;
	    if (!instance.isListening() || !instance.selection.isSelected()) {
	      return;
	    }
	    input = str;
	    inputArray = SheetClip.parse(input);
	    selected = instance.getSelected();
	    coordsFrom = new WalkontableCellCoords(selected[0], selected[1]);
	    coordsTo = new WalkontableCellCoords(selected[2], selected[3]);
	    cellRange = new WalkontableCellRange(coordsFrom, coordsFrom, coordsTo);
	    topLeftCorner = cellRange.getTopLeftCorner();
	    bottomRightCorner = cellRange.getBottomRightCorner();
	    areaStart = topLeftCorner;
	    areaEnd = new WalkontableCellCoords(Math.max(bottomRightCorner.row, inputArray.length - 1 + topLeftCorner.row), Math.max(bottomRightCorner.col, inputArray[0].length - 1 + topLeftCorner.col));
	    var isSelRowAreaCoverInputValue = coordsTo.row - coordsFrom.row >= inputArray.length - 1;
	    var isSelColAreaCoverInputValue = coordsTo.col - coordsFrom.col >= inputArray[0].length - 1;
	    instance.addHookOnce('afterChange', (function(changes, source) {
	      var changesLength = changes ? changes.length : 0;
	      if (changesLength) {
	        var offset = {
	          row: 0,
	          col: 0
	        };
	        var highestColumnIndex = -1;
	        arrayEach(changes, (function(change, index) {
	          var nextChange = changesLength > index + 1 ? changes[index + 1] : null;
	          if (nextChange) {
	            if (!isSelRowAreaCoverInputValue) {
	              offset.row = offset.row + Math.max(nextChange[0] - change[0] - 1, 0);
	            }
	            if (!isSelColAreaCoverInputValue && change[1] > highestColumnIndex) {
	              highestColumnIndex = change[1];
	              offset.col = offset.col + Math.max(nextChange[1] - change[1] - 1, 0);
	            }
	          }
	        }));
	        instance.selectCell(areaStart.row, areaStart.col, areaEnd.row + offset.row, areaEnd.col + offset.col);
	      }
	    }));
	    instance.populateFromArray(areaStart.row, areaStart.col, inputArray, areaEnd.row, areaEnd.col, 'paste', instance.getSettings().pasteMode);
	  }
	  function onBeforeKeyDown(event) {
	    if (!instance.getSelected()) {
	      return;
	    }
	    if (instance.getActiveEditor() && instance.getActiveEditor().isOpened()) {
	      return;
	    }
	    if (isImmediatePropagationStopped(event)) {
	      return;
	    }
	    if (isCtrlKey(event.keyCode)) {
	      if (instance.getSettings().fragmentSelection && getSelectionText()) {
	        return;
	      }
	      _this.setCopyableText();
	      stopImmediatePropagation(event);
	      return;
	    }
	    var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;
	    if (event.keyCode == KEY_CODES.A && ctrlDown) {
	      instance._registerTimeout(setTimeout(proxy(_this.setCopyableText, _this), 0));
	    }
	  }
	  this.destroy = function() {
	    if (this.copyPasteInstance) {
	      this.copyPasteInstance.removeCallback(onCut);
	      this.copyPasteInstance.removeCallback(onPaste);
	      this.copyPasteInstance.destroy();
	      this.copyPasteInstance = null;
	    }
	    instance.removeHook('beforeKeyDown', onBeforeKeyDown);
	  };
	  instance.addHook('afterDestroy', proxy(this.destroy, this));
	  this.triggerPaste = proxy(this.copyPasteInstance.triggerPaste, this.copyPasteInstance);
	  this.triggerCut = proxy(this.copyPasteInstance.triggerCut, this.copyPasteInstance);
	  this.setCopyableText = function() {
	    var settings = instance.getSettings();
	    var copyRowsLimit = settings.copyRowsLimit;
	    var copyColsLimit = settings.copyColsLimit;
	    var selRange = instance.getSelectedRange();
	    var topLeft = selRange.getTopLeftCorner();
	    var bottomRight = selRange.getBottomRightCorner();
	    var startRow = topLeft.row;
	    var startCol = topLeft.col;
	    var endRow = bottomRight.row;
	    var endCol = bottomRight.col;
	    var finalEndRow = Math.min(endRow, startRow + copyRowsLimit - 1);
	    var finalEndCol = Math.min(endCol, startCol + copyColsLimit - 1);
	    var copyableRanges = [];
	    copyableRanges.push({
	      startRow: startRow,
	      startCol: startCol,
	      endRow: finalEndRow,
	      endCol: finalEndCol
	    });
	    copyableRanges = Handsontable.hooks.run(instance, 'modifyCopyableRange', copyableRanges);
	    var copyableData = this.getRangedCopyableData(copyableRanges);
	    instance.copyPaste.copyPasteInstance.copyable(copyableData);
	    if (endRow !== finalEndRow || endCol !== finalEndCol) {
	      Handsontable.hooks.run(instance, 'afterCopyLimit', endRow - startRow + 1, endCol - startCol + 1, copyRowsLimit, copyColsLimit);
	    }
	  };
	  this.getRangedCopyableData = function(ranges) {
	    var dataSet = [];
	    var copyableRows = [];
	    var copyableColumns = [];
	    arrayEach(ranges, (function(range) {
	      rangeEach(range.startRow, range.endRow, (function(row) {
	        if (copyableRows.indexOf(row) === -1) {
	          copyableRows.push(row);
	        }
	      }));
	      rangeEach(range.startCol, range.endCol, (function(column) {
	        if (copyableColumns.indexOf(column) === -1) {
	          copyableColumns.push(column);
	        }
	      }));
	    }));
	    arrayEach(copyableRows, (function(row) {
	      var rowSet = [];
	      arrayEach(copyableColumns, (function(column) {
	        rowSet.push(instance.getCopyableData(row, column));
	      }));
	      dataSet.push(rowSet);
	    }));
	    return SheetClip.stringify(dataSet);
	  };
	}
	function init() {
	  var instance = this,
	      pluginEnabled = instance.getSettings().copyPaste !== false;
	  if (pluginEnabled && !instance.copyPaste) {
	    instance.copyPaste = new CopyPastePlugin(instance);
	  } else if (!pluginEnabled && instance.copyPaste) {
	    instance.copyPaste.destroy();
	    instance.copyPaste = null;
	  }
	}
	Handsontable.hooks.add('afterInit', init);
	Handsontable.hooks.add('afterUpdateSettings', init);
	Handsontable.hooks.register('afterCopyLimit');
	Handsontable.hooks.register('modifyCopyableRange');
	;

	//# 
	},{"3rdparty/walkontable/src/cell/coords":5,"3rdparty/walkontable/src/cell/range":6,"SheetClip":"SheetClip","browser":23,"copyPaste":"copyPaste","helpers/array":42,"helpers/dom/element":46,"helpers/dom/event":47,"helpers/function":49,"helpers/number":51,"helpers/unicode":55,"plugins":59}],76:[function(_dereq_,module,exports){
	"use strict";
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_selection__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var WalkontableCellRange = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ = _dereq_("3rdparty/walkontable/src/cell/range"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__}).WalkontableCellRange;
	var WalkontableSelection = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_selection__ = _dereq_("3rdparty/walkontable/src/selection"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_selection__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_selection__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_selection__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_selection__}).WalkontableSelection;
	function CustomBorders() {}
	var instance;
	var checkEnable = function(customBorders) {
	  if (typeof customBorders === 'boolean') {
	    if (customBorders === true) {
	      return true;
	    }
	  }
	  if (typeof customBorders === 'object') {
	    if (customBorders.length > 0) {
	      return true;
	    }
	  }
	  return false;
	};
	var init = function() {
	  if (checkEnable(this.getSettings().customBorders)) {
	    if (!this.customBorders) {
	      instance = this;
	      this.customBorders = new CustomBorders();
	    }
	  }
	};
	var getSettingIndex = function(className) {
	  for (var i = 0; i < instance.view.wt.selections.length; i++) {
	    if (instance.view.wt.selections[i].settings.className == className) {
	      return i;
	    }
	  }
	  return -1;
	};
	var insertBorderIntoSettings = function(border) {
	  var coordinates = {
	    row: border.row,
	    col: border.col
	  };
	  var selection = new WalkontableSelection(border, new WalkontableCellRange(coordinates, coordinates, coordinates));
	  var index = getSettingIndex(border.className);
	  if (index >= 0) {
	    instance.view.wt.selections[index] = selection;
	  } else {
	    instance.view.wt.selections.push(selection);
	  }
	};
	var prepareBorderFromCustomAdded = function(row, col, borderObj) {
	  var border = createEmptyBorders(row, col);
	  border = extendDefaultBorder(border, borderObj);
	  this.setCellMeta(row, col, 'borders', border);
	  insertBorderIntoSettings(border);
	};
	var prepareBorderFromCustomAddedRange = function(rowObj) {
	  var range = rowObj.range;
	  for (var row = range.from.row; row <= range.to.row; row++) {
	    for (var col = range.from.col; col <= range.to.col; col++) {
	      var border = createEmptyBorders(row, col);
	      var add = 0;
	      if (row == range.from.row) {
	        add++;
	        if (rowObj.hasOwnProperty('top')) {
	          border.top = rowObj.top;
	        }
	      }
	      if (row == range.to.row) {
	        add++;
	        if (rowObj.hasOwnProperty('bottom')) {
	          border.bottom = rowObj.bottom;
	        }
	      }
	      if (col == range.from.col) {
	        add++;
	        if (rowObj.hasOwnProperty('left')) {
	          border.left = rowObj.left;
	        }
	      }
	      if (col == range.to.col) {
	        add++;
	        if (rowObj.hasOwnProperty('right')) {
	          border.right = rowObj.right;
	        }
	      }
	      if (add > 0) {
	        this.setCellMeta(row, col, 'borders', border);
	        insertBorderIntoSettings(border);
	      }
	    }
	  }
	};
	var createClassName = function(row, col) {
	  return 'border_row' + row + 'col' + col;
	};
	var createDefaultCustomBorder = function() {
	  return {
	    width: 1,
	    color: '#000'
	  };
	};
	var createSingleEmptyBorder = function() {
	  return {hide: true};
	};
	var createDefaultHtBorder = function() {
	  return {
	    width: 1,
	    color: '#000',
	    cornerVisible: false
	  };
	};
	var createEmptyBorders = function(row, col) {
	  return {
	    className: createClassName(row, col),
	    border: createDefaultHtBorder(),
	    row: row,
	    col: col,
	    top: createSingleEmptyBorder(),
	    right: createSingleEmptyBorder(),
	    bottom: createSingleEmptyBorder(),
	    left: createSingleEmptyBorder()
	  };
	};
	var extendDefaultBorder = function(defaultBorder, customBorder) {
	  if (customBorder.hasOwnProperty('border')) {
	    defaultBorder.border = customBorder.border;
	  }
	  if (customBorder.hasOwnProperty('top')) {
	    defaultBorder.top = customBorder.top;
	  }
	  if (customBorder.hasOwnProperty('right')) {
	    defaultBorder.right = customBorder.right;
	  }
	  if (customBorder.hasOwnProperty('bottom')) {
	    defaultBorder.bottom = customBorder.bottom;
	  }
	  if (customBorder.hasOwnProperty('left')) {
	    defaultBorder.left = customBorder.left;
	  }
	  return defaultBorder;
	};
	var removeBordersFromDom = function(borderClassName) {
	  var borders = document.querySelectorAll('.' + borderClassName);
	  for (var i = 0; i < borders.length; i++) {
	    if (borders[i]) {
	      if (borders[i].nodeName != 'TD') {
	        var parent = borders[i].parentNode;
	        if (parent.parentNode) {
	          parent.parentNode.removeChild(parent);
	        }
	      }
	    }
	  }
	};
	var removeAllBorders = function(row, col) {
	  var borderClassName = createClassName(row, col);
	  removeBordersFromDom(borderClassName);
	  this.removeCellMeta(row, col, 'borders');
	};
	var setBorder = function(row, col, place, remove) {
	  var bordersMeta = this.getCellMeta(row, col).borders;
	  if (!bordersMeta || bordersMeta.border == undefined) {
	    bordersMeta = createEmptyBorders(row, col);
	  }
	  if (remove) {
	    bordersMeta[place] = createSingleEmptyBorder();
	  } else {
	    bordersMeta[place] = createDefaultCustomBorder();
	  }
	  this.setCellMeta(row, col, 'borders', bordersMeta);
	  var borderClassName = createClassName(row, col);
	  removeBordersFromDom(borderClassName);
	  insertBorderIntoSettings(bordersMeta);
	  this.render();
	};
	var prepareBorder = function(range, place, remove) {
	  if (range.from.row == range.to.row && range.from.col == range.to.col) {
	    if (place == 'noBorders') {
	      removeAllBorders.call(this, range.from.row, range.from.col);
	    } else {
	      setBorder.call(this, range.from.row, range.from.col, place, remove);
	    }
	  } else {
	    switch (place) {
	      case 'noBorders':
	        for (var column = range.from.col; column <= range.to.col; column++) {
	          for (var row = range.from.row; row <= range.to.row; row++) {
	            removeAllBorders.call(this, row, column);
	          }
	        }
	        break;
	      case 'top':
	        for (var topCol = range.from.col; topCol <= range.to.col; topCol++) {
	          setBorder.call(this, range.from.row, topCol, place, remove);
	        }
	        break;
	      case 'right':
	        for (var rowRight = range.from.row; rowRight <= range.to.row; rowRight++) {
	          setBorder.call(this, rowRight, range.to.col, place);
	        }
	        break;
	      case 'bottom':
	        for (var bottomCol = range.from.col; bottomCol <= range.to.col; bottomCol++) {
	          setBorder.call(this, range.to.row, bottomCol, place);
	        }
	        break;
	      case 'left':
	        for (var rowLeft = range.from.row; rowLeft <= range.to.row; rowLeft++) {
	          setBorder.call(this, rowLeft, range.from.col, place);
	        }
	        break;
	    }
	  }
	};
	var checkSelectionBorders = function(hot, direction) {
	  var atLeastOneHasBorder = false;
	  hot.getSelectedRange().forAll(function(r, c) {
	    var metaBorders = hot.getCellMeta(r, c).borders;
	    if (metaBorders) {
	      if (direction) {
	        if (!metaBorders[direction].hasOwnProperty('hide')) {
	          atLeastOneHasBorder = true;
	          return false;
	        }
	      } else {
	        atLeastOneHasBorder = true;
	        return false;
	      }
	    }
	  });
	  return atLeastOneHasBorder;
	};
	var markSelected = function(label) {
	  return '<span class="selected">' + String.fromCharCode(10003) + '</span>' + label;
	};
	var addBordersOptionsToContextMenu = function(defaultOptions) {
	  if (!this.getSettings().customBorders) {
	    return;
	  }
	  defaultOptions.items.push(Handsontable.plugins.ContextMenu.SEPARATOR);
	  defaultOptions.items.push({
	    key: 'borders',
	    name: 'Borders',
	    submenu: {items: [{
	        key: 'borders:top',
	        name: function() {
	          var label = 'Top';
	          var hasBorder = checkSelectionBorders(this, 'top');
	          if (hasBorder) {
	            label = markSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var hasBorder = checkSelectionBorders(this, 'top');
	          prepareBorder.call(this, this.getSelectedRange(), 'top', hasBorder);
	        },
	        disabled: false
	      }, {
	        key: 'borders:right',
	        name: function() {
	          var label = 'Right';
	          var hasBorder = checkSelectionBorders(this, 'right');
	          if (hasBorder) {
	            label = markSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var hasBorder = checkSelectionBorders(this, 'right');
	          prepareBorder.call(this, this.getSelectedRange(), 'right', hasBorder);
	        },
	        disabled: false
	      }, {
	        key: 'borders:bottom',
	        name: function() {
	          var label = 'Bottom';
	          var hasBorder = checkSelectionBorders(this, 'bottom');
	          if (hasBorder) {
	            label = markSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var hasBorder = checkSelectionBorders(this, 'bottom');
	          prepareBorder.call(this, this.getSelectedRange(), 'bottom', hasBorder);
	        },
	        disabled: false
	      }, {
	        key: 'borders:left',
	        name: function() {
	          var label = 'Left';
	          var hasBorder = checkSelectionBorders(this, 'left');
	          if (hasBorder) {
	            label = markSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var hasBorder = checkSelectionBorders(this, 'left');
	          prepareBorder.call(this, this.getSelectedRange(), 'left', hasBorder);
	        },
	        disabled: false
	      }, {
	        key: 'borders:no_borders',
	        name: 'Remove border(s)',
	        callback: function() {
	          prepareBorder.call(this, this.getSelectedRange(), 'noBorders');
	        },
	        disabled: function() {
	          return !checkSelectionBorders(this);
	        }
	      }]}
	  });
	};
	Handsontable.hooks.add('beforeInit', init);
	Handsontable.hooks.add('afterContextMenuDefaultOptions', addBordersOptionsToContextMenu);
	Handsontable.hooks.add('afterInit', function() {
	  var customBorders = this.getSettings().customBorders;
	  if (customBorders) {
	    for (var i = 0; i < customBorders.length; i++) {
	      if (customBorders[i].range) {
	        prepareBorderFromCustomAddedRange.call(this, customBorders[i]);
	      } else {
	        prepareBorderFromCustomAdded.call(this, customBorders[i].row, customBorders[i].col, customBorders[i]);
	      }
	    }
	    this.render();
	    this.view.wt.draw(true);
	  }
	});
	Handsontable.CustomBorders = CustomBorders;

	//# 
	},{"3rdparty/walkontable/src/cell/range":6,"3rdparty/walkontable/src/selection":18,"browser":23,"plugins":59}],77:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  DragToScroll: {get: function() {
	      return DragToScroll;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_plugins__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var eventManagerObject = ($___46__46__47__46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).eventManager;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	;
	Handsontable.plugins.DragToScroll = DragToScroll;
	function DragToScroll() {
	  this.boundaries = null;
	  this.callback = null;
	}
	DragToScroll.prototype.setBoundaries = function(boundaries) {
	  this.boundaries = boundaries;
	};
	DragToScroll.prototype.setCallback = function(callback) {
	  this.callback = callback;
	};
	DragToScroll.prototype.check = function(x, y) {
	  var diffX = 0;
	  var diffY = 0;
	  if (y < this.boundaries.top) {
	    diffY = y - this.boundaries.top;
	  } else if (y > this.boundaries.bottom) {
	    diffY = y - this.boundaries.bottom;
	  }
	  if (x < this.boundaries.left) {
	    diffX = x - this.boundaries.left;
	  } else if (x > this.boundaries.right) {
	    diffX = x - this.boundaries.right;
	  }
	  this.callback(diffX, diffY);
	};
	var dragToScroll;
	var instance;
	var setupListening = function(instance) {
	  instance.dragToScrollListening = false;
	  var scrollHandler = instance.view.wt.wtTable.holder;
	  dragToScroll = new DragToScroll();
	  if (scrollHandler === window) {
	    return;
	  } else {
	    dragToScroll.setBoundaries(scrollHandler.getBoundingClientRect());
	  }
	  dragToScroll.setCallback(function(scrollX, scrollY) {
	    if (scrollX < 0) {
	      scrollHandler.scrollLeft -= 50;
	    } else if (scrollX > 0) {
	      scrollHandler.scrollLeft += 50;
	    }
	    if (scrollY < 0) {
	      scrollHandler.scrollTop -= 20;
	    } else if (scrollY > 0) {
	      scrollHandler.scrollTop += 20;
	    }
	  });
	  instance.dragToScrollListening = true;
	};
	Handsontable.hooks.add('afterInit', function() {
	  var instance = this;
	  var eventManager = eventManagerObject(this);
	  eventManager.addEventListener(document, 'mouseup', function() {
	    instance.dragToScrollListening = false;
	  });
	  eventManager.addEventListener(document, 'mousemove', function(event) {
	    if (instance.dragToScrollListening) {
	      dragToScroll.check(event.clientX, event.clientY);
	    }
	  });
	});
	Handsontable.hooks.add('afterDestroy', function() {
	  eventManagerObject(this).clear();
	});
	Handsontable.hooks.add('afterOnCellMouseDown', function() {
	  setupListening(this);
	});
	Handsontable.hooks.add('afterOnCellCornerMouseDown', function() {
	  setupListening(this);
	});
	Handsontable.plugins.DragToScroll = DragToScroll;

	//# 
	},{"browser":23,"eventManager":41,"plugins":59}],78:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ManualColumnFreeze: {get: function() {
	      return ManualColumnFreeze;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__95_base__,
	    $___46__46__47__46__46__47_plugins__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var BasePlugin = ($___46__46__47__95_base__ = _dereq_("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var ManualColumnFreeze = function ManualColumnFreeze(hotInstance) {
	  $traceurRuntime.superConstructor($ManualColumnFreeze).call(this, hotInstance);
	  this.manualColumnMovePlugin = null;
	  this.frozenColumnsBasePositions = [];
	};
	var $ManualColumnFreeze = ManualColumnFreeze;
	($traceurRuntime.createClass)(ManualColumnFreeze, {
	  isEnabled: function() {
	    return !!this.hot.getSettings().manualColumnFreeze;
	  },
	  enablePlugin: function() {
	    var $__3 = this;
	    if (this.enabled) {
	      return;
	    }
	    this.addHook('modifyCol', (function(col) {
	      return $__3.onModifyCol(col);
	    }));
	    this.addHook('afterContextMenuDefaultOptions', (function(defaultOptions) {
	      return $__3.addContextMenuEntry(defaultOptions);
	    }));
	    $traceurRuntime.superGet(this, $ManualColumnFreeze.prototype, "enablePlugin").call(this);
	  },
	  init: function() {
	    $traceurRuntime.superGet(this, $ManualColumnFreeze.prototype, "init").call(this);
	    this.fixedColumnsCount = this.hot.getSettings().fixedColumnsLeft;
	  },
	  getManualColumnMovePlugin: function() {
	    if (!this.manualColumnMovePlugin) {
	      this.manualColumnMovePlugin = this.hot.getPlugin('manualColumnMove');
	    }
	    return this.manualColumnMovePlugin;
	  },
	  onModifyCol: function(column) {
	    if (this.getManualColumnMovePlugin().isEnabled()) {
	      return column;
	    }
	    return this.getLogicalColumnIndex(column);
	  },
	  addContextMenuEntry: function(defaultOptions) {
	    var _this = this;
	    defaultOptions.items.push(Handsontable.plugins.ContextMenu.SEPARATOR, {
	      key: 'freeze_column',
	      name: function() {
	        var selectedColumn = _this.hot.getSelected()[1];
	        if (selectedColumn > _this.fixedColumnsCount - 1) {
	          return 'Freeze this column';
	        } else {
	          return 'Unfreeze this column';
	        }
	      },
	      disabled: function() {
	        var selection = _this.hot.getSelected();
	        return selection[1] !== selection[3];
	      },
	      callback: function() {
	        var selectedColumn = _this.hot.getSelected()[1];
	        if (selectedColumn > _this.fixedColumnsCount - 1) {
	          _this.freezeColumn(selectedColumn);
	        } else {
	          _this.unfreezeColumn(selectedColumn);
	        }
	      }
	    });
	  },
	  freezeColumn: function(column) {
	    if (column <= this.fixedColumnsCount - 1) {
	      return;
	    }
	    if (column !== this.getLogicalColumnIndex(column)) {
	      this.frozenColumnsBasePositions[this.fixedColumnsCount] = column;
	    }
	    this.changeColumnPositions(column, this.fixedColumnsCount);
	    this.addFixedColumn();
	    this.hot.view.wt.wtOverlays.leftOverlay.refresh();
	    this.hot.view.wt.wtOverlays.adjustElementsSize();
	  },
	  unfreezeColumn: function(column) {
	    if (column > this.fixedColumnsCount - 1) {
	      return;
	    }
	    var returnCol = this.getBestColumnReturnPosition(column);
	    this.changeColumnPositions(column, returnCol);
	    this.removeFixedColumn();
	    this.hot.view.wt.wtOverlays.leftOverlay.refresh();
	    this.hot.view.wt.wtOverlays.adjustElementsSize();
	  },
	  addFixedColumn: function() {
	    this.hot.updateSettings({fixedColumnsLeft: this.fixedColumnsCount + 1});
	    this.fixedColumnsCount++;
	  },
	  removeFixedColumn: function() {
	    this.hot.updateSettings({fixedColumnsLeft: this.fixedColumnsCount - 1});
	    this.fixedColumnsCount--;
	  },
	  getBestColumnReturnPosition: function(column) {
	    var i = this.fixedColumnsCount;
	    var j = this.getLogicalColumnIndex(i);
	    var initialCol;
	    if (this.frozenColumnsBasePositions[column] == null) {
	      initialCol = this.getLogicalColumnIndex(column);
	      while (j < initialCol) {
	        i++;
	        j = this.getLogicalColumnIndex(i);
	      }
	    } else {
	      initialCol = this.frozenColumnsBasePositions[column];
	      this.frozenColumnsBasePositions[column] = void 0;
	      while (j <= initialCol) {
	        i++;
	        j = this.getLogicalColumnIndex(i);
	      }
	      i = j;
	    }
	    return i - 1;
	  },
	  getVisibleColumnIndex: function(column) {
	    return this.getManualColumnMovePlugin().getVisibleColumnIndex(column);
	  },
	  getLogicalColumnIndex: function(column) {
	    return this.getManualColumnMovePlugin().getLogicalColumnIndex(column);
	  },
	  changeColumnPositions: function(sourceColumn, destinationColumn) {
	    this.getManualColumnMovePlugin().changeColumnPositions(sourceColumn, destinationColumn);
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('manualColumnFreeze', ManualColumnFreeze);

	//# 
	},{"_base":60,"browser":23,"plugins":59}],79:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ManualColumnMove: {get: function() {
	      return ManualColumnMove;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__95_base_46_js__,
	    $___46__46__47__46__46__47_browser__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47_helpers_47_number__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47__46__46__47_plugins__;
	var BasePlugin = ($___46__46__47__95_base_46_js__ = _dereq_("_base.js"), $___46__46__47__95_base_46_js__ && $___46__46__47__95_base_46_js__.__esModule && $___46__46__47__95_base_46_js__ || {default: $___46__46__47__95_base_46_js__}).default;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var $__2 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__2.addClass,
	    hasClass = $__2.hasClass,
	    removeClass = $__2.removeClass,
	    outerHeight = $__2.outerHeight;
	var $__3 = ($___46__46__47__46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}),
	    arrayEach = $__3.arrayEach,
	    arrayMap = $__3.arrayMap;
	var rangeEach = ($___46__46__47__46__46__47_helpers_47_number__ = _dereq_("helpers/number"), $___46__46__47__46__46__47_helpers_47_number__ && $___46__46__47__46__46__47_helpers_47_number__.__esModule && $___46__46__47__46__46__47_helpers_47_number__ || {default: $___46__46__47__46__46__47_helpers_47_number__}).rangeEach;
	var eventManagerObject = ($___46__46__47__46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).eventManager;
	var $__6 = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}),
	    pageX = $__6.pageX,
	    pageY = $__6.pageY;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var privatePool = new WeakMap();
	var ManualColumnMove = function ManualColumnMove(hotInstance) {
	  var $__8 = this;
	  $traceurRuntime.superConstructor($ManualColumnMove).call(this, hotInstance);
	  privatePool.set(this, {
	    guideClassName: 'manualColumnMoverGuide',
	    handleClassName: 'manualColumnMover',
	    startOffset: null,
	    pressed: null,
	    startCol: null,
	    endCol: null,
	    currentCol: null,
	    startX: null,
	    startY: null
	  });
	  this.guideElement = null;
	  this.handleElement = null;
	  this.currentTH = null;
	  this.columnPositions = [];
	  this.eventManager = eventManagerObject(this);
	  this.addHook('init', (function() {
	    return $__8.onInit();
	  }));
	};
	var $ManualColumnMove = ManualColumnMove;
	($traceurRuntime.createClass)(ManualColumnMove, {
	  isEnabled: function() {
	    return !!this.hot.getSettings().manualColumnMove;
	  },
	  enablePlugin: function() {
	    var $__8 = this;
	    var priv = privatePool.get(this);
	    var initialSettings = this.hot.getSettings().manualColumnMove;
	    var loadedManualColumnPositions = this.loadManualColumnPositions();
	    this.handleElement = document.createElement('DIV');
	    this.handleElement.className = priv.handleClassName;
	    this.guideElement = document.createElement('DIV');
	    this.guideElement.className = priv.guideClassName;
	    this.addHook('modifyCol', (function(col) {
	      return $__8.onModifyCol(col);
	    }));
	    this.addHook('unmodifyCol', (function(col) {
	      return $__8.onUnmodifyCol(col);
	    }));
	    this.addHook('afterRemoveCol', (function(index, amount) {
	      return $__8.onAfterRemoveCol(index, amount);
	    }));
	    this.addHook('afterCreateCol', (function(index, amount) {
	      return $__8.onAfterCreateCol(index, amount);
	    }));
	    this.registerEvents();
	    if (typeof loadedManualColumnPositions != 'undefined') {
	      this.columnPositions = loadedManualColumnPositions;
	    } else if (Array.isArray(initialSettings)) {
	      this.columnPositions = initialSettings;
	    } else if (!initialSettings || this.columnPositions === void 0) {
	      this.columnPositions = [];
	    }
	    $traceurRuntime.superGet(this, $ManualColumnMove.prototype, "enablePlugin").call(this);
	  },
	  updatePlugin: function() {
	    this.disablePlugin();
	    this.enablePlugin();
	    $traceurRuntime.superGet(this, $ManualColumnMove.prototype, "updatePlugin").call(this);
	  },
	  disablePlugin: function() {
	    var pluginSetting = this.hot.getSettings().manualColumnMove;
	    if (Array.isArray(pluginSetting)) {
	      this.unregisterEvents();
	      this.columnPositions = [];
	    }
	    $traceurRuntime.superGet(this, $ManualColumnMove.prototype, "disablePlugin").call(this);
	  },
	  registerEvents: function() {
	    var $__8 = this;
	    this.eventManager.addEventListener(this.hot.rootElement, 'mouseover', (function(event) {
	      return $__8.onMouseOver(event);
	    }));
	    this.eventManager.addEventListener(this.hot.rootElement, 'mousedown', (function(event) {
	      return $__8.onMouseDown(event);
	    }));
	    this.eventManager.addEventListener(window, 'mousemove', (function(event) {
	      return $__8.onMouseMove(event);
	    }));
	    this.eventManager.addEventListener(window, 'mouseup', (function(event) {
	      return $__8.onMouseUp(event);
	    }));
	  },
	  unregisterEvents: function() {
	    this.eventManager.clear();
	  },
	  saveManualColumnPositions: function() {
	    Handsontable.hooks.run(this.hot, 'persistentStateSave', 'manualColumnPositions', this.columnPositions);
	  },
	  loadManualColumnPositions: function() {
	    var storedState = {};
	    Handsontable.hooks.run(this.hot, 'persistentStateLoad', 'manualColumnPositions', storedState);
	    return storedState.value;
	  },
	  completeSettingsArray: function() {
	    var $__8 = this;
	    var columnCount = this.hot.countCols();
	    if (this.columnPositions.length === columnCount) {
	      return;
	    }
	    rangeEach(0, columnCount - 1, (function(i) {
	      if ($__8.columnPositions.indexOf(i) === -1) {
	        $__8.columnPositions.push(i);
	      }
	    }));
	  },
	  setupHandlePosition: function(TH) {
	    this.currentTH = TH;
	    var priv = privatePool.get(this);
	    var col = this.hot.view.wt.wtTable.getCoords(TH).col;
	    var headerHeight = outerHeight(this.currentTH);
	    if (col >= 0) {
	      var box = this.currentTH.getBoundingClientRect();
	      priv.currentCol = col;
	      priv.startOffset = box.left;
	      this.handleElement.style.top = box.top + 'px';
	      this.handleElement.style.left = priv.startOffset + 'px';
	      this.handleElement.style.height = headerHeight + 'px';
	      this.hot.rootElement.appendChild(this.handleElement);
	    }
	  },
	  refreshHandlePosition: function(TH, delta) {
	    var box = TH.getBoundingClientRect();
	    var handleWidth = 6;
	    if (delta > 0) {
	      this.handleElement.style.left = (box.left + box.width - handleWidth) + 'px';
	    } else {
	      this.handleElement.style.left = box.left + 'px';
	    }
	  },
	  setupGuidePosition: function() {
	    var box = this.currentTH.getBoundingClientRect();
	    var priv = privatePool.get(this);
	    var handleHeight = parseInt(outerHeight(this.handleElement), 10);
	    var handleBottomPosition = parseInt(this.handleElement.style.top, 10) + handleHeight;
	    var maximumVisibleElementHeight = parseInt(this.hot.view.maximumVisibleElementHeight(0), 10);
	    addClass(this.handleElement, 'active');
	    addClass(this.guideElement, 'active');
	    this.guideElement.style.width = box.width + 'px';
	    this.guideElement.style.height = (maximumVisibleElementHeight - handleHeight) + 'px';
	    this.guideElement.style.top = handleBottomPosition + 'px';
	    this.guideElement.style.left = priv.startOffset + 'px';
	    this.hot.rootElement.appendChild(this.guideElement);
	  },
	  refreshGuidePosition: function(diff) {
	    var priv = privatePool.get(this);
	    this.guideElement.style.left = priv.startOffset + diff + 'px';
	  },
	  hideHandleAndGuide: function() {
	    removeClass(this.handleElement, 'active');
	    removeClass(this.guideElement, 'active');
	  },
	  checkColumnHeader: function(element) {
	    if (element != this.hot.rootElement) {
	      var parent = element.parentNode;
	      if (parent.tagName === 'THEAD') {
	        return true;
	      }
	      return this.checkColumnHeader(parent);
	    }
	    return false;
	  },
	  createPositionData: function(len) {
	    var positionArr = this.columnPositions;
	    if (positionArr.length < len) {
	      rangeEach(positionArr.length, len - 1, (function(i) {
	        positionArr[i] = i;
	      }));
	    }
	  },
	  getTHFromTargetElement: function(element) {
	    if (element.tagName != 'TABLE') {
	      if (element.tagName == 'TH') {
	        return element;
	      } else {
	        return this.getTHFromTargetElement(element.parentNode);
	      }
	    }
	    return null;
	  },
	  changeColumnPositions: function(columnIndex, destinationIndex) {
	    var maxLength = Math.max(columnIndex, destinationIndex);
	    if (maxLength > this.columnPositions.length - 1) {
	      this.createPositionData(maxLength + 1);
	    }
	    this.columnPositions.splice(destinationIndex, 0, this.columnPositions.splice(columnIndex, 1)[0]);
	  },
	  getVisibleColumnIndex: function(column) {
	    if (column > this.columnPositions.length - 1) {
	      this.createPositionData(column);
	    }
	    return this.columnPositions.indexOf(column);
	  },
	  getLogicalColumnIndex: function(column) {
	    return this.columnPositions[column];
	  },
	  onMouseOver: function(event) {
	    var priv = privatePool.get(this);
	    if (this.checkColumnHeader(event.target)) {
	      var th = this.getTHFromTargetElement(event.target);
	      if (th) {
	        if (priv.pressed) {
	          var col = this.hot.view.wt.wtTable.getCoords(th).col;
	          if (col >= 0) {
	            priv.endCol = col;
	            this.refreshHandlePosition(th, priv.endCol - priv.startCol);
	          }
	        } else {
	          this.setupHandlePosition(th);
	        }
	      }
	    }
	  },
	  onMouseDown: function(event) {
	    var priv = privatePool.get(this);
	    if (hasClass(event.target, priv.handleClassName)) {
	      priv.startX = pageX(event);
	      this.setupGuidePosition();
	      priv.pressed = this.hot;
	      priv.startCol = priv.currentCol;
	      priv.endCol = priv.currentCol;
	    }
	  },
	  onMouseMove: function(event) {
	    var priv = privatePool.get(this);
	    if (priv.pressed) {
	      this.refreshGuidePosition(pageX(event) - priv.startX);
	    }
	  },
	  onMouseUp: function(event) {
	    var priv = privatePool.get(this);
	    if (priv.pressed) {
	      this.hideHandleAndGuide();
	      priv.pressed = false;
	      this.createPositionData(this.hot.countCols());
	      this.changeColumnPositions(priv.startCol, priv.endCol);
	      Handsontable.hooks.run(this.hot, 'beforeColumnMove', priv.startCol, priv.endCol);
	      this.hot.forceFullRender = true;
	      this.hot.view.render();
	      this.saveManualColumnPositions();
	      Handsontable.hooks.run(this.hot, 'afterColumnMove', priv.startCol, priv.endCol);
	      this.setupHandlePosition(this.currentTH);
	    }
	  },
	  onModifyCol: function(col) {
	    if (typeof this.getVisibleColumnIndex(col) == -1) {
	      this.createPositionData(col + 1);
	    }
	    return this.getLogicalColumnIndex(col);
	  },
	  onUnmodifyCol: function(col) {
	    if (typeof this.getVisibleColumnIndex(col) == -1) {
	      this.createPositionData(col + 1);
	    }
	    return this.getVisibleColumnIndex(col);
	  },
	  onAfterRemoveCol: function(index, amount) {
	    if (!this.isEnabled()) {
	      return;
	    }
	    var rmindx;
	    var colpos = this.columnPositions;
	    rmindx = colpos.splice(index, amount);
	    colpos = arrayMap(colpos, function(value, index) {
	      var i,
	          newpos = value;
	      arrayEach(rmindx, (function(elem, index) {
	        if (value > elem) {
	          newpos--;
	        }
	      }));
	      return newpos;
	    });
	    this.columnPositions = colpos;
	  },
	  onAfterCreateCol: function(index, amount) {
	    if (!this.isEnabled()) {
	      return;
	    }
	    var colpos = this.columnPositions;
	    if (!colpos.length) {
	      return;
	    }
	    var addindx = [];
	    rangeEach(0, amount - 1, (function(i) {
	      addindx.push(index + i);
	    }));
	    if (index >= colpos.length) {
	      colpos.concat(addindx);
	    } else {
	      colpos = arrayMap(colpos, function(value, ind) {
	        return (value >= index) ? (value + amount) : value;
	      });
	      colpos.splice.apply(colpos, [index, 0].concat(addindx));
	    }
	    this.columnPositions = colpos;
	  },
	  onInit: function() {
	    this.completeSettingsArray();
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('manualColumnMove', ManualColumnMove);
	Handsontable.hooks.register('beforeColumnMove');
	Handsontable.hooks.register('afterColumnMove');
	Handsontable.hooks.register('unmodifyCol');

	//# 
	},{"_base.js":60,"browser":23,"eventManager":41,"helpers/array":42,"helpers/dom/element":46,"helpers/dom/event":47,"helpers/number":51,"plugins":59}],80:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ManualColumnResize: {get: function() {
	      return ManualColumnResize;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__95_base_46_js__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47_helpers_47_number__,
	    $___46__46__47__46__46__47_plugins__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var BasePlugin = ($___46__46__47__95_base_46_js__ = _dereq_("_base.js"), $___46__46__47__95_base_46_js__ && $___46__46__47__95_base_46_js__.__esModule && $___46__46__47__95_base_46_js__ || {default: $___46__46__47__95_base_46_js__}).default;
	var $__2 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__2.addClass,
	    hasClass = $__2.hasClass,
	    removeClass = $__2.removeClass,
	    outerHeight = $__2.outerHeight;
	var eventManagerObject = ($___46__46__47__46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).eventManager;
	var $__4 = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}),
	    pageX = $__4.pageX,
	    pageY = $__4.pageY;
	var arrayEach = ($___46__46__47__46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}).arrayEach;
	var rangeEach = ($___46__46__47__46__46__47_helpers_47_number__ = _dereq_("helpers/number"), $___46__46__47__46__46__47_helpers_47_number__ && $___46__46__47__46__46__47_helpers_47_number__.__esModule && $___46__46__47__46__46__47_helpers_47_number__ || {default: $___46__46__47__46__46__47_helpers_47_number__}).rangeEach;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var ManualColumnResize = function ManualColumnResize(hotInstance) {
	  $traceurRuntime.superConstructor($ManualColumnResize).call(this, hotInstance);
	  this.currentTH = null;
	  this.currentCol = null;
	  this.selectedCols = [];
	  this.currentWidth = null;
	  this.newSize = null;
	  this.startY = null;
	  this.startWidth = null;
	  this.startOffset = null;
	  this.handle = document.createElement('DIV');
	  this.guide = document.createElement('DIV');
	  this.eventManager = eventManagerObject(this);
	  this.pressed = null;
	  this.dblclick = 0;
	  this.autoresizeTimeout = null;
	  this.manualColumnWidths = [];
	  addClass(this.handle, 'manualColumnResizer');
	  addClass(this.guide, 'manualColumnResizerGuide');
	};
	var $ManualColumnResize = ManualColumnResize;
	($traceurRuntime.createClass)(ManualColumnResize, {
	  isEnabled: function() {
	    return this.hot.getSettings().manualColumnResize;
	  },
	  enablePlugin: function() {
	    var $__8 = this;
	    if (this.enabled) {
	      return;
	    }
	    this.manualColumnWidths = [];
	    var initialColumnWidth = this.hot.getSettings().manualColumnResize;
	    var loadedManualColumnWidths = this.loadManualColumnWidths();
	    this.addHook('modifyColWidth', (function(width, col) {
	      return $__8.onModifyColWidth(width, col);
	    }));
	    this.addHook('beforeStretchingColumnWidth', (function(stretchedWidth, column) {
	      return $__8.onBeforeStretchingColumnWidth(stretchedWidth, column);
	    }));
	    this.addHook('beforeColumnResize', (function(currentColumn, newSize, isDoubleClick) {
	      return $__8.onBeforeColumnResize(currentColumn, newSize, isDoubleClick);
	    }));
	    if (typeof loadedManualColumnWidths != 'undefined') {
	      this.manualColumnWidths = loadedManualColumnWidths;
	    } else if (Array.isArray(initialColumnWidth)) {
	      this.manualColumnWidths = initialColumnWidth;
	    } else {
	      this.manualColumnWidths = [];
	    }
	    Handsontable.hooks.register('beforeColumnResize');
	    Handsontable.hooks.register('afterColumnResize');
	    this.bindEvents();
	    $traceurRuntime.superGet(this, $ManualColumnResize.prototype, "enablePlugin").call(this);
	  },
	  updatePlugin: function() {
	    var initialColumnWidth = this.hot.getSettings().manualColumnResize;
	    if (Array.isArray(initialColumnWidth)) {
	      this.manualColumnWidths = initialColumnWidth;
	    } else if (!initialColumnWidth) {
	      this.manualColumnWidths = [];
	    }
	  },
	  disablePlugin: function() {
	    $traceurRuntime.superGet(this, $ManualColumnResize.prototype, "disablePlugin").call(this);
	  },
	  saveManualColumnWidths: function() {
	    this.hot.runHooks('persistentStateSave', 'manualColumnWidths', this.manualColumnWidths);
	  },
	  loadManualColumnWidths: function() {
	    var storedState = {};
	    this.hot.runHooks('persistentStateLoad', 'manualColumnWidths', storedState);
	    return storedState.value;
	  },
	  setupHandlePosition: function(TH) {
	    var $__8 = this;
	    if (!TH.parentNode) {
	      return false;
	    }
	    this.currentTH = TH;
	    var col = this.hot.view.wt.wtTable.getCoords(TH).col;
	    var headerHeight = outerHeight(this.currentTH);
	    if (col >= 0) {
	      var box = this.currentTH.getBoundingClientRect();
	      this.currentCol = col;
	      this.selectedCols = [];
	      if (this.hot.selection.isSelected() && this.hot.selection.selectedHeader.cols) {
	        var $__10 = this.hot.getSelectedRange(),
	            from = $__10.from,
	            to = $__10.to;
	        var start = from.col;
	        var end = to.col;
	        if (start >= end) {
	          start = to.col;
	          end = from.col;
	        }
	        if (this.currentCol >= start && this.currentCol <= end) {
	          rangeEach(start, end, (function(i) {
	            return $__8.selectedCols.push(i);
	          }));
	        } else {
	          this.selectedCols.push(this.currentCol);
	        }
	      } else {
	        this.selectedCols.push(this.currentCol);
	      }
	      this.startOffset = box.left - 6;
	      this.startWidth = parseInt(box.width, 10);
	      this.handle.style.top = box.top + 'px';
	      this.handle.style.left = this.startOffset + this.startWidth + 'px';
	      this.handle.style.height = headerHeight + 'px';
	      this.hot.rootElement.appendChild(this.handle);
	    }
	  },
	  refreshHandlePosition: function() {
	    this.handle.style.left = this.startOffset + this.currentWidth + 'px';
	  },
	  setupGuidePosition: function() {
	    var handleHeight = parseInt(outerHeight(this.handle), 10);
	    var handleBottomPosition = parseInt(this.handle.style.top, 10) + handleHeight;
	    var maximumVisibleElementHeight = parseInt(this.hot.view.maximumVisibleElementHeight(0), 10);
	    addClass(this.handle, 'active');
	    addClass(this.guide, 'active');
	    this.guide.style.top = handleBottomPosition + 'px';
	    this.guide.style.left = this.handle.style.left;
	    this.guide.style.height = (maximumVisibleElementHeight - handleHeight) + 'px';
	    this.hot.rootElement.appendChild(this.guide);
	  },
	  refreshGuidePosition: function() {
	    this.guide.style.left = this.handle.style.left;
	  },
	  hideHandleAndGuide: function() {
	    removeClass(this.handle, 'active');
	    removeClass(this.guide, 'active');
	  },
	  checkIfColumnHeader: function(element) {
	    if (element != this.hot.rootElement) {
	      var parent = element.parentNode;
	      if (parent.tagName === 'THEAD') {
	        return true;
	      }
	      return this.checkIfColumnHeader(parent);
	    }
	    return false;
	  },
	  getTHFromTargetElement: function(element) {
	    if (element.tagName != 'TABLE') {
	      if (element.tagName == 'TH') {
	        return element;
	      } else {
	        return this.getTHFromTargetElement(element.parentNode);
	      }
	    }
	    return null;
	  },
	  onMouseOver: function(event) {
	    if (this.checkIfColumnHeader(event.target)) {
	      var th = this.getTHFromTargetElement(event.target);
	      if (!th) {
	        return;
	      }
	      var colspan = th.getAttribute('colspan');
	      if (th && (colspan === null || colspan === 1)) {
	        if (!this.pressed) {
	          this.setupHandlePosition(th);
	        }
	      }
	    }
	  },
	  afterMouseDownTimeout: function() {
	    var $__8 = this;
	    var render = (function() {
	      $__8.hot.forceFullRender = true;
	      $__8.hot.view.render();
	      $__8.hot.view.wt.wtOverlays.adjustElementsSize(true);
	    });
	    var resize = (function(selectedCol, forceRender) {
	      var hookNewSize = $__8.hot.runHooks('beforeColumnResize', selectedCol, $__8.newSize, true);
	      if (hookNewSize !== void 0) {
	        $__8.newSize = hookNewSize;
	      }
	      if ($__8.hot.getSettings().stretchH === 'all') {
	        $__8.clearManualSize(selectedCol);
	      } else {
	        $__8.setManualSize(selectedCol, $__8.newSize);
	      }
	      if (forceRender) {
	        render();
	      }
	      $__8.saveManualColumnWidths();
	      $__8.hot.runHooks('afterColumnResize', selectedCol, $__8.newSize, true);
	    });
	    if (this.dblclick >= 2) {
	      var selectedColsLength = this.selectedCols.length;
	      if (selectedColsLength > 1) {
	        arrayEach(this.selectedCols, (function(selectedCol) {
	          resize(selectedCol);
	        }));
	        render();
	      } else {
	        arrayEach(this.selectedCols, (function(selectedCol) {
	          resize(selectedCol, true);
	        }));
	      }
	    }
	    this.dblclick = 0;
	    this.autoresizeTimeout = null;
	  },
	  onMouseDown: function(event) {
	    var $__8 = this;
	    if (hasClass(event.target, 'manualColumnResizer')) {
	      this.setupGuidePosition();
	      this.pressed = this.hot;
	      if (this.autoresizeTimeout === null) {
	        this.autoresizeTimeout = setTimeout((function() {
	          return $__8.afterMouseDownTimeout();
	        }), 500);
	        this.hot._registerTimeout(this.autoresizeTimeout);
	      }
	      this.dblclick++;
	      this.startX = pageX(event);
	      this.newSize = this.startWidth;
	    }
	  },
	  onMouseMove: function(event) {
	    var $__8 = this;
	    if (this.pressed) {
	      this.currentWidth = this.startWidth + (pageX(event) - this.startX);
	      arrayEach(this.selectedCols, (function(selectedCol) {
	        $__8.newSize = $__8.setManualSize(selectedCol, $__8.currentWidth);
	      }));
	      this.refreshHandlePosition();
	      this.refreshGuidePosition();
	    }
	  },
	  onMouseUp: function(event) {
	    var $__8 = this;
	    var render = (function() {
	      $__8.hot.forceFullRender = true;
	      $__8.hot.view.render();
	      $__8.hot.view.wt.wtOverlays.adjustElementsSize(true);
	    });
	    var resize = (function(selectedCol, forceRender) {
	      $__8.hot.runHooks('beforeColumnResize', selectedCol, $__8.newSize);
	      if (forceRender) {
	        render();
	      }
	      $__8.saveManualColumnWidths();
	      $__8.hot.runHooks('afterColumnResize', selectedCol, $__8.newSize);
	    });
	    if (this.pressed) {
	      this.hideHandleAndGuide();
	      this.pressed = false;
	      if (this.newSize != this.startWidth) {
	        var selectedColsLength = this.selectedCols.length;
	        if (selectedColsLength > 1) {
	          arrayEach(this.selectedCols, (function(selectedCol) {
	            resize(selectedCol);
	          }));
	          render();
	        } else {
	          arrayEach(this.selectedCols, (function(selectedCol) {
	            resize(selectedCol, true);
	          }));
	        }
	      }
	      this.setupHandlePosition(this.currentTH);
	    }
	  },
	  bindEvents: function() {
	    var $__8 = this;
	    this.eventManager.addEventListener(this.hot.rootElement, 'mouseover', (function(e) {
	      return $__8.onMouseOver(e);
	    }));
	    this.eventManager.addEventListener(this.hot.rootElement, 'mousedown', (function(e) {
	      return $__8.onMouseDown(e);
	    }));
	    this.eventManager.addEventListener(window, 'mousemove', (function(e) {
	      return $__8.onMouseMove(e);
	    }));
	    this.eventManager.addEventListener(window, 'mouseup', (function(e) {
	      return $__8.onMouseUp(e);
	    }));
	  },
	  setManualSize: function(column, width) {
	    width = Math.max(width, 20);
	    column = this.hot.runHooks('modifyCol', column);
	    this.manualColumnWidths[column] = width;
	    return width;
	  },
	  clearManualSize: function(column) {
	    column = this.hot.runHooks('modifyCol', column);
	    this.manualColumnWidths[column] = void 0;
	  },
	  onModifyColWidth: function(width, column) {
	    if (this.enabled) {
	      column = this.hot.runHooks('modifyCol', column);
	      if (this.hot.getSettings().manualColumnResize && this.manualColumnWidths[column]) {
	        return this.manualColumnWidths[column];
	      }
	    }
	    return width;
	  },
	  onBeforeStretchingColumnWidth: function(stretchedWidth, column) {
	    var width = this.manualColumnWidths[column];
	    if (width === void 0) {
	      width = stretchedWidth;
	    }
	    return width;
	  },
	  onBeforeColumnResize: function() {
	    this.hot.view.wt.wtViewport.hasOversizedColumnHeadersMarked = {};
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('manualColumnResize', ManualColumnResize);

	//# 
	},{"_base.js":60,"browser":23,"eventManager":41,"helpers/array":42,"helpers/dom/element":46,"helpers/dom/event":47,"helpers/number":51,"plugins":59}],81:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ManualRowMove: {get: function() {
	      return ManualRowMove;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__95_base_46_js__,
	    $___46__46__47__46__46__47_browser__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47_helpers_47_number__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47__46__46__47_plugins__;
	var BasePlugin = ($___46__46__47__95_base_46_js__ = _dereq_("_base.js"), $___46__46__47__95_base_46_js__ && $___46__46__47__95_base_46_js__.__esModule && $___46__46__47__95_base_46_js__ || {default: $___46__46__47__95_base_46_js__}).default;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var $__2 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__2.addClass,
	    hasClass = $__2.hasClass,
	    removeClass = $__2.removeClass,
	    outerWidth = $__2.outerWidth;
	var $__3 = ($___46__46__47__46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}),
	    arrayEach = $__3.arrayEach,
	    arrayMap = $__3.arrayMap;
	var rangeEach = ($___46__46__47__46__46__47_helpers_47_number__ = _dereq_("helpers/number"), $___46__46__47__46__46__47_helpers_47_number__ && $___46__46__47__46__46__47_helpers_47_number__.__esModule && $___46__46__47__46__46__47_helpers_47_number__ || {default: $___46__46__47__46__46__47_helpers_47_number__}).rangeEach;
	var eventManagerObject = ($___46__46__47__46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).eventManager;
	var $__6 = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}),
	    pageX = $__6.pageX,
	    pageY = $__6.pageY;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var privatePool = new WeakMap();
	var ManualRowMove = function ManualRowMove(hotInstance) {
	  $traceurRuntime.superConstructor($ManualRowMove).call(this, hotInstance);
	  privatePool.set(this, {
	    guideClassName: 'manualRowMoverGuide',
	    handleClassName: 'manualRowMover',
	    startOffset: null,
	    pressed: null,
	    startRow: null,
	    endRow: null,
	    currentRow: null,
	    startX: null,
	    startY: null
	  });
	  this.guideElement = null;
	  this.handleElement = null;
	  this.currentTH = null;
	  this.rowPositions = [];
	  this.eventManager = eventManagerObject(this);
	};
	var $ManualRowMove = ManualRowMove;
	($traceurRuntime.createClass)(ManualRowMove, {
	  isEnabled: function() {
	    return !!this.hot.getSettings().manualRowMove;
	  },
	  enablePlugin: function() {
	    var $__8 = this;
	    var priv = privatePool.get(this);
	    var initialSettings = this.hot.getSettings().manualRowMove;
	    var loadedManualRowPositions = this.loadManualRowPositions();
	    this.handleElement = document.createElement('DIV');
	    this.handleElement.className = priv.handleClassName;
	    this.guideElement = document.createElement('DIV');
	    this.guideElement.className = priv.guideClassName;
	    this.addHook('modifyRow', (function(row) {
	      return $__8.onModifyRow(row);
	    }));
	    this.addHook('afterRemoveRow', (function(index, amount) {
	      return $__8.onAfterRemoveRow(index, amount);
	    }));
	    this.addHook('afterCreateRow', (function(index, amount) {
	      return $__8.onAfterCreateRow(index, amount);
	    }));
	    this.addHook('init', (function() {
	      return $__8.onInit();
	    }));
	    this.registerEvents();
	    if (typeof loadedManualRowPositions != 'undefined') {
	      this.rowPositions = loadedManualRowPositions;
	    } else if (Array.isArray(initialSettings)) {
	      this.rowPositions = initialSettings;
	    } else if (!initialSettings || this.rowPositions === void 0) {
	      this.rowPositions = [];
	    }
	    $traceurRuntime.superGet(this, $ManualRowMove.prototype, "enablePlugin").call(this);
	  },
	  updatePlugin: function() {
	    this.disablePlugin();
	    this.enablePlugin();
	    $traceurRuntime.superGet(this, $ManualRowMove.prototype, "updatePlugin").call(this);
	  },
	  disablePlugin: function() {
	    var pluginSetting = this.hot.getSettings().manualRowMove;
	    if (Array.isArray(pluginSetting)) {
	      this.unregisterEvents();
	      this.rowPositions = [];
	    }
	    $traceurRuntime.superGet(this, $ManualRowMove.prototype, "disablePlugin").call(this);
	  },
	  registerEvents: function() {
	    var $__8 = this;
	    this.eventManager.addEventListener(this.hot.rootElement, 'mouseover', (function(event) {
	      return $__8.onMouseOver(event);
	    }));
	    this.eventManager.addEventListener(this.hot.rootElement, 'mousedown', (function(event) {
	      return $__8.onMouseDown(event);
	    }));
	    this.eventManager.addEventListener(window, 'mousemove', (function(event) {
	      return $__8.onMouseMove(event);
	    }));
	    this.eventManager.addEventListener(window, 'mouseup', (function(event) {
	      return $__8.onMouseUp(event);
	    }));
	  },
	  unregisterEvents: function() {
	    this.eventManager.clear();
	  },
	  saveManualRowPositions: function() {
	    Handsontable.hooks.run(this.hot, 'persistentStateSave', 'manualRowPositions', this.rowPositions);
	  },
	  loadManualRowPositions: function() {
	    var storedState = {};
	    Handsontable.hooks.run(this.hot, 'persistentStateLoad', 'manualRowPositions', storedState);
	    return storedState.value;
	  },
	  completeSettingsArray: function() {
	    var $__8 = this;
	    var rowCount = this.hot.countRows();
	    if (this.rowPositions.length === rowCount) {
	      return;
	    }
	    rangeEach(0, rowCount - 1, (function(i) {
	      if ($__8.rowPositions.indexOf(i) === -1) {
	        $__8.rowPositions.push(i);
	      }
	    }));
	  },
	  setupHandlePosition: function(TH) {
	    this.currentTH = TH;
	    var priv = privatePool.get(this);
	    var row = this.hot.view.wt.wtTable.getCoords(TH).row;
	    var headerWidth = outerWidth(this.currentTH);
	    if (row >= 0) {
	      var box = this.currentTH.getBoundingClientRect();
	      priv.currentRow = row;
	      priv.startOffset = box.top;
	      this.handleElement.style.top = priv.startOffset + 'px';
	      this.handleElement.style.left = box.left + 'px';
	      this.handleElement.style.width = headerWidth + 'px';
	      this.hot.rootElement.appendChild(this.handleElement);
	    }
	  },
	  refreshHandlePosition: function(TH, delta) {
	    var box = TH.getBoundingClientRect();
	    var handleHeight = 6;
	    if (delta > 0) {
	      this.handleElement.style.top = (box.top + box.height - handleHeight) + 'px';
	    } else {
	      this.handleElement.style.top = box.top + 'px';
	    }
	  },
	  setupGuidePosition: function() {
	    var box = this.currentTH.getBoundingClientRect();
	    var priv = privatePool.get(this);
	    var handleWidth = parseInt(outerWidth(this.handleElement), 10);
	    var handleRightPosition = parseInt(this.handleElement.style.left, 10) + handleWidth;
	    var maximumVisibleElementWidth = parseInt(this.hot.view.maximumVisibleElementWidth(0), 10);
	    addClass(this.handleElement, 'active');
	    addClass(this.guideElement, 'active');
	    this.guideElement.style.height = box.height + 'px';
	    this.guideElement.style.width = (maximumVisibleElementWidth - handleWidth) + 'px';
	    this.guideElement.style.top = priv.startOffset + 'px';
	    this.guideElement.style.left = handleRightPosition + 'px';
	    this.hot.rootElement.appendChild(this.guideElement);
	  },
	  refreshGuidePosition: function(diff) {
	    var priv = privatePool.get(this);
	    this.guideElement.style.top = priv.startOffset + diff + 'px';
	  },
	  hideHandleAndGuide: function() {
	    removeClass(this.handleElement, 'active');
	    removeClass(this.guideElement, 'active');
	  },
	  checkRowHeader: function(element) {
	    if (element != this.hot.rootElement) {
	      var parent = element.parentNode;
	      if (parent.tagName === 'TBODY') {
	        return true;
	      }
	      return this.checkRowHeader(parent);
	    }
	    return false;
	  },
	  createPositionData: function(len) {
	    var positionArr = this.rowPositions;
	    if (positionArr.length < len) {
	      rangeEach(positionArr.length, len - 1, (function(i) {
	        positionArr[i] = i;
	      }));
	    }
	  },
	  getTHFromTargetElement: function(element) {
	    if (element.tagName != 'TABLE') {
	      if (element.tagName == 'TH') {
	        return element;
	      } else {
	        return this.getTHFromTargetElement(element.parentNode);
	      }
	    }
	    return null;
	  },
	  changeRowPositions: function(rowIndex, destinationIndex) {
	    var maxLength = Math.max(rowIndex, destinationIndex);
	    if (maxLength > this.rowPositions.length - 1) {
	      this.createPositionData(maxLength + 1);
	    }
	    this.rowPositions.splice(destinationIndex, 0, this.rowPositions.splice(rowIndex, 1)[0]);
	  },
	  getVisibleRowIndex: function(row) {
	    if (row > this.rowPositions.length - 1) {
	      this.createPositionData(row);
	    }
	    return this.rowPositions.indexOf(row);
	  },
	  getLogicalRowIndex: function(row) {
	    return this.rowPositions[row];
	  },
	  onMouseOver: function(event) {
	    var priv = privatePool.get(this);
	    if (this.checkRowHeader(event.target)) {
	      var th = this.getTHFromTargetElement(event.target);
	      if (th) {
	        if (priv.pressed) {
	          priv.endRow = this.hot.view.wt.wtTable.getCoords(th).row;
	          this.refreshHandlePosition(th, priv.endRow - priv.startRow);
	        } else {
	          this.setupHandlePosition(th);
	        }
	      }
	    }
	  },
	  onMouseDown: function(event) {
	    var priv = privatePool.get(this);
	    if (hasClass(event.target, priv.handleClassName)) {
	      priv.startY = pageY(event);
	      this.setupGuidePosition();
	      priv.pressed = this.hot;
	      priv.startRow = priv.currentRow;
	      priv.endRow = priv.currentRow;
	    }
	  },
	  onMouseMove: function(event) {
	    var priv = privatePool.get(this);
	    if (priv.pressed) {
	      this.refreshGuidePosition(pageY(event) - priv.startY);
	    }
	  },
	  onMouseUp: function(event) {
	    var priv = privatePool.get(this);
	    if (priv.pressed) {
	      this.hideHandleAndGuide();
	      priv.pressed = false;
	      this.createPositionData(this.hot.countRows());
	      this.changeRowPositions(priv.startRow, priv.endRow);
	      Handsontable.hooks.run(this.hot, 'beforeRowMove', priv.startRow, priv.endRow);
	      this.hot.forceFullRender = true;
	      this.hot.view.render();
	      this.saveManualRowPositions();
	      Handsontable.hooks.run(this.hot, 'afterRowMove', priv.startRow, priv.endRow);
	      this.setupHandlePosition(this.currentTH);
	    }
	  },
	  onModifyRow: function(row) {
	    if (typeof this.getVisibleRowIndex(row) === 'undefined') {
	      this.createPositionData(row + 1);
	    }
	    return this.getLogicalRowIndex(row);
	  },
	  onAfterRemoveRow: function(index, amount) {
	    if (!this.isEnabled()) {
	      return;
	    }
	    var rmindx;
	    var rowpos = this.rowPositions;
	    rmindx = rowpos.splice(index, amount);
	    rowpos = arrayMap(rowpos, function(value, index) {
	      var newpos = value;
	      arrayEach(rmindx, (function(elem, index) {
	        if (value > elem) {
	          newpos--;
	        }
	      }));
	      return newpos;
	    });
	    this.rowPositions = rowpos;
	  },
	  onAfterCreateRow: function(index, amount) {
	    if (!this.isEnabled()) {
	      return;
	    }
	    var rowpos = this.rowPositions;
	    if (!rowpos.length) {
	      return;
	    }
	    var addindx = [];
	    for (var i = 0; i < amount; i++) {
	      addindx.push(index + i);
	    }
	    if (index >= rowpos.length) {
	      rowpos.concat(addindx);
	    } else {
	      rowpos = arrayMap(rowpos, function(value, ind) {
	        return (value >= index) ? (value + amount) : value;
	      });
	      rowpos.splice.apply(rowpos, [index, 0].concat(addindx));
	    }
	    this.rowPositions = rowpos;
	  },
	  onInit: function() {
	    this.completeSettingsArray();
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('ManualRowMove', ManualRowMove);
	Handsontable.hooks.register('beforeRowMove');
	Handsontable.hooks.register('afterRowMove');

	//# 
	},{"_base.js":60,"browser":23,"eventManager":41,"helpers/array":42,"helpers/dom/element":46,"helpers/dom/event":47,"helpers/number":51,"plugins":59}],82:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ManualRowResize: {get: function() {
	      return ManualRowResize;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__95_base_46_js__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47_helpers_47_number__,
	    $___46__46__47__46__46__47_plugins__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var BasePlugin = ($___46__46__47__95_base_46_js__ = _dereq_("_base.js"), $___46__46__47__95_base_46_js__ && $___46__46__47__95_base_46_js__.__esModule && $___46__46__47__95_base_46_js__ || {default: $___46__46__47__95_base_46_js__}).default;
	var $__2 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__2.addClass,
	    hasClass = $__2.hasClass,
	    removeClass = $__2.removeClass,
	    outerWidth = $__2.outerWidth;
	var eventManagerObject = ($___46__46__47__46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).eventManager;
	var $__4 = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}),
	    pageX = $__4.pageX,
	    pageY = $__4.pageY;
	var arrayEach = ($___46__46__47__46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}).arrayEach;
	var rangeEach = ($___46__46__47__46__46__47_helpers_47_number__ = _dereq_("helpers/number"), $___46__46__47__46__46__47_helpers_47_number__ && $___46__46__47__46__46__47_helpers_47_number__.__esModule && $___46__46__47__46__46__47_helpers_47_number__ || {default: $___46__46__47__46__46__47_helpers_47_number__}).rangeEach;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var ManualRowResize = function ManualRowResize(hotInstance) {
	  $traceurRuntime.superConstructor($ManualRowResize).call(this, hotInstance);
	  this.currentTH = null;
	  this.currentRow = null;
	  this.selectedRows = [];
	  this.currentHeight = null;
	  this.newSize = null;
	  this.startY = null;
	  this.startHeight = null;
	  this.startOffset = null;
	  this.handle = document.createElement('DIV');
	  this.guide = document.createElement('DIV');
	  this.eventManager = eventManagerObject(this);
	  this.pressed = null;
	  this.dblclick = 0;
	  this.autoresizeTimeout = null;
	  this.manualRowHeights = [];
	  addClass(this.handle, 'manualRowResizer');
	  addClass(this.guide, 'manualRowResizerGuide');
	};
	var $ManualRowResize = ManualRowResize;
	($traceurRuntime.createClass)(ManualRowResize, {
	  isEnabled: function() {
	    return this.hot.getSettings().manualRowResize;
	  },
	  enablePlugin: function() {
	    var $__8 = this;
	    if (this.enabled) {
	      return;
	    }
	    this.manualRowHeights = [];
	    var initialRowHeights = this.hot.getSettings().manualRowResize;
	    var loadedManualRowHeights = this.loadManualRowHeights();
	    if (typeof loadedManualRowHeights != 'undefined') {
	      this.manualRowHeights = loadedManualRowHeights;
	    } else if (Array.isArray(initialRowHeights)) {
	      this.manualRowHeights = initialRowHeights;
	    } else {
	      this.manualRowHeights = [];
	    }
	    this.addHook('modifyRowHeight', (function(height, row) {
	      return $__8.onModifyRowHeight(height, row);
	    }));
	    Handsontable.hooks.register('beforeRowResize');
	    Handsontable.hooks.register('afterRowResize');
	    this.bindEvents();
	    $traceurRuntime.superGet(this, $ManualRowResize.prototype, "enablePlugin").call(this);
	  },
	  updatePlugin: function() {
	    var initialRowHeights = this.hot.getSettings().manualRowResize;
	    if (Array.isArray(initialRowHeights)) {
	      this.manualRowHeights = initialRowHeights;
	    } else if (!initialRowHeights) {
	      this.manualRowHeights = [];
	    }
	  },
	  disablePlugin: function() {
	    $traceurRuntime.superGet(this, $ManualRowResize.prototype, "disablePlugin").call(this);
	  },
	  saveManualRowHeights: function() {
	    this.hot.runHooks('persistentStateSave', 'manualRowHeights', this.manualRowHeights);
	  },
	  loadManualRowHeights: function() {
	    var storedState = {};
	    this.hot.runHooks('persistentStateLoad', 'manualRowHeights', storedState);
	    return storedState.value;
	  },
	  setupHandlePosition: function(TH) {
	    var $__8 = this;
	    this.currentTH = TH;
	    var row = this.hot.view.wt.wtTable.getCoords(TH).row;
	    var headerWidth = outerWidth(this.currentTH);
	    if (row >= 0) {
	      var box = this.currentTH.getBoundingClientRect();
	      this.currentRow = row;
	      this.selectedRows = [];
	      if (this.hot.selection.isSelected() && this.hot.selection.selectedHeader.rows) {
	        var $__10 = this.hot.getSelectedRange(),
	            from = $__10.from,
	            to = $__10.to;
	        var start = from.row;
	        var end = to.row;
	        if (start >= end) {
	          start = to.row;
	          end = from.row;
	        }
	        if (this.currentRow >= start && this.currentRow <= end) {
	          rangeEach(start, end, (function(i) {
	            return $__8.selectedRows.push(i);
	          }));
	        } else {
	          this.selectedRows.push(this.currentRow);
	        }
	      } else {
	        this.selectedRows.push(this.currentRow);
	      }
	      this.startOffset = box.top - 6;
	      this.startHeight = parseInt(box.height, 10);
	      this.handle.style.left = box.left + 'px';
	      this.handle.style.top = this.startOffset + this.startHeight + 'px';
	      this.handle.style.width = headerWidth + 'px';
	      this.hot.rootElement.appendChild(this.handle);
	    }
	  },
	  refreshHandlePosition: function() {
	    this.handle.style.top = this.startOffset + this.currentHeight + 'px';
	  },
	  setupGuidePosition: function() {
	    var handleWidth = parseInt(outerWidth(this.handle), 10);
	    var handleRightPosition = parseInt(this.handle.style.left, 10) + handleWidth;
	    var maximumVisibleElementWidth = parseInt(this.hot.view.maximumVisibleElementWidth(0), 10);
	    addClass(this.handle, 'active');
	    addClass(this.guide, 'active');
	    this.guide.style.top = this.handle.style.top;
	    this.guide.style.left = handleRightPosition + 'px';
	    this.guide.style.width = (maximumVisibleElementWidth - handleWidth) + 'px';
	    this.hot.rootElement.appendChild(this.guide);
	  },
	  refreshGuidePosition: function() {
	    this.guide.style.top = this.handle.style.top;
	  },
	  hideHandleAndGuide: function() {
	    removeClass(this.handle, 'active');
	    removeClass(this.guide, 'active');
	  },
	  checkIfRowHeader: function(element) {
	    if (element != this.hot.rootElement) {
	      var parent = element.parentNode;
	      if (parent.tagName === 'TBODY') {
	        return true;
	      }
	      return this.checkIfRowHeader(parent);
	    }
	    return false;
	  },
	  getTHFromTargetElement: function(element) {
	    if (element.tagName != 'TABLE') {
	      if (element.tagName == 'TH') {
	        return element;
	      } else {
	        return this.getTHFromTargetElement(element.parentNode);
	      }
	    }
	    return null;
	  },
	  onMouseOver: function(event) {
	    if (this.checkIfRowHeader(event.target)) {
	      var th = this.getTHFromTargetElement(event.target);
	      if (th) {
	        if (!this.pressed) {
	          this.setupHandlePosition(th);
	        }
	      }
	    }
	  },
	  afterMouseDownTimeout: function() {
	    var $__8 = this;
	    var render = (function() {
	      $__8.hot.forceFullRender = true;
	      $__8.hot.view.render();
	      $__8.hot.view.wt.wtOverlays.adjustElementsSize(true);
	    });
	    var resize = (function(selectedRow, forceRender) {
	      var hookNewSize = $__8.hot.runHooks('beforeRowResize', selectedRow, $__8.newSize, true);
	      if (hookNewSize !== void 0) {
	        $__8.newSize = hookNewSize;
	      }
	      $__8.setManualSize(selectedRow, $__8.newSize);
	      if (forceRender) {
	        render();
	      }
	      $__8.hot.runHooks('afterRowResize', selectedRow, $__8.newSize, true);
	    });
	    if (this.dblclick >= 2) {
	      var selectedRowsLength = this.selectedRows.length;
	      if (selectedRowsLength > 1) {
	        arrayEach(this.selectedRows, (function(selectedRow) {
	          resize(selectedRow);
	        }));
	        render();
	      } else {
	        arrayEach(this.selectedRows, (function(selectedRow) {
	          resize(selectedRow, true);
	        }));
	      }
	    }
	    this.dblclick = 0;
	    this.autoresizeTimeout = null;
	  },
	  onMouseDown: function(event) {
	    var $__8 = this;
	    if (hasClass(event.target, 'manualRowResizer')) {
	      this.setupGuidePosition();
	      this.pressed = this.hot;
	      if (this.autoresizeTimeout == null) {
	        this.autoresizeTimeout = setTimeout((function() {
	          return $__8.afterMouseDownTimeout();
	        }), 500);
	        this.hot._registerTimeout(this.autoresizeTimeout);
	      }
	      this.dblclick++;
	      this.startY = pageY(event);
	      this.newSize = this.startHeight;
	    }
	  },
	  onMouseMove: function(event) {
	    var $__8 = this;
	    if (this.pressed) {
	      this.currentHeight = this.startHeight + (pageY(event) - this.startY);
	      arrayEach(this.selectedRows, (function(selectedRow) {
	        $__8.newSize = $__8.setManualSize(selectedRow, $__8.currentHeight);
	      }));
	      this.refreshHandlePosition();
	      this.refreshGuidePosition();
	    }
	  },
	  onMouseUp: function(event) {
	    var $__8 = this;
	    var render = (function() {
	      $__8.hot.forceFullRender = true;
	      $__8.hot.view.render();
	      $__8.hot.view.wt.wtOverlays.adjustElementsSize(true);
	    });
	    var runHooks = (function(selectedRow, forceRender) {
	      $__8.hot.runHooks('beforeRowResize', selectedRow, $__8.newSize);
	      if (forceRender) {
	        render();
	      }
	      $__8.saveManualRowHeights();
	      $__8.hot.runHooks('afterRowResize', selectedRow, $__8.newSize);
	    });
	    if (this.pressed) {
	      this.hideHandleAndGuide();
	      this.pressed = false;
	      if (this.newSize != this.startHeight) {
	        var selectedRowsLength = this.selectedRows.length;
	        if (selectedRowsLength > 1) {
	          arrayEach(this.selectedRows, (function(selectedRow) {
	            runHooks(selectedRow);
	          }));
	          render();
	        } else {
	          arrayEach(this.selectedRows, (function(selectedRow) {
	            runHooks(selectedRow, true);
	          }));
	        }
	      }
	      this.setupHandlePosition(this.currentTH);
	    }
	  },
	  bindEvents: function() {
	    var $__8 = this;
	    this.eventManager.addEventListener(this.hot.rootElement, 'mouseover', (function(e) {
	      return $__8.onMouseOver(e);
	    }));
	    this.eventManager.addEventListener(this.hot.rootElement, 'mousedown', (function(e) {
	      return $__8.onMouseDown(e);
	    }));
	    this.eventManager.addEventListener(window, 'mousemove', (function(e) {
	      return $__8.onMouseMove(e);
	    }));
	    this.eventManager.addEventListener(window, 'mouseup', (function(e) {
	      return $__8.onMouseUp(e);
	    }));
	  },
	  setManualSize: function(row, height) {
	    row = this.hot.runHooks('modifyRow', row);
	    this.manualRowHeights[row] = height;
	    return height;
	  },
	  onModifyRowHeight: function(height, row) {
	    if (this.enabled) {
	      var autoRowSizePlugin = this.hot.getPlugin('autoRowSize');
	      var autoRowHeightResult = autoRowSizePlugin ? autoRowSizePlugin.heights[row] : null;
	      row = this.hot.runHooks('modifyRow', row);
	      var manualRowHeight = this.manualRowHeights[row];
	      if (manualRowHeight !== void 0 && (manualRowHeight === autoRowHeightResult || manualRowHeight > (height || 0))) {
	        return manualRowHeight;
	      }
	    }
	    return height;
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('manualRowResize', ManualRowResize);

	//# 
	},{"_base.js":60,"browser":23,"eventManager":41,"helpers/array":42,"helpers/dom/element":46,"helpers/dom/event":47,"helpers/number":51,"plugins":59}],83:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  MergeCells: {get: function() {
	      return MergeCells;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_table__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var stopImmediatePropagation = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}).stopImmediatePropagation;
	var WalkontableCellCoords = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ = _dereq_("3rdparty/walkontable/src/cell/coords"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	var WalkontableCellRange = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ = _dereq_("3rdparty/walkontable/src/cell/range"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__}).WalkontableCellRange;
	var WalkontableTable = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_table__ = _dereq_("3rdparty/walkontable/src/table"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_table__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_table__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_table__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_table__}).WalkontableTable;
	;
	function CellInfoCollection() {
	  var collection = [];
	  collection.getInfo = function(row, col) {
	    for (var i = 0,
	        ilen = this.length; i < ilen; i++) {
	      if (this[i].row <= row && this[i].row + this[i].rowspan - 1 >= row && this[i].col <= col && this[i].col + this[i].colspan - 1 >= col) {
	        return this[i];
	      }
	    }
	  };
	  collection.setInfo = function(info) {
	    for (var i = 0,
	        ilen = this.length; i < ilen; i++) {
	      if (this[i].row === info.row && this[i].col === info.col) {
	        this[i] = info;
	        return;
	      }
	    }
	    this.push(info);
	  };
	  collection.removeInfo = function(row, col) {
	    for (var i = 0,
	        ilen = this.length; i < ilen; i++) {
	      if (this[i].row === row && this[i].col === col) {
	        this.splice(i, 1);
	        break;
	      }
	    }
	  };
	  return collection;
	}
	function MergeCells(mergeCellsSetting) {
	  this.mergedCellInfoCollection = new CellInfoCollection();
	  if (Array.isArray(mergeCellsSetting)) {
	    for (var i = 0,
	        ilen = mergeCellsSetting.length; i < ilen; i++) {
	      this.mergedCellInfoCollection.setInfo(mergeCellsSetting[i]);
	    }
	  }
	}
	MergeCells.prototype.canMergeRange = function(cellRange) {
	  return !cellRange.isSingle();
	};
	MergeCells.prototype.mergeRange = function(cellRange) {
	  if (!this.canMergeRange(cellRange)) {
	    return;
	  }
	  var topLeft = cellRange.getTopLeftCorner();
	  var bottomRight = cellRange.getBottomRightCorner();
	  var mergeParent = {};
	  mergeParent.row = topLeft.row;
	  mergeParent.col = topLeft.col;
	  mergeParent.rowspan = bottomRight.row - topLeft.row + 1;
	  mergeParent.colspan = bottomRight.col - topLeft.col + 1;
	  this.mergedCellInfoCollection.setInfo(mergeParent);
	};
	MergeCells.prototype.mergeOrUnmergeSelection = function(cellRange) {
	  var info = this.mergedCellInfoCollection.getInfo(cellRange.from.row, cellRange.from.col);
	  if (info) {
	    this.unmergeSelection(cellRange.from);
	  } else {
	    this.mergeSelection(cellRange);
	  }
	};
	MergeCells.prototype.mergeSelection = function(cellRange) {
	  this.mergeRange(cellRange);
	};
	MergeCells.prototype.unmergeSelection = function(cellRange) {
	  var info = this.mergedCellInfoCollection.getInfo(cellRange.row, cellRange.col);
	  this.mergedCellInfoCollection.removeInfo(info.row, info.col);
	};
	MergeCells.prototype.applySpanProperties = function(TD, row, col) {
	  var info = this.mergedCellInfoCollection.getInfo(row, col);
	  if (info) {
	    if (info.row === row && info.col === col) {
	      TD.setAttribute('rowspan', info.rowspan);
	      TD.setAttribute('colspan', info.colspan);
	    } else {
	      TD.removeAttribute('rowspan');
	      TD.removeAttribute('colspan');
	      TD.style.display = 'none';
	    }
	  } else {
	    TD.removeAttribute('rowspan');
	    TD.removeAttribute('colspan');
	  }
	};
	MergeCells.prototype.modifyTransform = function(hook, currentSelectedRange, delta) {
	  var sameRowspan = function(merged, coords) {
	    if (coords.row >= merged.row && coords.row <= (merged.row + merged.rowspan - 1)) {
	      return true;
	    }
	    return false;
	  },
	      sameColspan = function(merged, coords) {
	        if (coords.col >= merged.col && coords.col <= (merged.col + merged.colspan - 1)) {
	          return true;
	        }
	        return false;
	      },
	      getNextPosition = function(newDelta) {
	        return new WalkontableCellCoords(currentSelectedRange.to.row + newDelta.row, currentSelectedRange.to.col + newDelta.col);
	      };
	  var newDelta = {
	    row: delta.row,
	    col: delta.col
	  };
	  if (hook == 'modifyTransformStart') {
	    if (!this.lastDesiredCoords) {
	      this.lastDesiredCoords = new WalkontableCellCoords(null, null);
	    }
	    var currentPosition = new WalkontableCellCoords(currentSelectedRange.highlight.row, currentSelectedRange.highlight.col),
	        mergedParent = this.mergedCellInfoCollection.getInfo(currentPosition.row, currentPosition.col),
	        currentRangeContainsMerge;
	    for (var i = 0,
	        mergesLength = this.mergedCellInfoCollection.length; i < mergesLength; i++) {
	      var range = this.mergedCellInfoCollection[i];
	      range = new WalkontableCellCoords(range.row + range.rowspan - 1, range.col + range.colspan - 1);
	      if (currentSelectedRange.includes(range)) {
	        currentRangeContainsMerge = true;
	        break;
	      }
	    }
	    if (mergedParent) {
	      var mergeTopLeft = new WalkontableCellCoords(mergedParent.row, mergedParent.col),
	          mergeBottomRight = new WalkontableCellCoords(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1),
	          mergeRange = new WalkontableCellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);
	      if (!mergeRange.includes(this.lastDesiredCoords)) {
	        this.lastDesiredCoords = new WalkontableCellCoords(null, null);
	      }
	      newDelta.row = this.lastDesiredCoords.row ? this.lastDesiredCoords.row - currentPosition.row : newDelta.row;
	      newDelta.col = this.lastDesiredCoords.col ? this.lastDesiredCoords.col - currentPosition.col : newDelta.col;
	      if (delta.row > 0) {
	        newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;
	      } else if (delta.row < 0) {
	        newDelta.row = currentPosition.row - mergedParent.row + delta.row;
	      }
	      if (delta.col > 0) {
	        newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;
	      } else if (delta.col < 0) {
	        newDelta.col = currentPosition.col - mergedParent.col + delta.col;
	      }
	    }
	    var nextPosition = new WalkontableCellCoords(currentSelectedRange.highlight.row + newDelta.row, currentSelectedRange.highlight.col + newDelta.col),
	        nextParentIsMerged = this.mergedCellInfoCollection.getInfo(nextPosition.row, nextPosition.col);
	    if (nextParentIsMerged) {
	      this.lastDesiredCoords = nextPosition;
	      newDelta = {
	        row: nextParentIsMerged.row - currentPosition.row,
	        col: nextParentIsMerged.col - currentPosition.col
	      };
	    }
	  } else if (hook == 'modifyTransformEnd') {
	    for (var i = 0,
	        mergesLength = this.mergedCellInfoCollection.length; i < mergesLength; i++) {
	      var currentMerge = this.mergedCellInfoCollection[i],
	          mergeTopLeft = new WalkontableCellCoords(currentMerge.row, currentMerge.col),
	          mergeBottomRight = new WalkontableCellCoords(currentMerge.row + currentMerge.rowspan - 1, currentMerge.col + currentMerge.colspan - 1),
	          mergedRange = new WalkontableCellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight),
	          sharedBorders = currentSelectedRange.getBordersSharedWith(mergedRange);
	      if (mergedRange.isEqual(currentSelectedRange)) {
	        currentSelectedRange.setDirection('NW-SE');
	      } else if (sharedBorders.length > 0) {
	        var mergeHighlighted = (currentSelectedRange.highlight.isEqual(mergedRange.from));
	        if (sharedBorders.indexOf('top') > -1) {
	          if (currentSelectedRange.to.isSouthEastOf(mergedRange.from) && mergeHighlighted) {
	            currentSelectedRange.setDirection('NW-SE');
	          } else if (currentSelectedRange.to.isSouthWestOf(mergedRange.from) && mergeHighlighted) {
	            currentSelectedRange.setDirection('NE-SW');
	          }
	        } else if (sharedBorders.indexOf('bottom') > -1) {
	          if (currentSelectedRange.to.isNorthEastOf(mergedRange.from) && mergeHighlighted) {
	            currentSelectedRange.setDirection('SW-NE');
	          } else if (currentSelectedRange.to.isNorthWestOf(mergedRange.from) && mergeHighlighted) {
	            currentSelectedRange.setDirection('SE-NW');
	          }
	        }
	      }
	      var nextPosition = getNextPosition(newDelta),
	          withinRowspan = sameRowspan(currentMerge, nextPosition),
	          withinColspan = sameColspan(currentMerge, nextPosition);
	      if (currentSelectedRange.includesRange(mergedRange) && (mergedRange.includes(nextPosition) || withinRowspan || withinColspan)) {
	        if (withinRowspan) {
	          if (newDelta.row < 0) {
	            newDelta.row -= currentMerge.rowspan - 1;
	          } else if (newDelta.row > 0) {
	            newDelta.row += currentMerge.rowspan - 1;
	          }
	        }
	        if (withinColspan) {
	          if (newDelta.col < 0) {
	            newDelta.col -= currentMerge.colspan - 1;
	          } else if (newDelta.col > 0) {
	            newDelta.col += currentMerge.colspan - 1;
	          }
	        }
	      }
	    }
	  }
	  if (newDelta.row !== 0) {
	    delta.row = newDelta.row;
	  }
	  if (newDelta.col !== 0) {
	    delta.col = newDelta.col;
	  }
	};
	MergeCells.prototype.shiftCollection = function(direction, index, count) {
	  var shiftVector = [0, 0];
	  switch (direction) {
	    case 'right':
	      shiftVector[0] += 1;
	      break;
	    case 'left':
	      shiftVector[0] -= 1;
	      break;
	    case 'down':
	      shiftVector[1] += 1;
	      break;
	    case 'up':
	      shiftVector[1] -= 1;
	      break;
	  }
	  for (var i = 0; i < this.mergedCellInfoCollection.length; i++) {
	    var currentMerge = this.mergedCellInfoCollection[i];
	    if (direction === 'right' || direction === 'left') {
	      if (index <= currentMerge.col) {
	        currentMerge.col += shiftVector[0];
	      }
	    } else {
	      if (index <= currentMerge.row) {
	        currentMerge.row += shiftVector[1];
	      }
	    }
	  }
	};
	var beforeInit = function() {
	  var instance = this;
	  var mergeCellsSetting = instance.getSettings().mergeCells;
	  if (mergeCellsSetting) {
	    if (!instance.mergeCells) {
	      instance.mergeCells = new MergeCells(mergeCellsSetting);
	    }
	  }
	};
	var afterInit = function() {
	  var instance = this;
	  if (instance.mergeCells) {
	    instance.view.wt.wtTable.getCell = function(coords) {
	      if (instance.getSettings().mergeCells) {
	        var mergeParent = instance.mergeCells.mergedCellInfoCollection.getInfo(coords.row, coords.col);
	        if (mergeParent) {
	          coords = mergeParent;
	        }
	      }
	      return WalkontableTable.prototype.getCell.call(this, coords);
	    };
	  }
	};
	var afterUpdateSettings = function() {
	  var instance = this;
	  var mergeCellsSetting = instance.getSettings().mergeCells;
	  if (mergeCellsSetting) {
	    if (instance.mergeCells) {
	      instance.mergeCells.mergedCellInfoCollection = new CellInfoCollection();
	      if (Array.isArray(mergeCellsSetting)) {
	        for (var i = 0,
	            ilen = mergeCellsSetting.length; i < ilen; i++) {
	          instance.mergeCells.mergedCellInfoCollection.setInfo(mergeCellsSetting[i]);
	        }
	      }
	    } else {
	      instance.mergeCells = new MergeCells(mergeCellsSetting);
	    }
	  } else {
	    if (instance.mergeCells) {
	      instance.mergeCells.mergedCellInfoCollection = new CellInfoCollection();
	    }
	  }
	};
	var onBeforeKeyDown = function(event) {
	  if (!this.mergeCells) {
	    return;
	  }
	  var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;
	  if (ctrlDown) {
	    if (event.keyCode === 77) {
	      this.mergeCells.mergeOrUnmergeSelection(this.getSelectedRange());
	      this.render();
	      stopImmediatePropagation(event);
	    }
	  }
	};
	var addMergeActionsToContextMenu = function(defaultOptions) {
	  if (!this.getSettings().mergeCells) {
	    return;
	  }
	  defaultOptions.items.push(Handsontable.plugins.ContextMenu.SEPARATOR);
	  defaultOptions.items.push({
	    key: 'mergeCells',
	    name: function() {
	      var sel = this.getSelected();
	      var info = this.mergeCells.mergedCellInfoCollection.getInfo(sel[0], sel[1]);
	      if (info) {
	        return 'Unmerge cells';
	      } else {
	        return 'Merge cells';
	      }
	    },
	    callback: function() {
	      this.mergeCells.mergeOrUnmergeSelection(this.getSelectedRange());
	      this.render();
	    },
	    disabled: function() {
	      return false;
	    }
	  });
	};
	var afterRenderer = function(TD, row, col, prop, value, cellProperties) {
	  if (this.mergeCells) {
	    this.mergeCells.applySpanProperties(TD, row, col);
	  }
	};
	var modifyTransformFactory = function(hook) {
	  return function(delta) {
	    var mergeCellsSetting = this.getSettings().mergeCells;
	    if (mergeCellsSetting) {
	      var currentSelectedRange = this.getSelectedRange();
	      this.mergeCells.modifyTransform(hook, currentSelectedRange, delta);
	      if (hook === 'modifyTransformEnd') {
	        var totalRows = this.countRows();
	        var totalCols = this.countCols();
	        if (currentSelectedRange.from.row < 0) {
	          currentSelectedRange.from.row = 0;
	        } else if (currentSelectedRange.from.row > 0 && currentSelectedRange.from.row >= totalRows) {
	          currentSelectedRange.from.row = currentSelectedRange.from - 1;
	        }
	        if (currentSelectedRange.from.col < 0) {
	          currentSelectedRange.from.col = 0;
	        } else if (currentSelectedRange.from.col > 0 && currentSelectedRange.from.col >= totalCols) {
	          currentSelectedRange.from.col = totalCols - 1;
	        }
	      }
	    }
	  };
	};
	var beforeSetRangeEnd = function(coords) {
	  this.lastDesiredCoords = null;
	  var mergeCellsSetting = this.getSettings().mergeCells;
	  if (mergeCellsSetting) {
	    var selRange = this.getSelectedRange();
	    selRange.highlight = new WalkontableCellCoords(selRange.highlight.row, selRange.highlight.col);
	    selRange.to = coords;
	    var rangeExpanded = false;
	    do {
	      rangeExpanded = false;
	      for (var i = 0,
	          ilen = this.mergeCells.mergedCellInfoCollection.length; i < ilen; i++) {
	        var cellInfo = this.mergeCells.mergedCellInfoCollection[i];
	        var mergedCellTopLeft = new WalkontableCellCoords(cellInfo.row, cellInfo.col);
	        var mergedCellBottomRight = new WalkontableCellCoords(cellInfo.row + cellInfo.rowspan - 1, cellInfo.col + cellInfo.colspan - 1);
	        var mergedCellRange = new WalkontableCellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);
	        if (selRange.expandByRange(mergedCellRange)) {
	          coords.row = selRange.to.row;
	          coords.col = selRange.to.col;
	          rangeExpanded = true;
	        }
	      }
	    } while (rangeExpanded);
	  }
	};
	var beforeDrawAreaBorders = function(corners, className) {
	  if (className && className == 'area') {
	    var mergeCellsSetting = this.getSettings().mergeCells;
	    if (mergeCellsSetting) {
	      var selRange = this.getSelectedRange();
	      var startRange = new WalkontableCellRange(selRange.from, selRange.from, selRange.from);
	      var stopRange = new WalkontableCellRange(selRange.to, selRange.to, selRange.to);
	      for (var i = 0,
	          ilen = this.mergeCells.mergedCellInfoCollection.length; i < ilen; i++) {
	        var cellInfo = this.mergeCells.mergedCellInfoCollection[i];
	        var mergedCellTopLeft = new WalkontableCellCoords(cellInfo.row, cellInfo.col);
	        var mergedCellBottomRight = new WalkontableCellCoords(cellInfo.row + cellInfo.rowspan - 1, cellInfo.col + cellInfo.colspan - 1);
	        var mergedCellRange = new WalkontableCellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);
	        if (startRange.expandByRange(mergedCellRange)) {
	          corners[0] = startRange.from.row;
	          corners[1] = startRange.from.col;
	        }
	        if (stopRange.expandByRange(mergedCellRange)) {
	          corners[2] = stopRange.from.row;
	          corners[3] = stopRange.from.col;
	        }
	      }
	    }
	  }
	};
	var afterGetCellMeta = function(row, col, cellProperties) {
	  var mergeCellsSetting = this.getSettings().mergeCells;
	  if (mergeCellsSetting) {
	    var mergeParent = this.mergeCells.mergedCellInfoCollection.getInfo(row, col);
	    if (mergeParent && (mergeParent.row != row || mergeParent.col != col)) {
	      cellProperties.copyable = false;
	    }
	  }
	};
	var afterViewportRowCalculatorOverride = function(calc) {
	  var mergeCellsSetting = this.getSettings().mergeCells;
	  if (mergeCellsSetting) {
	    var colCount = this.countCols();
	    var mergeParent;
	    for (var c = 0; c < colCount; c++) {
	      mergeParent = this.mergeCells.mergedCellInfoCollection.getInfo(calc.startRow, c);
	      if (mergeParent) {
	        if (mergeParent.row < calc.startRow) {
	          calc.startRow = mergeParent.row;
	          return afterViewportRowCalculatorOverride.call(this, calc);
	        }
	      }
	      mergeParent = this.mergeCells.mergedCellInfoCollection.getInfo(calc.endRow, c);
	      if (mergeParent) {
	        var mergeEnd = mergeParent.row + mergeParent.rowspan - 1;
	        if (mergeEnd > calc.endRow) {
	          calc.endRow = mergeEnd;
	          return afterViewportRowCalculatorOverride.call(this, calc);
	        }
	      }
	    }
	  }
	};
	var afterViewportColumnCalculatorOverride = function(calc) {
	  var mergeCellsSetting = this.getSettings().mergeCells;
	  if (mergeCellsSetting) {
	    var rowCount = this.countRows();
	    var mergeParent;
	    for (var r = 0; r < rowCount; r++) {
	      mergeParent = this.mergeCells.mergedCellInfoCollection.getInfo(r, calc.startColumn);
	      if (mergeParent) {
	        if (mergeParent.col < calc.startColumn) {
	          calc.startColumn = mergeParent.col;
	          return afterViewportColumnCalculatorOverride.call(this, calc);
	        }
	      }
	      mergeParent = this.mergeCells.mergedCellInfoCollection.getInfo(r, calc.endColumn);
	      if (mergeParent) {
	        var mergeEnd = mergeParent.col + mergeParent.colspan - 1;
	        if (mergeEnd > calc.endColumn) {
	          calc.endColumn = mergeEnd;
	          return afterViewportColumnCalculatorOverride.call(this, calc);
	        }
	      }
	    }
	  }
	};
	var isMultipleSelection = function(isMultiple) {
	  if (isMultiple && this.mergeCells) {
	    var mergedCells = this.mergeCells.mergedCellInfoCollection,
	        selectionRange = this.getSelectedRange();
	    for (var group in mergedCells) {
	      if (selectionRange.highlight.row == mergedCells[group].row && selectionRange.highlight.col == mergedCells[group].col && selectionRange.to.row == mergedCells[group].row + mergedCells[group].rowspan - 1 && selectionRange.to.col == mergedCells[group].col + mergedCells[group].colspan - 1) {
	        return false;
	      }
	    }
	  }
	  return isMultiple;
	};
	function afterAutofillApplyValues(select, drag) {
	  var mergeCellsSetting = this.getSettings().mergeCells;
	  if (!mergeCellsSetting || this.selection.isMultiple()) {
	    return;
	  }
	  var info = this.mergeCells.mergedCellInfoCollection.getInfo(select[0], select[1]);
	  if (info) {
	    select[0] = info.row;
	    select[1] = info.col;
	    select[2] = info.row + info.rowspan - 1;
	    select[3] = info.col + info.colspan - 1;
	  }
	}
	function onAfterCreateCol(col, count) {
	  if (this.mergeCells) {
	    this.mergeCells.shiftCollection('right', col, count);
	  }
	}
	function onAfterRemoveCol(col, count) {
	  if (this.mergeCells) {
	    this.mergeCells.shiftCollection('left', col, count);
	  }
	}
	function onAfterCreateRow(row, count) {
	  if (this.mergeCells) {
	    this.mergeCells.shiftCollection('down', row, count);
	  }
	}
	function onAfterRemoveRow(row, count) {
	  if (this.mergeCells) {
	    this.mergeCells.shiftCollection('up', row, count);
	  }
	}
	Handsontable.hooks.add('beforeInit', beforeInit);
	Handsontable.hooks.add('afterInit', afterInit);
	Handsontable.hooks.add('afterUpdateSettings', afterUpdateSettings);
	Handsontable.hooks.add('beforeKeyDown', onBeforeKeyDown);
	Handsontable.hooks.add('modifyTransformStart', modifyTransformFactory('modifyTransformStart'));
	Handsontable.hooks.add('modifyTransformEnd', modifyTransformFactory('modifyTransformEnd'));
	Handsontable.hooks.add('beforeSetRangeEnd', beforeSetRangeEnd);
	Handsontable.hooks.add('beforeDrawBorders', beforeDrawAreaBorders);
	Handsontable.hooks.add('afterIsMultipleSelection', isMultipleSelection);
	Handsontable.hooks.add('afterRenderer', afterRenderer);
	Handsontable.hooks.add('afterContextMenuDefaultOptions', addMergeActionsToContextMenu);
	Handsontable.hooks.add('afterGetCellMeta', afterGetCellMeta);
	Handsontable.hooks.add('afterViewportRowCalculatorOverride', afterViewportRowCalculatorOverride);
	Handsontable.hooks.add('afterViewportColumnCalculatorOverride', afterViewportColumnCalculatorOverride);
	Handsontable.hooks.add('afterAutofillApplyValues', afterAutofillApplyValues);
	Handsontable.hooks.add('afterCreateCol', onAfterCreateCol);
	Handsontable.hooks.add('afterRemoveCol', onAfterRemoveCol);
	Handsontable.hooks.add('afterCreateRow', onAfterCreateRow);
	Handsontable.hooks.add('afterRemoveRow', onAfterRemoveRow);
	Handsontable.MergeCells = MergeCells;

	//# 
	},{"3rdparty/walkontable/src/cell/coords":5,"3rdparty/walkontable/src/cell/range":6,"3rdparty/walkontable/src/table":20,"browser":23,"helpers/dom/event":47,"plugins":59}],84:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  MultipleSelectionHandles: {get: function() {
	      return MultipleSelectionHandles;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_helpers_47_browser__,
	    $___46__46__47__95_base__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_plugins__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var $__1 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    getWindowScrollTop = $__1.getWindowScrollTop,
	    hasClass = $__1.hasClass,
	    getWindowScrollLeft = $__1.getWindowScrollLeft;
	var isMobileBrowser = ($___46__46__47__46__46__47_helpers_47_browser__ = _dereq_("helpers/browser"), $___46__46__47__46__46__47_helpers_47_browser__ && $___46__46__47__46__46__47_helpers_47_browser__.__esModule && $___46__46__47__46__46__47_helpers_47_browser__ || {default: $___46__46__47__46__46__47_helpers_47_browser__}).isMobileBrowser;
	var BasePlugin = ($___46__46__47__95_base__ = _dereq_("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var EventManager = ($___46__46__47__46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).EventManager;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var MultipleSelectionHandles = function MultipleSelectionHandles(hotInstance) {
	  $traceurRuntime.superConstructor($MultipleSelectionHandles).call(this, hotInstance);
	  this.dragged = [];
	  this.eventManager = null;
	  this.lastSetCell = null;
	};
	var $MultipleSelectionHandles = MultipleSelectionHandles;
	($traceurRuntime.createClass)(MultipleSelectionHandles, {
	  isEnabled: function() {
	    return isMobileBrowser();
	  },
	  enablePlugin: function() {
	    if (this.enabled) {
	      return;
	    }
	    if (!this.eventManager) {
	      this.eventManager = new EventManager(this);
	    }
	    this.registerListeners();
	    $traceurRuntime.superGet(this, $MultipleSelectionHandles.prototype, "enablePlugin").call(this);
	  },
	  registerListeners: function() {
	    var _this = this;
	    function removeFromDragged(query) {
	      if (_this.dragged.length === 1) {
	        _this.dragged.splice(0, _this.dragged.length);
	        return true;
	      }
	      var entryPosition = _this.dragged.indexOf(query);
	      if (entryPosition == -1) {
	        return false;
	      } else if (entryPosition === 0) {
	        _this.dragged = _this.dragged.slice(0, 1);
	      } else if (entryPosition == 1) {
	        _this.dragged = _this.dragged.slice(-1);
	      }
	    }
	    this.eventManager.addEventListener(this.hot.rootElement, 'touchstart', function(event) {
	      var selectedRange;
	      if (hasClass(event.target, 'topLeftSelectionHandle-HitArea')) {
	        selectedRange = _this.hot.getSelectedRange();
	        _this.dragged.push('topLeft');
	        _this.touchStartRange = {
	          width: selectedRange.getWidth(),
	          height: selectedRange.getHeight(),
	          direction: selectedRange.getDirection()
	        };
	        event.preventDefault();
	        return false;
	      } else if (hasClass(event.target, 'bottomRightSelectionHandle-HitArea')) {
	        selectedRange = _this.hot.getSelectedRange();
	        _this.dragged.push('bottomRight');
	        _this.touchStartRange = {
	          width: selectedRange.getWidth(),
	          height: selectedRange.getHeight(),
	          direction: selectedRange.getDirection()
	        };
	        event.preventDefault();
	        return false;
	      }
	    });
	    this.eventManager.addEventListener(this.hot.rootElement, 'touchend', function(event) {
	      if (hasClass(event.target, 'topLeftSelectionHandle-HitArea')) {
	        removeFromDragged.call(_this, 'topLeft');
	        _this.touchStartRange = void 0;
	        event.preventDefault();
	        return false;
	      } else if (hasClass(event.target, 'bottomRightSelectionHandle-HitArea')) {
	        removeFromDragged.call(_this, 'bottomRight');
	        _this.touchStartRange = void 0;
	        event.preventDefault();
	        return false;
	      }
	    });
	    this.eventManager.addEventListener(this.hot.rootElement, 'touchmove', function(event) {
	      var scrollTop = getWindowScrollTop(),
	          scrollLeft = getWindowScrollLeft(),
	          endTarget,
	          targetCoords,
	          selectedRange,
	          rangeWidth,
	          rangeHeight,
	          rangeDirection,
	          newRangeCoords;
	      if (_this.dragged.length === 0) {
	        return;
	      }
	      endTarget = document.elementFromPoint(event.touches[0].screenX - scrollLeft, event.touches[0].screenY - scrollTop);
	      if (!endTarget || endTarget === _this.lastSetCell) {
	        return;
	      }
	      if (endTarget.nodeName == 'TD' || endTarget.nodeName == 'TH') {
	        targetCoords = _this.hot.getCoords(endTarget);
	        if (targetCoords.col == -1) {
	          targetCoords.col = 0;
	        }
	        selectedRange = _this.hot.getSelectedRange();
	        rangeWidth = selectedRange.getWidth();
	        rangeHeight = selectedRange.getHeight();
	        rangeDirection = selectedRange.getDirection();
	        if (rangeWidth == 1 && rangeHeight == 1) {
	          _this.hot.selection.setRangeEnd(targetCoords);
	        }
	        newRangeCoords = _this.getCurrentRangeCoords(selectedRange, targetCoords, _this.touchStartRange.direction, rangeDirection, _this.dragged[0]);
	        if (newRangeCoords.start !== null) {
	          _this.hot.selection.setRangeStart(newRangeCoords.start);
	        }
	        _this.hot.selection.setRangeEnd(newRangeCoords.end);
	        _this.lastSetCell = endTarget;
	      }
	      event.preventDefault();
	    });
	  },
	  getCurrentRangeCoords: function(selectedRange, currentTouch, touchStartDirection, currentDirection, draggedHandle) {
	    var topLeftCorner = selectedRange.getTopLeftCorner(),
	        bottomRightCorner = selectedRange.getBottomRightCorner(),
	        bottomLeftCorner = selectedRange.getBottomLeftCorner(),
	        topRightCorner = selectedRange.getTopRightCorner();
	    var newCoords = {
	      start: null,
	      end: null
	    };
	    switch (touchStartDirection) {
	      case 'NE-SW':
	        switch (currentDirection) {
	          case 'NE-SW':
	          case 'NW-SE':
	            if (draggedHandle == 'topLeft') {
	              newCoords = {
	                start: new WalkontableCellCoords(currentTouch.row, selectedRange.highlight.col),
	                end: new WalkontableCellCoords(bottomLeftCorner.row, currentTouch.col)
	              };
	            } else {
	              newCoords = {
	                start: new WalkontableCellCoords(selectedRange.highlight.row, currentTouch.col),
	                end: new WalkontableCellCoords(currentTouch.row, topLeftCorner.col)
	              };
	            }
	            break;
	          case 'SE-NW':
	            if (draggedHandle == 'bottomRight') {
	              newCoords = {
	                start: new WalkontableCellCoords(bottomRightCorner.row, currentTouch.col),
	                end: new WalkontableCellCoords(currentTouch.row, topLeftCorner.col)
	              };
	            }
	            break;
	        }
	        break;
	      case 'NW-SE':
	        switch (currentDirection) {
	          case 'NE-SW':
	            if (draggedHandle == 'topLeft') {
	              newCoords = {
	                start: currentTouch,
	                end: bottomLeftCorner
	              };
	            } else {
	              newCoords.end = currentTouch;
	            }
	            break;
	          case 'NW-SE':
	            if (draggedHandle == 'topLeft') {
	              newCoords = {
	                start: currentTouch,
	                end: bottomRightCorner
	              };
	            } else {
	              newCoords.end = currentTouch;
	            }
	            break;
	          case 'SE-NW':
	            if (draggedHandle == 'topLeft') {
	              newCoords = {
	                start: currentTouch,
	                end: topLeftCorner
	              };
	            } else {
	              newCoords.end = currentTouch;
	            }
	            break;
	          case 'SW-NE':
	            if (draggedHandle == 'topLeft') {
	              newCoords = {
	                start: currentTouch,
	                end: topRightCorner
	              };
	            } else {
	              newCoords.end = currentTouch;
	            }
	            break;
	        }
	        break;
	      case 'SW-NE':
	        switch (currentDirection) {
	          case 'NW-SE':
	            if (draggedHandle == 'bottomRight') {
	              newCoords = {
	                start: new WalkontableCellCoords(currentTouch.row, topLeftCorner.col),
	                end: new WalkontableCellCoords(bottomLeftCorner.row, currentTouch.col)
	              };
	            } else {
	              newCoords = {
	                start: new WalkontableCellCoords(topLeftCorner.row, currentTouch.col),
	                end: new WalkontableCellCoords(currentTouch.row, bottomRightCorner.col)
	              };
	            }
	            break;
	          case 'SW-NE':
	            if (draggedHandle == 'topLeft') {
	              newCoords = {
	                start: new WalkontableCellCoords(selectedRange.highlight.row, currentTouch.col),
	                end: new WalkontableCellCoords(currentTouch.row, bottomRightCorner.col)
	              };
	            } else {
	              newCoords = {
	                start: new WalkontableCellCoords(currentTouch.row, topLeftCorner.col),
	                end: new WalkontableCellCoords(topLeftCorner.row, currentTouch.col)
	              };
	            }
	            break;
	          case 'SE-NW':
	            if (draggedHandle == 'bottomRight') {
	              newCoords = {
	                start: new WalkontableCellCoords(currentTouch.row, topRightCorner.col),
	                end: new WalkontableCellCoords(topLeftCorner.row, currentTouch.col)
	              };
	            } else if (draggedHandle == 'topLeft') {
	              newCoords = {
	                start: bottomLeftCorner,
	                end: currentTouch
	              };
	            }
	            break;
	        }
	        break;
	      case 'SE-NW':
	        switch (currentDirection) {
	          case 'NW-SE':
	          case 'NE-SW':
	          case 'SW-NE':
	            if (draggedHandle == 'topLeft') {
	              newCoords.end = currentTouch;
	            }
	            break;
	          case 'SE-NW':
	            if (draggedHandle == 'topLeft') {
	              newCoords.end = currentTouch;
	            } else {
	              newCoords = {
	                start: currentTouch,
	                end: topLeftCorner
	              };
	            }
	            break;
	        }
	        break;
	    }
	    return newCoords;
	  },
	  isDragged: function() {
	    return this.dragged.length > 0;
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('multipleSelectionHandles', MultipleSelectionHandles);

	//# 
	},{"_base":60,"browser":23,"eventManager":41,"helpers/browser":43,"helpers/dom/element":46,"plugins":59}],85:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  DataObserver: {get: function() {
	      return DataObserver;
	    }},
	  __esModule: {value: true}
	});
	var $__jsonpatch__,
	    $___46__46__47__46__46__47_mixins_47_localHooks__,
	    $___46__46__47__46__46__47_helpers_47_object__,
	    $__utils__;
	var jsonpatch = ($__jsonpatch__ = _dereq_("jsonpatch"), $__jsonpatch__ && $__jsonpatch__.__esModule && $__jsonpatch__ || {default: $__jsonpatch__}).default;
	var localHooks = ($___46__46__47__46__46__47_mixins_47_localHooks__ = _dereq_("../../mixins/localHooks"), $___46__46__47__46__46__47_mixins_47_localHooks__ && $___46__46__47__46__46__47_mixins_47_localHooks__.__esModule && $___46__46__47__46__46__47_mixins_47_localHooks__ || {default: $___46__46__47__46__46__47_mixins_47_localHooks__}).localHooks;
	var mixin = ($___46__46__47__46__46__47_helpers_47_object__ = _dereq_("../../helpers/object"), $___46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47_helpers_47_object__}).mixin;
	var cleanPatches = ($__utils__ = _dereq_("utils"), $__utils__ && $__utils__.__esModule && $__utils__ || {default: $__utils__}).cleanPatches;
	var DataObserver = function DataObserver(observedData) {
	  this.observedData = null;
	  this.observer = null;
	  this.paused = false;
	  this.setObservedData(observedData);
	};
	($traceurRuntime.createClass)(DataObserver, {
	  setObservedData: function(observedData) {
	    var $__4 = this;
	    if (this.observer) {
	      jsonpatch.unobserve(this.observedData, this.observer);
	    }
	    this.observedData = observedData;
	    this.observer = jsonpatch.observe(this.observedData, (function(patches) {
	      return $__4.onChange(patches);
	    }));
	  },
	  isPaused: function() {
	    return this.paused;
	  },
	  pause: function() {
	    this.paused = true;
	  },
	  resume: function() {
	    this.paused = false;
	  },
	  onChange: function(patches) {
	    this.runLocalHooks('change', cleanPatches(patches));
	  },
	  destroy: function() {
	    jsonpatch.unobserve(this.observedData, this.observer);
	    this.observedData = null;
	    this.observer = null;
	  }
	}, {});
	mixin(DataObserver, localHooks);
	;

	//# 
	},{"../../helpers/object":52,"../../mixins/localHooks":56,"jsonpatch":"jsonpatch","utils":87}],86:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ObserveChanges: {get: function() {
	      return ObserveChanges;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__95_base__,
	    $__jsonpatch__,
	    $__dataObserver__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47_plugins__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var BasePlugin = ($___46__46__47__95_base__ = _dereq_("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var jsonpatch = ($__jsonpatch__ = _dereq_("jsonpatch"), $__jsonpatch__ && $__jsonpatch__.__esModule && $__jsonpatch__ || {default: $__jsonpatch__}).default;
	var DataObserver = ($__dataObserver__ = _dereq_("dataObserver"), $__dataObserver__ && $__dataObserver__.__esModule && $__dataObserver__ || {default: $__dataObserver__}).DataObserver;
	var arrayEach = ($___46__46__47__46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}).arrayEach;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	Handsontable.hooks.register('afterChangesObserved');
	var ObserveChanges = function ObserveChanges(hotInstance) {
	  $traceurRuntime.superConstructor($ObserveChanges).call(this, hotInstance);
	  this.observer = null;
	};
	var $ObserveChanges = ObserveChanges;
	($traceurRuntime.createClass)(ObserveChanges, {
	  isEnabled: function() {
	    return this.hot.getSettings().observeChanges;
	  },
	  enablePlugin: function() {
	    var $__6 = this;
	    if (this.enabled) {
	      return;
	    }
	    if (!this.observer) {
	      this.observer = new DataObserver(this.hot.getSourceData());
	      this._exposePublicApi();
	    }
	    this.observer.addLocalHook('change', (function(patches) {
	      return $__6.onDataChange(patches);
	    }));
	    this.addHook('afterCreateRow', (function() {
	      return $__6.onAfterTableAlter();
	    }));
	    this.addHook('afterRemoveRow', (function() {
	      return $__6.onAfterTableAlter();
	    }));
	    this.addHook('afterCreateCol', (function() {
	      return $__6.onAfterTableAlter();
	    }));
	    this.addHook('afterRemoveCol', (function() {
	      return $__6.onAfterTableAlter();
	    }));
	    this.addHook('afterChange', (function(changes, source) {
	      return $__6.onAfterTableAlter(source);
	    }));
	    this.addHook('afterLoadData', (function(firstRun) {
	      return $__6.onAfterLoadData(firstRun);
	    }));
	    $traceurRuntime.superGet(this, $ObserveChanges.prototype, "enablePlugin").call(this);
	  },
	  disablePlugin: function() {
	    if (this.observer) {
	      this.observer.destroy();
	      this.observer = null;
	      this._deletePublicApi();
	    }
	    $traceurRuntime.superGet(this, $ObserveChanges.prototype, "disablePlugin").call(this);
	  },
	  onDataChange: function(patches) {
	    var $__6 = this;
	    if (!this.observer.isPaused()) {
	      var actions = {
	        add: (function(patch) {
	          if (isNaN(patch.col)) {
	            $__6.hot.runHooks('afterCreateRow', patch.row);
	          } else {
	            $__6.hot.runHooks('afterCreateCol', patch.col);
	          }
	        }),
	        remove: (function(patch) {
	          if (isNaN(patch.col)) {
	            $__6.hot.runHooks('afterRemoveRow', patch.row, 1);
	          } else {
	            $__6.hot.runHooks('afterRemoveCol', patch.col, 1);
	          }
	        }),
	        replace: (function(patch) {
	          $__6.hot.runHooks('afterChange', [patch.row, patch.col, null, patch.value], 'external');
	        })
	      };
	      arrayEach(patches, (function(patch) {
	        if (actions[patch.op]) {
	          actions[patch.op](patch);
	        }
	      }));
	      this.hot.render();
	    }
	    this.hot.runHooks('afterChangesObserved');
	  },
	  onAfterTableAlter: function(source) {
	    var $__6 = this;
	    if (source !== 'loadData') {
	      this.observer.pause();
	      this.hot.addHookOnce('afterChangesObserved', (function() {
	        return $__6.observer.resume();
	      }));
	    }
	  },
	  onAfterLoadData: function(firstRun) {
	    if (!firstRun) {
	      this.observer.setObservedData(this.hot.getSourceData());
	    }
	  },
	  destroy: function() {
	    if (this.observer) {
	      this.observer.destroy();
	      this._deletePublicApi();
	    }
	    $traceurRuntime.superGet(this, $ObserveChanges.prototype, "destroy").call(this);
	  },
	  _exposePublicApi: function() {
	    var $__6 = this;
	    var hot = this.hot;
	    hot.pauseObservingChanges = (function() {
	      return $__6.observer.pause();
	    });
	    hot.resumeObservingChanges = (function() {
	      return $__6.observer.resume();
	    });
	    hot.isPausedObservingChanges = (function() {
	      return $__6.observer.isPaused();
	    });
	  },
	  _deletePublicApi: function() {
	    var hot = this.hot;
	    delete hot.pauseObservingChanges;
	    delete hot.resumeObservingChanges;
	    delete hot.isPausedObservingChanges;
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('observeChanges', ObserveChanges);

	//# 
	},{"_base":60,"browser":23,"dataObserver":85,"helpers/array":42,"jsonpatch":"jsonpatch","plugins":59}],87:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  cleanPatches: {get: function() {
	      return cleanPatches;
	    }},
	  parsePath: {get: function() {
	      return parsePath;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_array__;
	var $__0 = ($___46__46__47__46__46__47_helpers_47_array__ = _dereq_("../../helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}),
	    arrayFilter = $__0.arrayFilter,
	    arrayMap = $__0.arrayMap;
	function cleanPatches(patches) {
	  var newOrRemovedColumns = [];
	  patches = arrayFilter(patches, (function(patch) {
	    if (/[/]length/ig.test(patch.path)) {
	      return false;
	    }
	    if (!parsePath(patch.path)) {
	      return false;
	    }
	    return true;
	  }));
	  patches = arrayMap(patches, (function(patch) {
	    var coords = parsePath(patch.path);
	    patch.row = coords.row;
	    patch.col = coords.col;
	    return patch;
	  }));
	  patches = arrayFilter(patches, function(patch) {
	    if (['add', 'remove'].indexOf(patch.op) !== -1 && !isNaN(patch.col)) {
	      if (newOrRemovedColumns.indexOf(patch.col) !== -1) {
	        return false;
	      }
	      newOrRemovedColumns.push(patch.col);
	    }
	    return true;
	  });
	  newOrRemovedColumns.length = 0;
	  return patches;
	}
	function parsePath(path) {
	  var match = path.match(/^\/(\d+)\/?(.*)?$/);
	  if (!match) {
	    return null;
	  }
	  var $__1 = match,
	      row = $__1[1],
	      column = $__1[2];
	  return {
	    row: parseInt(row, 10),
	    col: /^\d*$/.test(column) ? parseInt(column, 10) : column
	  };
	}

	//# 
	},{"../../helpers/array":42}],88:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  HandsontablePersistentState: {get: function() {
	      return HandsontablePersistentState;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__46__46__47_plugins__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	;
	function Storage(prefix) {
	  var savedKeys;
	  var saveSavedKeys = function() {
	    window.localStorage[prefix + '__' + 'persistentStateKeys'] = JSON.stringify(savedKeys);
	  };
	  var loadSavedKeys = function() {
	    var keysJSON = window.localStorage[prefix + '__' + 'persistentStateKeys'];
	    var keys = typeof keysJSON == 'string' ? JSON.parse(keysJSON) : void 0;
	    savedKeys = keys ? keys : [];
	  };
	  var clearSavedKeys = function() {
	    savedKeys = [];
	    saveSavedKeys();
	  };
	  loadSavedKeys();
	  this.saveValue = function(key, value) {
	    window.localStorage[prefix + '_' + key] = JSON.stringify(value);
	    if (savedKeys.indexOf(key) == -1) {
	      savedKeys.push(key);
	      saveSavedKeys();
	    }
	  };
	  this.loadValue = function(key, defaultValue) {
	    key = typeof key === 'undefined' ? defaultValue : key;
	    var value = window.localStorage[prefix + '_' + key];
	    return typeof value == 'undefined' ? void 0 : JSON.parse(value);
	  };
	  this.reset = function(key) {
	    window.localStorage.removeItem(prefix + '_' + key);
	  };
	  this.resetAll = function() {
	    for (var index = 0; index < savedKeys.length; index++) {
	      window.localStorage.removeItem(prefix + '_' + savedKeys[index]);
	    }
	    clearSavedKeys();
	  };
	}
	function HandsontablePersistentState() {
	  var plugin = this;
	  this.init = function() {
	    var instance = this,
	        pluginSettings = instance.getSettings().persistentState;
	    plugin.enabled = !!(pluginSettings);
	    if (!plugin.enabled) {
	      removeHooks.call(instance);
	      return;
	    }
	    if (!instance.storage) {
	      instance.storage = new Storage(instance.rootElement.id);
	    }
	    instance.resetState = plugin.resetValue;
	    addHooks.call(instance);
	  };
	  this.saveValue = function(key, value) {
	    var instance = this;
	    instance.storage.saveValue(key, value);
	  };
	  this.loadValue = function(key, saveTo) {
	    var instance = this;
	    saveTo.value = instance.storage.loadValue(key);
	  };
	  this.resetValue = function(key) {
	    var instance = this;
	    if (typeof key === 'undefined') {
	      instance.storage.resetAll();
	    } else {
	      instance.storage.reset(key);
	    }
	  };
	  var hooks = {
	    persistentStateSave: plugin.saveValue,
	    persistentStateLoad: plugin.loadValue,
	    persistentStateReset: plugin.resetValue
	  };
	  for (var hookName in hooks) {
	    if (hooks.hasOwnProperty(hookName)) {
	      Handsontable.hooks.register(hookName);
	    }
	  }
	  function addHooks() {
	    var instance = this;
	    for (var hookName in hooks) {
	      if (hooks.hasOwnProperty(hookName)) {
	        instance.addHook(hookName, hooks[hookName]);
	      }
	    }
	  }
	  function removeHooks() {
	    var instance = this;
	    for (var hookName in hooks) {
	      if (hooks.hasOwnProperty(hookName)) {
	        instance.removeHook(hookName, hooks[hookName]);
	      }
	    }
	  }
	}
	var htPersistentState = new HandsontablePersistentState();
	Handsontable.hooks.add('beforeInit', htPersistentState.init);
	Handsontable.hooks.add('afterUpdateSettings', htPersistentState.init);

	//# 
	},{"browser":23,"plugins":59}],89:[function(_dereq_,module,exports){
	"use strict";
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_renderers__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var $__1 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__1.addClass,
	    removeClass = $__1.removeClass;
	var $__2 = ($___46__46__47__46__46__47_renderers__ = _dereq_("renderers"), $___46__46__47__46__46__47_renderers__ && $___46__46__47__46__46__47_renderers__.__esModule && $___46__46__47__46__46__47_renderers__ || {default: $___46__46__47__46__46__47_renderers__}),
	    registerRenderer = $__2.registerRenderer,
	    getRenderer = $__2.getRenderer;
	Handsontable.Search = function Search(instance) {
	  this.query = function(queryStr, callback, queryMethod) {
	    var rowCount = instance.countRows();
	    var colCount = instance.countCols();
	    var queryResult = [];
	    if (!callback) {
	      callback = Handsontable.Search.global.getDefaultCallback();
	    }
	    if (!queryMethod) {
	      queryMethod = Handsontable.Search.global.getDefaultQueryMethod();
	    }
	    for (var rowIndex = 0; rowIndex < rowCount; rowIndex++) {
	      for (var colIndex = 0; colIndex < colCount; colIndex++) {
	        var cellData = instance.getDataAtCell(rowIndex, colIndex);
	        var cellProperties = instance.getCellMeta(rowIndex, colIndex);
	        var cellCallback = cellProperties.search.callback || callback;
	        var cellQueryMethod = cellProperties.search.queryMethod || queryMethod;
	        var testResult = cellQueryMethod(queryStr, cellData);
	        if (testResult) {
	          var singleResult = {
	            row: rowIndex,
	            col: colIndex,
	            data: cellData
	          };
	          queryResult.push(singleResult);
	        }
	        if (cellCallback) {
	          cellCallback(instance, rowIndex, colIndex, cellData, testResult);
	        }
	      }
	    }
	    return queryResult;
	  };
	};
	Handsontable.Search.DEFAULT_CALLBACK = function(instance, row, col, data, testResult) {
	  instance.getCellMeta(row, col).isSearchResult = testResult;
	};
	Handsontable.Search.DEFAULT_QUERY_METHOD = function(query, value) {
	  if (typeof query == 'undefined' || query == null || !query.toLowerCase || query.length === 0) {
	    return false;
	  }
	  if (typeof value == 'undefined' || value == null) {
	    return false;
	  }
	  return value.toString().toLowerCase().indexOf(query.toLowerCase()) != -1;
	};
	Handsontable.Search.DEFAULT_SEARCH_RESULT_CLASS = 'htSearchResult';
	Handsontable.Search.global = (function() {
	  var defaultCallback = Handsontable.Search.DEFAULT_CALLBACK;
	  var defaultQueryMethod = Handsontable.Search.DEFAULT_QUERY_METHOD;
	  var defaultSearchResultClass = Handsontable.Search.DEFAULT_SEARCH_RESULT_CLASS;
	  return {
	    getDefaultCallback: function() {
	      return defaultCallback;
	    },
	    setDefaultCallback: function(newDefaultCallback) {
	      defaultCallback = newDefaultCallback;
	    },
	    getDefaultQueryMethod: function() {
	      return defaultQueryMethod;
	    },
	    setDefaultQueryMethod: function(newDefaultQueryMethod) {
	      defaultQueryMethod = newDefaultQueryMethod;
	    },
	    getDefaultSearchResultClass: function() {
	      return defaultSearchResultClass;
	    },
	    setDefaultSearchResultClass: function(newSearchResultClass) {
	      defaultSearchResultClass = newSearchResultClass;
	    }
	  };
	})();
	Handsontable.SearchCellDecorator = function(instance, TD, row, col, prop, value, cellProperties) {
	  var searchResultClass = (cellProperties.search !== null && typeof cellProperties.search == 'object' && cellProperties.search.searchResultClass) || Handsontable.Search.global.getDefaultSearchResultClass();
	  if (cellProperties.isSearchResult) {
	    addClass(TD, searchResultClass);
	  } else {
	    removeClass(TD, searchResultClass);
	  }
	};
	var originalBaseRenderer = getRenderer('base');
	registerRenderer('base', function(instance, TD, row, col, prop, value, cellProperties) {
	  originalBaseRenderer.apply(this, arguments);
	  Handsontable.SearchCellDecorator.apply(this, arguments);
	});
	function init() {
	  var instance = this;
	  var pluginEnabled = !!instance.getSettings().search;
	  if (pluginEnabled) {
	    instance.search = new Handsontable.Search(instance);
	  } else {
	    delete instance.search;
	  }
	}
	Handsontable.hooks.add('afterInit', init);
	Handsontable.hooks.add('afterUpdateSettings', init);

	//# 
	},{"browser":23,"helpers/dom/element":46,"renderers":92}],90:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  TouchScroll: {get: function() {
	      return TouchScroll;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__95_base__,
	    $___46__46__47__46__46__47_plugins__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var $__1 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__1.addClass,
	    removeClass = $__1.removeClass;
	var BasePlugin = ($___46__46__47__95_base__ = _dereq_("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = _dereq_("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var TouchScroll = function TouchScroll(hotInstance) {
	  var $__4 = this;
	  $traceurRuntime.superConstructor($TouchScroll).call(this, hotInstance);
	  this.hot.addHook('afterInit', (function() {
	    return $__4.afterInit();
	  }));
	  this.hot.addHook('afterUpdateSettings', (function() {
	    return $__4.onAfterUpdateSettings();
	  }));
	  this.scrollbars = [];
	  this.clones = [];
	};
	var $TouchScroll = TouchScroll;
	($traceurRuntime.createClass)(TouchScroll, {
	  afterInit: function() {
	    this.registerEvents();
	    this.onAfterUpdateSettings();
	  },
	  onAfterUpdateSettings: function() {
	    var _this = this;
	    this.hot.addHookOnce('afterRender', function() {
	      var wtOverlays = _this.hot.view.wt.wtOverlays;
	      _this.scrollbars = [];
	      _this.scrollbars.push(wtOverlays.topOverlay);
	      if (wtOverlays.bottomOverlay.clone) {
	        _this.scrollbars.push(wtOverlays.bottomOverlay);
	      }
	      _this.scrollbars.push(wtOverlays.leftOverlay);
	      if (wtOverlays.topLeftCornerOverlay) {
	        _this.scrollbars.push(wtOverlays.topLeftCornerOverlay);
	      }
	      if (wtOverlays.bottomLeftCornerOverlay && wtOverlays.bottomLeftCornerOverlay.clone) {
	        _this.scrollbars.push(wtOverlays.bottomLeftCornerOverlay);
	      }
	      _this.clones = [];
	      if (wtOverlays.topOverlay.needFullRender) {
	        _this.clones.push(wtOverlays.topOverlay.clone.wtTable.holder.parentNode);
	      }
	      if (wtOverlays.bottomOverlay.needFullRender) {
	        _this.clones.push(wtOverlays.bottomOverlay.clone.wtTable.holder.parentNode);
	      }
	      if (wtOverlays.leftOverlay.needFullRender) {
	        _this.clones.push(wtOverlays.leftOverlay.clone.wtTable.holder.parentNode);
	      }
	      if (wtOverlays.topLeftCornerOverlay) {
	        _this.clones.push(wtOverlays.topLeftCornerOverlay.clone.wtTable.holder.parentNode);
	      }
	      if (wtOverlays.bottomLeftCornerOverlay && wtOverlays.bottomLeftCornerOverlay.clone) {
	        _this.clones.push(wtOverlays.bottomLeftCornerOverlay.clone.wtTable.holder.parentNode);
	      }
	    });
	  },
	  registerEvents: function() {
	    var $__4 = this;
	    this.hot.addHook('beforeTouchScroll', (function() {
	      return $__4.onBeforeTouchScroll();
	    }));
	    this.hot.addHook('afterMomentumScroll', (function() {
	      return $__4.onAfterMomentumScroll();
	    }));
	  },
	  onBeforeTouchScroll: function() {
	    Handsontable.freezeOverlays = true;
	    for (var i = 0,
	        cloneCount = this.clones.length; i < cloneCount; i++) {
	      addClass(this.clones[i], 'hide-tween');
	    }
	  },
	  onAfterMomentumScroll: function() {
	    Handsontable.freezeOverlays = false;
	    var _that = this;
	    for (var i = 0,
	        cloneCount = this.clones.length; i < cloneCount; i++) {
	      removeClass(this.clones[i], 'hide-tween');
	    }
	    for (var i$__6 = 0,
	        cloneCount$__7 = this.clones.length; i$__6 < cloneCount$__7; i$__6++) {
	      addClass(this.clones[i$__6], 'show-tween');
	    }
	    setTimeout(function() {
	      for (var i = 0,
	          cloneCount = _that.clones.length; i < cloneCount; i++) {
	        removeClass(_that.clones[i], 'show-tween');
	      }
	    }, 400);
	    for (var i$__8 = 0,
	        cloneCount$__9 = this.scrollbars.length; i$__8 < cloneCount$__9; i$__8++) {
	      this.scrollbars[i$__8].refresh();
	      this.scrollbars[i$__8].resetFixedPosition();
	    }
	    this.hot.view.wt.wtOverlays.syncScrollWithMaster();
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('touchScroll', TouchScroll);

	//# 
	},{"_base":60,"browser":23,"helpers/dom/element":46,"plugins":59}],91:[function(_dereq_,module,exports){
	"use strict";
	var $___46__46__47__46__46__47_browser__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47_helpers_47_number__,
	    $___46__46__47__46__46__47_helpers_47_object__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__;
	var Handsontable = ($___46__46__47__46__46__47_browser__ = _dereq_("browser"), $___46__46__47__46__46__47_browser__ && $___46__46__47__46__46__47_browser__.__esModule && $___46__46__47__46__46__47_browser__ || {default: $___46__46__47__46__46__47_browser__}).default;
	var arrayMap = ($___46__46__47__46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}).arrayMap;
	var rangeEach = ($___46__46__47__46__46__47_helpers_47_number__ = _dereq_("helpers/number"), $___46__46__47__46__46__47_helpers_47_number__ && $___46__46__47__46__46__47_helpers_47_number__.__esModule && $___46__46__47__46__46__47_helpers_47_number__ || {default: $___46__46__47__46__46__47_helpers_47_number__}).rangeEach;
	var $__3 = ($___46__46__47__46__46__47_helpers_47_object__ = _dereq_("helpers/object"), $___46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47_helpers_47_object__}),
	    inherit = $__3.inherit,
	    deepClone = $__3.deepClone;
	var stopImmediatePropagation = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}).stopImmediatePropagation;
	Handsontable.UndoRedo = function(instance) {
	  var plugin = this;
	  this.instance = instance;
	  this.doneActions = [];
	  this.undoneActions = [];
	  this.ignoreNewActions = false;
	  instance.addHook('afterChange', function(changes, origin) {
	    if (changes) {
	      var action = new Handsontable.UndoRedo.ChangeAction(changes);
	      plugin.done(action);
	    }
	  });
	  instance.addHook('afterCreateRow', function(index, amount, createdAutomatically) {
	    if (createdAutomatically) {
	      return;
	    }
	    var action = new Handsontable.UndoRedo.CreateRowAction(index, amount);
	    plugin.done(action);
	  });
	  instance.addHook('beforeRemoveRow', function(index, amount) {
	    var originalData = plugin.instance.getSourceData();
	    index = (originalData.length + index) % originalData.length;
	    var removedData = originalData.slice(index, index + amount);
	    var action = new Handsontable.UndoRedo.RemoveRowAction(index, removedData);
	    plugin.done(action);
	  });
	  instance.addHook('afterCreateCol', function(index, amount, createdAutomatically) {
	    if (createdAutomatically) {
	      return;
	    }
	    var action = new Handsontable.UndoRedo.CreateColumnAction(index, amount);
	    plugin.done(action);
	  });
	  instance.addHook('beforeRemoveCol', function(index, amount) {
	    var originalData = plugin.instance.getData();
	    index = (plugin.instance.countCols() + index) % plugin.instance.countCols();
	    var removedData = [];
	    var headers = [];
	    var indexes = [];
	    rangeEach(0, originalData.length - 1, (function(i) {
	      removedData[i] = originalData[i].slice(index, index + amount);
	    }));
	    rangeEach(0, amount - 1, (function(i) {
	      indexes.push(instance.runHooks('modifyCol', index + i));
	    }));
	    if (Array.isArray(instance.getSettings().colHeaders)) {
	      rangeEach(0, amount - 1, (function(i) {
	        headers.push(instance.getSettings().colHeaders[instance.runHooks('modifyCol', index + i)] || null);
	      }));
	    }
	    var manualColumnMovePlugin = plugin.instance.getPlugin('manualColumnMove');
	    var action = new Handsontable.UndoRedo.RemoveColumnAction(indexes, removedData, headers, manualColumnMovePlugin ? manualColumnMovePlugin.columnPositions : []);
	    plugin.done(action);
	  });
	  instance.addHook('beforeCellAlignment', function(stateBefore, range, type, alignment) {
	    var action = new Handsontable.UndoRedo.CellAlignmentAction(stateBefore, range, type, alignment);
	    plugin.done(action);
	  });
	  instance.addHook('beforeFilter', function(formulaStacks) {
	    plugin.done(new Handsontable.UndoRedo.FiltersAction(formulaStacks));
	  });
	};
	Handsontable.UndoRedo.prototype.done = function(action) {
	  if (!this.ignoreNewActions) {
	    this.doneActions.push(action);
	    this.undoneActions.length = 0;
	  }
	};
	Handsontable.UndoRedo.prototype.undo = function() {
	  if (this.isUndoAvailable()) {
	    var action = this.doneActions.pop();
	    this.ignoreNewActions = true;
	    var that = this;
	    action.undo(this.instance, function() {
	      that.ignoreNewActions = false;
	      that.undoneActions.push(action);
	    });
	  }
	};
	Handsontable.UndoRedo.prototype.redo = function() {
	  if (this.isRedoAvailable()) {
	    var action = this.undoneActions.pop();
	    this.ignoreNewActions = true;
	    var that = this;
	    action.redo(this.instance, function() {
	      that.ignoreNewActions = false;
	      that.doneActions.push(action);
	    });
	  }
	};
	Handsontable.UndoRedo.prototype.isUndoAvailable = function() {
	  return this.doneActions.length > 0;
	};
	Handsontable.UndoRedo.prototype.isRedoAvailable = function() {
	  return this.undoneActions.length > 0;
	};
	Handsontable.UndoRedo.prototype.clear = function() {
	  this.doneActions.length = 0;
	  this.undoneActions.length = 0;
	};
	Handsontable.UndoRedo.Action = function() {};
	Handsontable.UndoRedo.Action.prototype.undo = function() {};
	Handsontable.UndoRedo.Action.prototype.redo = function() {};
	Handsontable.UndoRedo.ChangeAction = function(changes) {
	  this.changes = changes;
	};
	inherit(Handsontable.UndoRedo.ChangeAction, Handsontable.UndoRedo.Action);
	Handsontable.UndoRedo.ChangeAction.prototype.undo = function(instance, undoneCallback) {
	  var data = deepClone(this.changes),
	      emptyRowsAtTheEnd = instance.countEmptyRows(true),
	      emptyColsAtTheEnd = instance.countEmptyCols(true);
	  for (var i = 0,
	      len = data.length; i < len; i++) {
	    data[i].splice(3, 1);
	  }
	  instance.addHookOnce('afterChange', undoneCallback);
	  instance.setDataAtRowProp(data, null, null, 'undo');
	  for (var i = 0,
	      len = data.length; i < len; i++) {
	    if (instance.getSettings().minSpareRows && data[i][0] + 1 + instance.getSettings().minSpareRows === instance.countRows() && emptyRowsAtTheEnd == instance.getSettings().minSpareRows) {
	      instance.alter('remove_row', parseInt(data[i][0] + 1, 10), instance.getSettings().minSpareRows);
	      instance.undoRedo.doneActions.pop();
	    }
	    if (instance.getSettings().minSpareCols && data[i][1] + 1 + instance.getSettings().minSpareCols === instance.countCols() && emptyColsAtTheEnd == instance.getSettings().minSpareCols) {
	      instance.alter('remove_col', parseInt(data[i][1] + 1, 10), instance.getSettings().minSpareCols);
	      instance.undoRedo.doneActions.pop();
	    }
	  }
	};
	Handsontable.UndoRedo.ChangeAction.prototype.redo = function(instance, onFinishCallback) {
	  var data = deepClone(this.changes);
	  for (var i = 0,
	      len = data.length; i < len; i++) {
	    data[i].splice(2, 1);
	  }
	  instance.addHookOnce('afterChange', onFinishCallback);
	  instance.setDataAtRowProp(data, null, null, 'redo');
	};
	Handsontable.UndoRedo.CreateRowAction = function(index, amount) {
	  this.index = index;
	  this.amount = amount;
	};
	inherit(Handsontable.UndoRedo.CreateRowAction, Handsontable.UndoRedo.Action);
	Handsontable.UndoRedo.CreateRowAction.prototype.undo = function(instance, undoneCallback) {
	  var rowCount = instance.countRows(),
	      minSpareRows = instance.getSettings().minSpareRows;
	  if (this.index >= rowCount && this.index - minSpareRows < rowCount) {
	    this.index -= minSpareRows;
	  }
	  instance.addHookOnce('afterRemoveRow', undoneCallback);
	  instance.alter('remove_row', this.index, this.amount);
	};
	Handsontable.UndoRedo.CreateRowAction.prototype.redo = function(instance, redoneCallback) {
	  instance.addHookOnce('afterCreateRow', redoneCallback);
	  instance.alter('insert_row', this.index + 1, this.amount);
	};
	Handsontable.UndoRedo.RemoveRowAction = function(index, data) {
	  this.index = index;
	  this.data = data;
	};
	inherit(Handsontable.UndoRedo.RemoveRowAction, Handsontable.UndoRedo.Action);
	Handsontable.UndoRedo.RemoveRowAction.prototype.undo = function(instance, undoneCallback) {
	  var spliceArgs = [this.index, 0];
	  Array.prototype.push.apply(spliceArgs, this.data);
	  Array.prototype.splice.apply(instance.getSourceData(), spliceArgs);
	  instance.addHookOnce('afterRender', undoneCallback);
	  instance.render();
	};
	Handsontable.UndoRedo.RemoveRowAction.prototype.redo = function(instance, redoneCallback) {
	  instance.addHookOnce('afterRemoveRow', redoneCallback);
	  instance.alter('remove_row', this.index, this.data.length);
	};
	Handsontable.UndoRedo.CreateColumnAction = function(index, amount) {
	  this.index = index;
	  this.amount = amount;
	};
	inherit(Handsontable.UndoRedo.CreateColumnAction, Handsontable.UndoRedo.Action);
	Handsontable.UndoRedo.CreateColumnAction.prototype.undo = function(instance, undoneCallback) {
	  instance.addHookOnce('afterRemoveCol', undoneCallback);
	  instance.alter('remove_col', this.index, this.amount);
	};
	Handsontable.UndoRedo.CreateColumnAction.prototype.redo = function(instance, redoneCallback) {
	  instance.addHookOnce('afterCreateCol', redoneCallback);
	  instance.alter('insert_col', this.index + 1, this.amount);
	};
	Handsontable.UndoRedo.CellAlignmentAction = function(stateBefore, range, type, alignment) {
	  this.stateBefore = stateBefore;
	  this.range = range;
	  this.type = type;
	  this.alignment = alignment;
	};
	Handsontable.UndoRedo.CellAlignmentAction.prototype.undo = function(instance, undoneCallback) {
	  if (!instance.getPlugin('contextMenu').isEnabled()) {
	    return;
	  }
	  for (var row = this.range.from.row; row <= this.range.to.row; row++) {
	    for (var col = this.range.from.col; col <= this.range.to.col; col++) {
	      instance.setCellMeta(row, col, 'className', this.stateBefore[row][col] || ' htLeft');
	    }
	  }
	  instance.addHookOnce('afterRender', undoneCallback);
	  instance.render();
	};
	Handsontable.UndoRedo.CellAlignmentAction.prototype.redo = function(instance, undoneCallback) {
	  if (!instance.getPlugin('contextMenu').isEnabled()) {
	    return;
	  }
	  instance.selectCell(this.range.from.row, this.range.from.col, this.range.to.row, this.range.to.col);
	  instance.getPlugin('contextMenu').executeCommand('alignment:' + this.alignment.replace('ht', '').toLowerCase());
	  instance.addHookOnce('afterRender', undoneCallback);
	  instance.render();
	};
	Handsontable.UndoRedo.RemoveColumnAction = function(indexes, data, headers, columnPositions) {
	  this.indexes = indexes;
	  this.data = data;
	  this.amount = this.data[0].length;
	  this.headers = headers;
	  this.columnPositions = columnPositions.slice(0);
	};
	inherit(Handsontable.UndoRedo.RemoveColumnAction, Handsontable.UndoRedo.Action);
	Handsontable.UndoRedo.RemoveColumnAction.prototype.undo = function(instance, undoneCallback) {
	  var $__5 = this;
	  var row;
	  var ascendingIndexes = this.indexes.slice(0).sort();
	  var sortByIndexes = (function(elem, j, arr) {
	    return arr[$__5.indexes.indexOf(ascendingIndexes[j])];
	  });
	  var sortedData = [];
	  rangeEach(0, this.data.length - 1, (function(i) {
	    sortedData[i] = arrayMap($__5.data[i], sortByIndexes);
	  }));
	  var sortedHeaders = [];
	  sortedHeaders = arrayMap(this.headers, sortByIndexes);
	  rangeEach(0, this.data.length - 1, (function(i) {
	    row = instance.getSourceDataAtRow(i);
	    rangeEach(0, ascendingIndexes.length - 1, (function(j) {
	      row.splice(ascendingIndexes[j], 0, sortedData[i][j]);
	    }));
	  }));
	  if (typeof this.headers != 'undefined') {
	    rangeEach(0, sortedHeaders.length - 1, (function(j) {
	      instance.getSettings().colHeaders.splice(ascendingIndexes[j], 0, sortedHeaders[j]);
	    }));
	  }
	  if (instance.getPlugin('manualColumnMove')) {
	    instance.getPlugin('manualColumnMove').columnPositions = this.columnPositions;
	  }
	  instance.addHookOnce('afterRender', undoneCallback);
	  instance.render();
	};
	Handsontable.UndoRedo.RemoveColumnAction.prototype.redo = function(instance, redoneCallback) {
	  instance.addHookOnce('afterRemoveCol', redoneCallback);
	  instance.alter('remove_col', instance.runHooks('unmodifyCol', this.indexes[0]), this.amount);
	};
	Handsontable.UndoRedo.FiltersAction = function(formulaStacks) {
	  this.formulaStacks = formulaStacks;
	};
	inherit(Handsontable.UndoRedo.FiltersAction, Handsontable.UndoRedo.Action);
	Handsontable.UndoRedo.FiltersAction.prototype.undo = function(instance, undoneCallback) {
	  var filters = instance.getPlugin('filters');
	  instance.addHookOnce('afterRender', undoneCallback);
	  filters.formulaCollection.importAllFormulas(this.formulaStacks.slice(0, this.formulaStacks.length - 1));
	  filters.filter();
	};
	Handsontable.UndoRedo.FiltersAction.prototype.redo = function(instance, redoneCallback) {
	  var filters = instance.getPlugin('filters');
	  instance.addHookOnce('afterRender', redoneCallback);
	  filters.formulaCollection.importAllFormulas(this.formulaStacks);
	  filters.filter();
	};
	function init() {
	  var instance = this;
	  var pluginEnabled = typeof instance.getSettings().undo == 'undefined' || instance.getSettings().undo;
	  if (pluginEnabled) {
	    if (!instance.undoRedo) {
	      instance.undoRedo = new Handsontable.UndoRedo(instance);
	      exposeUndoRedoMethods(instance);
	      instance.addHook('beforeKeyDown', onBeforeKeyDown);
	      instance.addHook('afterChange', onAfterChange);
	    }
	  } else {
	    if (instance.undoRedo) {
	      delete instance.undoRedo;
	      removeExposedUndoRedoMethods(instance);
	      instance.removeHook('beforeKeyDown', onBeforeKeyDown);
	      instance.removeHook('afterChange', onAfterChange);
	    }
	  }
	}
	function onBeforeKeyDown(event) {
	  var instance = this;
	  var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;
	  if (ctrlDown) {
	    if (event.keyCode === 89 || (event.shiftKey && event.keyCode === 90)) {
	      instance.undoRedo.redo();
	      stopImmediatePropagation(event);
	    } else if (event.keyCode === 90) {
	      instance.undoRedo.undo();
	      stopImmediatePropagation(event);
	    }
	  }
	}
	function onAfterChange(changes, source) {
	  var instance = this;
	  if (source == 'loadData') {
	    return instance.undoRedo.clear();
	  }
	}
	function exposeUndoRedoMethods(instance) {
	  instance.undo = function() {
	    return instance.undoRedo.undo();
	  };
	  instance.redo = function() {
	    return instance.undoRedo.redo();
	  };
	  instance.isUndoAvailable = function() {
	    return instance.undoRedo.isUndoAvailable();
	  };
	  instance.isRedoAvailable = function() {
	    return instance.undoRedo.isRedoAvailable();
	  };
	  instance.clearUndo = function() {
	    return instance.undoRedo.clear();
	  };
	}
	function removeExposedUndoRedoMethods(instance) {
	  delete instance.undo;
	  delete instance.redo;
	  delete instance.isUndoAvailable;
	  delete instance.isRedoAvailable;
	  delete instance.clearUndo;
	}
	Handsontable.hooks.add('afterInit', init);
	Handsontable.hooks.add('afterUpdateSettings', init);

	//# 
	},{"browser":23,"helpers/array":42,"helpers/dom/event":47,"helpers/number":51,"helpers/object":52}],92:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  registerRenderer: {get: function() {
	      return registerRenderer;
	    }},
	  getRenderer: {get: function() {
	      return getRenderer;
	    }},
	  hasRenderer: {get: function() {
	      return hasRenderer;
	    }},
	  __esModule: {value: true}
	});
	var $__browser__,
	    $__helpers_47_string__;
	var Handsontable = ($__browser__ = _dereq_("browser"), $__browser__ && $__browser__.__esModule && $__browser__ || {default: $__browser__}).default;
	var toUpperCaseFirst = ($__helpers_47_string__ = _dereq_("helpers/string"), $__helpers_47_string__ && $__helpers_47_string__.__esModule && $__helpers_47_string__ || {default: $__helpers_47_string__}).toUpperCaseFirst;
	var registeredRenderers = {};
	Handsontable.renderers = Handsontable.renderers || {};
	Handsontable.renderers.registerRenderer = registerRenderer;
	Handsontable.renderers.getRenderer = getRenderer;
	function registerRenderer(rendererName, rendererFunction) {
	  var registerName;
	  registeredRenderers[rendererName] = rendererFunction;
	  registerName = toUpperCaseFirst(rendererName) + 'Renderer';
	  Handsontable.renderers[registerName] = rendererFunction;
	  Handsontable[registerName] = rendererFunction;
	  if (rendererName === 'base') {
	    Handsontable.renderers.cellDecorator = rendererFunction;
	  }
	}
	function getRenderer(rendererName) {
	  if (typeof rendererName == 'function') {
	    return rendererName;
	  }
	  if (typeof rendererName != 'string') {
	    throw Error('Only strings and functions can be passed as "renderer" parameter');
	  }
	  if (!(rendererName in registeredRenderers)) {
	    throw Error('No editor registered under name "' + rendererName + '"');
	  }
	  return registeredRenderers[rendererName];
	}
	function hasRenderer(rendererName) {
	  return rendererName in registeredRenderers;
	}
	;

	//# 
	},{"browser":23,"helpers/string":54}],93:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  cellDecorator: {get: function() {
	      return cellDecorator;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_renderers__;
	var $__0 = ($___46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    removeClass = $__0.removeClass;
	var registerRenderer = ($___46__46__47_renderers__ = _dereq_("renderers"), $___46__46__47_renderers__ && $___46__46__47_renderers__.__esModule && $___46__46__47_renderers__ || {default: $___46__46__47_renderers__}).registerRenderer;
	function cellDecorator(instance, TD, row, col, prop, value, cellProperties) {
	  if (cellProperties.className) {
	    if (TD.className) {
	      TD.className = TD.className + ' ' + cellProperties.className;
	    } else {
	      TD.className = cellProperties.className;
	    }
	  }
	  if (cellProperties.readOnly) {
	    addClass(TD, cellProperties.readOnlyCellClassName);
	  }
	  if (cellProperties.valid === false && cellProperties.invalidCellClassName) {
	    addClass(TD, cellProperties.invalidCellClassName);
	  } else {
	    removeClass(TD, cellProperties.invalidCellClassName);
	  }
	  if (cellProperties.wordWrap === false && cellProperties.noWordWrapClassName) {
	    addClass(TD, cellProperties.noWordWrapClassName);
	  }
	  if (!value && cellProperties.placeholder) {
	    addClass(TD, cellProperties.placeholderCellClassName);
	  }
	}
	;
	registerRenderer('base', cellDecorator);

	//# 
	},{"helpers/dom/element":46,"renderers":92}],94:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  autocompleteRenderer: {get: function() {
	      return autocompleteRenderer;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_eventManager__,
	    $___46__46__47_renderers__,
	    $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__;
	var $__0 = ($___46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    hasClass = $__0.hasClass,
	    empty = $__0.empty;
	var eventManagerObject = ($___46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47_eventManager__ && $___46__46__47_eventManager__.__esModule && $___46__46__47_eventManager__ || {default: $___46__46__47_eventManager__}).eventManager;
	var $__2 = ($___46__46__47_renderers__ = _dereq_("renderers"), $___46__46__47_renderers__ && $___46__46__47_renderers__.__esModule && $___46__46__47_renderers__ || {default: $___46__46__47_renderers__}),
	    getRenderer = $__2.getRenderer,
	    registerRenderer = $__2.registerRenderer;
	var WalkontableCellCoords = ($___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ = _dereq_("3rdparty/walkontable/src/cell/coords"), $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	var clonableWRAPPER = document.createElement('DIV');
	clonableWRAPPER.className = 'htAutocompleteWrapper';
	var clonableARROW = document.createElement('DIV');
	clonableARROW.className = 'htAutocompleteArrow';
	clonableARROW.appendChild(document.createTextNode(String.fromCharCode(9660)));
	var wrapTdContentWithWrapper = function(TD, WRAPPER) {
	  WRAPPER.innerHTML = TD.innerHTML;
	  empty(TD);
	  TD.appendChild(WRAPPER);
	};
	function autocompleteRenderer(instance, TD, row, col, prop, value, cellProperties) {
	  var WRAPPER = clonableWRAPPER.cloneNode(true);
	  var ARROW = clonableARROW.cloneNode(true);
	  getRenderer('text')(instance, TD, row, col, prop, value, cellProperties);
	  TD.appendChild(ARROW);
	  addClass(TD, 'htAutocomplete');
	  if (!TD.firstChild) {
	    TD.appendChild(document.createTextNode(String.fromCharCode(160)));
	  }
	  if (!instance.acArrowListener) {
	    var eventManager = eventManagerObject(instance);
	    instance.acArrowListener = function(event) {
	      if (hasClass(event.target, 'htAutocompleteArrow')) {
	        instance.view.wt.getSetting('onCellDblClick', null, new WalkontableCellCoords(row, col), TD);
	      }
	    };
	    eventManager.addEventListener(instance.rootElement, 'mousedown', instance.acArrowListener);
	    instance.addHookOnce('afterDestroy', function() {
	      eventManager.destroy();
	    });
	  }
	}
	;
	registerRenderer('autocomplete', autocompleteRenderer);

	//# 
	},{"3rdparty/walkontable/src/cell/coords":5,"eventManager":41,"helpers/dom/element":46,"renderers":92}],95:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  checkboxRenderer: {get: function() {
	      return checkboxRenderer;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_helpers_47_string__,
	    $___46__46__47_eventManager__,
	    $___46__46__47_renderers__,
	    $___46__46__47_helpers_47_unicode__,
	    $___46__46__47_helpers_47_dom_47_event__;
	var $__0 = ($___46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    empty = $__0.empty,
	    addClass = $__0.addClass,
	    hasClass = $__0.hasClass;
	var equalsIgnoreCase = ($___46__46__47_helpers_47_string__ = _dereq_("helpers/string"), $___46__46__47_helpers_47_string__ && $___46__46__47_helpers_47_string__.__esModule && $___46__46__47_helpers_47_string__ || {default: $___46__46__47_helpers_47_string__}).equalsIgnoreCase;
	var EventManager = ($___46__46__47_eventManager__ = _dereq_("eventManager"), $___46__46__47_eventManager__ && $___46__46__47_eventManager__.__esModule && $___46__46__47_eventManager__ || {default: $___46__46__47_eventManager__}).EventManager;
	var $__3 = ($___46__46__47_renderers__ = _dereq_("renderers"), $___46__46__47_renderers__ && $___46__46__47_renderers__.__esModule && $___46__46__47_renderers__ || {default: $___46__46__47_renderers__}),
	    getRenderer = $__3.getRenderer,
	    registerRenderer = $__3.registerRenderer;
	var KEY_CODES = ($___46__46__47_helpers_47_unicode__ = _dereq_("helpers/unicode"), $___46__46__47_helpers_47_unicode__ && $___46__46__47_helpers_47_unicode__.__esModule && $___46__46__47_helpers_47_unicode__ || {default: $___46__46__47_helpers_47_unicode__}).KEY_CODES;
	var $__5 = ($___46__46__47_helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $___46__46__47_helpers_47_dom_47_event__ && $___46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47_helpers_47_dom_47_event__}),
	    stopPropagation = $__5.stopPropagation,
	    stopImmediatePropagation = $__5.stopImmediatePropagation,
	    isImmediatePropagationStopped = $__5.isImmediatePropagationStopped;
	var isListeningKeyDownEvent = new WeakMap();
	var isCheckboxListenerAdded = new WeakMap();
	var BAD_VALUE_CLASS = 'htBadValue';
	function checkboxRenderer(instance, TD, row, col, prop, value, cellProperties) {
	  var eventManager = new EventManager(instance);
	  var input = createInput();
	  var labelOptions = cellProperties.label;
	  var badValue = false;
	  if (typeof cellProperties.checkedTemplate === 'undefined') {
	    cellProperties.checkedTemplate = true;
	  }
	  if (typeof cellProperties.uncheckedTemplate === 'undefined') {
	    cellProperties.uncheckedTemplate = false;
	  }
	  empty(TD);
	  if (value === cellProperties.checkedTemplate || equalsIgnoreCase(value, cellProperties.checkedTemplate)) {
	    input.checked = true;
	  } else if (value === cellProperties.uncheckedTemplate || equalsIgnoreCase(value, cellProperties.uncheckedTemplate)) {
	    input.checked = false;
	  } else if (value === null) {
	    addClass(input, 'noValue');
	  } else {
	    input.style.display = 'none';
	    addClass(input, BAD_VALUE_CLASS);
	    badValue = true;
	  }
	  input.setAttribute('data-row', row);
	  input.setAttribute('data-col', col);
	  if (!badValue && labelOptions) {
	    var labelText = '';
	    if (labelOptions.value) {
	      labelText = typeof labelOptions.value === 'function' ? labelOptions.value.call(this, row, col, prop, value) : labelOptions.value;
	    } else if (labelOptions.property) {
	      labelText = instance.getDataAtRowProp(row, labelOptions.property);
	    }
	    var label = createLabel(labelText);
	    if (labelOptions.position === 'before') {
	      label.appendChild(input);
	    } else {
	      label.insertBefore(input, label.firstChild);
	    }
	    input = label;
	  }
	  TD.appendChild(input);
	  if (badValue) {
	    TD.appendChild(document.createTextNode('#bad-value#'));
	  }
	  if (!isCheckboxListenerAdded.has(instance)) {
	    if (cellProperties.readOnly) {
	      eventManager.addEventListener(instance.rootElement, 'click', preventDefault);
	    } else {
	      eventManager.addEventListener(instance.rootElement, 'mouseup', (function(event) {
	        return onMouseUp(event, instance);
	      }));
	      eventManager.addEventListener(instance.rootElement, 'change', (function(event) {
	        return onChange(event, instance);
	      }));
	    }
	    isCheckboxListenerAdded.set(instance, true);
	  }
	  if (!isListeningKeyDownEvent.has(instance)) {
	    isListeningKeyDownEvent.set(instance, true);
	    instance.addHook('beforeKeyDown', onBeforeKeyDown);
	  }
	  function onBeforeKeyDown(event) {
	    var allowedKeys = [KEY_CODES.SPACE, KEY_CODES.ENTER, KEY_CODES.DELETE, KEY_CODES.BACKSPACE];
	    if (allowedKeys.indexOf(event.keyCode) !== -1 && !isImmediatePropagationStopped(event)) {
	      eachSelectedCheckboxCell(function() {
	        stopImmediatePropagation(event);
	        event.preventDefault();
	      });
	    }
	    if (event.keyCode === KEY_CODES.SPACE || event.keyCode === KEY_CODES.ENTER) {
	      toggleSelected();
	    }
	    if (event.keyCode === KEY_CODES.DELETE || event.keyCode === KEY_CODES.BACKSPACE) {
	      toggleSelected(false);
	    }
	  }
	  function toggleSelected() {
	    var checked = arguments[0] !== (void 0) ? arguments[0] : null;
	    eachSelectedCheckboxCell(function(checkboxes) {
	      for (var i = 0,
	          len = checkboxes.length; i < len; i++) {
	        if (hasClass(checkboxes[i], BAD_VALUE_CLASS) && checked === null) {
	          return;
	        }
	        toggleCheckbox(checkboxes[i], checked);
	      }
	    });
	  }
	  function toggleCheckbox(checkbox) {
	    var checked = arguments[1] !== (void 0) ? arguments[1] : null;
	    if (checked === null) {
	      checkbox.checked = !checkbox.checked;
	    } else {
	      checkbox.checked = checked;
	    }
	    eventManager.fireEvent(checkbox, 'change');
	  }
	  function eachSelectedCheckboxCell(callback) {
	    var selRange = instance.getSelectedRange();
	    if (!selRange) {
	      return;
	    }
	    var topLeft = selRange.getTopLeftCorner();
	    var bottomRight = selRange.getBottomRightCorner();
	    for (var row = topLeft.row; row <= bottomRight.row; row++) {
	      for (var col = topLeft.col; col <= bottomRight.col; col++) {
	        var cell = instance.getCell(row, col);
	        var cellProperties$__6 = instance.getCellMeta(row, col);
	        var checkboxes = cell.querySelectorAll('input[type=checkbox]');
	        if (checkboxes.length > 0 && !cellProperties$__6.readOnly) {
	          callback(checkboxes);
	        }
	      }
	    }
	  }
	}
	function createInput() {
	  var input = document.createElement('input');
	  input.className = 'htCheckboxRendererInput';
	  input.type = 'checkbox';
	  input.setAttribute('autocomplete', 'off');
	  input.setAttribute('tabindex', '-1');
	  return input.cloneNode(false);
	}
	function createLabel(text) {
	  var label = document.createElement('label');
	  label.className = 'htCheckboxRendererLabel';
	  label.appendChild(document.createTextNode(text));
	  return label.cloneNode(true);
	}
	function preventDefault(event) {
	  if (isCheckboxInput(event.target)) {
	    event.preventDefault();
	  }
	}
	function onMouseUp(event, instance) {
	  if (isCheckboxInput(event.target)) {
	    setTimeout(instance.listen, 10);
	  }
	}
	function onChange(event, instance) {
	  if (!isCheckboxInput(event.target)) {
	    return false;
	  }
	  var row = parseInt(event.target.getAttribute('data-row'), 10);
	  var col = parseInt(event.target.getAttribute('data-col'), 10);
	  var cellProperties = instance.getCellMeta(row, col);
	  instance.setDataAtCell(row, col, event.target.checked ? (cellProperties.checkedTemplate || true) : (cellProperties.uncheckedTemplate || false));
	}
	function isCheckboxInput(element) {
	  return element.tagName === 'INPUT' && element.getAttribute('type') === 'checkbox';
	}
	;
	registerRenderer('checkbox', checkboxRenderer);

	//# 
	},{"eventManager":41,"helpers/dom/element":46,"helpers/dom/event":47,"helpers/string":54,"helpers/unicode":55,"renderers":92}],96:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  htmlRenderer: {get: function() {
	      return htmlRenderer;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_renderers__;
	var fastInnerHTML = ($___46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}).fastInnerHTML;
	var $__1 = ($___46__46__47_renderers__ = _dereq_("renderers"), $___46__46__47_renderers__ && $___46__46__47_renderers__.__esModule && $___46__46__47_renderers__ || {default: $___46__46__47_renderers__}),
	    getRenderer = $__1.getRenderer,
	    registerRenderer = $__1.registerRenderer;
	function htmlRenderer(instance, TD, row, col, prop, value, cellProperties) {
	  getRenderer('base').apply(this, arguments);
	  if (value === null || value === void 0) {
	    value = '';
	  }
	  fastInnerHTML(TD, value);
	}
	;
	registerRenderer('html', htmlRenderer);

	//# 
	},{"helpers/dom/element":46,"renderers":92}],97:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  numericRenderer: {get: function() {
	      return numericRenderer;
	    }},
	  __esModule: {value: true}
	});
	var $__numeral__,
	    $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_renderers__,
	    $___46__46__47_helpers_47_number__;
	var numeral = ($__numeral__ = _dereq_("numeral"), $__numeral__ && $__numeral__.__esModule && $__numeral__ || {default: $__numeral__}).default;
	var addClass = ($___46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}).addClass;
	var $__2 = ($___46__46__47_renderers__ = _dereq_("renderers"), $___46__46__47_renderers__ && $___46__46__47_renderers__.__esModule && $___46__46__47_renderers__ || {default: $___46__46__47_renderers__}),
	    getRenderer = $__2.getRenderer,
	    registerRenderer = $__2.registerRenderer;
	var isNumeric = ($___46__46__47_helpers_47_number__ = _dereq_("helpers/number"), $___46__46__47_helpers_47_number__ && $___46__46__47_helpers_47_number__.__esModule && $___46__46__47_helpers_47_number__ || {default: $___46__46__47_helpers_47_number__}).isNumeric;
	function numericRenderer(instance, TD, row, col, prop, value, cellProperties) {
	  if (isNumeric(value)) {
	    if (typeof cellProperties.language !== 'undefined') {
	      numeral.language(cellProperties.language);
	    }
	    value = numeral(value).format(cellProperties.format || '0');
	    addClass(TD, 'htNumeric');
	  }
	  getRenderer('text')(instance, TD, row, col, prop, value, cellProperties);
	}
	;
	registerRenderer('numeric', numericRenderer);

	//# 
	},{"helpers/dom/element":46,"helpers/number":51,"numeral":"numeral","renderers":92}],98:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  passwordRenderer: {get: function() {
	      return passwordRenderer;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_renderers__;
	var fastInnerHTML = ($___46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}).fastInnerHTML;
	var $__1 = ($___46__46__47_renderers__ = _dereq_("renderers"), $___46__46__47_renderers__ && $___46__46__47_renderers__.__esModule && $___46__46__47_renderers__ || {default: $___46__46__47_renderers__}),
	    getRenderer = $__1.getRenderer,
	    registerRenderer = $__1.registerRenderer;
	function passwordRenderer(instance, TD, row, col, prop, value, cellProperties) {
	  getRenderer('text').apply(this, arguments);
	  value = TD.innerHTML;
	  var hash;
	  var hashLength = cellProperties.hashLength || value.length;
	  var hashSymbol = cellProperties.hashSymbol || '*';
	  for (hash = ''; hash.split(hashSymbol).length - 1 < hashLength; hash += hashSymbol) {}
	  fastInnerHTML(TD, hash);
	}
	;
	registerRenderer('password', passwordRenderer);

	//# 
	},{"helpers/dom/element":46,"renderers":92}],99:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  textRenderer: {get: function() {
	      return textRenderer;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_helpers_47_mixed__,
	    $___46__46__47_renderers__;
	var $__0 = ($___46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    empty = $__0.empty,
	    fastInnerText = $__0.fastInnerText;
	var stringify = ($___46__46__47_helpers_47_mixed__ = _dereq_("helpers/mixed"), $___46__46__47_helpers_47_mixed__ && $___46__46__47_helpers_47_mixed__.__esModule && $___46__46__47_helpers_47_mixed__ || {default: $___46__46__47_helpers_47_mixed__}).stringify;
	var $__2 = ($___46__46__47_renderers__ = _dereq_("renderers"), $___46__46__47_renderers__ && $___46__46__47_renderers__.__esModule && $___46__46__47_renderers__ || {default: $___46__46__47_renderers__}),
	    getRenderer = $__2.getRenderer,
	    registerRenderer = $__2.registerRenderer;
	function textRenderer(instance, TD, row, col, prop, value, cellProperties) {
	  getRenderer('base').apply(this, arguments);
	  if (!value && cellProperties.placeholder) {
	    value = cellProperties.placeholder;
	  }
	  var escaped = stringify(value);
	  if (!instance.getSettings().trimWhitespace) {
	    escaped = escaped.replace(/ /g, String.fromCharCode(160));
	  }
	  if (cellProperties.rendererTemplate) {
	    empty(TD);
	    var TEMPLATE = document.createElement('TEMPLATE');
	    TEMPLATE.setAttribute('bind', '{{}}');
	    TEMPLATE.innerHTML = cellProperties.rendererTemplate;
	    HTMLTemplateElement.decorate(TEMPLATE);
	    TEMPLATE.model = instance.getSourceDataAtRow(row);
	    TD.appendChild(TEMPLATE);
	  } else {
	    fastInnerText(TD, escaped);
	  }
	}
	;
	registerRenderer('text', textRenderer);

	//# 
	},{"helpers/dom/element":46,"helpers/mixed":50,"renderers":92}],100:[function(_dereq_,module,exports){
	// jscs:disable
	/* jshint ignore:start */
	(function(global) {
	  'use strict';
	  if (global.$traceurRuntime) {
	    return;
	  }
	  var $Object = Object;
	  var $TypeError = TypeError;
	  var $create = $Object.create;
	  var $defineProperties = $Object.defineProperties;
	  var $defineProperty = $Object.defineProperty;
	  var $freeze = $Object.freeze;
	  var $getOwnPropertyDescriptor = $Object.getOwnPropertyDescriptor;
	  var $getOwnPropertyNames = $Object.getOwnPropertyNames;
	  var $keys = $Object.keys;
	  var $isExtensible = Object.isExtensible;
	  function nonEnum(value) {
	    return {
	      configurable: true,
	      enumerable: false,
	      value: value,
	      writable: true
	    };
	  }
	  var method = nonEnum;
	  var counter = 0;
	  function newUniqueString() {
	    return '__$' + Math.floor(Math.random() * 1e9) + '$' + ++counter + '$__';
	  }
	  var symbolInternalProperty = newUniqueString();
	  var symbolDescriptionProperty = newUniqueString();
	  var symbolDataProperty = newUniqueString();
	  var symbolValues = $create(null);
	  var privateNames = $create(null);
	  function isPrivateName(s) {
	    return privateNames[s];
	  }
	  function createPrivateName() {
	    var s = newUniqueString();
	    privateNames[s] = true;
	    return s;
	  }
	  function isShimSymbol(symbol) {
	    return typeof symbol === 'object' && symbol instanceof SymbolValue;
	  }
	  function typeOf(v) {
	    if (isShimSymbol(v))
	      return 'symbol';
	    return typeof v;
	  }
	  function Symbol(description) {
	    var value = new SymbolValue(description);
	    if (!(this instanceof Symbol))
	      return value;
	    throw new TypeError('Symbol cannot be new\'ed');
	  }
	  $defineProperty(Symbol.prototype, 'constructor', nonEnum(Symbol));
	  $defineProperty(Symbol.prototype, 'toString', method(function() {
	    var symbolValue = this[symbolDataProperty];
	    if (!getOption('symbols'))
	      return symbolValue[symbolInternalProperty];
	    if (!symbolValue)
	      throw TypeError('Conversion from symbol to string');
	    var desc = symbolValue[symbolDescriptionProperty];
	    if (desc === undefined)
	      desc = '';
	    return 'Symbol(' + desc + ')';
	  }));
	  $defineProperty(Symbol.prototype, 'valueOf', method(function() {
	    var symbolValue = this[symbolDataProperty];
	    if (!symbolValue)
	      throw TypeError('Conversion from symbol to string');
	    if (!getOption('symbols'))
	      return symbolValue[symbolInternalProperty];
	    return symbolValue;
	  }));
	  function SymbolValue(description) {
	    var key = newUniqueString();
	    $defineProperty(this, symbolDataProperty, {value: this});
	    $defineProperty(this, symbolInternalProperty, {value: key});
	    $defineProperty(this, symbolDescriptionProperty, {value: description});
	    freeze(this);
	    symbolValues[key] = this;
	  }
	  $defineProperty(SymbolValue.prototype, 'constructor', nonEnum(Symbol));
	  $defineProperty(SymbolValue.prototype, 'toString', {
	    value: Symbol.prototype.toString,
	    enumerable: false
	  });
	  $defineProperty(SymbolValue.prototype, 'valueOf', {
	    value: Symbol.prototype.valueOf,
	    enumerable: false
	  });
	  var hashProperty = createPrivateName();
	  var hashPropertyDescriptor = {value: undefined};
	  var hashObjectProperties = {
	    hash: {value: undefined},
	    self: {value: undefined}
	  };
	  var hashCounter = 0;
	  function getOwnHashObject(object) {
	    var hashObject = object[hashProperty];
	    if (hashObject && hashObject.self === object)
	      return hashObject;
	    if ($isExtensible(object)) {
	      hashObjectProperties.hash.value = hashCounter++;
	      hashObjectProperties.self.value = object;
	      hashPropertyDescriptor.value = $create(null, hashObjectProperties);
	      $defineProperty(object, hashProperty, hashPropertyDescriptor);
	      return hashPropertyDescriptor.value;
	    }
	    return undefined;
	  }
	  function freeze(object) {
	    getOwnHashObject(object);
	    return $freeze.apply(this, arguments);
	  }
	  freeze(SymbolValue.prototype);
	  function isSymbolString(s) {
	    return symbolValues[s] || privateNames[s];
	  }
	  function toProperty(name) {
	    if (isShimSymbol(name))
	      return name[symbolInternalProperty];
	    return name;
	  }
	  function getOwnPropertySymbols(object) {
	    var rv = [];
	    var names = $getOwnPropertyNames(object);
	    for (var i = 0; i < names.length; i++) {
	      var symbol = symbolValues[names[i]];
	      if (symbol) {
	        rv.push(symbol);
	      }
	    }
	    return rv;
	  }
	  function getOption(name) {
	    return global.traceur && global.traceur.options[name];
	  }
	  function exportStar(object) {
	    for (var i = 1; i < arguments.length; i++) {
	      var names = $getOwnPropertyNames(arguments[i]);
	      for (var j = 0; j < names.length; j++) {
	        var name = names[j];
	        if (isSymbolString(name))
	          continue;
	        (function(mod, name) {
	          $defineProperty(object, name, {
	            get: function() {
	              return mod[name];
	            },
	            enumerable: true
	          });
	        })(arguments[i], names[j]);
	      }
	    }
	    return object;
	  }
	  function isObject(x) {
	    return x != null && (typeof x === 'object' || typeof x === 'function');
	  }
	  function toObject(x) {
	    if (x == null)
	      throw $TypeError();
	    return $Object(x);
	  }
	  function checkObjectCoercible(argument) {
	    if (argument == null) {
	      throw new TypeError('Value cannot be converted to an Object');
	    }
	    return argument;
	  }
	  function polyfillSymbol(global, Symbol) {
	    if (!global.Symbol) {
	      global.Symbol = Symbol;
	      Object.getOwnPropertySymbols = getOwnPropertySymbols;
	    }
	    if (!global.Symbol.iterator) {
	      global.Symbol.iterator = Symbol('Symbol.iterator');
	    }
	  }
	  function setupGlobals(global) {
	    polyfillSymbol(global, Symbol);
	    global.Reflect = global.Reflect || {};
	    global.Reflect.global = global.Reflect.global || global;
	  }
	  setupGlobals(global);
	  global.$traceurRuntime = {
	    checkObjectCoercible: checkObjectCoercible,
	    createPrivateName: createPrivateName,
	    defineProperties: $defineProperties,
	    defineProperty: $defineProperty,
	    exportStar: exportStar,
	    getOwnHashObject: getOwnHashObject,
	    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	    getOwnPropertyNames: $getOwnPropertyNames,
	    isObject: isObject,
	    isPrivateName: isPrivateName,
	    isSymbolString: isSymbolString,
	    keys: $keys,
	    setupGlobals: setupGlobals,
	    toObject: toObject,
	    toProperty: toProperty,
	    typeof: typeOf
	  };
	})(window);
	(function() {
	  'use strict';
	  var $toProperty = $traceurRuntime.toProperty;

	  function spread() {
	    var rv = [],
	      j = 0,
	      iterResult;
	    for (var i = 0; i < arguments.length; i++) {
	      var valueToSpread = $traceurRuntime.checkObjectCoercible(arguments[i]);

	      if (typeof valueToSpread[$toProperty(Symbol.iterator)] !== 'function') {
	        valueToSpread[$toProperty(Symbol.iterator)] = function() {
	          var value = this;
	          var length = value.length;
	          var index = 0;

	          return {
	            next: function() {
	              var result = {done: true};

	              if (index < length) {
	                result.done = false;
	                result.value = value[index];
	                ++index;
	              }

	              return result;
	            }
	          }
	        };
	      }
	      var iter = valueToSpread[$toProperty(Symbol.iterator)]();

	      while (!(iterResult = iter.next()).done) {
	        rv[j++] = iterResult.value;
	      }
	    }
	    return rv;
	  }
	  $traceurRuntime.spread = spread;
	})();
	(function() {
	  'use strict';
	  var $Object = Object;
	  var $TypeError = TypeError;
	  var $create = $Object.create;
	  var $defineProperties = $traceurRuntime.defineProperties;
	  var $defineProperty = $traceurRuntime.defineProperty;
	  var $getOwnPropertyDescriptor = $traceurRuntime.getOwnPropertyDescriptor;
	  var $getPrototypeOf = Object.getPrototypeOf;
	  var $toProperty = $traceurRuntime.toProperty;
	  var $__0 = Object,
	    getOwnPropertyNames = $__0.getOwnPropertyNames,
	    getOwnPropertySymbols = $__0.getOwnPropertySymbols;
	  function superDescriptor(homeObject, name) {
	    var proto = $getPrototypeOf(homeObject);
	    do {
	      var result = $getOwnPropertyDescriptor(proto, name);
	      if (result)
	        return result;
	      proto = $getPrototypeOf(proto);
	    } while (proto);
	    return undefined;
	  }
	  function superConstructor(ctor) {
	    return ctor.__proto__;
	  }
	  function superCall(self, homeObject, name, args) {
	    return superGet(self, homeObject, name).apply(self, args);
	  }
	  function superGet(self, homeObject, name) {
	    var descriptor = superDescriptor(homeObject, name);
	    if (descriptor) {
	      if (!descriptor.get)
	        return descriptor.value;
	      return descriptor.get.call(self);
	    }
	    return undefined;
	  }
	  function superSet(self, homeObject, name, value) {
	    var descriptor = superDescriptor(homeObject, name);
	    if (descriptor && descriptor.set) {
	      descriptor.set.call(self, value);
	      return value;
	    }
	    throw $TypeError(("super has no setter '" + name + "'."));
	  }
	  function getDescriptors(object) {
	    var descriptors = {};
	    var names = getOwnPropertyNames(object);
	    for (var i = 0; i < names.length; i++) {
	      var name = names[i];
	      descriptors[name] = $getOwnPropertyDescriptor(object, name);
	    }
	    var symbols = getOwnPropertySymbols(object);
	    for (var i = 0; i < symbols.length; i++) {
	      var symbol = symbols[i];
	      descriptors[$toProperty(symbol)] = $getOwnPropertyDescriptor(object, $toProperty(symbol));
	    }
	    return descriptors;
	  }
	  function createClass(ctor, object, staticObject, superClass) {
	    $defineProperty(object, 'constructor', {
	      value: ctor,
	      configurable: true,
	      enumerable: false,
	      writable: true
	    });
	    if (arguments.length > 3) {
	      if (typeof superClass === 'function')
	        ctor.__proto__ = superClass;
	      ctor.prototype = $create(getProtoParent(superClass), getDescriptors(object));
	    } else {
	      ctor.prototype = object;
	    }
	    $defineProperty(ctor, 'prototype', {
	      configurable: false,
	      writable: false
	    });
	    return $defineProperties(ctor, getDescriptors(staticObject));
	  }
	  function getProtoParent(superClass) {
	    if (typeof superClass === 'function') {
	      var prototype = superClass.prototype;
	      if ($Object(prototype) === prototype || prototype === null)
	        return superClass.prototype;
	      throw new $TypeError('super prototype must be an Object or null');
	    }
	    if (superClass === null)
	      return null;
	    throw new $TypeError(("Super expression must either be null or a function, not " + typeof superClass + "."));
	  }
	  function defaultSuperCall(self, homeObject, args) {
	    if ($getPrototypeOf(homeObject) !== null)
	      superCall(self, homeObject, 'constructor', args);
	  }
	  $traceurRuntime.createClass = createClass;
	  $traceurRuntime.defaultSuperCall = defaultSuperCall;
	  $traceurRuntime.superCall = superCall;
	  $traceurRuntime.superConstructor = superConstructor;
	  $traceurRuntime.superGet = superGet;
	  $traceurRuntime.superSet = superSet;
	})();
	/* jshint ignore:end */

	},{}],101:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  TableView: {get: function() {
	      return TableView;
	    }},
	  __esModule: {value: true}
	});
	var $__browser__,
	    $__helpers_47_dom_47_element__,
	    $__helpers_47_object__,
	    $__eventManager__,
	    $__helpers_47_dom_47_event__,
	    $__3rdparty_47_walkontable_47_src_47_cell_47_coords__,
	    $__3rdparty_47_walkontable_47_src_47_selection__,
	    $__3rdparty_47_walkontable_47_src_47_core__;
	var Handsontable = ($__browser__ = _dereq_("browser"), $__browser__ && $__browser__.__esModule && $__browser__ || {default: $__browser__}).default;
	var $__1 = ($__helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $__helpers_47_dom_47_element__ && $__helpers_47_dom_47_element__.__esModule && $__helpers_47_dom_47_element__ || {default: $__helpers_47_dom_47_element__}),
	    addClass = $__1.addClass,
	    empty = $__1.empty,
	    fastInnerHTML = $__1.fastInnerHTML,
	    fastInnerText = $__1.fastInnerText,
	    getScrollbarWidth = $__1.getScrollbarWidth,
	    hasClass = $__1.hasClass,
	    isChildOf = $__1.isChildOf,
	    isInput = $__1.isInput,
	    isOutsideInput = $__1.isOutsideInput,
	    closest = $__1.closest;
	var clone = ($__helpers_47_object__ = _dereq_("helpers/object"), $__helpers_47_object__ && $__helpers_47_object__.__esModule && $__helpers_47_object__ || {default: $__helpers_47_object__}).clone;
	var eventManagerObject = ($__eventManager__ = _dereq_("eventManager"), $__eventManager__ && $__eventManager__.__esModule && $__eventManager__ || {default: $__eventManager__}).eventManager;
	var $__4 = ($__helpers_47_dom_47_event__ = _dereq_("helpers/dom/event"), $__helpers_47_dom_47_event__ && $__helpers_47_dom_47_event__.__esModule && $__helpers_47_dom_47_event__ || {default: $__helpers_47_dom_47_event__}),
	    stopPropagation = $__4.stopPropagation,
	    isImmediatePropagationStopped = $__4.isImmediatePropagationStopped;
	var WalkontableCellCoords = ($__3rdparty_47_walkontable_47_src_47_cell_47_coords__ = _dereq_("3rdparty/walkontable/src/cell/coords"), $__3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $__3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $__3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $__3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	var WalkontableSelection = ($__3rdparty_47_walkontable_47_src_47_selection__ = _dereq_("3rdparty/walkontable/src/selection"), $__3rdparty_47_walkontable_47_src_47_selection__ && $__3rdparty_47_walkontable_47_src_47_selection__.__esModule && $__3rdparty_47_walkontable_47_src_47_selection__ || {default: $__3rdparty_47_walkontable_47_src_47_selection__}).WalkontableSelection;
	var Walkontable = ($__3rdparty_47_walkontable_47_src_47_core__ = _dereq_("3rdparty/walkontable/src/core"), $__3rdparty_47_walkontable_47_src_47_core__ && $__3rdparty_47_walkontable_47_src_47_core__.__esModule && $__3rdparty_47_walkontable_47_src_47_core__ || {default: $__3rdparty_47_walkontable_47_src_47_core__}).Walkontable;
	Handsontable.TableView = TableView;
	function TableView(instance) {
	  var $__8 = this;
	  var that = this;
	  this.eventManager = eventManagerObject(instance);
	  this.instance = instance;
	  this.settings = instance.getSettings();
	  this.selectionMouseDown = false;
	  var originalStyle = instance.rootElement.getAttribute('style');
	  if (originalStyle) {
	    instance.rootElement.setAttribute('data-originalstyle', originalStyle);
	  }
	  addClass(instance.rootElement, 'handsontable');
	  var table = document.createElement('TABLE');
	  addClass(table, 'htCore');
	  if (instance.getSettings().tableClassName) {
	    addClass(table, instance.getSettings().tableClassName);
	  }
	  this.THEAD = document.createElement('THEAD');
	  table.appendChild(this.THEAD);
	  this.TBODY = document.createElement('TBODY');
	  table.appendChild(this.TBODY);
	  instance.table = table;
	  instance.container.insertBefore(table, instance.container.firstChild);
	  this.eventManager.addEventListener(instance.rootElement, 'mousedown', function(event) {
	    this.selectionMouseDown = true;
	    if (!that.isTextSelectionAllowed(event.target)) {
	      clearTextSelection();
	      event.preventDefault();
	      window.focus();
	    }
	  });
	  this.eventManager.addEventListener(instance.rootElement, 'mouseup', function(event) {
	    this.selectionMouseDown = false;
	  });
	  this.eventManager.addEventListener(instance.rootElement, 'mousemove', function(event) {
	    if (this.selectionMouseDown && !that.isTextSelectionAllowed(event.target)) {
	      clearTextSelection();
	      event.preventDefault();
	    }
	  });
	  this.eventManager.addEventListener(document.documentElement, 'keyup', function(event) {
	    if (instance.selection.isInProgress() && !event.shiftKey) {
	      instance.selection.finish();
	    }
	  });
	  var isMouseDown;
	  this.isMouseDown = function() {
	    return isMouseDown;
	  };
	  this.eventManager.addEventListener(document.documentElement, 'mouseup', function(event) {
	    if (instance.selection.isInProgress() && event.which === 1) {
	      instance.selection.finish();
	    }
	    isMouseDown = false;
	    if (isOutsideInput(document.activeElement)) {
	      instance.unlisten();
	    }
	  });
	  this.eventManager.addEventListener(document.documentElement, 'mousedown', function(event) {
	    var next = event.target;
	    var eventX = event.x || event.clientX;
	    var eventY = event.y || event.clientY;
	    if (isMouseDown || !instance.rootElement) {
	      return;
	    }
	    if (next === instance.view.wt.wtTable.holder) {
	      var scrollbarWidth = getScrollbarWidth();
	      if (document.elementFromPoint(eventX + scrollbarWidth, eventY) !== instance.view.wt.wtTable.holder || document.elementFromPoint(eventX, eventY + scrollbarWidth) !== instance.view.wt.wtTable.holder) {
	        return;
	      }
	    } else {
	      while (next !== document.documentElement) {
	        if (next === null) {
	          if (event.isTargetWebComponent) {
	            break;
	          }
	          return;
	        }
	        if (next === instance.rootElement) {
	          return;
	        }
	        next = next.parentNode;
	      }
	    }
	    if (that.settings.outsideClickDeselects) {
	      instance.deselectCell();
	    } else {
	      instance.destroyEditor();
	    }
	  });
	  this.eventManager.addEventListener(table, 'selectstart', function(event) {
	    if (that.settings.fragmentSelection || isInput(event.target)) {
	      return;
	    }
	    event.preventDefault();
	  });
	  var clearTextSelection = function() {
	    if (window.getSelection) {
	      if (window.getSelection().empty) {
	        window.getSelection().empty();
	      } else if (window.getSelection().removeAllRanges) {
	        window.getSelection().removeAllRanges();
	      }
	    } else if (document.selection) {
	      document.selection.empty();
	    }
	  };
	  var selections = [new WalkontableSelection({
	    className: 'current',
	    border: {
	      width: 2,
	      color: '#5292F7',
	      cornerVisible: function() {
	        return that.settings.fillHandle && !that.isCellEdited() && !instance.selection.isMultiple();
	      },
	      multipleSelectionHandlesVisible: function() {
	        return !that.isCellEdited() && !instance.selection.isMultiple();
	      }
	    }
	  }), new WalkontableSelection({
	    className: 'area',
	    border: {
	      width: 1,
	      color: '#89AFF9',
	      cornerVisible: function() {
	        return that.settings.fillHandle && !that.isCellEdited() && instance.selection.isMultiple();
	      },
	      multipleSelectionHandlesVisible: function() {
	        return !that.isCellEdited() && instance.selection.isMultiple();
	      }
	    }
	  }), new WalkontableSelection({
	    className: 'highlight',
	    highlightRowClassName: that.settings.currentRowClassName,
	    highlightColumnClassName: that.settings.currentColClassName
	  }), new WalkontableSelection({
	    className: 'fill',
	    border: {
	      width: 1,
	      color: 'red'
	    }
	  })];
	  selections.current = selections[0];
	  selections.area = selections[1];
	  selections.highlight = selections[2];
	  selections.fill = selections[3];
	  var walkontableConfig = {
	    debug: function() {
	      return that.settings.debug;
	    },
	    externalRowCalculator: this.instance.getPlugin('autoRowSize') && this.instance.getPlugin('autoRowSize').isEnabled(),
	    table: table,
	    preventOverflow: (function() {
	      return $__8.settings.preventOverflow;
	    }),
	    stretchH: function() {
	      return that.settings.stretchH;
	    },
	    data: instance.getDataAtCell,
	    totalRows: (function() {
	      return instance.countRows();
	    }),
	    totalColumns: (function() {
	      return instance.countCols();
	    }),
	    fixedColumnsLeft: function() {
	      return that.settings.fixedColumnsLeft;
	    },
	    fixedRowsTop: function() {
	      return that.settings.fixedRowsTop;
	    },
	    fixedRowsBottom: function() {
	      return that.settings.fixedRowsBottom;
	    },
	    minSpareRows: function() {
	      return that.settings.minSpareRows;
	    },
	    renderAllRows: that.settings.renderAllRows,
	    rowHeaders: function() {
	      var headerRenderers = [];
	      if (instance.hasRowHeaders()) {
	        headerRenderers.push(function(row, TH) {
	          that.appendRowHeader(row, TH);
	        });
	      }
	      Handsontable.hooks.run(instance, 'afterGetRowHeaderRenderers', headerRenderers);
	      return headerRenderers;
	    },
	    columnHeaders: function() {
	      var headerRenderers = [];
	      if (instance.hasColHeaders()) {
	        headerRenderers.push(function(column, TH) {
	          that.appendColHeader(column, TH);
	        });
	      }
	      Handsontable.hooks.run(instance, 'afterGetColumnHeaderRenderers', headerRenderers);
	      return headerRenderers;
	    },
	    columnWidth: instance.getColWidth,
	    rowHeight: instance.getRowHeight,
	    cellRenderer: function(row, col, TD) {
	      var cellProperties = that.instance.getCellMeta(row, col);
	      var prop = that.instance.colToProp(col);
	      var value = that.instance.getDataAtRowProp(row, prop);
	      Handsontable.hooks.run(that.instance, 'beforeRenderer', TD, row, col, prop, value, cellProperties);
	      that.instance.getCellRenderer(cellProperties)(that.instance, TD, row, col, prop, value, cellProperties);
	      Handsontable.hooks.run(that.instance, 'afterRenderer', TD, row, col, prop, value, cellProperties);
	    },
	    selections: selections,
	    hideBorderOnMouseDownOver: function() {
	      return that.settings.fragmentSelection;
	    },
	    onCellMouseDown: function(event, coords, TD, wt) {
	      instance.listen();
	      that.activeWt = wt;
	      isMouseDown = true;
	      Handsontable.hooks.run(instance, 'beforeOnCellMouseDown', event, coords, TD);
	      if (!isImmediatePropagationStopped(event)) {
	        if (event.shiftKey) {
	          if (coords.row >= 0 && coords.col >= 0) {
	            instance.selection.setRangeEnd(coords);
	          }
	          if (instance.selection.selectedHeader.cols && coords.col >= 0) {
	            instance.selection.setRangeEnd(new WalkontableCellCoords(instance.countRows() - 1, coords.col));
	          }
	          if (instance.selection.selectedHeader.rows && coords.row >= 0) {
	            instance.selection.setRangeEnd(new WalkontableCellCoords(coords.row, instance.countCols() - 1));
	          }
	        } else {
	          if (event.button === 0 || (event.button === 2 && !instance.selection.inInSelection(coords))) {
	            if ((coords.row < 0 || coords.col < 0) && (coords.row >= 0 || coords.col >= 0)) {
	              if (coords.row < 0) {
	                instance.selection.setSelectedHeaders(false, true);
	                instance.selectCell(0, coords.col, instance.countRows() - 1, coords.col);
	              }
	              if (coords.col < 0) {
	                instance.selection.setSelectedHeaders(true, false);
	                instance.selectCell(coords.row, 0, coords.row, instance.countCols() - 1);
	              }
	            } else {
	              coords.row = coords.row < 0 ? 0 : coords.row;
	              coords.col = coords.col < 0 ? 0 : coords.col;
	              instance.selection.setSelectedHeaders(false, false);
	              instance.selection.setRangeStart(coords);
	            }
	          }
	        }
	        Handsontable.hooks.run(instance, 'afterOnCellMouseDown', event, coords, TD);
	        that.activeWt = that.wt;
	      }
	    },
	    onCellMouseOver: function(event, coords, TD, wt) {
	      var blockCalculations = {
	        row: false,
	        column: false
	      };
	      that.activeWt = wt;
	      Handsontable.hooks.run(instance, 'beforeOnCellMouseOver', event, coords, TD, blockCalculations);
	      if (event.button === 0) {
	        if (coords.row >= 0 && coords.col >= 0) {
	          if (isMouseDown) {
	            instance.selection.setRangeEnd(coords);
	          }
	        } else {
	          if (isMouseDown) {
	            if (coords.row < 0 && !blockCalculations.column) {
	              if (instance.selection.selectedHeader.cols) {
	                instance.selection.setRangeEnd(new WalkontableCellCoords(instance.countRows() - 1, coords.col));
	                instance.selection.setSelectedHeaders(false, true);
	              } else {
	                instance.selection.setRangeEnd(new WalkontableCellCoords(coords.row, coords.col));
	              }
	            }
	            if (coords.col < 0 && !blockCalculations.row) {
	              if (instance.selection.selectedHeader.rows) {
	                instance.selection.setRangeEnd(new WalkontableCellCoords(coords.row, instance.countCols() - 1));
	                instance.selection.setSelectedHeaders(true, false);
	              } else {
	                instance.selection.setRangeEnd(new WalkontableCellCoords(coords.row, coords.col));
	              }
	            }
	          }
	        }
	      }
	      Handsontable.hooks.run(instance, 'afterOnCellMouseOver', event, coords, TD);
	      that.activeWt = that.wt;
	    },
	    onCellCornerMouseDown: function(event) {
	      event.preventDefault();
	      Handsontable.hooks.run(instance, 'afterOnCellCornerMouseDown', event);
	    },
	    beforeDraw: function(force) {
	      that.beforeRender(force);
	    },
	    onDraw: function(force) {
	      that.onDraw(force);
	    },
	    onScrollVertically: function() {
	      instance.runHooks('afterScrollVertically');
	    },
	    onScrollHorizontally: function() {
	      instance.runHooks('afterScrollHorizontally');
	    },
	    onBeforeDrawBorders: function(corners, borderClassName) {
	      instance.runHooks('beforeDrawBorders', corners, borderClassName);
	    },
	    onBeforeTouchScroll: function() {
	      instance.runHooks('beforeTouchScroll');
	    },
	    onAfterMomentumScroll: function() {
	      instance.runHooks('afterMomentumScroll');
	    },
	    onBeforeStretchingColumnWidth: function(stretchedWidth, column) {
	      return instance.runHooks('beforeStretchingColumnWidth', stretchedWidth, column);
	    },
	    viewportRowCalculatorOverride: function(calc) {
	      var rows = instance.countRows();
	      var viewportOffset = that.settings.viewportRowRenderingOffset;
	      if (viewportOffset === 'auto' && that.settings.fixedRowsTop) {
	        viewportOffset = 10;
	      }
	      if (typeof viewportOffset === 'number') {
	        calc.startRow = Math.max(calc.startRow - viewportOffset, 0);
	        calc.endRow = Math.min(calc.endRow + viewportOffset, rows - 1);
	      }
	      if (viewportOffset === 'auto') {
	        var center = calc.startRow + calc.endRow - calc.startRow;
	        var offset = Math.ceil(center / rows * 12);
	        calc.startRow = Math.max(calc.startRow - offset, 0);
	        calc.endRow = Math.min(calc.endRow + offset, rows - 1);
	      }
	      instance.runHooks('afterViewportRowCalculatorOverride', calc);
	    },
	    viewportColumnCalculatorOverride: function(calc) {
	      var cols = instance.countCols();
	      var viewportOffset = that.settings.viewportColumnRenderingOffset;
	      if (viewportOffset === 'auto' && that.settings.fixedColumnsLeft) {
	        viewportOffset = 10;
	      }
	      if (typeof viewportOffset === 'number') {
	        calc.startColumn = Math.max(calc.startColumn - viewportOffset, 0);
	        calc.endColumn = Math.min(calc.endColumn + viewportOffset, cols - 1);
	      }
	      if (viewportOffset === 'auto') {
	        var center = calc.startColumn + calc.endColumn - calc.startColumn;
	        var offset = Math.ceil(center / cols * 12);
	        calc.startRow = Math.max(calc.startColumn - offset, 0);
	        calc.endColumn = Math.min(calc.endColumn + offset, cols - 1);
	      }
	      instance.runHooks('afterViewportColumnCalculatorOverride', calc);
	    },
	    rowHeaderWidth: function() {
	      return that.settings.rowHeaderWidth;
	    },
	    columnHeaderHeight: function() {
	      var columnHeaderHeight = instance.runHooks('modifyColumnHeaderHeight');
	      return that.settings.columnHeaderHeight || columnHeaderHeight;
	    }
	  };
	  Handsontable.hooks.run(instance, 'beforeInitWalkontable', walkontableConfig);
	  this.wt = new Walkontable(walkontableConfig);
	  this.activeWt = this.wt;
	  this.eventManager.addEventListener(that.wt.wtTable.spreader, 'mousedown', function(event) {
	    if (event.target === that.wt.wtTable.spreader && event.which === 3) {
	      stopPropagation(event);
	    }
	  });
	  this.eventManager.addEventListener(that.wt.wtTable.spreader, 'contextmenu', function(event) {
	    if (event.target === that.wt.wtTable.spreader && event.which === 3) {
	      stopPropagation(event);
	    }
	  });
	  this.eventManager.addEventListener(document.documentElement, 'click', function() {
	    if (that.settings.observeDOMVisibility) {
	      if (that.wt.drawInterrupted) {
	        that.instance.forceFullRender = true;
	        that.render();
	      }
	    }
	  });
	}
	TableView.prototype.isTextSelectionAllowed = function(el) {
	  if (isInput(el)) {
	    return true;
	  }
	  var isChildOfTableBody = isChildOf(el, this.instance.view.wt.wtTable.spreader);
	  if (this.settings.fragmentSelection === true && isChildOfTableBody) {
	    return true;
	  }
	  if (this.settings.fragmentSelection === 'cell' && this.isSelectedOnlyCell() && isChildOfTableBody) {
	    return true;
	  }
	  if (!this.settings.fragmentSelection && this.isCellEdited() && this.isSelectedOnlyCell()) {
	    return true;
	  }
	  return false;
	};
	TableView.prototype.isSelectedOnlyCell = function() {
	  var $__9 = this.instance.getSelected() || [],
	      row = $__9[0],
	      col = $__9[1],
	      rowEnd = $__9[2],
	      colEnd = $__9[3];
	  return row !== void 0 && row === rowEnd && col === colEnd;
	};
	TableView.prototype.isCellEdited = function() {
	  var activeEditor = this.instance.getActiveEditor();
	  return activeEditor && activeEditor.isOpened();
	};
	TableView.prototype.beforeRender = function(force) {
	  if (force) {
	    Handsontable.hooks.run(this.instance, 'beforeRender', this.instance.forceFullRender);
	  }
	};
	TableView.prototype.onDraw = function(force) {
	  if (force) {
	    Handsontable.hooks.run(this.instance, 'afterRender', this.instance.forceFullRender);
	  }
	};
	TableView.prototype.render = function() {
	  this.wt.draw(!this.instance.forceFullRender);
	  this.instance.forceFullRender = false;
	  this.instance.renderCall = false;
	};
	TableView.prototype.getCellAtCoords = function(coords, topmost) {
	  var td = this.wt.getCell(coords, topmost);
	  if (td < 0) {
	    return null;
	  } else {
	    return td;
	  }
	};
	TableView.prototype.scrollViewport = function(coords) {
	  this.wt.scrollViewport(coords);
	};
	TableView.prototype.appendRowHeader = function(row, TH) {
	  if (TH.firstChild) {
	    var container = TH.firstChild;
	    if (!hasClass(container, 'relative')) {
	      empty(TH);
	      this.appendRowHeader(row, TH);
	      return;
	    }
	    this.updateCellHeader(container.querySelector('.rowHeader'), row, this.instance.getRowHeader);
	  } else {
	    var div = document.createElement('div');
	    var span = document.createElement('span');
	    div.className = 'relative';
	    span.className = 'rowHeader';
	    this.updateCellHeader(span, row, this.instance.getRowHeader);
	    div.appendChild(span);
	    TH.appendChild(div);
	  }
	  Handsontable.hooks.run(this.instance, 'afterGetRowHeader', row, TH);
	};
	TableView.prototype.appendColHeader = function(col, TH) {
	  if (TH.firstChild) {
	    var container = TH.firstChild;
	    if (hasClass(container, 'relative')) {
	      this.updateCellHeader(container.querySelector('.colHeader'), col, this.instance.getColHeader);
	    } else {
	      empty(TH);
	      this.appendColHeader(col, TH);
	    }
	  } else {
	    var div = document.createElement('div');
	    var span = document.createElement('span');
	    div.className = 'relative';
	    span.className = 'colHeader';
	    this.updateCellHeader(span, col, this.instance.getColHeader);
	    div.appendChild(span);
	    TH.appendChild(div);
	  }
	  Handsontable.hooks.run(this.instance, 'afterGetColHeader', col, TH);
	};
	TableView.prototype.updateCellHeader = function(element, index, content) {
	  var renderedIndex = index;
	  var parentOverlay = this.wt.wtOverlays.getParentOverlay(element) || this.wt;
	  if (element.parentNode) {
	    if (hasClass(element, 'colHeader')) {
	      renderedIndex = parentOverlay.wtTable.columnFilter.sourceToRendered(index);
	    } else if (hasClass(element, 'rowHeader')) {
	      renderedIndex = parentOverlay.wtTable.rowFilter.sourceToRendered(index);
	    }
	  }
	  if (renderedIndex > -1) {
	    fastInnerHTML(element, content(index));
	  } else {
	    fastInnerText(element, String.fromCharCode(160));
	    addClass(element, 'cornerHeader');
	  }
	};
	TableView.prototype.maximumVisibleElementWidth = function(leftOffset) {
	  var workspaceWidth = this.wt.wtViewport.getWorkspaceWidth();
	  var maxWidth = workspaceWidth - leftOffset;
	  return maxWidth > 0 ? maxWidth : 0;
	};
	TableView.prototype.maximumVisibleElementHeight = function(topOffset) {
	  var workspaceHeight = this.wt.wtViewport.getWorkspaceHeight();
	  var maxHeight = workspaceHeight - topOffset;
	  return maxHeight > 0 ? maxHeight : 0;
	};
	TableView.prototype.mainViewIsActive = function() {
	  return this.wt === this.activeWt;
	};
	TableView.prototype.destroy = function() {
	  this.wt.destroy();
	  this.eventManager.destroy();
	};
	;

	//# 
	},{"3rdparty/walkontable/src/cell/coords":5,"3rdparty/walkontable/src/core":7,"3rdparty/walkontable/src/selection":18,"browser":23,"eventManager":41,"helpers/dom/element":46,"helpers/dom/event":47,"helpers/object":52}],102:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  GhostTable: {get: function() {
	      return GhostTable;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_helpers_47_array__,
	    $___46__46__47_helpers_47_object__,
	    $___46__46__47_helpers_47_number__,
	    $___46__46__47_helpers_47_mixed__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var $__1 = ($___46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__1.addClass,
	    outerHeight = $__1.outerHeight,
	    outerWidth = $__1.outerWidth;
	var arrayEach = ($___46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47_helpers_47_array__ && $___46__46__47_helpers_47_array__.__esModule && $___46__46__47_helpers_47_array__ || {default: $___46__46__47_helpers_47_array__}).arrayEach;
	var objectEach = ($___46__46__47_helpers_47_object__ = _dereq_("helpers/object"), $___46__46__47_helpers_47_object__ && $___46__46__47_helpers_47_object__.__esModule && $___46__46__47_helpers_47_object__ || {default: $___46__46__47_helpers_47_object__}).objectEach;
	var rangeEach = ($___46__46__47_helpers_47_number__ = _dereq_("helpers/number"), $___46__46__47_helpers_47_number__ && $___46__46__47_helpers_47_number__.__esModule && $___46__46__47_helpers_47_number__ || {default: $___46__46__47_helpers_47_number__}).rangeEach;
	var stringify = ($___46__46__47_helpers_47_mixed__ = _dereq_("helpers/mixed"), $___46__46__47_helpers_47_mixed__ && $___46__46__47_helpers_47_mixed__.__esModule && $___46__46__47_helpers_47_mixed__ || {default: $___46__46__47_helpers_47_mixed__}).stringify;
	var GhostTable = function GhostTable(hotInstance) {
	  this.hot = hotInstance;
	  this.container = null;
	  this.injected = false;
	  this.rows = [];
	  this.columns = [];
	  this.samples = null;
	  this.settings = {useHeaders: true};
	};
	($traceurRuntime.createClass)(GhostTable, {
	  addRow: function(row, samples) {
	    if (this.columns.length) {
	      throw new Error('Doesn\'t support multi-dimensional table');
	    }
	    if (!this.rows.length) {
	      this.container = this.createContainer(this.hot.rootElement.className);
	    }
	    var rowObject = {row: row};
	    this.rows.push(rowObject);
	    this.samples = samples;
	    this.table = this.createTable(this.hot.table.className);
	    this.table.colGroup.appendChild(this.createColGroupsCol());
	    this.table.tr.appendChild(this.createRow(row));
	    this.container.container.appendChild(this.table.fragment);
	    rowObject.table = this.table.table;
	  },
	  addColumnHeadersRow: function(samples) {
	    if (this.hot.getColHeader(0) != null) {
	      var rowObject = {row: -1};
	      this.rows.push(rowObject);
	      this.container = this.createContainer(this.hot.rootElement.className);
	      this.samples = samples;
	      this.table = this.createTable(this.hot.table.className);
	      this.table.colGroup.appendChild(this.createColGroupsCol());
	      this.table.tHead.appendChild(this.createColumnHeadersRow());
	      this.container.container.appendChild(this.table.fragment);
	      rowObject.table = this.table.table;
	    }
	  },
	  addColumn: function(column, samples) {
	    if (this.rows.length) {
	      throw new Error('Doesn\'t support multi-dimensional table');
	    }
	    if (!this.columns.length) {
	      this.container = this.createContainer(this.hot.rootElement.className);
	    }
	    var columnObject = {col: column};
	    this.columns.push(columnObject);
	    this.samples = samples;
	    this.table = this.createTable(this.hot.table.className);
	    if (this.getSetting('useHeaders') && this.hot.getColHeader(column) !== null) {
	      this.hot.view.appendColHeader(column, this.table.th);
	    }
	    this.table.tBody.appendChild(this.createCol(column));
	    this.container.container.appendChild(this.table.fragment);
	    columnObject.table = this.table.table;
	  },
	  getHeights: function(callback) {
	    if (!this.injected) {
	      this.injectTable();
	    }
	    arrayEach(this.rows, (function(row) {
	      callback(row.row, outerHeight(row.table) - 1);
	    }));
	  },
	  getWidths: function(callback) {
	    if (!this.injected) {
	      this.injectTable();
	    }
	    arrayEach(this.columns, (function(column) {
	      callback(column.col, outerWidth(column.table));
	    }));
	  },
	  setSettings: function(settings) {
	    this.settings = settings;
	  },
	  setSetting: function(name, value) {
	    if (!this.settings) {
	      this.settings = {};
	    }
	    this.settings[name] = value;
	  },
	  getSettings: function() {
	    return this.settings;
	  },
	  getSetting: function(name) {
	    if (this.settings) {
	      return this.settings[name];
	    } else {
	      return null;
	    }
	  },
	  createColGroupsCol: function() {
	    var $__6 = this;
	    var d = document;
	    var fragment = d.createDocumentFragment();
	    if (this.hot.hasRowHeaders()) {
	      fragment.appendChild(this.createColElement(-1));
	    }
	    this.samples.forEach((function(sample) {
	      arrayEach(sample.strings, (function(string) {
	        fragment.appendChild($__6.createColElement(string.col));
	      }));
	    }));
	    return fragment;
	  },
	  createRow: function(row) {
	    var $__6 = this;
	    var d = document;
	    var fragment = d.createDocumentFragment();
	    var th = d.createElement('th');
	    if (this.hot.hasRowHeaders()) {
	      this.hot.view.appendRowHeader(row, th);
	      fragment.appendChild(th);
	    }
	    this.samples.forEach((function(sample) {
	      arrayEach(sample.strings, (function(string) {
	        var column = string.col;
	        var cellProperties = $__6.hot.getCellMeta(row, column);
	        cellProperties.col = column;
	        cellProperties.row = row;
	        var renderer = $__6.hot.getCellRenderer(cellProperties);
	        var td = d.createElement('td');
	        renderer($__6.hot, td, row, column, $__6.hot.colToProp(column), string.value, cellProperties);
	        fragment.appendChild(td);
	      }));
	    }));
	    return fragment;
	  },
	  createColumnHeadersRow: function() {
	    var $__6 = this;
	    var d = document;
	    var fragment = d.createDocumentFragment();
	    if (this.hot.hasRowHeaders()) {
	      var th = d.createElement('th');
	      this.hot.view.appendColHeader(-1, th);
	      fragment.appendChild(th);
	    }
	    this.samples.forEach((function(sample) {
	      arrayEach(sample.strings, (function(string) {
	        var column = string.col;
	        var th = d.createElement('th');
	        $__6.hot.view.appendColHeader(column, th);
	        fragment.appendChild(th);
	      }));
	    }));
	    return fragment;
	  },
	  createCol: function(column) {
	    var $__6 = this;
	    var d = document;
	    var fragment = d.createDocumentFragment();
	    this.samples.forEach((function(sample) {
	      arrayEach(sample.strings, (function(string) {
	        var row = string.row;
	        var cellProperties = $__6.hot.getCellMeta(row, column);
	        cellProperties.col = column;
	        cellProperties.row = row;
	        var renderer = $__6.hot.getCellRenderer(cellProperties);
	        var td = d.createElement('td');
	        var tr = d.createElement('tr');
	        renderer($__6.hot, td, row, column, $__6.hot.colToProp(column), string.value, cellProperties);
	        tr.appendChild(td);
	        fragment.appendChild(tr);
	      }));
	    }));
	    return fragment;
	  },
	  clean: function() {
	    this.rows.length = 0;
	    this.rows[-1] = void 0;
	    this.columns.length = 0;
	    if (this.samples) {
	      this.samples.clear();
	    }
	    this.samples = null;
	    this.removeTable();
	  },
	  injectTable: function() {
	    var parent = arguments[0] !== (void 0) ? arguments[0] : null;
	    if (!this.injected) {
	      (parent || this.hot.rootElement).appendChild(this.container.fragment);
	      this.injected = true;
	    }
	  },
	  removeTable: function() {
	    if (this.injected && this.container.container.parentNode) {
	      this.container.container.parentNode.removeChild(this.container.container);
	      this.container = null;
	      this.injected = false;
	    }
	  },
	  createColElement: function(column) {
	    var d = document;
	    var col = d.createElement('col');
	    col.style.width = this.hot.view.wt.wtTable.getStretchedColumnWidth(column) + 'px';
	    return col;
	  },
	  createTable: function() {
	    var className = arguments[0] !== (void 0) ? arguments[0] : '';
	    var d = document;
	    var fragment = d.createDocumentFragment();
	    var table = d.createElement('table');
	    var tHead = d.createElement('thead');
	    var tBody = d.createElement('tbody');
	    var colGroup = d.createElement('colgroup');
	    var tr = d.createElement('tr');
	    var th = d.createElement('th');
	    if (this.isVertical()) {
	      table.appendChild(colGroup);
	    }
	    if (this.isHorizontal()) {
	      tr.appendChild(th);
	      tHead.appendChild(tr);
	      table.style.tableLayout = 'auto';
	      table.style.width = 'auto';
	    }
	    table.appendChild(tHead);
	    if (this.isVertical()) {
	      tBody.appendChild(tr);
	    }
	    table.appendChild(tBody);
	    addClass(table, className);
	    fragment.appendChild(table);
	    return {
	      fragment: fragment,
	      table: table,
	      tHead: tHead,
	      tBody: tBody,
	      colGroup: colGroup,
	      tr: tr,
	      th: th
	    };
	  },
	  createContainer: function() {
	    var className = arguments[0] !== (void 0) ? arguments[0] : '';
	    var d = document;
	    var fragment = d.createDocumentFragment();
	    var container = d.createElement('div');
	    className = 'htGhostTable htAutoSize ' + className.trim();
	    addClass(container, className);
	    fragment.appendChild(container);
	    return {
	      fragment: fragment,
	      container: container
	    };
	  },
	  isVertical: function() {
	    return this.rows.length && !this.columns.length ? true : false;
	  },
	  isHorizontal: function() {
	    return this.columns.length && !this.rows.length ? true : false;
	  }
	}, {});
	;
	Handsontable.utils.GhostTable = GhostTable;

	//# 
	},{"browser":23,"helpers/array":42,"helpers/dom/element":46,"helpers/mixed":50,"helpers/number":51,"helpers/object":52}],103:[function(_dereq_,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  Interval: {get: function() {
	      return Interval;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $___46__46__47_helpers_47_feature__,
	    $___46__46__47_helpers_47_array__,
	    $___46__46__47_helpers_47_object__,
	    $___46__46__47_helpers_47_number__,
	    $___46__46__47_helpers_47_mixed__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var $__1 = ($___46__46__47_helpers_47_feature__ = _dereq_("helpers/feature"), $___46__46__47_helpers_47_feature__ && $___46__46__47_helpers_47_feature__.__esModule && $___46__46__47_helpers_47_feature__ || {default: $___46__46__47_helpers_47_feature__}),
	    requestAnimationFrame = $__1.requestAnimationFrame,
	    cancelAnimationFrame = $__1.cancelAnimationFrame;
	var arrayEach = ($___46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47_helpers_47_array__ && $___46__46__47_helpers_47_array__.__esModule && $___46__46__47_helpers_47_array__ || {default: $___46__46__47_helpers_47_array__}).arrayEach;
	var objectEach = ($___46__46__47_helpers_47_object__ = _dereq_("helpers/object"), $___46__46__47_helpers_47_object__ && $___46__46__47_helpers_47_object__.__esModule && $___46__46__47_helpers_47_object__ || {default: $___46__46__47_helpers_47_object__}).objectEach;
	var rangeEach = ($___46__46__47_helpers_47_number__ = _dereq_("helpers/number"), $___46__46__47_helpers_47_number__ && $___46__46__47_helpers_47_number__.__esModule && $___46__46__47_helpers_47_number__ || {default: $___46__46__47_helpers_47_number__}).rangeEach;
	var stringify = ($___46__46__47_helpers_47_mixed__ = _dereq_("helpers/mixed"), $___46__46__47_helpers_47_mixed__ && $___46__46__47_helpers_47_mixed__.__esModule && $___46__46__47_helpers_47_mixed__ || {default: $___46__46__47_helpers_47_mixed__}).stringify;
	var Interval = function Interval(func, delay) {
	  var $__6 = this;
	  this.timer = null;
	  this.func = func;
	  this.delay = parseDelay(delay);
	  this.stopped = true;
	  this._then = null;
	  this._callback = (function() {
	    return $__6.__callback();
	  });
	};
	var $Interval = Interval;
	($traceurRuntime.createClass)(Interval, {
	  start: function() {
	    if (this.stopped) {
	      this._then = Date.now();
	      this.stopped = false;
	      this.timer = requestAnimationFrame(this._callback);
	    }
	    return this;
	  },
	  stop: function() {
	    if (!this.stopped) {
	      this.stopped = true;
	      cancelAnimationFrame(this.timer);
	      this.timer = null;
	    }
	    return this;
	  },
	  __callback: function() {
	    this.timer = requestAnimationFrame(this._callback);
	    if (this.delay) {
	      var now = Date.now();
	      var elapsed = now - this._then;
	      if (elapsed > this.delay) {
	        this._then = now - (elapsed % this.delay);
	        this.func();
	      }
	    } else {
	      this.func();
	    }
	  }
	}, {create: function(func, delay) {
	    return new $Interval(func, delay);
	  }});
	;
	function parseDelay(delay) {
	  if (typeof delay === 'string' && /fps$/.test(delay)) {
	    delay = 1000 / parseInt(delay.replace('fps', '') || 0, 10);
	  }
	  return delay;
	}
	Handsontable.utils.Interval = Interval;

	//# 
	},{"browser":23,"helpers/array":42,"helpers/feature":48,"helpers/mixed":50,"helpers/number":51,"helpers/object":52}],104:[function(_dereq_,module,exports){
	"use strict";
	var $__8;
	Object.defineProperties(exports, {
	  SamplesGenerator: {get: function() {
	      return SamplesGenerator;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__,
	    $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_helpers_47_array__,
	    $___46__46__47_helpers_47_object__,
	    $___46__46__47_helpers_47_number__,
	    $___46__46__47_helpers_47_mixed__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var $__1 = ($___46__46__47_helpers_47_dom_47_element__ = _dereq_("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__1.addClass,
	    outerHeight = $__1.outerHeight,
	    outerWidth = $__1.outerWidth;
	var arrayEach = ($___46__46__47_helpers_47_array__ = _dereq_("helpers/array"), $___46__46__47_helpers_47_array__ && $___46__46__47_helpers_47_array__.__esModule && $___46__46__47_helpers_47_array__ || {default: $___46__46__47_helpers_47_array__}).arrayEach;
	var $__3 = ($___46__46__47_helpers_47_object__ = _dereq_("helpers/object"), $___46__46__47_helpers_47_object__ && $___46__46__47_helpers_47_object__.__esModule && $___46__46__47_helpers_47_object__ || {default: $___46__46__47_helpers_47_object__}),
	    objectEach = $__3.objectEach,
	    isObject = $__3.isObject;
	var rangeEach = ($___46__46__47_helpers_47_number__ = _dereq_("helpers/number"), $___46__46__47_helpers_47_number__ && $___46__46__47_helpers_47_number__.__esModule && $___46__46__47_helpers_47_number__ || {default: $___46__46__47_helpers_47_number__}).rangeEach;
	var stringify = ($___46__46__47_helpers_47_mixed__ = _dereq_("helpers/mixed"), $___46__46__47_helpers_47_mixed__ && $___46__46__47_helpers_47_mixed__.__esModule && $___46__46__47_helpers_47_mixed__ || {default: $___46__46__47_helpers_47_mixed__}).stringify;
	var SamplesGenerator = function SamplesGenerator(dataFactory) {
	  this.samples = null;
	  this.dataFactory = dataFactory;
	  this.customSampleCount = null;
	};
	var $SamplesGenerator = SamplesGenerator;
	($traceurRuntime.createClass)(SamplesGenerator, ($__8 = {}, Object.defineProperty($__8, "getSampleCount", {
	  value: function() {
	    if (this.customSampleCount) {
	      return this.customSampleCount;
	    }
	    return $SamplesGenerator.SAMPLE_COUNT;
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__8, "generateRowSamples", {
	  value: function(rowRange, colRange) {
	    return this.generateSamples('row', colRange, rowRange);
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__8, "generateColumnSamples", {
	  value: function(colRange, rowRange) {
	    return this.generateSamples('col', rowRange, colRange);
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__8, "generateSamples", {
	  value: function(type, range, specifierRange) {
	    var $__6 = this;
	    var samples = new Map();
	    if (typeof specifierRange === 'number') {
	      specifierRange = {
	        from: specifierRange,
	        to: specifierRange
	      };
	    }
	    rangeEach(specifierRange.from, specifierRange.to, (function(index) {
	      var sample = $__6.generateSample(type, range, index);
	      samples.set(index, sample);
	    }));
	    return samples;
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__8, "generateSample", {
	  value: function(type, range, specifierValue) {
	    var $__6 = this;
	    var samples = new Map();
	    var sampledValues = [];
	    var length;
	    rangeEach(range.from, range.to, (function(index) {
	      var $__8;
	      var value;
	      if (type === 'row') {
	        value = $__6.dataFactory(specifierValue, index);
	      } else if (type === 'col') {
	        value = $__6.dataFactory(index, specifierValue);
	      } else {
	        throw new Error('Unsupported sample type');
	      }
	      if (isObject(value)) {
	        length = Object.keys(value).length;
	      } else if (Array.isArray(value)) {
	        length = value.length;
	      } else {
	        length = stringify(value).length;
	      }
	      if (!samples.has(length)) {
	        samples.set(length, {
	          needed: $__6.getSampleCount(),
	          strings: []
	        });
	      }
	      var sample = samples.get(length);
	      if (sample.needed) {
	        var duplicate = sampledValues.indexOf(value) > -1;
	        if (!duplicate) {
	          var computedKey = type === 'row' ? 'col' : 'row';
	          sample.strings.push(($__8 = {}, Object.defineProperty($__8, "value", {
	            value: value,
	            configurable: true,
	            enumerable: true,
	            writable: true
	          }), Object.defineProperty($__8, computedKey, {
	            value: index,
	            configurable: true,
	            enumerable: true,
	            writable: true
	          }), $__8));
	          sampledValues.push(value);
	          sample.needed--;
	        }
	      }
	    }));
	    return samples;
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), $__8), {get SAMPLE_COUNT() {
	    return 3;
	  }});
	;
	Handsontable.utils.SamplesGenerator = SamplesGenerator;

	//# 
	},{"browser":23,"helpers/array":42,"helpers/dom/element":46,"helpers/mixed":50,"helpers/number":51,"helpers/object":52}],105:[function(_dereq_,module,exports){
	"use strict";
	var $___46__46__47_browser__,
	    $___46__46__47_helpers_47_mixed__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var stringify = ($___46__46__47_helpers_47_mixed__ = _dereq_("helpers/mixed"), $___46__46__47_helpers_47_mixed__ && $___46__46__47_helpers_47_mixed__.__esModule && $___46__46__47_helpers_47_mixed__ || {default: $___46__46__47_helpers_47_mixed__}).stringify;
	Handsontable.AutocompleteValidator = function(value, callback) {
	  if (value == null) {
	    value = '';
	  }
	  if (this.allowEmpty && value === '') {
	    callback(true);
	    return;
	  }
	  if (this.strict && this.source) {
	    if (typeof this.source === 'function') {
	      this.source(value, process(value, callback));
	    } else {
	      process(value, callback)(this.source);
	    }
	  } else {
	    callback(true);
	  }
	};
	function process(value, callback) {
	  var originalVal = value;
	  var lowercaseVal = typeof originalVal === 'string' ? originalVal.toLowerCase() : null;
	  return function(source) {
	    var found = false;
	    for (var s = 0,
	        slen = source.length; s < slen; s++) {
	      if (originalVal === source[s]) {
	        found = true;
	        break;
	      } else if (lowercaseVal === stringify(source[s]).toLowerCase()) {
	        found = true;
	        break;
	      }
	    }
	    callback(found);
	  };
	}

	//# 
	},{"browser":23,"helpers/mixed":50}],106:[function(_dereq_,module,exports){
	"use strict";
	var $___46__46__47_browser__,
	    $__moment__,
	    $___46__46__47_helpers_47_date__,
	    $___46__46__47_editors__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var moment = ($__moment__ = _dereq_("moment"), $__moment__ && $__moment__.__esModule && $__moment__ || {default: $__moment__}).default;
	var getNormalizedDate = ($___46__46__47_helpers_47_date__ = _dereq_("../helpers/date"), $___46__46__47_helpers_47_date__ && $___46__46__47_helpers_47_date__.__esModule && $___46__46__47_helpers_47_date__ || {default: $___46__46__47_helpers_47_date__}).getNormalizedDate;
	var getEditor = ($___46__46__47_editors__ = _dereq_("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}).getEditor;
	Handsontable.DateValidator = function(value, callback) {
	  var valid = true;
	  var dateEditor = getEditor('date', this.instance);
	  if (value == null) {
	    value = '';
	  }
	  var isValidDate = moment(new Date(value)).isValid();
	  var isValidFormat = moment(value, this.dateFormat || dateEditor.defaultDateFormat, true).isValid();
	  if (this.allowEmpty && value === '') {
	    isValidDate = true;
	    isValidFormat = true;
	  }
	  if (!isValidDate) {
	    valid = false;
	  }
	  if (!isValidDate && isValidFormat) {
	    valid = true;
	  }
	  if (isValidDate && !isValidFormat) {
	    if (this.correctFormat === true) {
	      var correctedValue = correctFormat(value, this.dateFormat);
	      this.instance.setDataAtCell(this.row, this.col, correctedValue, 'dateValidator');
	      valid = true;
	    } else {
	      valid = false;
	    }
	  }
	  callback(valid);
	};
	var correctFormat = function correctFormat(value, dateFormat) {
	  var date = moment(getNormalizedDate(value));
	  var year = date.format('YYYY');
	  var yearNow = moment().format('YYYY');
	  if (year.substr(0, 2) !== yearNow.substr(0, 2)) {
	    if (!value.match(new RegExp(year))) {
	      date.year(year.replace(year.substr(0, 2), yearNow.substr(0, 2)));
	    }
	  } else if (year.length > 4) {
	    date.year((date.year() + '').substr(0, 4));
	  }
	  return date.format(dateFormat);
	};

	//# 
	},{"../helpers/date":45,"browser":23,"editors":29,"moment":"moment"}],107:[function(_dereq_,module,exports){
	"use strict";
	var $___46__46__47_browser__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	Handsontable.NumericValidator = function(value, callback) {
	  if (value == null) {
	    value = '';
	  }
	  if (this.allowEmpty && value === '') {
	    callback(true);
	  } else if (value === '') {
	    callback(false);
	  } else {
	    callback(/^-?\d*(\.|\,)?\d*$/.test(value));
	  }
	};

	//# 
	},{"browser":23}],108:[function(_dereq_,module,exports){
	"use strict";
	var $___46__46__47_browser__,
	    $__moment__;
	var Handsontable = ($___46__46__47_browser__ = _dereq_("browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}).default;
	var moment = ($__moment__ = _dereq_("moment"), $__moment__ && $__moment__.__esModule && $__moment__ || {default: $__moment__}).default;
	var STRICT_FORMATS = ['YYYY-MM-DDTHH:mm:ss.SSSZ', 'X', 'x'];
	Handsontable.TimeValidator = function(value, callback) {
	  var valid = true;
	  var timeFormat = this.timeFormat || 'h:mm:ss a';
	  if (value === null) {
	    value = '';
	  }
	  value = /^\d{3,}$/.test(value) ? parseInt(value, 10) : value;
	  var twoDigitValue = /^\d{1,2}$/.test(value);
	  if (twoDigitValue) {
	    value = value + ':00';
	  }
	  var date = moment(value, STRICT_FORMATS, true).isValid() ? moment(value) : moment(value, timeFormat);
	  var isValidTime = date.isValid();
	  var isValidFormat = moment(value, timeFormat, true).isValid() && !twoDigitValue;
	  if (this.allowEmpty && value === '') {
	    isValidTime = true;
	    isValidFormat = true;
	  }
	  if (!isValidTime) {
	    valid = false;
	  }
	  if (!isValidTime && isValidFormat) {
	    valid = true;
	  }
	  if (isValidTime && !isValidFormat) {
	    if (this.correctFormat === true) {
	      var correctedValue = date.format(timeFormat);
	      this.instance.setDataAtCell(this.row, this.col, correctedValue, 'timeValidator');
	      valid = true;
	    } else {
	      valid = false;
	    }
	  }
	  callback(valid);
	};

	//# 
	},{"browser":23,"moment":"moment"}],"SheetClip":[function(_dereq_,module,exports){
	/**
	 * SheetClip - Spreadsheet Clipboard Parser
	 * version 0.2
	 *
	 * This tiny library transforms JavaScript arrays to strings that are pasteable by LibreOffice, OpenOffice,
	 * Google Docs and Microsoft Excel.
	 *
	 * Copyright 2012, Marcin Warpechowski
	 * Licensed under the MIT license.
	 * http://github.com/warpech/sheetclip/
	 */
	/*jslint white: true*/
	(function (global) {
	  "use strict";

	  function countQuotes(str) {
	    return str.split('"').length - 1;
	  }

	  var SheetClip = {
	    /**
	     * Decode spreadsheet string into array
	     *
	     * @param {String} str
	     * @returns {Array}
	     */
	    parse: function (str) {
	      var r, rLen, rows, arr = [], a = 0, c, cLen, multiline, last;

	      rows = str.split('\n');

	      if (rows.length > 1 && rows[rows.length - 1] === '') {
	        rows.pop();
	      }
	      for (r = 0, rLen = rows.length; r < rLen; r += 1) {
	        rows[r] = rows[r].split('\t');

	        for (c = 0, cLen = rows[r].length; c < cLen; c += 1) {
	          if (!arr[a]) {
	            arr[a] = [];
	          }
	          if (multiline && c === 0) {
	            last = arr[a].length - 1;
	            arr[a][last] = arr[a][last] + '\n' + rows[r][0];

	            if (multiline && (countQuotes(rows[r][0]) & 1)) { //& 1 is a bitwise way of performing mod 2
	              multiline = false;
	              arr[a][last] = arr[a][last].substring(0, arr[a][last].length - 1).replace(/""/g, '"');
	            }
	          }
	          else {
	            if (c === cLen - 1 && rows[r][c].indexOf('"') === 0 && (countQuotes(rows[r][c]) & 1)) {
	              arr[a].push(rows[r][c].substring(1).replace(/""/g, '"'));
	              multiline = true;
	            }
	            else {
	              arr[a].push(rows[r][c].replace(/""/g, '"'));
	              multiline = false;
	            }
	          }
	        }
	        if (!multiline) {
	          a += 1;
	        }
	      }

	      return arr;
	    },

	    /**
	     * Encode array into valid spreadsheet string
	     *
	     * @param arr
	     * @returns {String}
	     */
	    stringify: function (arr) {
	      var r, rLen, c, cLen, str = '', val;

	      for (r = 0, rLen = arr.length; r < rLen; r += 1) {
	        cLen = arr[r].length;

	        for (c = 0; c < cLen; c += 1) {
	          if (c > 0) {
	            str += '\t';
	          }
	          val = arr[r][c];

	          if (typeof val === 'string') {
	            if (val.indexOf('\n') > -1) {
	              str += '"' + val.replace(/"/g, '""') + '"';
	            }
	            else {
	              str += val;
	            }
	          }
	          else if (val === null || val === void 0) { // void 0 resolves to undefined
	            str += '';
	          }
	          else {
	            str += val;
	          }
	        }
	        str += '\n';
	      }

	      return str;
	    }
	  };

	  if (typeof exports !== 'undefined') {
	    exports.parse = SheetClip.parse;
	    exports.stringify = SheetClip.stringify;
	  } else {
	    global.SheetClip = SheetClip;
	  }
	}(window));

	},{}],"autoResize":[function(_dereq_,module,exports){
	/**
	 * autoResize - resizes a DOM element to the width and height of another DOM element
	 *
	 * Copyright 2014, Marcin Warpechowski
	 * Licensed under the MIT license
	 */


	function autoResize() {
	  var defaults = {
	      minHeight: 200,
	      maxHeight: 300,
	      minWidth: 100,
	      maxWidth: 300
	    },
	    el,
	    body = document.body,
	    text = document.createTextNode(''),
	    span = document.createElement('SPAN'),
	    observe = function (element, event, handler) {
	      if (window.attachEvent) {
	        element.attachEvent('on' + event, handler);
	      } else {
	        element.addEventListener(event, handler, false);
	      }
	    },
	    unObserve = function (element, event, handler) {
	      if (window.removeEventListener) {
	        element.removeEventListener(event, handler, false);
	      } else {
	        element.detachEvent('on' + event, handler);
	      }
	    },
	    resize = function (newChar) {
	      var width, scrollHeight;

	      if (!newChar) {
	        newChar = "";
	      } else if (!/^[a-zA-Z \.,\\\/\|0-9]$/.test(newChar)) {
	        newChar = ".";
	      }

	      if (text.textContent !== void 0) {
	        text.textContent = el.value + newChar;
	      }
	      else {
	        text.data = el.value + newChar; //IE8
	      }
	      span.style.fontSize = getComputedStyle(el).fontSize;
	      span.style.fontFamily = getComputedStyle(el).fontFamily;
	      span.style.whiteSpace = "pre";

	      body.appendChild(span);
	      width = span.clientWidth + 2;
	      body.removeChild(span);

	      el.style.height = defaults.minHeight + 'px';

	      if (defaults.minWidth > width) {
	        el.style.width = defaults.minWidth + 'px';

	      } else if (width > defaults.maxWidth) {
	        el.style.width = defaults.maxWidth + 'px';

	      } else {
	        el.style.width = width + 'px';
	      }
	      scrollHeight = el.scrollHeight ? el.scrollHeight - 1 : 0;

	      if (defaults.minHeight > scrollHeight) {
	        el.style.height = defaults.minHeight + 'px';

	      } else if (defaults.maxHeight < scrollHeight) {
	        el.style.height = defaults.maxHeight + 'px';
	        el.style.overflowY = 'visible';

	      } else {
	        el.style.height = scrollHeight + 'px';
	      }
	    },
	    delayedResize = function () {
	      window.setTimeout(resize, 0);
	    },
	    extendDefaults = function (config) {

	      if (config && config.minHeight) {
	        if (config.minHeight == 'inherit') {
	          defaults.minHeight = el.clientHeight;
	        } else {
	          var minHeight = parseInt(config.minHeight);
	          if (!isNaN(minHeight)) {
	            defaults.minHeight = minHeight;
	          }
	        }
	      }

	      if (config && config.maxHeight) {
	        if (config.maxHeight == 'inherit') {
	          defaults.maxHeight = el.clientHeight;
	        } else {
	          var maxHeight = parseInt(config.maxHeight);
	          if (!isNaN(maxHeight)) {
	            defaults.maxHeight = maxHeight;
	          }
	        }
	      }

	      if (config && config.minWidth) {
	        if (config.minWidth == 'inherit') {
	          defaults.minWidth = el.clientWidth;
	        } else {
	          var minWidth = parseInt(config.minWidth);
	          if (!isNaN(minWidth)) {
	            defaults.minWidth = minWidth;
	          }
	        }
	      }

	      if (config && config.maxWidth) {
	        if (config.maxWidth == 'inherit') {
	          defaults.maxWidth = el.clientWidth;
	        } else {
	          var maxWidth = parseInt(config.maxWidth);
	          if (!isNaN(maxWidth)) {
	            defaults.maxWidth = maxWidth;
	          }
	        }
	      }

	      if(!span.firstChild) {
	        span.className = "autoResize";
	        span.style.display = 'inline-block';
	        span.appendChild(text);
	      }
	    },
	    init = function (el_, config, doObserve) {
	      el = el_;
	      extendDefaults(config);

	      if (el.nodeName == 'TEXTAREA') {

	        el.style.resize = 'none';
	        el.style.overflowY = '';
	        el.style.height = defaults.minHeight + 'px';
	        el.style.minWidth = defaults.minWidth + 'px';
	        el.style.maxWidth = defaults.maxWidth + 'px';
	        el.style.overflowY = 'hidden';
	      }

	      if(doObserve) {
	        observe(el, 'change', resize);
	        observe(el, 'cut', delayedResize);
	        observe(el, 'paste', delayedResize);
	        observe(el, 'drop', delayedResize);
	        observe(el, 'keydown', delayedResize);
	        observe(el, 'focus', resize);
	      }

	      resize();
	    };

	  function getComputedStyle(element) {
	    return element.currentStyle || document.defaultView.getComputedStyle(element);
	  }

	  return {
	    init: function (el_, config, doObserve) {
	      init(el_, config, doObserve);
	    },
	    unObserve: function () {
	      unObserve(el, 'change', resize);
	      unObserve(el, 'cut', delayedResize);
	      unObserve(el, 'paste', delayedResize);
	      unObserve(el, 'drop', delayedResize);
	      unObserve(el, 'keydown', delayedResize);
	      unObserve(el, 'focus', resize);
	    },
	    resize: resize
	  };
	}

	if (typeof exports !== 'undefined') {
	  module.exports = autoResize;
	}

	},{}],"copyPaste":[function(_dereq_,module,exports){
	/**
	 * Creates a textarea that stays hidden on the page and gets focused when user presses CTRL while not having a form
	 * input focused.
	 * In future we may implement a better driver when better APIs are available.
	 *
	 * @constructor
	 * @private
	 */

	var instance;

	function copyPaste() {
	  if (!instance) {
	    instance = new CopyPasteClass();

	  } else if (instance.hasBeenDestroyed()){
	    instance.init();
	  }
	  instance.refCounter++;

	  return instance;
	}

	if (typeof exports !== 'undefined') {
	  module.exports = copyPaste;
	}

	function CopyPasteClass() {
	  this.refCounter = 0;
	  this.init();
	}

	CopyPasteClass.prototype.init = function () {
	  var
	    style,
	    parent;

	  this.copyCallbacks = [];
	  this.cutCallbacks = [];
	  this.pasteCallbacks = [];

	  // this.listenerElement = document.documentElement;
	  parent = document.body;

	  if (document.getElementById('CopyPasteDiv')) {
	    this.elDiv = document.getElementById('CopyPasteDiv');
	    this.elTextarea = this.elDiv.firstChild;

	  } else {
	    this.elDiv = document.createElement('div');
	    this.elDiv.id = 'CopyPasteDiv';
	    style = this.elDiv.style;
	    style.position = 'fixed';
	    style.top = '-10000px';
	    style.left = '-10000px';
	    parent.appendChild(this.elDiv);

	    this.elTextarea = document.createElement('textarea');
	    this.elTextarea.className = 'copyPaste';
	    this.elTextarea.onpaste = function(event) {
	      var clipboardContents,
	        temp;

	      if ('WebkitAppearance' in document.documentElement.style) { // chrome and safari
	        clipboardContents = event.clipboardData.getData("Text");

	        // Safari adds an additional newline to copied text
	        if (navigator.userAgent.indexOf('Safari') !== -1 && navigator.userAgent.indexOf('Chrome') === -1) {
	          temp = clipboardContents.split('\n');

	          if (temp[temp.length - 1] === '') {
	            temp.pop();
	          }
	          clipboardContents = temp.join('\n');
	        }
	        this.value = clipboardContents;

	        event.preventDefault();
	      }
	    };
	    style = this.elTextarea.style;
	    style.width = '10000px';
	    style.height = '10000px';
	    style.overflow = 'hidden';
	    this.elDiv.appendChild(this.elTextarea);

	    if (typeof style.opacity !== 'undefined') {
	      style.opacity = 0;
	    }
	  }
	  this.onKeyDownRef = this.onKeyDown.bind(this);
	  document.documentElement.addEventListener('keydown', this.onKeyDownRef, false);
	};

	/**
	 * Call method on every key down event
	 *
	 * @param {Event} event
	 */
	CopyPasteClass.prototype.onKeyDown = function(event) {
	  var _this = this,
	    isCtrlDown = false;

	  function isActiveElementEditable() {
	    var element = document.activeElement;

	    if (element.shadowRoot && element.shadowRoot.activeElement) {
	      element = element.shadowRoot.activeElement;
	    }

	    return ['INPUT', 'SELECT', 'TEXTAREA'].indexOf(element.nodeName) > -1 || element.contentEditable === 'true';
	  }

	  // mac
	  if (event.metaKey) {
	    isCtrlDown = true;
	  }
	  // pc
	  else if (event.ctrlKey && navigator.userAgent.indexOf('Mac') === -1) {
	    isCtrlDown = true;
	  }
	  if (isCtrlDown) {
	    // this is needed by fragmentSelection in Handsontable. Ignore copypaste.js behavior if fragment of cell text is selected
	    if (document.activeElement !== this.elTextarea && (this.getSelectionText() !== '' || isActiveElementEditable())) {
	      return;
	    }
	    this.selectNodeText(this.elTextarea);
	    setTimeout(function() {
	      if (document.activeElement !== _this.elTextarea) {
	        _this.selectNodeText(_this.elTextarea);
	      }
	    }, 0);
	  }

	  if (event.isImmediatePropagationEnabled !== false && isCtrlDown &&
	      (event.keyCode === 67 ||
	      event.keyCode === 86 ||
	      event.keyCode === 88)) {
	    // works in all browsers, incl. Opera < 12.12
	    if (event.keyCode === 88) {
	      setTimeout(function () {
	        _this.triggerCut(event);
	      }, 0);

	    } else if (event.keyCode === 86) {
	      setTimeout(function () {
	        _this.triggerPaste(event);
	      }, 0);
	    }
	  }
	};

	//http://jsperf.com/textara-selection
	//http://stackoverflow.com/questions/1502385/how-can-i-make-this-code-work-in-ie
	/**
	 * Select all text contains in passed node element
	 *
	 * @param {Element} element
	 */
	CopyPasteClass.prototype.selectNodeText = function(element) {
	  if (element) {
	    element.select();
	  }
	};

	//http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text
	/**
	 * Get selection text
	 *
	 * @returns {String}
	 */
	CopyPasteClass.prototype.getSelectionText = function() {
	  var text = '';

	  if (window.getSelection) {
	    text = window.getSelection().toString();

	  } else if (document.selection && document.selection.type !== 'Control') {
	    text = document.selection.createRange().text;
	  }

	  return text;
	};

	/**
	 * Make string copyable
	 *
	 * @param {String} string
	 */
	CopyPasteClass.prototype.copyable = function(string) {
	  if (typeof string !== 'string' && string.toString === void 0) {
	    throw new Error('copyable requires string parameter');
	  }
	  this.elTextarea.value = string;
	  this.selectNodeText(this.elTextarea);
	};

	/*CopyPasteClass.prototype.onCopy = function (fn) {
	  this.copyCallbacks.push(fn);
	};*/

	/**
	 * Add function callback to onCut event
	 *
	 * @param {Function} callback
	 */
	CopyPasteClass.prototype.onCut = function(callback) {
	  this.cutCallbacks.push(callback);
	};

	/**
	 * Add function callback to onPaste event
	 *
	 * @param {Function} callback
	 */
	CopyPasteClass.prototype.onPaste = function(callback) {
	  this.pasteCallbacks.push(callback);
	};

	/**
	 * Remove callback from all events
	 *
	 * @param {Function} callback
	 * @returns {Boolean}
	 */
	CopyPasteClass.prototype.removeCallback = function(callback) {
	  var i, len;

	  for (i = 0, len = this.copyCallbacks.length; i < len; i++) {
	    if (this.copyCallbacks[i] === callback) {
	      this.copyCallbacks.splice(i, 1);

	      return true;
	    }
	  }
	  for (i = 0, len = this.cutCallbacks.length; i < len; i++) {
	    if (this.cutCallbacks[i] === callback) {
	      this.cutCallbacks.splice(i, 1);

	      return true;
	    }
	  }
	  for (i = 0, len = this.pasteCallbacks.length; i < len; i++) {
	    if (this.pasteCallbacks[i] === callback) {
	      this.pasteCallbacks.splice(i, 1);

	      return true;
	    }
	  }

	  return false;
	};

	/**
	 * Trigger cut event
	 *
	 * @param {DOMEvent} event
	 */
	CopyPasteClass.prototype.triggerCut = function(event) {
	  var _this = this;

	  if (_this.cutCallbacks) {
	    setTimeout(function () {
	      for (var i = 0, len = _this.cutCallbacks.length; i < len; i++) {
	        _this.cutCallbacks[i](event);
	      }
	    }, 50);
	  }
	};

	/**
	 * Trigger paste event
	 *
	 * @param {DOMEvent} event
	 * @param {String} string
	 */
	CopyPasteClass.prototype.triggerPaste = function(event, string) {
	  var _this = this;

	  if (_this.pasteCallbacks) {
	    setTimeout(function () {
	      var val = string || _this.elTextarea.value;

	      for (var i = 0, len = _this.pasteCallbacks.length; i < len; i++) {
	        _this.pasteCallbacks[i](val, event);
	      }
	    }, 50);
	  }
	};

	/**
	 * Destroy instance
	 */
	CopyPasteClass.prototype.destroy = function() {
	  if (!this.hasBeenDestroyed() && --this.refCounter === 0) {
	    if (this.elDiv && this.elDiv.parentNode) {
	      this.elDiv.parentNode.removeChild(this.elDiv);
	      this.elDiv = null;
	      this.elTextarea = null;
	    }
	    document.documentElement.removeEventListener('keydown', this.onKeyDownRef);
	    this.onKeyDownRef = null;
	  }
	};

	/**
	 * Check if instance has been destroyed
	 *
	 * @returns {Boolean}
	 */
	CopyPasteClass.prototype.hasBeenDestroyed = function() {
	  return !this.refCounter;
	};



	},{}],"es6collections":[function(_dereq_,module,exports){
	/*!
	 * Copyright (C) 2011 by Andrea Giammarchi, @WebReflection
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	(function(exports) {
	  'use strict';
	  //shared pointer
	  var i;
	  //shortcuts
	  var defineProperty = Object.defineProperty,
	    is = function(a, b) {
	      return isNaN(a) ? isNaN(b) : a === b;
	    };


	  //Polyfill global objects
	  if (typeof WeakMap == 'undefined') {
	    exports.WeakMap = createCollection({
	      // WeakMap#delete(key:void*):boolean
	      'delete': sharedDelete,
	      // WeakMap#clear():
	      clear: sharedClear,
	      // WeakMap#get(key:void*):void*
	      get: sharedGet,
	      // WeakMap#has(key:void*):boolean
	      has: mapHas,
	      // WeakMap#set(key:void*, value:void*):void
	      set: sharedSet
	    }, true);
	  }

	  if (typeof Map == 'undefined') {
	    exports.Map = createCollection({
	      // WeakMap#delete(key:void*):boolean
	      'delete': sharedDelete,
	      //:was Map#get(key:void*[, d3fault:void*]):void*
	      // Map#has(key:void*):boolean
	      has: mapHas,
	      // Map#get(key:void*):boolean
	      get: sharedGet,
	      // Map#set(key:void*, value:void*):void
	      set: sharedSet,
	      // Map#keys(void):Iterator
	      keys: sharedKeys,
	      // Map#values(void):Iterator
	      values: sharedValues,
	      // Map#entries(void):Iterator
	      entries: mapEntries,
	      // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`
	      forEach: sharedForEach,
	      // Map#clear():
	      clear: sharedClear
	    });
	  }

	  if (typeof Set == 'undefined') {
	    exports.Set = createCollection({
	      // Set#has(value:void*):boolean
	      has: setHas,
	      // Set#add(value:void*):boolean
	      add: sharedAdd,
	      // Set#delete(key:void*):boolean
	      'delete': sharedDelete,
	      // Set#clear():
	      clear: sharedClear,
	      // Set#keys(void):Iterator
	      keys: sharedValues, // specs actually say "the same function object as the initial value of the values property"
	      // Set#values(void):Iterator
	      values: sharedValues,
	      // Set#entries(void):Iterator
	      entries: setEntries,
	      // Set#forEach(callback:Function, context:void*):void ==> callback.call(context, value, index) === not in specs
	      forEach: sharedForEach
	    });
	  }

	  if (typeof WeakSet == 'undefined') {
	    exports.WeakSet = createCollection({
	      // WeakSet#delete(key:void*):boolean
	      'delete': sharedDelete,
	      // WeakSet#add(value:void*):boolean
	      add: sharedAdd,
	      // WeakSet#clear():
	      clear: sharedClear,
	      // WeakSet#has(value:void*):boolean
	      has: setHas
	    }, true);
	  }


	  /**
	   * ES6 collection constructor
	   * @return {Function} a collection class
	   */
	  function createCollection(proto, objectOnly) {
	    function Collection(a) {
	      if (!this || this.constructor !== Collection) return new Collection(a);
	      this._keys = [];
	      this._values = [];
	      this._itp = []; // iteration pointers
	      this.objectOnly = objectOnly;

	      //parse initial iterable argument passed
	      if (a) init.call(this, a);
	    }

	    //define size for non object-only collections
	    if (!objectOnly) {
	      defineProperty(proto, 'size', {
	        get: sharedSize
	      });
	    }

	    //set prototype
	    proto.constructor = Collection;
	    Collection.prototype = proto;

	    return Collection;
	  }


	  /** parse initial iterable argument passed */
	  function init(a) {
	    var i;
	    //init Set argument, like `[1,2,3,{}]`
	    if (this.add) a.forEach(this.add, this);
	    //init Map argument like `[[1,2], [{}, 4]]`
	    else a.forEach(function(a) {
	      this.set(a[0], a[1])
	    }, this);
	  }


	  /** delete */
	  function sharedDelete(key) {
	    if (this.has(key)) {
	      this._keys.splice(i, 1);
	      this._values.splice(i, 1);
	      // update iteration pointers
	      this._itp.forEach(function(p) {
	        if (i < p[0]) p[0]--;
	      });
	    }
	    // Aurora here does it while Canary doesn't
	    return -1 < i;
	  };

	  function sharedGet(key) {
	    return this.has(key) ? this._values[i] : undefined;
	  }

	  function has(list, key) {
	    if (this.objectOnly && key !== Object(key)) throw new TypeError("Invalid value used as weak collection key");
	    //NaN or 0 passed
	    if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} else i = list.indexOf(key);
	    return -1 < i;
	  }

	  function setHas(value) {
	    return has.call(this, this._values, value);
	  }

	  function mapHas(value) {
	    return has.call(this, this._keys, value);
	  }

	  /** @chainable */
	  function sharedSet(key, value) {
	    this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;
	    return this;
	  }

	  /** @chainable */
	  function sharedAdd(value) {
	    if (!this.has(value)) this._values.push(value);
	    return this;
	  }

	  function sharedClear() {
	    this._values.length = 0;
	  }

	  /** keys, values, and iterate related methods */
	  function sharedKeys() {
	    return sharedIterator(this._itp, this._keys);
	  }

	  function sharedValues() {
	    return sharedIterator(this._itp, this._values);
	  }

	  function mapEntries() {
	    return sharedIterator(this._itp, this._keys, this._values);
	  }

	  function setEntries() {
	    return sharedIterator(this._itp, this._values, this._values);
	  }

	  function sharedIterator(itp, array, array2) {
	    var p = [0],
	      done = false;
	    itp.push(p);
	    return {
	      next: function() {
	        var v, k = p[0];
	        if (!done && k < array.length) {
	          v = array2 ? [array[k], array2[k]] : array[k];
	          p[0]++;
	        } else {
	          done = true;
	          itp.splice(itp.indexOf(p), 1);
	        }
	        return {
	          done: done,
	          value: v
	        };
	      }
	    };
	  }

	  function sharedSize() {
	    return this._values.length;
	  }

	  function sharedForEach(callback, context) {
	    var it = this.entries();
	    for (;;) {
	      var r = it.next();
	      if (r.done) break;
	      callback.call(context, r.value[1], r.value[0], this);
	    }
	  }

	})(typeof exports != 'undefined' && typeof global != 'undefined' ? global : window);

	},{}],"jsonpatch":[function(_dereq_,module,exports){
	/*!
	 * https://github.com/Starcounter-Jack/JSON-Patch
	 * json-patch-duplex.js version: 0.5.7
	 * (c) 2013 Joachim Wester
	 * MIT license
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OriginalError = Error;
	var jsonpatch;
	(function (jsonpatch) {
	    var _objectKeys = function (obj) {
	        if (_isArray(obj)) {
	            var keys = new Array(obj.length);
	            for (var k = 0; k < keys.length; k++) {
	                keys[k] = "" + k;
	            }
	            return keys;
	        }
	        if (Object.keys) {
	            return Object.keys(obj);
	        }
	        var keys = [];
	        for (var i in obj) {
	            if (obj.hasOwnProperty(i)) {
	                keys.push(i);
	            }
	        }
	        return keys;
	    };
	    function _equals(a, b) {
	        switch (typeof a) {
	            case 'undefined': //backward compatibility, but really I think we should return false
	            case 'boolean':
	            case 'string':
	            case 'number':
	                return a === b;
	            case 'object':
	                if (a === null)
	                    return b === null;
	                if (_isArray(a)) {
	                    if (!_isArray(b) || a.length !== b.length)
	                        return false;
	                    for (var i = 0, l = a.length; i < l; i++)
	                        if (!_equals(a[i], b[i]))
	                            return false;
	                    return true;
	                }
	                var bKeys = _objectKeys(b);
	                var bLength = bKeys.length;
	                if (_objectKeys(a).length !== bLength)
	                    return false;
	                for (var i = 0; i < bLength; i++)
	                    if (!_equals(a[i], b[i]))
	                        return false;
	                return true;
	            default:
	                return false;
	        }
	    }
	    /* We use a Javascript hash to store each
	     function. Each hash entry (property) uses
	     the operation identifiers specified in rfc6902.
	     In this way, we can map each patch operation
	     to its dedicated function in efficient way.
	     */
	    /* The operations applicable to an object */
	    var objOps = {
	        add: function (obj, key) {
	            obj[key] = this.value;
	            return true;
	        },
	        remove: function (obj, key) {
	            delete obj[key];
	            return true;
	        },
	        replace: function (obj, key) {
	            obj[key] = this.value;
	            return true;
	        },
	        move: function (obj, key, tree) {
	            var temp = { op: "_get", path: this.from };
	            apply(tree, [temp]);
	            apply(tree, [
	                { op: "remove", path: this.from }
	            ]);
	            apply(tree, [
	                { op: "add", path: this.path, value: temp.value }
	            ]);
	            return true;
	        },
	        copy: function (obj, key, tree) {
	            var temp = { op: "_get", path: this.from };
	            apply(tree, [temp]);
	            apply(tree, [
	                { op: "add", path: this.path, value: temp.value }
	            ]);
	            return true;
	        },
	        test: function (obj, key) {
	            return _equals(obj[key], this.value);
	        },
	        _get: function (obj, key) {
	            this.value = obj[key];
	        }
	    };
	    /* The operations applicable to an array. Many are the same as for the object */
	    var arrOps = {
	        add: function (arr, i) {
	            arr.splice(i, 0, this.value);
	            return true;
	        },
	        remove: function (arr, i) {
	            arr.splice(i, 1);
	            return true;
	        },
	        replace: function (arr, i) {
	            arr[i] = this.value;
	            return true;
	        },
	        move: objOps.move,
	        copy: objOps.copy,
	        test: objOps.test,
	        _get: objOps._get
	    };
	    /* The operations applicable to object root. Many are the same as for the object */
	    var rootOps = {
	        add: function (obj) {
	            rootOps.remove.call(this, obj);
	            for (var key in this.value) {
	                if (this.value.hasOwnProperty(key)) {
	                    obj[key] = this.value[key];
	                }
	            }
	            return true;
	        },
	        remove: function (obj) {
	            for (var key in obj) {
	                if (obj.hasOwnProperty(key)) {
	                    objOps.remove.call(this, obj, key);
	                }
	            }
	            return true;
	        },
	        replace: function (obj) {
	            apply(obj, [
	                { op: "remove", path: this.path }
	            ]);
	            apply(obj, [
	                { op: "add", path: this.path, value: this.value }
	            ]);
	            return true;
	        },
	        move: objOps.move,
	        copy: objOps.copy,
	        test: function (obj) {
	            return (JSON.stringify(obj) === JSON.stringify(this.value));
	        },
	        _get: function (obj) {
	            this.value = obj;
	        }
	    };
	    var observeOps = {
	        add: function (patches, path) {
	            var patch = {
	                op: "add",
	                path: path + escapePathComponent(this.name),
	                value: this.object[this.name] };
	            patches.push(patch);
	        },
	        'delete': function (patches, path) {
	            var patch = {
	                op: "remove",
	                path: path + escapePathComponent(this.name)
	            };
	            patches.push(patch);
	        },
	        update: function (patches, path) {
	            var patch = {
	                op: "replace",
	                path: path + escapePathComponent(this.name),
	                value: this.object[this.name]
	            };
	            patches.push(patch);
	        }
	    };
	    function escapePathComponent(str) {
	        if (str.indexOf('/') === -1 && str.indexOf('~') === -1)
	            return str;
	        return str.replace(/~/g, '~0').replace(/\//g, '~1');
	    }
	    function _getPathRecursive(root, obj) {
	        var found;
	        for (var key in root) {
	            if (root.hasOwnProperty(key)) {
	                if (root[key] === obj) {
	                    return escapePathComponent(key) + '/';
	                }
	                else if (typeof root[key] === 'object') {
	                    found = _getPathRecursive(root[key], obj);
	                    if (found != '') {
	                        return escapePathComponent(key) + '/' + found;
	                    }
	                }
	            }
	        }
	        return '';
	    }
	    function getPath(root, obj) {
	        if (root === obj) {
	            return '/';
	        }
	        var path = _getPathRecursive(root, obj);
	        if (path === '') {
	            throw new OriginalError("Object not found in root");
	        }
	        return '/' + path;
	    }
	    var beforeDict = [];
	    var Mirror = (function () {
	        function Mirror(obj) {
	            this.observers = [];
	            this.obj = obj;
	        }
	        return Mirror;
	    })();
	    var ObserverInfo = (function () {
	        function ObserverInfo(callback, observer) {
	            this.callback = callback;
	            this.observer = observer;
	        }
	        return ObserverInfo;
	    })();
	    function getMirror(obj) {
	        for (var i = 0, ilen = beforeDict.length; i < ilen; i++) {
	            if (beforeDict[i].obj === obj) {
	                return beforeDict[i];
	            }
	        }
	    }
	    function getObserverFromMirror(mirror, callback) {
	        for (var j = 0, jlen = mirror.observers.length; j < jlen; j++) {
	            if (mirror.observers[j].callback === callback) {
	                return mirror.observers[j].observer;
	            }
	        }
	    }
	    function removeObserverFromMirror(mirror, observer) {
	        for (var j = 0, jlen = mirror.observers.length; j < jlen; j++) {
	            if (mirror.observers[j].observer === observer) {
	                mirror.observers.splice(j, 1);
	                return;
	            }
	        }
	    }
	    function unobserve(root, observer) {
	        observer.unobserve();
	    }
	    jsonpatch.unobserve = unobserve;
	    function deepClone(obj) {
	        if (typeof obj === "object") {
	            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
	        }
	        else {
	            return obj; //no need to clone primitives
	        }
	    }
	    function observe(obj, callback) {
	        var patches = [];
	        var root = obj;
	        var observer;
	        var mirror = getMirror(obj);
	        if (!mirror) {
	            mirror = new Mirror(obj);
	            beforeDict.push(mirror);
	        }
	        else {
	            observer = getObserverFromMirror(mirror, callback);
	        }
	        if (observer) {
	            return observer;
	        }
	        observer = {};
	        mirror.value = deepClone(obj);
	        if (callback) {
	            observer.callback = callback;
	            observer.next = null;
	            var intervals = this.intervals || [100, 1000, 10000, 60000];
	            if (intervals.push === void 0) {
	                throw new OriginalError("jsonpatch.intervals must be an array");
	            }
	            var currentInterval = 0;
	            var dirtyCheck = function () {
	                generate(observer);
	            };
	            var fastCheck = function () {
	                clearTimeout(observer.next);
	                observer.next = setTimeout(function () {
	                    dirtyCheck();
	                    currentInterval = 0;
	                    observer.next = setTimeout(slowCheck, intervals[currentInterval++]);
	                }, 0);
	            };
	            var slowCheck = function () {
	                dirtyCheck();
	                if (currentInterval == intervals.length)
	                    currentInterval = intervals.length - 1;
	                observer.next = setTimeout(slowCheck, intervals[currentInterval++]);
	            };
	            if (typeof window !== 'undefined') {
	                if (window.addEventListener) {
	                    window.addEventListener('mousedown', fastCheck);
	                    window.addEventListener('mouseup', fastCheck);
	                    window.addEventListener('keydown', fastCheck);
	                }
	                else {
	                    document.documentElement.attachEvent('onmousedown', fastCheck);
	                    document.documentElement.attachEvent('onmouseup', fastCheck);
	                    document.documentElement.attachEvent('onkeydown', fastCheck);
	                }
	            }
	            observer.next = setTimeout(slowCheck, intervals[currentInterval++]);
	        }
	        observer.patches = patches;
	        observer.object = obj;
	        observer.unobserve = function () {
	            generate(observer);
	            clearTimeout(observer.next);
	            removeObserverFromMirror(mirror, observer);
	            if (typeof window !== 'undefined') {
	                if (window.removeEventListener) {
	                    window.removeEventListener('mousedown', fastCheck);
	                    window.removeEventListener('mouseup', fastCheck);
	                    window.removeEventListener('keydown', fastCheck);
	                }
	                else {
	                    document.documentElement.detachEvent('onmousedown', fastCheck);
	                    document.documentElement.detachEvent('onmouseup', fastCheck);
	                    document.documentElement.detachEvent('onkeydown', fastCheck);
	                }
	            }
	        };
	        mirror.observers.push(new ObserverInfo(callback, observer));
	        return observer;
	    }
	    jsonpatch.observe = observe;
	    function generate(observer) {
	        var mirror;
	        for (var i = 0, ilen = beforeDict.length; i < ilen; i++) {
	            if (beforeDict[i].obj === observer.object) {
	                mirror = beforeDict[i];
	                break;
	            }
	        }
	        _generate(mirror.value, observer.object, observer.patches, "");
	        if (observer.patches.length) {
	            apply(mirror.value, observer.patches);
	        }
	        var temp = observer.patches;
	        if (temp.length > 0) {
	            observer.patches = [];
	            if (observer.callback) {
	                observer.callback(temp);
	            }
	        }
	        return temp;
	    }
	    jsonpatch.generate = generate;
	    // Dirty check if obj is different from mirror, generate patches and update mirror
	    function _generate(mirror, obj, patches, path) {
	        var newKeys = _objectKeys(obj);
	        var oldKeys = _objectKeys(mirror);
	        var changed = false;
	        var deleted = false;
	        //if ever "move" operation is implemented here, make sure this test runs OK: "should not generate the same patch twice (move)"
	        for (var t = oldKeys.length - 1; t >= 0; t--) {
	            var key = oldKeys[t];
	            var oldVal = mirror[key];
	            if (obj.hasOwnProperty(key)) {
	                var newVal = obj[key];
	                if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null) {
	                    _generate(oldVal, newVal, patches, path + "/" + escapePathComponent(key));
	                }
	                else {
	                    if (oldVal != newVal) {
	                        changed = true;
	                        patches.push({ op: "replace", path: path + "/" + escapePathComponent(key), value: deepClone(newVal) });
	                    }
	                }
	            }
	            else {
	                patches.push({ op: "remove", path: path + "/" + escapePathComponent(key) });
	                deleted = true; // property has been deleted
	            }
	        }
	        if (!deleted && newKeys.length == oldKeys.length) {
	            return;
	        }
	        for (var t = 0; t < newKeys.length; t++) {
	            var key = newKeys[t];
	            if (!mirror.hasOwnProperty(key)) {
	                patches.push({ op: "add", path: path + "/" + escapePathComponent(key), value: deepClone(obj[key]) });
	            }
	        }
	    }
	    var _isArray;
	    if (Array.isArray) {
	        _isArray = Array.isArray;
	    }
	    else {
	        _isArray = function (obj) {
	            return obj.push && typeof obj.length === 'number';
	        };
	    }
	    //3x faster than cached /^\d+$/.test(str)
	    function isInteger(str) {
	        var i = 0;
	        var len = str.length;
	        var charCode;
	        while (i < len) {
	            charCode = str.charCodeAt(i);
	            if (charCode >= 48 && charCode <= 57) {
	                i++;
	                continue;
	            }
	            return false;
	        }
	        return true;
	    }
	    /// Apply a json-patch operation on an object tree
	    function apply(tree, patches, validate) {
	        var result = false, p = 0, plen = patches.length, patch, key;
	        while (p < plen) {
	            patch = patches[p];
	            p++;
	            // Find the object
	            var path = patch.path || "";
	            var keys = path.split('/');
	            var obj = tree;
	            var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift
	            var len = keys.length;
	            var existingPathFragment = undefined;
	            while (true) {
	                key = keys[t];
	                if (validate) {
	                    if (existingPathFragment === undefined) {
	                        if (obj[key] === undefined) {
	                            existingPathFragment = keys.slice(0, t).join('/');
	                        }
	                        else if (t == len - 1) {
	                            existingPathFragment = patch.path;
	                        }
	                        if (existingPathFragment !== undefined) {
	                            this.validator(patch, p - 1, tree, existingPathFragment);
	                        }
	                    }
	                }
	                t++;
	                if (key === undefined) {
	                    if (t >= len) {
	                        result = rootOps[patch.op].call(patch, obj, key, tree); // Apply patch
	                        break;
	                    }
	                }
	                if (_isArray(obj)) {
	                    if (key === '-') {
	                        key = obj.length;
	                    }
	                    else {
	                        if (validate && !isInteger(key)) {
	                            throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", p - 1, patch.path, patch);
	                        }
	                        key = parseInt(key, 10);
	                    }
	                    if (t >= len) {
	                        if (validate && patch.op === "add" && key > obj.length) {
	                            throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", p - 1, patch.path, patch);
	                        }
	                        result = arrOps[patch.op].call(patch, obj, key, tree); // Apply patch
	                        break;
	                    }
	                }
	                else {
	                    if (key && key.indexOf('~') != -1)
	                        key = key.replace(/~1/g, '/').replace(/~0/g, '~'); // escape chars
	                    if (t >= len) {
	                        result = objOps[patch.op].call(patch, obj, key, tree); // Apply patch
	                        break;
	                    }
	                }
	                obj = obj[key];
	            }
	        }
	        return result;
	    }
	    jsonpatch.apply = apply;
	    function compare(tree1, tree2) {
	        var patches = [];
	        _generate(tree1, tree2, patches, '');
	        return patches;
	    }
	    jsonpatch.compare = compare;
	    var JsonPatchError = (function (_super) {
	        __extends(JsonPatchError, _super);
	        function JsonPatchError(message, name, index, operation, tree) {
	            _super.call(this, message);
	            this.message = message;
	            this.name = name;
	            this.index = index;
	            this.operation = operation;
	            this.tree = tree;
	        }
	        return JsonPatchError;
	    })(OriginalError);
	    jsonpatch.JsonPatchError = JsonPatchError;
	    jsonpatch.Error = JsonPatchError;
	    /**
	     * Recursively checks whether an object has any undefined values inside.
	     */
	    function hasUndefined(obj) {
	        if (obj === undefined) {
	            return true;
	        }
	        if (typeof obj == "array" || typeof obj == "object") {
	            for (var i in obj) {
	                if (hasUndefined(obj[i])) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    }
	    /**
	     * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.
	     * @param {object} operation - operation object (patch)
	     * @param {number} index - index of operation in the sequence
	     * @param {object} [tree] - object where the operation is supposed to be applied
	     * @param {string} [existingPathFragment] - comes along with `tree`
	     */
	    function validator(operation, index, tree, existingPathFragment) {
	        if (typeof operation !== 'object' || operation === null || _isArray(operation)) {
	            throw new JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, tree);
	        }
	        else if (!objOps[operation.op]) {
	            throw new JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, tree);
	        }
	        else if (typeof operation.path !== 'string') {
	            throw new JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, tree);
	        }
	        else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {
	            throw new JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, tree);
	        }
	        else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {
	            throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, tree);
	        }
	        else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && hasUndefined(operation.value)) {
	            throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, tree);
	        }
	        else if (tree) {
	            if (operation.op == "add") {
	                var pathLen = operation.path.split("/").length;
	                var existingPathLen = existingPathFragment.split("/").length;
	                if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
	                    throw new JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, tree);
	                }
	            }
	            else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {
	                if (operation.path !== existingPathFragment) {
	                    throw new JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, tree);
	                }
	            }
	            else if (operation.op === 'move' || operation.op === 'copy') {
	                var existingValue = { op: "_get", path: operation.from, value: undefined };
	                var error = jsonpatch.validate([existingValue], tree);
	                if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {
	                    throw new JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, tree);
	                }
	            }
	        }
	    }
	    jsonpatch.validator = validator;
	    /**
	     * Validates a sequence of operations. If `tree` parameter is provided, the sequence is additionally validated against the object tree.
	     * If error is encountered, returns a JsonPatchError object
	     * @param sequence
	     * @param tree
	     * @returns {JsonPatchError|undefined}
	     */
	    function validate(sequence, tree) {
	        try {
	            if (!_isArray(sequence)) {
	                throw new JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
	            }
	            if (tree) {
	                tree = JSON.parse(JSON.stringify(tree)); //clone tree so that we can safely try applying operations
	                apply.call(this, tree, sequence, true);
	            }
	            else {
	                for (var i = 0; i < sequence.length; i++) {
	                    this.validator(sequence[i], i);
	                }
	            }
	        }
	        catch (e) {
	            if (e instanceof JsonPatchError) {
	                return e;
	            }
	            else {
	                throw e;
	            }
	        }
	    }
	    jsonpatch.validate = validate;
	})(jsonpatch || (jsonpatch = {}));
	if (typeof exports !== "undefined") {
	    exports.apply = jsonpatch.apply;
	    exports.observe = jsonpatch.observe;
	    exports.unobserve = jsonpatch.unobserve;
	    exports.generate = jsonpatch.generate;
	    exports.compare = jsonpatch.compare;
	    exports.validate = jsonpatch.validate;
	    exports.validator = jsonpatch.validator;
	    exports.JsonPatchError = jsonpatch.JsonPatchError;
	    exports.Error = jsonpatch.Error;
	}

	},{}],"moment":[function(_dereq_,module,exports){
	//! moment.js
	//! version : 2.12.0
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com

	;(function (global, factory) {
	    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    global.moment = factory()
	}(this, function () { 'use strict';

	    var hookCallback;

	    function utils_hooks__hooks () {
	        return hookCallback.apply(null, arguments);
	    }

	    // This is done to register the method called with moment()
	    // without creating circular dependencies.
	    function setHookCallback (callback) {
	        hookCallback = callback;
	    }

	    function isArray(input) {
	        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
	    }

	    function isDate(input) {
	        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	    }

	    function map(arr, fn) {
	        var res = [], i;
	        for (i = 0; i < arr.length; ++i) {
	            res.push(fn(arr[i], i));
	        }
	        return res;
	    }

	    function hasOwnProp(a, b) {
	        return Object.prototype.hasOwnProperty.call(a, b);
	    }

	    function extend(a, b) {
	        for (var i in b) {
	            if (hasOwnProp(b, i)) {
	                a[i] = b[i];
	            }
	        }

	        if (hasOwnProp(b, 'toString')) {
	            a.toString = b.toString;
	        }

	        if (hasOwnProp(b, 'valueOf')) {
	            a.valueOf = b.valueOf;
	        }

	        return a;
	    }

	    function create_utc__createUTC (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, true).utc();
	    }

	    function defaultParsingFlags() {
	        // We need to deep clone this object.
	        return {
	            empty           : false,
	            unusedTokens    : [],
	            unusedInput     : [],
	            overflow        : -2,
	            charsLeftOver   : 0,
	            nullInput       : false,
	            invalidMonth    : null,
	            invalidFormat   : false,
	            userInvalidated : false,
	            iso             : false
	        };
	    }

	    function getParsingFlags(m) {
	        if (m._pf == null) {
	            m._pf = defaultParsingFlags();
	        }
	        return m._pf;
	    }

	    function valid__isValid(m) {
	        if (m._isValid == null) {
	            var flags = getParsingFlags(m);
	            m._isValid = !isNaN(m._d.getTime()) &&
	                flags.overflow < 0 &&
	                !flags.empty &&
	                !flags.invalidMonth &&
	                !flags.invalidWeekday &&
	                !flags.nullInput &&
	                !flags.invalidFormat &&
	                !flags.userInvalidated;

	            if (m._strict) {
	                m._isValid = m._isValid &&
	                    flags.charsLeftOver === 0 &&
	                    flags.unusedTokens.length === 0 &&
	                    flags.bigHour === undefined;
	            }
	        }
	        return m._isValid;
	    }

	    function valid__createInvalid (flags) {
	        var m = create_utc__createUTC(NaN);
	        if (flags != null) {
	            extend(getParsingFlags(m), flags);
	        }
	        else {
	            getParsingFlags(m).userInvalidated = true;
	        }

	        return m;
	    }

	    function isUndefined(input) {
	        return input === void 0;
	    }

	    // Plugins that add properties should also add the key here (null value),
	    // so we can properly clone ourselves.
	    var momentProperties = utils_hooks__hooks.momentProperties = [];

	    function copyConfig(to, from) {
	        var i, prop, val;

	        if (!isUndefined(from._isAMomentObject)) {
	            to._isAMomentObject = from._isAMomentObject;
	        }
	        if (!isUndefined(from._i)) {
	            to._i = from._i;
	        }
	        if (!isUndefined(from._f)) {
	            to._f = from._f;
	        }
	        if (!isUndefined(from._l)) {
	            to._l = from._l;
	        }
	        if (!isUndefined(from._strict)) {
	            to._strict = from._strict;
	        }
	        if (!isUndefined(from._tzm)) {
	            to._tzm = from._tzm;
	        }
	        if (!isUndefined(from._isUTC)) {
	            to._isUTC = from._isUTC;
	        }
	        if (!isUndefined(from._offset)) {
	            to._offset = from._offset;
	        }
	        if (!isUndefined(from._pf)) {
	            to._pf = getParsingFlags(from);
	        }
	        if (!isUndefined(from._locale)) {
	            to._locale = from._locale;
	        }

	        if (momentProperties.length > 0) {
	            for (i in momentProperties) {
	                prop = momentProperties[i];
	                val = from[prop];
	                if (!isUndefined(val)) {
	                    to[prop] = val;
	                }
	            }
	        }

	        return to;
	    }

	    var updateInProgress = false;

	    // Moment prototype object
	    function Moment(config) {
	        copyConfig(this, config);
	        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	        // Prevent infinite loop in case updateOffset creates new moment
	        // objects.
	        if (updateInProgress === false) {
	            updateInProgress = true;
	            utils_hooks__hooks.updateOffset(this);
	            updateInProgress = false;
	        }
	    }

	    function isMoment (obj) {
	        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	    }

	    function absFloor (number) {
	        if (number < 0) {
	            return Math.ceil(number);
	        } else {
	            return Math.floor(number);
	        }
	    }

	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;

	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            value = absFloor(coercedNumber);
	        }

	        return value;
	    }

	    // compare two arrays, return the number of differences
	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if ((dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }

	    function warn(msg) {
	        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
	                (typeof console !==  'undefined') && console.warn) {
	            console.warn('Deprecation warning: ' + msg);
	        }
	    }

	    function deprecate(msg, fn) {
	        var firstTime = true;

	        return extend(function () {
	            if (firstTime) {
	                warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
	                firstTime = false;
	            }
	            return fn.apply(this, arguments);
	        }, fn);
	    }

	    var deprecations = {};

	    function deprecateSimple(name, msg) {
	        if (!deprecations[name]) {
	            warn(msg);
	            deprecations[name] = true;
	        }
	    }

	    utils_hooks__hooks.suppressDeprecationWarnings = false;

	    function isFunction(input) {
	        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	    }

	    function isObject(input) {
	        return Object.prototype.toString.call(input) === '[object Object]';
	    }

	    function locale_set__set (config) {
	        var prop, i;
	        for (i in config) {
	            prop = config[i];
	            if (isFunction(prop)) {
	                this[i] = prop;
	            } else {
	                this['_' + i] = prop;
	            }
	        }
	        this._config = config;
	        // Lenient ordinal parsing accepts just a number in addition to
	        // number + (possibly) stuff coming from _ordinalParseLenient.
	        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
	    }

	    function mergeConfigs(parentConfig, childConfig) {
	        var res = extend({}, parentConfig), prop;
	        for (prop in childConfig) {
	            if (hasOwnProp(childConfig, prop)) {
	                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
	                    res[prop] = {};
	                    extend(res[prop], parentConfig[prop]);
	                    extend(res[prop], childConfig[prop]);
	                } else if (childConfig[prop] != null) {
	                    res[prop] = childConfig[prop];
	                } else {
	                    delete res[prop];
	                }
	            }
	        }
	        return res;
	    }

	    function Locale(config) {
	        if (config != null) {
	            this.set(config);
	        }
	    }

	    // internal storage for locale config files
	    var locales = {};
	    var globalLocale;

	    function normalizeLocale(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }

	    // pick the locale from the array
	    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	    function chooseLocale(names) {
	        var i = 0, j, next, locale, split;

	        while (i < names.length) {
	            split = normalizeLocale(names[i]).split('-');
	            j = split.length;
	            next = normalizeLocale(names[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                locale = loadLocale(split.slice(0, j).join('-'));
	                if (locale) {
	                    return locale;
	                }
	                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return null;
	    }

	    function loadLocale(name) {
	        var oldLocale = null;
	        // TODO: Find a better way to register and load all the locales in Node
	        if (!locales[name] && (typeof module !== 'undefined') &&
	                module && module.exports) {
	            try {
	                oldLocale = globalLocale._abbr;
	                _dereq_('./locale/' + name);
	                // because defineLocale currently also sets the global locale, we
	                // want to undo that for lazy loaded locales
	                locale_locales__getSetGlobalLocale(oldLocale);
	            } catch (e) { }
	        }
	        return locales[name];
	    }

	    // This function will load locale and then set the global locale.  If
	    // no arguments are passed in, it will simply return the current global
	    // locale key.
	    function locale_locales__getSetGlobalLocale (key, values) {
	        var data;
	        if (key) {
	            if (isUndefined(values)) {
	                data = locale_locales__getLocale(key);
	            }
	            else {
	                data = defineLocale(key, values);
	            }

	            if (data) {
	                // moment.duration._locale = moment._locale = data;
	                globalLocale = data;
	            }
	        }

	        return globalLocale._abbr;
	    }

	    function defineLocale (name, config) {
	        if (config !== null) {
	            config.abbr = name;
	            if (locales[name] != null) {
	                deprecateSimple('defineLocaleOverride',
	                        'use moment.updateLocale(localeName, config) to change ' +
	                        'an existing locale. moment.defineLocale(localeName, ' +
	                        'config) should only be used for creating a new locale');
	                config = mergeConfigs(locales[name]._config, config);
	            } else if (config.parentLocale != null) {
	                if (locales[config.parentLocale] != null) {
	                    config = mergeConfigs(locales[config.parentLocale]._config, config);
	                } else {
	                    // treat as if there is no base config
	                    deprecateSimple('parentLocaleUndefined',
	                            'specified parentLocale is not defined yet');
	                }
	            }
	            locales[name] = new Locale(config);

	            // backwards compat for now: also set the locale
	            locale_locales__getSetGlobalLocale(name);

	            return locales[name];
	        } else {
	            // useful for testing
	            delete locales[name];
	            return null;
	        }
	    }

	    function updateLocale(name, config) {
	        if (config != null) {
	            var locale;
	            if (locales[name] != null) {
	                config = mergeConfigs(locales[name]._config, config);
	            }
	            locale = new Locale(config);
	            locale.parentLocale = locales[name];
	            locales[name] = locale;

	            // backwards compat for now: also set the locale
	            locale_locales__getSetGlobalLocale(name);
	        } else {
	            // pass null for config to unupdate, useful for tests
	            if (locales[name] != null) {
	                if (locales[name].parentLocale != null) {
	                    locales[name] = locales[name].parentLocale;
	                } else if (locales[name] != null) {
	                    delete locales[name];
	                }
	            }
	        }
	        return locales[name];
	    }

	    // returns locale data
	    function locale_locales__getLocale (key) {
	        var locale;

	        if (key && key._locale && key._locale._abbr) {
	            key = key._locale._abbr;
	        }

	        if (!key) {
	            return globalLocale;
	        }

	        if (!isArray(key)) {
	            //short-circuit everything else
	            locale = loadLocale(key);
	            if (locale) {
	                return locale;
	            }
	            key = [key];
	        }

	        return chooseLocale(key);
	    }

	    function locale_locales__listLocales() {
	        return Object.keys(locales);
	    }

	    var aliases = {};

	    function addUnitAlias (unit, shorthand) {
	        var lowerCase = unit.toLowerCase();
	        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	    }

	    function normalizeUnits(units) {
	        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	    }

	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop;

	        for (prop in inputObject) {
	            if (hasOwnProp(inputObject, prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }

	        return normalizedInput;
	    }

	    function makeGetSet (unit, keepTime) {
	        return function (value) {
	            if (value != null) {
	                get_set__set(this, unit, value);
	                utils_hooks__hooks.updateOffset(this, keepTime);
	                return this;
	            } else {
	                return get_set__get(this, unit);
	            }
	        };
	    }

	    function get_set__get (mom, unit) {
	        return mom.isValid() ?
	            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
	    }

	    function get_set__set (mom, unit, value) {
	        if (mom.isValid()) {
	            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	        }
	    }

	    // MOMENTS

	    function getSet (units, value) {
	        var unit;
	        if (typeof units === 'object') {
	            for (unit in units) {
	                this.set(unit, units[unit]);
	            }
	        } else {
	            units = normalizeUnits(units);
	            if (isFunction(this[units])) {
	                return this[units](value);
	            }
	        }
	        return this;
	    }

	    function zeroFill(number, targetLength, forceSign) {
	        var absNumber = '' + Math.abs(number),
	            zerosToFill = targetLength - absNumber.length,
	            sign = number >= 0;
	        return (sign ? (forceSign ? '+' : '') : '-') +
	            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	    }

	    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

	    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

	    var formatFunctions = {};

	    var formatTokenFunctions = {};

	    // token:    'M'
	    // padded:   ['MM', 2]
	    // ordinal:  'Mo'
	    // callback: function () { this.month() + 1 }
	    function addFormatToken (token, padded, ordinal, callback) {
	        var func = callback;
	        if (typeof callback === 'string') {
	            func = function () {
	                return this[callback]();
	            };
	        }
	        if (token) {
	            formatTokenFunctions[token] = func;
	        }
	        if (padded) {
	            formatTokenFunctions[padded[0]] = function () {
	                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	            };
	        }
	        if (ordinal) {
	            formatTokenFunctions[ordinal] = function () {
	                return this.localeData().ordinal(func.apply(this, arguments), token);
	            };
	        }
	    }

	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, '');
	        }
	        return input.replace(/\\/g, '');
	    }

	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens), i, length;

	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }

	        return function (mom) {
	            var output = '';
	            for (i = 0; i < length; i++) {
	                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	            }
	            return output;
	        };
	    }

	    // format date using native date object
	    function formatMoment(m, format) {
	        if (!m.isValid()) {
	            return m.localeData().invalidDate();
	        }

	        format = expandFormat(format, m.localeData());
	        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

	        return formatFunctions[format](m);
	    }

	    function expandFormat(format, locale) {
	        var i = 5;

	        function replaceLongDateFormatTokens(input) {
	            return locale.longDateFormat(input) || input;
	        }

	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }

	        return format;
	    }

	    var match1         = /\d/;            //       0 - 9
	    var match2         = /\d\d/;          //      00 - 99
	    var match3         = /\d{3}/;         //     000 - 999
	    var match4         = /\d{4}/;         //    0000 - 9999
	    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	    var match1to2      = /\d\d?/;         //       0 - 99
	    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
	    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
	    var match1to3      = /\d{1,3}/;       //       0 - 999
	    var match1to4      = /\d{1,4}/;       //       0 - 9999
	    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

	    var matchUnsigned  = /\d+/;           //       0 - inf
	    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

	    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

	    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

	    // any word (or two) characters or numbers including two/three word month in arabic.
	    // includes scottish gaelic two word and hyphenated months
	    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


	    var regexes = {};

	    function addRegexToken (token, regex, strictRegex) {
	        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
	            return (isStrict && strictRegex) ? strictRegex : regex;
	        };
	    }

	    function getParseRegexForToken (token, config) {
	        if (!hasOwnProp(regexes, token)) {
	            return new RegExp(unescapeFormat(token));
	        }

	        return regexes[token](config._strict, config._locale);
	    }

	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function unescapeFormat(s) {
	        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	            return p1 || p2 || p3 || p4;
	        }));
	    }

	    function regexEscape(s) {
	        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }

	    var tokens = {};

	    function addParseToken (token, callback) {
	        var i, func = callback;
	        if (typeof token === 'string') {
	            token = [token];
	        }
	        if (typeof callback === 'number') {
	            func = function (input, array) {
	                array[callback] = toInt(input);
	            };
	        }
	        for (i = 0; i < token.length; i++) {
	            tokens[token[i]] = func;
	        }
	    }

	    function addWeekParseToken (token, callback) {
	        addParseToken(token, function (input, array, config, token) {
	            config._w = config._w || {};
	            callback(input, config._w, config, token);
	        });
	    }

	    function addTimeToArrayFromToken(token, input, config) {
	        if (input != null && hasOwnProp(tokens, token)) {
	            tokens[token](input, config._a, config, token);
	        }
	    }

	    var YEAR = 0;
	    var MONTH = 1;
	    var DATE = 2;
	    var HOUR = 3;
	    var MINUTE = 4;
	    var SECOND = 5;
	    var MILLISECOND = 6;
	    var WEEK = 7;
	    var WEEKDAY = 8;

	    function daysInMonth(year, month) {
	        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	    }

	    // FORMATTING

	    addFormatToken('M', ['MM', 2], 'Mo', function () {
	        return this.month() + 1;
	    });

	    addFormatToken('MMM', 0, 0, function (format) {
	        return this.localeData().monthsShort(this, format);
	    });

	    addFormatToken('MMMM', 0, 0, function (format) {
	        return this.localeData().months(this, format);
	    });

	    // ALIASES

	    addUnitAlias('month', 'M');

	    // PARSING

	    addRegexToken('M',    match1to2);
	    addRegexToken('MM',   match1to2, match2);
	    addRegexToken('MMM',  function (isStrict, locale) {
	        return locale.monthsShortRegex(isStrict);
	    });
	    addRegexToken('MMMM', function (isStrict, locale) {
	        return locale.monthsRegex(isStrict);
	    });

	    addParseToken(['M', 'MM'], function (input, array) {
	        array[MONTH] = toInt(input) - 1;
	    });

	    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	        var month = config._locale.monthsParse(input, token, config._strict);
	        // if we didn't find a month name, mark the date as invalid.
	        if (month != null) {
	            array[MONTH] = month;
	        } else {
	            getParsingFlags(config).invalidMonth = input;
	        }
	    });

	    // LOCALES

	    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
	    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	    function localeMonths (m, format) {
	        return isArray(this._months) ? this._months[m.month()] :
	            this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	    }

	    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	    function localeMonthsShort (m, format) {
	        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
	            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	    }

	    function localeMonthsParse (monthName, format, strict) {
	        var i, mom, regex;

	        if (!this._monthsParse) {
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	        }

	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, i]);
	            if (strict && !this._longMonthsParse[i]) {
	                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	            }
	            if (!strict && !this._monthsParse[i]) {
	                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (!strict && this._monthsParse[i].test(monthName)) {
	                return i;
	            }
	        }
	    }

	    // MOMENTS

	    function setMonth (mom, value) {
	        var dayOfMonth;

	        if (!mom.isValid()) {
	            // No op
	            return mom;
	        }

	        if (typeof value === 'string') {
	            if (/^\d+$/.test(value)) {
	                value = toInt(value);
	            } else {
	                value = mom.localeData().monthsParse(value);
	                // TODO: Another silent failure?
	                if (typeof value !== 'number') {
	                    return mom;
	                }
	            }
	        }

	        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	        return mom;
	    }

	    function getSetMonth (value) {
	        if (value != null) {
	            setMonth(this, value);
	            utils_hooks__hooks.updateOffset(this, true);
	            return this;
	        } else {
	            return get_set__get(this, 'Month');
	        }
	    }

	    function getDaysInMonth () {
	        return daysInMonth(this.year(), this.month());
	    }

	    var defaultMonthsShortRegex = matchWord;
	    function monthsShortRegex (isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsShortStrictRegex;
	            } else {
	                return this._monthsShortRegex;
	            }
	        } else {
	            return this._monthsShortStrictRegex && isStrict ?
	                this._monthsShortStrictRegex : this._monthsShortRegex;
	        }
	    }

	    var defaultMonthsRegex = matchWord;
	    function monthsRegex (isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsStrictRegex;
	            } else {
	                return this._monthsRegex;
	            }
	        } else {
	            return this._monthsStrictRegex && isStrict ?
	                this._monthsStrictRegex : this._monthsRegex;
	        }
	    }

	    function computeMonthsParse () {
	        function cmpLenRev(a, b) {
	            return b.length - a.length;
	        }

	        var shortPieces = [], longPieces = [], mixedPieces = [],
	            i, mom;
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, i]);
	            shortPieces.push(this.monthsShort(mom, ''));
	            longPieces.push(this.months(mom, ''));
	            mixedPieces.push(this.months(mom, ''));
	            mixedPieces.push(this.monthsShort(mom, ''));
	        }
	        // Sorting makes sure if one month (or abbr) is a prefix of another it
	        // will match the longer piece.
	        shortPieces.sort(cmpLenRev);
	        longPieces.sort(cmpLenRev);
	        mixedPieces.sort(cmpLenRev);
	        for (i = 0; i < 12; i++) {
	            shortPieces[i] = regexEscape(shortPieces[i]);
	            longPieces[i] = regexEscape(longPieces[i]);
	            mixedPieces[i] = regexEscape(mixedPieces[i]);
	        }

	        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	        this._monthsShortRegex = this._monthsRegex;
	        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')$', 'i');
	        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')$', 'i');
	    }

	    function checkOverflow (m) {
	        var overflow;
	        var a = m._a;

	        if (a && getParsingFlags(m).overflow === -2) {
	            overflow =
	                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
	                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
	                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
	                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
	                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
	                -1;

	            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	                overflow = DATE;
	            }
	            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
	                overflow = WEEK;
	            }
	            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
	                overflow = WEEKDAY;
	            }

	            getParsingFlags(m).overflow = overflow;
	        }

	        return m;
	    }

	    // iso 8601 regex
	    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
	    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

	    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

	    var isoDates = [
	        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
	        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
	        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
	        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
	        ['YYYY-DDD', /\d{4}-\d{3}/],
	        ['YYYY-MM', /\d{4}-\d\d/, false],
	        ['YYYYYYMMDD', /[+-]\d{10}/],
	        ['YYYYMMDD', /\d{8}/],
	        // YYYYMM is NOT allowed by the standard
	        ['GGGG[W]WWE', /\d{4}W\d{3}/],
	        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
	        ['YYYYDDD', /\d{7}/]
	    ];

	    // iso time formats and regexes
	    var isoTimes = [
	        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
	        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
	        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
	        ['HH:mm', /\d\d:\d\d/],
	        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
	        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
	        ['HHmmss', /\d\d\d\d\d\d/],
	        ['HHmm', /\d\d\d\d/],
	        ['HH', /\d\d/]
	    ];

	    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

	    // date from iso format
	    function configFromISO(config) {
	        var i, l,
	            string = config._i,
	            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	            allowTime, dateFormat, timeFormat, tzFormat;

	        if (match) {
	            getParsingFlags(config).iso = true;

	            for (i = 0, l = isoDates.length; i < l; i++) {
	                if (isoDates[i][1].exec(match[1])) {
	                    dateFormat = isoDates[i][0];
	                    allowTime = isoDates[i][2] !== false;
	                    break;
	                }
	            }
	            if (dateFormat == null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[3]) {
	                for (i = 0, l = isoTimes.length; i < l; i++) {
	                    if (isoTimes[i][1].exec(match[3])) {
	                        // match[2] should be 'T' or space
	                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
	                        break;
	                    }
	                }
	                if (timeFormat == null) {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            if (!allowTime && timeFormat != null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[4]) {
	                if (tzRegex.exec(match[4])) {
	                    tzFormat = 'Z';
	                } else {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
	            configFromStringAndFormat(config);
	        } else {
	            config._isValid = false;
	        }
	    }

	    // date from iso format or fallback
	    function configFromString(config) {
	        var matched = aspNetJsonRegex.exec(config._i);

	        if (matched !== null) {
	            config._d = new Date(+matched[1]);
	            return;
	        }

	        configFromISO(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }

	    utils_hooks__hooks.createFromInputFallback = deprecate(
	        'moment construction falls back to js Date. This is ' +
	        'discouraged and will be removed in upcoming major ' +
	        'release. Please refer to ' +
	        'https://github.com/moment/moment/issues/1407 for more info.',
	        function (config) {
	            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	        }
	    );

	    function createDate (y, m, d, h, M, s, ms) {
	        //can't just apply() to create a date:
	        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	        var date = new Date(y, m, d, h, M, s, ms);

	        //the date constructor remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
	            date.setFullYear(y);
	        }
	        return date;
	    }

	    function createUTCDate (y) {
	        var date = new Date(Date.UTC.apply(null, arguments));

	        //the Date.UTC function remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
	            date.setUTCFullYear(y);
	        }
	        return date;
	    }

	    // FORMATTING

	    addFormatToken('Y', 0, 0, function () {
	        var y = this.year();
	        return y <= 9999 ? '' + y : '+' + y;
	    });

	    addFormatToken(0, ['YY', 2], 0, function () {
	        return this.year() % 100;
	    });

	    addFormatToken(0, ['YYYY',   4],       0, 'year');
	    addFormatToken(0, ['YYYYY',  5],       0, 'year');
	    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

	    // ALIASES

	    addUnitAlias('year', 'y');

	    // PARSING

	    addRegexToken('Y',      matchSigned);
	    addRegexToken('YY',     match1to2, match2);
	    addRegexToken('YYYY',   match1to4, match4);
	    addRegexToken('YYYYY',  match1to6, match6);
	    addRegexToken('YYYYYY', match1to6, match6);

	    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	    addParseToken('YYYY', function (input, array) {
	        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
	    });
	    addParseToken('YY', function (input, array) {
	        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });
	    addParseToken('Y', function (input, array) {
	        array[YEAR] = parseInt(input, 10);
	    });

	    // HELPERS

	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }

	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }

	    // HOOKS

	    utils_hooks__hooks.parseTwoDigitYear = function (input) {
	        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	    };

	    // MOMENTS

	    var getSetYear = makeGetSet('FullYear', false);

	    function getIsLeapYear () {
	        return isLeapYear(this.year());
	    }

	    // start-of-first-week - start-of-year
	    function firstWeekOffset(year, dow, doy) {
	        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	            fwd = 7 + dow - doy,
	            // first-week day local weekday -- which local weekday is fwd
	            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

	        return -fwdlw + fwd - 1;
	    }

	    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	        var localWeekday = (7 + weekday - dow) % 7,
	            weekOffset = firstWeekOffset(year, dow, doy),
	            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	            resYear, resDayOfYear;

	        if (dayOfYear <= 0) {
	            resYear = year - 1;
	            resDayOfYear = daysInYear(resYear) + dayOfYear;
	        } else if (dayOfYear > daysInYear(year)) {
	            resYear = year + 1;
	            resDayOfYear = dayOfYear - daysInYear(year);
	        } else {
	            resYear = year;
	            resDayOfYear = dayOfYear;
	        }

	        return {
	            year: resYear,
	            dayOfYear: resDayOfYear
	        };
	    }

	    function weekOfYear(mom, dow, doy) {
	        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	            resWeek, resYear;

	        if (week < 1) {
	            resYear = mom.year() - 1;
	            resWeek = week + weeksInYear(resYear, dow, doy);
	        } else if (week > weeksInYear(mom.year(), dow, doy)) {
	            resWeek = week - weeksInYear(mom.year(), dow, doy);
	            resYear = mom.year() + 1;
	        } else {
	            resYear = mom.year();
	            resWeek = week;
	        }

	        return {
	            week: resWeek,
	            year: resYear
	        };
	    }

	    function weeksInYear(year, dow, doy) {
	        var weekOffset = firstWeekOffset(year, dow, doy),
	            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	    }

	    // Pick the first defined of two or three arguments.
	    function defaults(a, b, c) {
	        if (a != null) {
	            return a;
	        }
	        if (b != null) {
	            return b;
	        }
	        return c;
	    }

	    function currentDateArray(config) {
	        // hooks is actually the exported moment object
	        var nowValue = new Date(utils_hooks__hooks.now());
	        if (config._useUTC) {
	            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
	        }
	        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	    }

	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function configFromArray (config) {
	        var i, date, input = [], currentDate, yearToUse;

	        if (config._d) {
	            return;
	        }

	        currentDate = currentDateArray(config);

	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            dayOfYearFromWeekInfo(config);
	        }

	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear) {
	            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

	            if (config._dayOfYear > daysInYear(yearToUse)) {
	                getParsingFlags(config)._overflowDayOfYear = true;
	            }

	            date = createUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }

	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }

	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	        }

	        // Check for 24:00:00.000
	        if (config._a[HOUR] === 24 &&
	                config._a[MINUTE] === 0 &&
	                config._a[SECOND] === 0 &&
	                config._a[MILLISECOND] === 0) {
	            config._nextDay = true;
	            config._a[HOUR] = 0;
	        }

	        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	        // Apply timezone offset from input. The actual utcOffset can be changed
	        // with parseZone.
	        if (config._tzm != null) {
	            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	        }

	        if (config._nextDay) {
	            config._a[HOUR] = 24;
	        }
	    }

	    function dayOfYearFromWeekInfo(config) {
	        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

	        w = config._w;
	        if (w.GG != null || w.W != null || w.E != null) {
	            dow = 1;
	            doy = 4;

	            // TODO: We need to take the current isoWeekYear, but that depends on
	            // how we interpret now (local, utc, fixed offset). So create
	            // a now version of current config (take local/utc/offset flags, and
	            // create now).
	            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
	            week = defaults(w.W, 1);
	            weekday = defaults(w.E, 1);
	            if (weekday < 1 || weekday > 7) {
	                weekdayOverflow = true;
	            }
	        } else {
	            dow = config._locale._week.dow;
	            doy = config._locale._week.doy;

	            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
	            week = defaults(w.w, 1);

	            if (w.d != null) {
	                // weekday -- low day numbers are considered next week
	                weekday = w.d;
	                if (weekday < 0 || weekday > 6) {
	                    weekdayOverflow = true;
	                }
	            } else if (w.e != null) {
	                // local weekday -- counting starts from begining of week
	                weekday = w.e + dow;
	                if (w.e < 0 || w.e > 6) {
	                    weekdayOverflow = true;
	                }
	            } else {
	                // default to begining of week
	                weekday = dow;
	            }
	        }
	        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
	            getParsingFlags(config)._overflowWeeks = true;
	        } else if (weekdayOverflow != null) {
	            getParsingFlags(config)._overflowWeekday = true;
	        } else {
	            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	            config._a[YEAR] = temp.year;
	            config._dayOfYear = temp.dayOfYear;
	        }
	    }

	    // constant that refers to the ISO standard
	    utils_hooks__hooks.ISO_8601 = function () {};

	    // date from string and format string
	    function configFromStringAndFormat(config) {
	        // TODO: Move this to another part of the creation flow to prevent circular deps
	        if (config._f === utils_hooks__hooks.ISO_8601) {
	            configFromISO(config);
	            return;
	        }

	        config._a = [];
	        getParsingFlags(config).empty = true;

	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var string = '' + config._i,
	            i, parsedInput, tokens, token, skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0;

	        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

	        for (i = 0; i < tokens.length; i++) {
	            token = tokens[i];
	            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	            // console.log('token', token, 'parsedInput', parsedInput,
	            //         'regex', getParseRegexForToken(token, config));
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    getParsingFlags(config).unusedInput.push(skipped);
	                }
	                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    getParsingFlags(config).empty = false;
	                }
	                else {
	                    getParsingFlags(config).unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            }
	            else if (config._strict && !parsedInput) {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	        }

	        // add remaining unparsed input length to the string
	        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            getParsingFlags(config).unusedInput.push(string);
	        }

	        // clear _12h flag if hour is <= 12
	        if (getParsingFlags(config).bigHour === true &&
	                config._a[HOUR] <= 12 &&
	                config._a[HOUR] > 0) {
	            getParsingFlags(config).bigHour = undefined;
	        }
	        // handle meridiem
	        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

	        configFromArray(config);
	        checkOverflow(config);
	    }


	    function meridiemFixWrap (locale, hour, meridiem) {
	        var isPm;

	        if (meridiem == null) {
	            // nothing to do
	            return hour;
	        }
	        if (locale.meridiemHour != null) {
	            return locale.meridiemHour(hour, meridiem);
	        } else if (locale.isPM != null) {
	            // Fallback
	            isPm = locale.isPM(meridiem);
	            if (isPm && hour < 12) {
	                hour += 12;
	            }
	            if (!isPm && hour === 12) {
	                hour = 0;
	            }
	            return hour;
	        } else {
	            // this is not supposed to happen
	            return hour;
	        }
	    }

	    // date from string and array of format strings
	    function configFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,

	            scoreToBeat,
	            i,
	            currentScore;

	        if (config._f.length === 0) {
	            getParsingFlags(config).invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }

	        for (i = 0; i < config._f.length; i++) {
	            currentScore = 0;
	            tempConfig = copyConfig({}, config);
	            if (config._useUTC != null) {
	                tempConfig._useUTC = config._useUTC;
	            }
	            tempConfig._f = config._f[i];
	            configFromStringAndFormat(tempConfig);

	            if (!valid__isValid(tempConfig)) {
	                continue;
	            }

	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += getParsingFlags(tempConfig).charsLeftOver;

	            //or tokens
	            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

	            getParsingFlags(tempConfig).score = currentScore;

	            if (scoreToBeat == null || currentScore < scoreToBeat) {
	                scoreToBeat = currentScore;
	                bestMoment = tempConfig;
	            }
	        }

	        extend(config, bestMoment || tempConfig);
	    }

	    function configFromObject(config) {
	        if (config._d) {
	            return;
	        }

	        var i = normalizeObjectUnits(config._i);
	        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
	            return obj && parseInt(obj, 10);
	        });

	        configFromArray(config);
	    }

	    function createFromConfig (config) {
	        var res = new Moment(checkOverflow(prepareConfig(config)));
	        if (res._nextDay) {
	            // Adding is smart enough around DST
	            res.add(1, 'd');
	            res._nextDay = undefined;
	        }

	        return res;
	    }

	    function prepareConfig (config) {
	        var input = config._i,
	            format = config._f;

	        config._locale = config._locale || locale_locales__getLocale(config._l);

	        if (input === null || (format === undefined && input === '')) {
	            return valid__createInvalid({nullInput: true});
	        }

	        if (typeof input === 'string') {
	            config._i = input = config._locale.preparse(input);
	        }

	        if (isMoment(input)) {
	            return new Moment(checkOverflow(input));
	        } else if (isArray(format)) {
	            configFromStringAndArray(config);
	        } else if (format) {
	            configFromStringAndFormat(config);
	        } else if (isDate(input)) {
	            config._d = input;
	        } else {
	            configFromInput(config);
	        }

	        if (!valid__isValid(config)) {
	            config._d = null;
	        }

	        return config;
	    }

	    function configFromInput(config) {
	        var input = config._i;
	        if (input === undefined) {
	            config._d = new Date(utils_hooks__hooks.now());
	        } else if (isDate(input)) {
	            config._d = new Date(+input);
	        } else if (typeof input === 'string') {
	            configFromString(config);
	        } else if (isArray(input)) {
	            config._a = map(input.slice(0), function (obj) {
	                return parseInt(obj, 10);
	            });
	            configFromArray(config);
	        } else if (typeof(input) === 'object') {
	            configFromObject(config);
	        } else if (typeof(input) === 'number') {
	            // from milliseconds
	            config._d = new Date(input);
	        } else {
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }

	    function createLocalOrUTC (input, format, locale, strict, isUTC) {
	        var c = {};

	        if (typeof(locale) === 'boolean') {
	            strict = locale;
	            locale = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c._isAMomentObject = true;
	        c._useUTC = c._isUTC = isUTC;
	        c._l = locale;
	        c._i = input;
	        c._f = format;
	        c._strict = strict;

	        return createFromConfig(c);
	    }

	    function local__createLocal (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, false);
	    }

	    var prototypeMin = deprecate(
	         'moment().min is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
	         function () {
	             var other = local__createLocal.apply(null, arguments);
	             if (this.isValid() && other.isValid()) {
	                 return other < this ? this : other;
	             } else {
	                 return valid__createInvalid();
	             }
	         }
	     );

	    var prototypeMax = deprecate(
	        'moment().max is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
	        function () {
	            var other = local__createLocal.apply(null, arguments);
	            if (this.isValid() && other.isValid()) {
	                return other > this ? this : other;
	            } else {
	                return valid__createInvalid();
	            }
	        }
	    );

	    // Pick a moment m from moments so that m[fn](other) is true for all
	    // other. This relies on the function fn to be transitive.
	    //
	    // moments should either be an array of moment objects or an array, whose
	    // first element is an array of moment objects.
	    function pickBy(fn, moments) {
	        var res, i;
	        if (moments.length === 1 && isArray(moments[0])) {
	            moments = moments[0];
	        }
	        if (!moments.length) {
	            return local__createLocal();
	        }
	        res = moments[0];
	        for (i = 1; i < moments.length; ++i) {
	            if (!moments[i].isValid() || moments[i][fn](res)) {
	                res = moments[i];
	            }
	        }
	        return res;
	    }

	    // TODO: Use [].sort instead?
	    function min () {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isBefore', args);
	    }

	    function max () {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isAfter', args);
	    }

	    var now = function () {
	        return Date.now ? Date.now() : +(new Date());
	    };

	    function Duration (duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            quarters = normalizedInput.quarter || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;

	        // representation for dateAddRemove
	        this._milliseconds = +milliseconds +
	            seconds * 1e3 + // 1000
	            minutes * 6e4 + // 1000 * 60
	            hours * 36e5; // 1000 * 60 * 60
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days +
	            weeks * 7;
	        // It is impossible translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months +
	            quarters * 3 +
	            years * 12;

	        this._data = {};

	        this._locale = locale_locales__getLocale();

	        this._bubble();
	    }

	    function isDuration (obj) {
	        return obj instanceof Duration;
	    }

	    // FORMATTING

	    function offset (token, separator) {
	        addFormatToken(token, 0, 0, function () {
	            var offset = this.utcOffset();
	            var sign = '+';
	            if (offset < 0) {
	                offset = -offset;
	                sign = '-';
	            }
	            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	        });
	    }

	    offset('Z', ':');
	    offset('ZZ', '');

	    // PARSING

	    addRegexToken('Z',  matchShortOffset);
	    addRegexToken('ZZ', matchShortOffset);
	    addParseToken(['Z', 'ZZ'], function (input, array, config) {
	        config._useUTC = true;
	        config._tzm = offsetFromString(matchShortOffset, input);
	    });

	    // HELPERS

	    // timezone chunker
	    // '+10:00' > ['10',  '00']
	    // '-1530'  > ['-15', '30']
	    var chunkOffset = /([\+\-]|\d\d)/gi;

	    function offsetFromString(matcher, string) {
	        var matches = ((string || '').match(matcher) || []);
	        var chunk   = matches[matches.length - 1] || [];
	        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	        var minutes = +(parts[1] * 60) + toInt(parts[2]);

	        return parts[0] === '+' ? minutes : -minutes;
	    }

	    // Return a moment from input, that is local/utc/zone equivalent to model.
	    function cloneWithOffset(input, model) {
	        var res, diff;
	        if (model._isUTC) {
	            res = model.clone();
	            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
	            // Use low-level api, because this fn is low-level api.
	            res._d.setTime(+res._d + diff);
	            utils_hooks__hooks.updateOffset(res, false);
	            return res;
	        } else {
	            return local__createLocal(input).local();
	        }
	    }

	    function getDateOffset (m) {
	        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	        // https://github.com/moment/moment/pull/1871
	        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	    }

	    // HOOKS

	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    utils_hooks__hooks.updateOffset = function () {};

	    // MOMENTS

	    // keepLocalTime = true means only change the timezone, without
	    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	    // +0200, so we adjust the time as needed, to be valid.
	    //
	    // Keeping the time actually adds/subtracts (one hour)
	    // from the actual represented time. That is why we call updateOffset
	    // a second time. In case it wants us to change the offset again
	    // _changeInProgress == true case, then we have to adjust, because
	    // there is no such time in the given timezone.
	    function getSetOffset (input, keepLocalTime) {
	        var offset = this._offset || 0,
	            localAdjust;
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        if (input != null) {
	            if (typeof input === 'string') {
	                input = offsetFromString(matchShortOffset, input);
	            } else if (Math.abs(input) < 16) {
	                input = input * 60;
	            }
	            if (!this._isUTC && keepLocalTime) {
	                localAdjust = getDateOffset(this);
	            }
	            this._offset = input;
	            this._isUTC = true;
	            if (localAdjust != null) {
	                this.add(localAdjust, 'm');
	            }
	            if (offset !== input) {
	                if (!keepLocalTime || this._changeInProgress) {
	                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
	                } else if (!this._changeInProgress) {
	                    this._changeInProgress = true;
	                    utils_hooks__hooks.updateOffset(this, true);
	                    this._changeInProgress = null;
	                }
	            }
	            return this;
	        } else {
	            return this._isUTC ? offset : getDateOffset(this);
	        }
	    }

	    function getSetZone (input, keepLocalTime) {
	        if (input != null) {
	            if (typeof input !== 'string') {
	                input = -input;
	            }

	            this.utcOffset(input, keepLocalTime);

	            return this;
	        } else {
	            return -this.utcOffset();
	        }
	    }

	    function setOffsetToUTC (keepLocalTime) {
	        return this.utcOffset(0, keepLocalTime);
	    }

	    function setOffsetToLocal (keepLocalTime) {
	        if (this._isUTC) {
	            this.utcOffset(0, keepLocalTime);
	            this._isUTC = false;

	            if (keepLocalTime) {
	                this.subtract(getDateOffset(this), 'm');
	            }
	        }
	        return this;
	    }

	    function setOffsetToParsedOffset () {
	        if (this._tzm) {
	            this.utcOffset(this._tzm);
	        } else if (typeof this._i === 'string') {
	            this.utcOffset(offsetFromString(matchOffset, this._i));
	        }
	        return this;
	    }

	    function hasAlignedHourOffset (input) {
	        if (!this.isValid()) {
	            return false;
	        }
	        input = input ? local__createLocal(input).utcOffset() : 0;

	        return (this.utcOffset() - input) % 60 === 0;
	    }

	    function isDaylightSavingTime () {
	        return (
	            this.utcOffset() > this.clone().month(0).utcOffset() ||
	            this.utcOffset() > this.clone().month(5).utcOffset()
	        );
	    }

	    function isDaylightSavingTimeShifted () {
	        if (!isUndefined(this._isDSTShifted)) {
	            return this._isDSTShifted;
	        }

	        var c = {};

	        copyConfig(c, this);
	        c = prepareConfig(c);

	        if (c._a) {
	            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
	            this._isDSTShifted = this.isValid() &&
	                compareArrays(c._a, other.toArray()) > 0;
	        } else {
	            this._isDSTShifted = false;
	        }

	        return this._isDSTShifted;
	    }

	    function isLocal () {
	        return this.isValid() ? !this._isUTC : false;
	    }

	    function isUtcOffset () {
	        return this.isValid() ? this._isUTC : false;
	    }

	    function isUtc () {
	        return this.isValid() ? this._isUTC && this._offset === 0 : false;
	    }

	    // ASP.NET json date format regex
	    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;

	    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	    // and further modified to allow for strings containing both week and day
	    var isoRegex = /^(-)?P(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)W)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?$/;

	    function create__createDuration (input, key) {
	        var duration = input,
	            // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            diffRes;

	        if (isDuration(input)) {
	            duration = {
	                ms : input._milliseconds,
	                d  : input._days,
	                M  : input._months
	            };
	        } else if (typeof input === 'number') {
	            duration = {};
	            if (key) {
	                duration[key] = input;
	            } else {
	                duration.milliseconds = input;
	            }
	        } else if (!!(match = aspNetRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y  : 0,
	                d  : toInt(match[DATE])        * sign,
	                h  : toInt(match[HOUR])        * sign,
	                m  : toInt(match[MINUTE])      * sign,
	                s  : toInt(match[SECOND])      * sign,
	                ms : toInt(match[MILLISECOND]) * sign
	            };
	        } else if (!!(match = isoRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y : parseIso(match[2], sign),
	                M : parseIso(match[3], sign),
	                w : parseIso(match[4], sign),
	                d : parseIso(match[5], sign),
	                h : parseIso(match[6], sign),
	                m : parseIso(match[7], sign),
	                s : parseIso(match[8], sign)
	            };
	        } else if (duration == null) {// checks for null or undefined
	            duration = {};
	        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
	            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

	            duration = {};
	            duration.ms = diffRes.milliseconds;
	            duration.M = diffRes.months;
	        }

	        ret = new Duration(duration);

	        if (isDuration(input) && hasOwnProp(input, '_locale')) {
	            ret._locale = input._locale;
	        }

	        return ret;
	    }

	    create__createDuration.fn = Duration.prototype;

	    function parseIso (inp, sign) {
	        // We'd normally use ~~inp for this, but unfortunately it also
	        // converts floats to ints.
	        // inp may be undefined, so careful calling replace on it.
	        var res = inp && parseFloat(inp.replace(',', '.'));
	        // apply sign while we're at it
	        return (isNaN(res) ? 0 : res) * sign;
	    }

	    function positiveMomentsDifference(base, other) {
	        var res = {milliseconds: 0, months: 0};

	        res.months = other.month() - base.month() +
	            (other.year() - base.year()) * 12;
	        if (base.clone().add(res.months, 'M').isAfter(other)) {
	            --res.months;
	        }

	        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

	        return res;
	    }

	    function momentsDifference(base, other) {
	        var res;
	        if (!(base.isValid() && other.isValid())) {
	            return {milliseconds: 0, months: 0};
	        }

	        other = cloneWithOffset(other, base);
	        if (base.isBefore(other)) {
	            res = positiveMomentsDifference(base, other);
	        } else {
	            res = positiveMomentsDifference(other, base);
	            res.milliseconds = -res.milliseconds;
	            res.months = -res.months;
	        }

	        return res;
	    }

	    function absRound (number) {
	        if (number < 0) {
	            return Math.round(-1 * number) * -1;
	        } else {
	            return Math.round(number);
	        }
	    }

	    // TODO: remove 'name' arg after deprecation is removed
	    function createAdder(direction, name) {
	        return function (val, period) {
	            var dur, tmp;
	            //invert the arguments, but complain about it
	            if (period !== null && !isNaN(+period)) {
	                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
	                tmp = val; val = period; period = tmp;
	            }

	            val = typeof val === 'string' ? +val : val;
	            dur = create__createDuration(val, period);
	            add_subtract__addSubtract(this, dur, direction);
	            return this;
	        };
	    }

	    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = absRound(duration._days),
	            months = absRound(duration._months);

	        if (!mom.isValid()) {
	            // No op
	            return;
	        }

	        updateOffset = updateOffset == null ? true : updateOffset;

	        if (milliseconds) {
	            mom._d.setTime(+mom._d + milliseconds * isAdding);
	        }
	        if (days) {
	            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
	        }
	        if (months) {
	            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
	        }
	        if (updateOffset) {
	            utils_hooks__hooks.updateOffset(mom, days || months);
	        }
	    }

	    var add_subtract__add      = createAdder(1, 'add');
	    var add_subtract__subtract = createAdder(-1, 'subtract');

	    function moment_calendar__calendar (time, formats) {
	        // We want to compare the start of today, vs this.
	        // Getting start-of-today depends on whether we're local/utc/offset or not.
	        var now = time || local__createLocal(),
	            sod = cloneWithOffset(now, this).startOf('day'),
	            diff = this.diff(sod, 'days', true),
	            format = diff < -6 ? 'sameElse' :
	                diff < -1 ? 'lastWeek' :
	                diff < 0 ? 'lastDay' :
	                diff < 1 ? 'sameDay' :
	                diff < 2 ? 'nextDay' :
	                diff < 7 ? 'nextWeek' : 'sameElse';

	        var output = formats && (isFunction(formats[format]) ? formats[format]() : formats[format]);

	        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
	    }

	    function clone () {
	        return new Moment(this);
	    }

	    function isAfter (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	        if (units === 'millisecond') {
	            return +this > +localInput;
	        } else {
	            return +localInput < +this.clone().startOf(units);
	        }
	    }

	    function isBefore (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	        if (units === 'millisecond') {
	            return +this < +localInput;
	        } else {
	            return +this.clone().endOf(units) < +localInput;
	        }
	    }

	    function isBetween (from, to, units) {
	        return this.isAfter(from, units) && this.isBefore(to, units);
	    }

	    function isSame (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input),
	            inputMs;
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(units || 'millisecond');
	        if (units === 'millisecond') {
	            return +this === +localInput;
	        } else {
	            inputMs = +localInput;
	            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
	        }
	    }

	    function isSameOrAfter (input, units) {
	        return this.isSame(input, units) || this.isAfter(input,units);
	    }

	    function isSameOrBefore (input, units) {
	        return this.isSame(input, units) || this.isBefore(input,units);
	    }

	    function diff (input, units, asFloat) {
	        var that,
	            zoneDelta,
	            delta, output;

	        if (!this.isValid()) {
	            return NaN;
	        }

	        that = cloneWithOffset(input, this);

	        if (!that.isValid()) {
	            return NaN;
	        }

	        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

	        units = normalizeUnits(units);

	        if (units === 'year' || units === 'month' || units === 'quarter') {
	            output = monthDiff(this, that);
	            if (units === 'quarter') {
	                output = output / 3;
	            } else if (units === 'year') {
	                output = output / 12;
	            }
	        } else {
	            delta = this - that;
	            output = units === 'second' ? delta / 1e3 : // 1000
	                units === 'minute' ? delta / 6e4 : // 1000 * 60
	                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
	                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	                delta;
	        }
	        return asFloat ? output : absFloor(output);
	    }

	    function monthDiff (a, b) {
	        // difference in months
	        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	            // b is in (anchor - 1 month, anchor + 1 month)
	            anchor = a.clone().add(wholeMonthDiff, 'months'),
	            anchor2, adjust;

	        if (b - anchor < 0) {
	            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor - anchor2);
	        } else {
	            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor2 - anchor);
	        }

	        return -(wholeMonthDiff + adjust);
	    }

	    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

	    function toString () {
	        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	    }

	    function moment_format__toISOString () {
	        var m = this.clone().utc();
	        if (0 < m.year() && m.year() <= 9999) {
	            if (isFunction(Date.prototype.toISOString)) {
	                // native implementation is ~50x faster, use it when we can
	                return this.toDate().toISOString();
	            } else {
	                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	            }
	        } else {
	            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	        }
	    }

	    function format (inputString) {
	        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
	        return this.localeData().postformat(output);
	    }

	    function from (time, withoutSuffix) {
	        if (this.isValid() &&
	                ((isMoment(time) && time.isValid()) ||
	                 local__createLocal(time).isValid())) {
	            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }

	    function fromNow (withoutSuffix) {
	        return this.from(local__createLocal(), withoutSuffix);
	    }

	    function to (time, withoutSuffix) {
	        if (this.isValid() &&
	                ((isMoment(time) && time.isValid()) ||
	                 local__createLocal(time).isValid())) {
	            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }

	    function toNow (withoutSuffix) {
	        return this.to(local__createLocal(), withoutSuffix);
	    }

	    // If passed a locale key, it will set the locale for this
	    // instance.  Otherwise, it will return the locale configuration
	    // variables for this instance.
	    function locale (key) {
	        var newLocaleData;

	        if (key === undefined) {
	            return this._locale._abbr;
	        } else {
	            newLocaleData = locale_locales__getLocale(key);
	            if (newLocaleData != null) {
	                this._locale = newLocaleData;
	            }
	            return this;
	        }
	    }

	    var lang = deprecate(
	        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	        function (key) {
	            if (key === undefined) {
	                return this.localeData();
	            } else {
	                return this.locale(key);
	            }
	        }
	    );

	    function localeData () {
	        return this._locale;
	    }

	    function startOf (units) {
	        units = normalizeUnits(units);
	        // the following switch intentionally omits break keywords
	        // to utilize falling through the cases.
	        switch (units) {
	        case 'year':
	            this.month(0);
	            /* falls through */
	        case 'quarter':
	        case 'month':
	            this.date(1);
	            /* falls through */
	        case 'week':
	        case 'isoWeek':
	        case 'day':
	            this.hours(0);
	            /* falls through */
	        case 'hour':
	            this.minutes(0);
	            /* falls through */
	        case 'minute':
	            this.seconds(0);
	            /* falls through */
	        case 'second':
	            this.milliseconds(0);
	        }

	        // weeks are a special case
	        if (units === 'week') {
	            this.weekday(0);
	        }
	        if (units === 'isoWeek') {
	            this.isoWeekday(1);
	        }

	        // quarters are also special
	        if (units === 'quarter') {
	            this.month(Math.floor(this.month() / 3) * 3);
	        }

	        return this;
	    }

	    function endOf (units) {
	        units = normalizeUnits(units);
	        if (units === undefined || units === 'millisecond') {
	            return this;
	        }
	        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	    }

	    function to_type__valueOf () {
	        return +this._d - ((this._offset || 0) * 60000);
	    }

	    function unix () {
	        return Math.floor(+this / 1000);
	    }

	    function toDate () {
	        return this._offset ? new Date(+this) : this._d;
	    }

	    function toArray () {
	        var m = this;
	        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	    }

	    function toObject () {
	        var m = this;
	        return {
	            years: m.year(),
	            months: m.month(),
	            date: m.date(),
	            hours: m.hours(),
	            minutes: m.minutes(),
	            seconds: m.seconds(),
	            milliseconds: m.milliseconds()
	        };
	    }

	    function toJSON () {
	        // new Date(NaN).toJSON() === null
	        return this.isValid() ? this.toISOString() : null;
	    }

	    function moment_valid__isValid () {
	        return valid__isValid(this);
	    }

	    function parsingFlags () {
	        return extend({}, getParsingFlags(this));
	    }

	    function invalidAt () {
	        return getParsingFlags(this).overflow;
	    }

	    function creationData() {
	        return {
	            input: this._i,
	            format: this._f,
	            locale: this._locale,
	            isUTC: this._isUTC,
	            strict: this._strict
	        };
	    }

	    // FORMATTING

	    addFormatToken(0, ['gg', 2], 0, function () {
	        return this.weekYear() % 100;
	    });

	    addFormatToken(0, ['GG', 2], 0, function () {
	        return this.isoWeekYear() % 100;
	    });

	    function addWeekYearFormatToken (token, getter) {
	        addFormatToken(0, [token, token.length], 0, getter);
	    }

	    addWeekYearFormatToken('gggg',     'weekYear');
	    addWeekYearFormatToken('ggggg',    'weekYear');
	    addWeekYearFormatToken('GGGG',  'isoWeekYear');
	    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

	    // ALIASES

	    addUnitAlias('weekYear', 'gg');
	    addUnitAlias('isoWeekYear', 'GG');

	    // PARSING

	    addRegexToken('G',      matchSigned);
	    addRegexToken('g',      matchSigned);
	    addRegexToken('GG',     match1to2, match2);
	    addRegexToken('gg',     match1to2, match2);
	    addRegexToken('GGGG',   match1to4, match4);
	    addRegexToken('gggg',   match1to4, match4);
	    addRegexToken('GGGGG',  match1to6, match6);
	    addRegexToken('ggggg',  match1to6, match6);

	    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	        week[token.substr(0, 2)] = toInt(input);
	    });

	    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });

	    // MOMENTS

	    function getSetWeekYear (input) {
	        return getSetWeekYearHelper.call(this,
	                input,
	                this.week(),
	                this.weekday(),
	                this.localeData()._week.dow,
	                this.localeData()._week.doy);
	    }

	    function getSetISOWeekYear (input) {
	        return getSetWeekYearHelper.call(this,
	                input, this.isoWeek(), this.isoWeekday(), 1, 4);
	    }

	    function getISOWeeksInYear () {
	        return weeksInYear(this.year(), 1, 4);
	    }

	    function getWeeksInYear () {
	        var weekInfo = this.localeData()._week;
	        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	    }

	    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	        var weeksTarget;
	        if (input == null) {
	            return weekOfYear(this, dow, doy).year;
	        } else {
	            weeksTarget = weeksInYear(input, dow, doy);
	            if (week > weeksTarget) {
	                week = weeksTarget;
	            }
	            return setWeekAll.call(this, input, week, weekday, dow, doy);
	        }
	    }

	    function setWeekAll(weekYear, week, weekday, dow, doy) {
	        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

	        this.year(date.getUTCFullYear());
	        this.month(date.getUTCMonth());
	        this.date(date.getUTCDate());
	        return this;
	    }

	    // FORMATTING

	    addFormatToken('Q', 0, 'Qo', 'quarter');

	    // ALIASES

	    addUnitAlias('quarter', 'Q');

	    // PARSING

	    addRegexToken('Q', match1);
	    addParseToken('Q', function (input, array) {
	        array[MONTH] = (toInt(input) - 1) * 3;
	    });

	    // MOMENTS

	    function getSetQuarter (input) {
	        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	    }

	    // FORMATTING

	    addFormatToken('w', ['ww', 2], 'wo', 'week');
	    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

	    // ALIASES

	    addUnitAlias('week', 'w');
	    addUnitAlias('isoWeek', 'W');

	    // PARSING

	    addRegexToken('w',  match1to2);
	    addRegexToken('ww', match1to2, match2);
	    addRegexToken('W',  match1to2);
	    addRegexToken('WW', match1to2, match2);

	    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	        week[token.substr(0, 1)] = toInt(input);
	    });

	    // HELPERS

	    // LOCALES

	    function localeWeek (mom) {
	        return weekOfYear(mom, this._week.dow, this._week.doy).week;
	    }

	    var defaultLocaleWeek = {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    };

	    function localeFirstDayOfWeek () {
	        return this._week.dow;
	    }

	    function localeFirstDayOfYear () {
	        return this._week.doy;
	    }

	    // MOMENTS

	    function getSetWeek (input) {
	        var week = this.localeData().week(this);
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }

	    function getSetISOWeek (input) {
	        var week = weekOfYear(this, 1, 4).week;
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }

	    // FORMATTING

	    addFormatToken('D', ['DD', 2], 'Do', 'date');

	    // ALIASES

	    addUnitAlias('date', 'D');

	    // PARSING

	    addRegexToken('D',  match1to2);
	    addRegexToken('DD', match1to2, match2);
	    addRegexToken('Do', function (isStrict, locale) {
	        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
	    });

	    addParseToken(['D', 'DD'], DATE);
	    addParseToken('Do', function (input, array) {
	        array[DATE] = toInt(input.match(match1to2)[0], 10);
	    });

	    // MOMENTS

	    var getSetDayOfMonth = makeGetSet('Date', true);

	    // FORMATTING

	    addFormatToken('d', 0, 'do', 'day');

	    addFormatToken('dd', 0, 0, function (format) {
	        return this.localeData().weekdaysMin(this, format);
	    });

	    addFormatToken('ddd', 0, 0, function (format) {
	        return this.localeData().weekdaysShort(this, format);
	    });

	    addFormatToken('dddd', 0, 0, function (format) {
	        return this.localeData().weekdays(this, format);
	    });

	    addFormatToken('e', 0, 0, 'weekday');
	    addFormatToken('E', 0, 0, 'isoWeekday');

	    // ALIASES

	    addUnitAlias('day', 'd');
	    addUnitAlias('weekday', 'e');
	    addUnitAlias('isoWeekday', 'E');

	    // PARSING

	    addRegexToken('d',    match1to2);
	    addRegexToken('e',    match1to2);
	    addRegexToken('E',    match1to2);
	    addRegexToken('dd',   matchWord);
	    addRegexToken('ddd',  matchWord);
	    addRegexToken('dddd', matchWord);

	    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
	        var weekday = config._locale.weekdaysParse(input, token, config._strict);
	        // if we didn't get a weekday name, mark the date as invalid
	        if (weekday != null) {
	            week.d = weekday;
	        } else {
	            getParsingFlags(config).invalidWeekday = input;
	        }
	    });

	    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	        week[token] = toInt(input);
	    });

	    // HELPERS

	    function parseWeekday(input, locale) {
	        if (typeof input !== 'string') {
	            return input;
	        }

	        if (!isNaN(input)) {
	            return parseInt(input, 10);
	        }

	        input = locale.weekdaysParse(input);
	        if (typeof input === 'number') {
	            return input;
	        }

	        return null;
	    }

	    // LOCALES

	    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	    function localeWeekdays (m, format) {
	        return isArray(this._weekdays) ? this._weekdays[m.day()] :
	            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
	    }

	    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	    function localeWeekdaysShort (m) {
	        return this._weekdaysShort[m.day()];
	    }

	    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	    function localeWeekdaysMin (m) {
	        return this._weekdaysMin[m.day()];
	    }

	    function localeWeekdaysParse (weekdayName, format, strict) {
	        var i, mom, regex;

	        if (!this._weekdaysParse) {
	            this._weekdaysParse = [];
	            this._minWeekdaysParse = [];
	            this._shortWeekdaysParse = [];
	            this._fullWeekdaysParse = [];
	        }

	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already

	            mom = local__createLocal([2000, 1]).day(i);
	            if (strict && !this._fullWeekdaysParse[i]) {
	                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
	                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
	                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
	            }
	            if (!this._weekdaysParse[i]) {
	                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
	                return i;
	            }
	        }
	    }

	    // MOMENTS

	    function getSetDayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	        if (input != null) {
	            input = parseWeekday(input, this.localeData());
	            return this.add(input - day, 'd');
	        } else {
	            return day;
	        }
	    }

	    function getSetLocaleDayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	        return input == null ? weekday : this.add(input - weekday, 'd');
	    }

	    function getSetISODayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        // behaves the same as moment#day except
	        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	        // as a setter, sunday should belong to the previous week.
	        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
	    }

	    // FORMATTING

	    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

	    // ALIASES

	    addUnitAlias('dayOfYear', 'DDD');

	    // PARSING

	    addRegexToken('DDD',  match1to3);
	    addRegexToken('DDDD', match3);
	    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	        config._dayOfYear = toInt(input);
	    });

	    // HELPERS

	    // MOMENTS

	    function getSetDayOfYear (input) {
	        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	    }

	    // FORMATTING

	    function hFormat() {
	        return this.hours() % 12 || 12;
	    }

	    addFormatToken('H', ['HH', 2], 0, 'hour');
	    addFormatToken('h', ['hh', 2], 0, hFormat);

	    addFormatToken('hmm', 0, 0, function () {
	        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	    });

	    addFormatToken('hmmss', 0, 0, function () {
	        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2);
	    });

	    addFormatToken('Hmm', 0, 0, function () {
	        return '' + this.hours() + zeroFill(this.minutes(), 2);
	    });

	    addFormatToken('Hmmss', 0, 0, function () {
	        return '' + this.hours() + zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2);
	    });

	    function meridiem (token, lowercase) {
	        addFormatToken(token, 0, 0, function () {
	            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	        });
	    }

	    meridiem('a', true);
	    meridiem('A', false);

	    // ALIASES

	    addUnitAlias('hour', 'h');

	    // PARSING

	    function matchMeridiem (isStrict, locale) {
	        return locale._meridiemParse;
	    }

	    addRegexToken('a',  matchMeridiem);
	    addRegexToken('A',  matchMeridiem);
	    addRegexToken('H',  match1to2);
	    addRegexToken('h',  match1to2);
	    addRegexToken('HH', match1to2, match2);
	    addRegexToken('hh', match1to2, match2);

	    addRegexToken('hmm', match3to4);
	    addRegexToken('hmmss', match5to6);
	    addRegexToken('Hmm', match3to4);
	    addRegexToken('Hmmss', match5to6);

	    addParseToken(['H', 'HH'], HOUR);
	    addParseToken(['a', 'A'], function (input, array, config) {
	        config._isPm = config._locale.isPM(input);
	        config._meridiem = input;
	    });
	    addParseToken(['h', 'hh'], function (input, array, config) {
	        array[HOUR] = toInt(input);
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmmss', function (input, array, config) {
	        var pos1 = input.length - 4;
	        var pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('Hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	    });
	    addParseToken('Hmmss', function (input, array, config) {
	        var pos1 = input.length - 4;
	        var pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	    });

	    // LOCALES

	    function localeIsPM (input) {
	        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	        // Using charAt should be more compatible.
	        return ((input + '').toLowerCase().charAt(0) === 'p');
	    }

	    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	    function localeMeridiem (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'pm' : 'PM';
	        } else {
	            return isLower ? 'am' : 'AM';
	        }
	    }


	    // MOMENTS

	    // Setting the hour should keep the time, because the user explicitly
	    // specified which hour he wants. So trying to maintain the same hour (in
	    // a new timezone) makes sense. Adding/subtracting hours does not follow
	    // this rule.
	    var getSetHour = makeGetSet('Hours', true);

	    // FORMATTING

	    addFormatToken('m', ['mm', 2], 0, 'minute');

	    // ALIASES

	    addUnitAlias('minute', 'm');

	    // PARSING

	    addRegexToken('m',  match1to2);
	    addRegexToken('mm', match1to2, match2);
	    addParseToken(['m', 'mm'], MINUTE);

	    // MOMENTS

	    var getSetMinute = makeGetSet('Minutes', false);

	    // FORMATTING

	    addFormatToken('s', ['ss', 2], 0, 'second');

	    // ALIASES

	    addUnitAlias('second', 's');

	    // PARSING

	    addRegexToken('s',  match1to2);
	    addRegexToken('ss', match1to2, match2);
	    addParseToken(['s', 'ss'], SECOND);

	    // MOMENTS

	    var getSetSecond = makeGetSet('Seconds', false);

	    // FORMATTING

	    addFormatToken('S', 0, 0, function () {
	        return ~~(this.millisecond() / 100);
	    });

	    addFormatToken(0, ['SS', 2], 0, function () {
	        return ~~(this.millisecond() / 10);
	    });

	    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	    addFormatToken(0, ['SSSS', 4], 0, function () {
	        return this.millisecond() * 10;
	    });
	    addFormatToken(0, ['SSSSS', 5], 0, function () {
	        return this.millisecond() * 100;
	    });
	    addFormatToken(0, ['SSSSSS', 6], 0, function () {
	        return this.millisecond() * 1000;
	    });
	    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	        return this.millisecond() * 10000;
	    });
	    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	        return this.millisecond() * 100000;
	    });
	    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	        return this.millisecond() * 1000000;
	    });


	    // ALIASES

	    addUnitAlias('millisecond', 'ms');

	    // PARSING

	    addRegexToken('S',    match1to3, match1);
	    addRegexToken('SS',   match1to3, match2);
	    addRegexToken('SSS',  match1to3, match3);

	    var token;
	    for (token = 'SSSS'; token.length <= 9; token += 'S') {
	        addRegexToken(token, matchUnsigned);
	    }

	    function parseMs(input, array) {
	        array[MILLISECOND] = toInt(('0.' + input) * 1000);
	    }

	    for (token = 'S'; token.length <= 9; token += 'S') {
	        addParseToken(token, parseMs);
	    }
	    // MOMENTS

	    var getSetMillisecond = makeGetSet('Milliseconds', false);

	    // FORMATTING

	    addFormatToken('z',  0, 0, 'zoneAbbr');
	    addFormatToken('zz', 0, 0, 'zoneName');

	    // MOMENTS

	    function getZoneAbbr () {
	        return this._isUTC ? 'UTC' : '';
	    }

	    function getZoneName () {
	        return this._isUTC ? 'Coordinated Universal Time' : '';
	    }

	    var momentPrototype__proto = Moment.prototype;

	    momentPrototype__proto.add               = add_subtract__add;
	    momentPrototype__proto.calendar          = moment_calendar__calendar;
	    momentPrototype__proto.clone             = clone;
	    momentPrototype__proto.diff              = diff;
	    momentPrototype__proto.endOf             = endOf;
	    momentPrototype__proto.format            = format;
	    momentPrototype__proto.from              = from;
	    momentPrototype__proto.fromNow           = fromNow;
	    momentPrototype__proto.to                = to;
	    momentPrototype__proto.toNow             = toNow;
	    momentPrototype__proto.get               = getSet;
	    momentPrototype__proto.invalidAt         = invalidAt;
	    momentPrototype__proto.isAfter           = isAfter;
	    momentPrototype__proto.isBefore          = isBefore;
	    momentPrototype__proto.isBetween         = isBetween;
	    momentPrototype__proto.isSame            = isSame;
	    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
	    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
	    momentPrototype__proto.isValid           = moment_valid__isValid;
	    momentPrototype__proto.lang              = lang;
	    momentPrototype__proto.locale            = locale;
	    momentPrototype__proto.localeData        = localeData;
	    momentPrototype__proto.max               = prototypeMax;
	    momentPrototype__proto.min               = prototypeMin;
	    momentPrototype__proto.parsingFlags      = parsingFlags;
	    momentPrototype__proto.set               = getSet;
	    momentPrototype__proto.startOf           = startOf;
	    momentPrototype__proto.subtract          = add_subtract__subtract;
	    momentPrototype__proto.toArray           = toArray;
	    momentPrototype__proto.toObject          = toObject;
	    momentPrototype__proto.toDate            = toDate;
	    momentPrototype__proto.toISOString       = moment_format__toISOString;
	    momentPrototype__proto.toJSON            = toJSON;
	    momentPrototype__proto.toString          = toString;
	    momentPrototype__proto.unix              = unix;
	    momentPrototype__proto.valueOf           = to_type__valueOf;
	    momentPrototype__proto.creationData      = creationData;

	    // Year
	    momentPrototype__proto.year       = getSetYear;
	    momentPrototype__proto.isLeapYear = getIsLeapYear;

	    // Week Year
	    momentPrototype__proto.weekYear    = getSetWeekYear;
	    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

	    // Quarter
	    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

	    // Month
	    momentPrototype__proto.month       = getSetMonth;
	    momentPrototype__proto.daysInMonth = getDaysInMonth;

	    // Week
	    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
	    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
	    momentPrototype__proto.weeksInYear    = getWeeksInYear;
	    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

	    // Day
	    momentPrototype__proto.date       = getSetDayOfMonth;
	    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
	    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
	    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
	    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

	    // Hour
	    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

	    // Minute
	    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

	    // Second
	    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

	    // Millisecond
	    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

	    // Offset
	    momentPrototype__proto.utcOffset            = getSetOffset;
	    momentPrototype__proto.utc                  = setOffsetToUTC;
	    momentPrototype__proto.local                = setOffsetToLocal;
	    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
	    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
	    momentPrototype__proto.isDST                = isDaylightSavingTime;
	    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
	    momentPrototype__proto.isLocal              = isLocal;
	    momentPrototype__proto.isUtcOffset          = isUtcOffset;
	    momentPrototype__proto.isUtc                = isUtc;
	    momentPrototype__proto.isUTC                = isUtc;

	    // Timezone
	    momentPrototype__proto.zoneAbbr = getZoneAbbr;
	    momentPrototype__proto.zoneName = getZoneName;

	    // Deprecations
	    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

	    var momentPrototype = momentPrototype__proto;

	    function moment__createUnix (input) {
	        return local__createLocal(input * 1000);
	    }

	    function moment__createInZone () {
	        return local__createLocal.apply(null, arguments).parseZone();
	    }

	    var defaultCalendar = {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    };

	    function locale_calendar__calendar (key, mom, now) {
	        var output = this._calendar[key];
	        return isFunction(output) ? output.call(mom, now) : output;
	    }

	    var defaultLongDateFormat = {
	        LTS  : 'h:mm:ss A',
	        LT   : 'h:mm A',
	        L    : 'MM/DD/YYYY',
	        LL   : 'MMMM D, YYYY',
	        LLL  : 'MMMM D, YYYY h:mm A',
	        LLLL : 'dddd, MMMM D, YYYY h:mm A'
	    };

	    function longDateFormat (key) {
	        var format = this._longDateFormat[key],
	            formatUpper = this._longDateFormat[key.toUpperCase()];

	        if (format || !formatUpper) {
	            return format;
	        }

	        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	            return val.slice(1);
	        });

	        return this._longDateFormat[key];
	    }

	    var defaultInvalidDate = 'Invalid date';

	    function invalidDate () {
	        return this._invalidDate;
	    }

	    var defaultOrdinal = '%d';
	    var defaultOrdinalParse = /\d{1,2}/;

	    function ordinal (number) {
	        return this._ordinal.replace('%d', number);
	    }

	    function preParsePostFormat (string) {
	        return string;
	    }

	    var defaultRelativeTime = {
	        future : 'in %s',
	        past   : '%s ago',
	        s  : 'a few seconds',
	        m  : 'a minute',
	        mm : '%d minutes',
	        h  : 'an hour',
	        hh : '%d hours',
	        d  : 'a day',
	        dd : '%d days',
	        M  : 'a month',
	        MM : '%d months',
	        y  : 'a year',
	        yy : '%d years'
	    };

	    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
	        var output = this._relativeTime[string];
	        return (isFunction(output)) ?
	            output(number, withoutSuffix, string, isFuture) :
	            output.replace(/%d/i, number);
	    }

	    function pastFuture (diff, output) {
	        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	    }

	    var prototype__proto = Locale.prototype;

	    prototype__proto._calendar       = defaultCalendar;
	    prototype__proto.calendar        = locale_calendar__calendar;
	    prototype__proto._longDateFormat = defaultLongDateFormat;
	    prototype__proto.longDateFormat  = longDateFormat;
	    prototype__proto._invalidDate    = defaultInvalidDate;
	    prototype__proto.invalidDate     = invalidDate;
	    prototype__proto._ordinal        = defaultOrdinal;
	    prototype__proto.ordinal         = ordinal;
	    prototype__proto._ordinalParse   = defaultOrdinalParse;
	    prototype__proto.preparse        = preParsePostFormat;
	    prototype__proto.postformat      = preParsePostFormat;
	    prototype__proto._relativeTime   = defaultRelativeTime;
	    prototype__proto.relativeTime    = relative__relativeTime;
	    prototype__proto.pastFuture      = pastFuture;
	    prototype__proto.set             = locale_set__set;

	    // Month
	    prototype__proto.months            =        localeMonths;
	    prototype__proto._months           = defaultLocaleMonths;
	    prototype__proto.monthsShort       =        localeMonthsShort;
	    prototype__proto._monthsShort      = defaultLocaleMonthsShort;
	    prototype__proto.monthsParse       =        localeMonthsParse;
	    prototype__proto._monthsRegex      = defaultMonthsRegex;
	    prototype__proto.monthsRegex       = monthsRegex;
	    prototype__proto._monthsShortRegex = defaultMonthsShortRegex;
	    prototype__proto.monthsShortRegex  = monthsShortRegex;

	    // Week
	    prototype__proto.week = localeWeek;
	    prototype__proto._week = defaultLocaleWeek;
	    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
	    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

	    // Day of Week
	    prototype__proto.weekdays       =        localeWeekdays;
	    prototype__proto._weekdays      = defaultLocaleWeekdays;
	    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
	    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
	    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
	    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
	    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

	    // Hours
	    prototype__proto.isPM = localeIsPM;
	    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
	    prototype__proto.meridiem = localeMeridiem;

	    function lists__get (format, index, field, setter) {
	        var locale = locale_locales__getLocale();
	        var utc = create_utc__createUTC().set(setter, index);
	        return locale[field](utc, format);
	    }

	    function list (format, index, field, count, setter) {
	        if (typeof format === 'number') {
	            index = format;
	            format = undefined;
	        }

	        format = format || '';

	        if (index != null) {
	            return lists__get(format, index, field, setter);
	        }

	        var i;
	        var out = [];
	        for (i = 0; i < count; i++) {
	            out[i] = lists__get(format, i, field, setter);
	        }
	        return out;
	    }

	    function lists__listMonths (format, index) {
	        return list(format, index, 'months', 12, 'month');
	    }

	    function lists__listMonthsShort (format, index) {
	        return list(format, index, 'monthsShort', 12, 'month');
	    }

	    function lists__listWeekdays (format, index) {
	        return list(format, index, 'weekdays', 7, 'day');
	    }

	    function lists__listWeekdaysShort (format, index) {
	        return list(format, index, 'weekdaysShort', 7, 'day');
	    }

	    function lists__listWeekdaysMin (format, index) {
	        return list(format, index, 'weekdaysMin', 7, 'day');
	    }

	    locale_locales__getSetGlobalLocale('en', {
	        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (toInt(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });

	    // Side effect imports
	    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
	    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

	    var mathAbs = Math.abs;

	    function duration_abs__abs () {
	        var data           = this._data;

	        this._milliseconds = mathAbs(this._milliseconds);
	        this._days         = mathAbs(this._days);
	        this._months       = mathAbs(this._months);

	        data.milliseconds  = mathAbs(data.milliseconds);
	        data.seconds       = mathAbs(data.seconds);
	        data.minutes       = mathAbs(data.minutes);
	        data.hours         = mathAbs(data.hours);
	        data.months        = mathAbs(data.months);
	        data.years         = mathAbs(data.years);

	        return this;
	    }

	    function duration_add_subtract__addSubtract (duration, input, value, direction) {
	        var other = create__createDuration(input, value);

	        duration._milliseconds += direction * other._milliseconds;
	        duration._days         += direction * other._days;
	        duration._months       += direction * other._months;

	        return duration._bubble();
	    }

	    // supports only 2.0-style add(1, 's') or add(duration)
	    function duration_add_subtract__add (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, 1);
	    }

	    // supports only 2.0-style subtract(1, 's') or subtract(duration)
	    function duration_add_subtract__subtract (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, -1);
	    }

	    function absCeil (number) {
	        if (number < 0) {
	            return Math.floor(number);
	        } else {
	            return Math.ceil(number);
	        }
	    }

	    function bubble () {
	        var milliseconds = this._milliseconds;
	        var days         = this._days;
	        var months       = this._months;
	        var data         = this._data;
	        var seconds, minutes, hours, years, monthsFromDays;

	        // if we have a mix of positive and negative values, bubble down first
	        // check: https://github.com/moment/moment/issues/2166
	        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
	                (milliseconds <= 0 && days <= 0 && months <= 0))) {
	            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	            days = 0;
	            months = 0;
	        }

	        // The following code bubbles up values, see the tests for
	        // examples of what that means.
	        data.milliseconds = milliseconds % 1000;

	        seconds           = absFloor(milliseconds / 1000);
	        data.seconds      = seconds % 60;

	        minutes           = absFloor(seconds / 60);
	        data.minutes      = minutes % 60;

	        hours             = absFloor(minutes / 60);
	        data.hours        = hours % 24;

	        days += absFloor(hours / 24);

	        // convert days to months
	        monthsFromDays = absFloor(daysToMonths(days));
	        months += monthsFromDays;
	        days -= absCeil(monthsToDays(monthsFromDays));

	        // 12 months -> 1 year
	        years = absFloor(months / 12);
	        months %= 12;

	        data.days   = days;
	        data.months = months;
	        data.years  = years;

	        return this;
	    }

	    function daysToMonths (days) {
	        // 400 years have 146097 days (taking into account leap year rules)
	        // 400 years have 12 months === 4800
	        return days * 4800 / 146097;
	    }

	    function monthsToDays (months) {
	        // the reverse of daysToMonths
	        return months * 146097 / 4800;
	    }

	    function as (units) {
	        var days;
	        var months;
	        var milliseconds = this._milliseconds;

	        units = normalizeUnits(units);

	        if (units === 'month' || units === 'year') {
	            days   = this._days   + milliseconds / 864e5;
	            months = this._months + daysToMonths(days);
	            return units === 'month' ? months : months / 12;
	        } else {
	            // handle milliseconds separately because of floating point math errors (issue #1867)
	            days = this._days + Math.round(monthsToDays(this._months));
	            switch (units) {
	                case 'week'   : return days / 7     + milliseconds / 6048e5;
	                case 'day'    : return days         + milliseconds / 864e5;
	                case 'hour'   : return days * 24    + milliseconds / 36e5;
	                case 'minute' : return days * 1440  + milliseconds / 6e4;
	                case 'second' : return days * 86400 + milliseconds / 1000;
	                // Math.floor prevents floating point math errors here
	                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
	                default: throw new Error('Unknown unit ' + units);
	            }
	        }
	    }

	    // TODO: Use this.as('ms')?
	    function duration_as__valueOf () {
	        return (
	            this._milliseconds +
	            this._days * 864e5 +
	            (this._months % 12) * 2592e6 +
	            toInt(this._months / 12) * 31536e6
	        );
	    }

	    function makeAs (alias) {
	        return function () {
	            return this.as(alias);
	        };
	    }

	    var asMilliseconds = makeAs('ms');
	    var asSeconds      = makeAs('s');
	    var asMinutes      = makeAs('m');
	    var asHours        = makeAs('h');
	    var asDays         = makeAs('d');
	    var asWeeks        = makeAs('w');
	    var asMonths       = makeAs('M');
	    var asYears        = makeAs('y');

	    function duration_get__get (units) {
	        units = normalizeUnits(units);
	        return this[units + 's']();
	    }

	    function makeGetter(name) {
	        return function () {
	            return this._data[name];
	        };
	    }

	    var milliseconds = makeGetter('milliseconds');
	    var seconds      = makeGetter('seconds');
	    var minutes      = makeGetter('minutes');
	    var hours        = makeGetter('hours');
	    var days         = makeGetter('days');
	    var months       = makeGetter('months');
	    var years        = makeGetter('years');

	    function weeks () {
	        return absFloor(this.days() / 7);
	    }

	    var round = Math.round;
	    var thresholds = {
	        s: 45,  // seconds to minute
	        m: 45,  // minutes to hour
	        h: 22,  // hours to day
	        d: 26,  // days to month
	        M: 11   // months to year
	    };

	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }

	    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
	        var duration = create__createDuration(posNegDuration).abs();
	        var seconds  = round(duration.as('s'));
	        var minutes  = round(duration.as('m'));
	        var hours    = round(duration.as('h'));
	        var days     = round(duration.as('d'));
	        var months   = round(duration.as('M'));
	        var years    = round(duration.as('y'));

	        var a = seconds < thresholds.s && ['s', seconds]  ||
	                minutes <= 1           && ['m']           ||
	                minutes < thresholds.m && ['mm', minutes] ||
	                hours   <= 1           && ['h']           ||
	                hours   < thresholds.h && ['hh', hours]   ||
	                days    <= 1           && ['d']           ||
	                days    < thresholds.d && ['dd', days]    ||
	                months  <= 1           && ['M']           ||
	                months  < thresholds.M && ['MM', months]  ||
	                years   <= 1           && ['y']           || ['yy', years];

	        a[2] = withoutSuffix;
	        a[3] = +posNegDuration > 0;
	        a[4] = locale;
	        return substituteTimeAgo.apply(null, a);
	    }

	    // This function allows you to set a threshold for relative time strings
	    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
	        if (thresholds[threshold] === undefined) {
	            return false;
	        }
	        if (limit === undefined) {
	            return thresholds[threshold];
	        }
	        thresholds[threshold] = limit;
	        return true;
	    }

	    function humanize (withSuffix) {
	        var locale = this.localeData();
	        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

	        if (withSuffix) {
	            output = locale.pastFuture(+this, output);
	        }

	        return locale.postformat(output);
	    }

	    var iso_string__abs = Math.abs;

	    function iso_string__toISOString() {
	        // for ISO strings we do not use the normal bubbling rules:
	        //  * milliseconds bubble up until they become hours
	        //  * days do not bubble at all
	        //  * months bubble up until they become years
	        // This is because there is no context-free conversion between hours and days
	        // (think of clock changes)
	        // and also not between days and months (28-31 days per month)
	        var seconds = iso_string__abs(this._milliseconds) / 1000;
	        var days         = iso_string__abs(this._days);
	        var months       = iso_string__abs(this._months);
	        var minutes, hours, years;

	        // 3600 seconds -> 60 minutes -> 1 hour
	        minutes           = absFloor(seconds / 60);
	        hours             = absFloor(minutes / 60);
	        seconds %= 60;
	        minutes %= 60;

	        // 12 months -> 1 year
	        years  = absFloor(months / 12);
	        months %= 12;


	        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	        var Y = years;
	        var M = months;
	        var D = days;
	        var h = hours;
	        var m = minutes;
	        var s = seconds;
	        var total = this.asSeconds();

	        if (!total) {
	            // this is the same as C#'s (Noda) and python (isodate)...
	            // but not other JS (goog.date)
	            return 'P0D';
	        }

	        return (total < 0 ? '-' : '') +
	            'P' +
	            (Y ? Y + 'Y' : '') +
	            (M ? M + 'M' : '') +
	            (D ? D + 'D' : '') +
	            ((h || m || s) ? 'T' : '') +
	            (h ? h + 'H' : '') +
	            (m ? m + 'M' : '') +
	            (s ? s + 'S' : '');
	    }

	    var duration_prototype__proto = Duration.prototype;

	    duration_prototype__proto.abs            = duration_abs__abs;
	    duration_prototype__proto.add            = duration_add_subtract__add;
	    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
	    duration_prototype__proto.as             = as;
	    duration_prototype__proto.asMilliseconds = asMilliseconds;
	    duration_prototype__proto.asSeconds      = asSeconds;
	    duration_prototype__proto.asMinutes      = asMinutes;
	    duration_prototype__proto.asHours        = asHours;
	    duration_prototype__proto.asDays         = asDays;
	    duration_prototype__proto.asWeeks        = asWeeks;
	    duration_prototype__proto.asMonths       = asMonths;
	    duration_prototype__proto.asYears        = asYears;
	    duration_prototype__proto.valueOf        = duration_as__valueOf;
	    duration_prototype__proto._bubble        = bubble;
	    duration_prototype__proto.get            = duration_get__get;
	    duration_prototype__proto.milliseconds   = milliseconds;
	    duration_prototype__proto.seconds        = seconds;
	    duration_prototype__proto.minutes        = minutes;
	    duration_prototype__proto.hours          = hours;
	    duration_prototype__proto.days           = days;
	    duration_prototype__proto.weeks          = weeks;
	    duration_prototype__proto.months         = months;
	    duration_prototype__proto.years          = years;
	    duration_prototype__proto.humanize       = humanize;
	    duration_prototype__proto.toISOString    = iso_string__toISOString;
	    duration_prototype__proto.toString       = iso_string__toISOString;
	    duration_prototype__proto.toJSON         = iso_string__toISOString;
	    duration_prototype__proto.locale         = locale;
	    duration_prototype__proto.localeData     = localeData;

	    // Deprecations
	    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
	    duration_prototype__proto.lang = lang;

	    // Side effect imports

	    // FORMATTING

	    addFormatToken('X', 0, 0, 'unix');
	    addFormatToken('x', 0, 0, 'valueOf');

	    // PARSING

	    addRegexToken('x', matchSigned);
	    addRegexToken('X', matchTimestamp);
	    addParseToken('X', function (input, array, config) {
	        config._d = new Date(parseFloat(input, 10) * 1000);
	    });
	    addParseToken('x', function (input, array, config) {
	        config._d = new Date(toInt(input));
	    });

	    // Side effect imports


	    utils_hooks__hooks.version = '2.12.0';

	    setHookCallback(local__createLocal);

	    utils_hooks__hooks.fn                    = momentPrototype;
	    utils_hooks__hooks.min                   = min;
	    utils_hooks__hooks.max                   = max;
	    utils_hooks__hooks.now                   = now;
	    utils_hooks__hooks.utc                   = create_utc__createUTC;
	    utils_hooks__hooks.unix                  = moment__createUnix;
	    utils_hooks__hooks.months                = lists__listMonths;
	    utils_hooks__hooks.isDate                = isDate;
	    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
	    utils_hooks__hooks.invalid               = valid__createInvalid;
	    utils_hooks__hooks.duration              = create__createDuration;
	    utils_hooks__hooks.isMoment              = isMoment;
	    utils_hooks__hooks.weekdays              = lists__listWeekdays;
	    utils_hooks__hooks.parseZone             = moment__createInZone;
	    utils_hooks__hooks.localeData            = locale_locales__getLocale;
	    utils_hooks__hooks.isDuration            = isDuration;
	    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
	    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
	    utils_hooks__hooks.defineLocale          = defineLocale;
	    utils_hooks__hooks.updateLocale          = updateLocale;
	    utils_hooks__hooks.locales               = locale_locales__listLocales;
	    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
	    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
	    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
	    utils_hooks__hooks.prototype             = momentPrototype;

	    var _moment = utils_hooks__hooks;

	    return _moment;

	}));
	},{}],"numeral":[function(_dereq_,module,exports){
	/*!
	 * numeral.js
	 * version : 1.5.3
	 * author : Adam Draper
	 * license : MIT
	 * http://adamwdraper.github.com/Numeral-js/
	 */

	(function () {

	    /************************************
	        Constants
	    ************************************/

	    var numeral,
	        VERSION = '1.5.3',
	        // internal storage for language config files
	        languages = {},
	        currentLanguage = 'en',
	        zeroFormat = null,
	        defaultFormat = '0,0',
	        // check for nodeJS
	        hasModule = (typeof module !== 'undefined' && module.exports);


	    /************************************
	        Constructors
	    ************************************/


	    // Numeral prototype object
	    function Numeral (number) {
	        this._value = number;
	    }

	    /**
	     * Implementation of toFixed() that treats floats more like decimals
	     *
	     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
	     * problems for accounting- and finance-related software.
	     */
	    function toFixed (value, precision, roundingFunction, optionals) {
	        var power = Math.pow(10, precision),
	            optionalsRegExp,
	            output;

	        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
	        // Multiply up by precision, round accurately, then divide and use native toFixed():
	        output = (roundingFunction(value * power) / power).toFixed(precision);

	        if (optionals) {
	            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
	            output = output.replace(optionalsRegExp, '');
	        }

	        return output;
	    }

	    /************************************
	        Formatting
	    ************************************/

	    // determine what type of formatting we need to do
	    function formatNumeral (n, format, roundingFunction) {
	        var output;

	        // figure out what kind of format we are dealing with
	        if (format.indexOf('$') > -1) { // currency!!!!!
	            output = formatCurrency(n, format, roundingFunction);
	        } else if (format.indexOf('%') > -1) { // percentage
	            output = formatPercentage(n, format, roundingFunction);
	        } else if (format.indexOf(':') > -1) { // time
	            output = formatTime(n, format);
	        } else { // plain ol' numbers or bytes
	            output = formatNumber(n._value, format, roundingFunction);
	        }

	        // return string
	        return output;
	    }

	    // revert to number
	    function unformatNumeral (n, string) {
	        var stringOriginal = string,
	            thousandRegExp,
	            millionRegExp,
	            billionRegExp,
	            trillionRegExp,
	            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
	            bytesMultiplier = false,
	            power;

	        if (string.indexOf(':') > -1) {
	            n._value = unformatTime(string);
	        } else {
	            if (string === zeroFormat) {
	                n._value = 0;
	            } else {
	                if (languages[currentLanguage].delimiters.decimal !== '.') {
	                    string = string.replace(/\./g,'').replace(languages[currentLanguage].delimiters.decimal, '.');
	                }

	                // see if abbreviations are there so that we can multiply to the correct number
	                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
	                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
	                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
	                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

	                // see if bytes are there so that we can multiply to the correct number
	                for (power = 0; power <= suffixes.length; power++) {
	                    bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;

	                    if (bytesMultiplier) {
	                        break;
	                    }
	                }

	                // do some math to create our number
	                n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * (((string.split('-').length + Math.min(string.split('(').length-1, string.split(')').length-1)) % 2)? 1: -1) * Number(string.replace(/[^0-9\.]+/g, ''));

	                // round if we are talking about bytes
	                n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;
	            }
	        }
	        return n._value;
	    }

	    function formatCurrency (n, format, roundingFunction) {
	        var symbolIndex = format.indexOf('$'),
	            openParenIndex = format.indexOf('('),
	            minusSignIndex = format.indexOf('-'),
	            space = '',
	            spliceIndex,
	            output;

	        // check for space before or after currency
	        if (format.indexOf(' $') > -1) {
	            space = ' ';
	            format = format.replace(' $', '');
	        } else if (format.indexOf('$ ') > -1) {
	            space = ' ';
	            format = format.replace('$ ', '');
	        } else {
	            format = format.replace('$', '');
	        }

	        // format the number
	        output = formatNumber(n._value, format, roundingFunction);

	        // position the symbol
	        if (symbolIndex <= 1) {
	            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
	                output = output.split('');
	                spliceIndex = 1;
	                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex){
	                    // the symbol appears before the "(" or "-"
	                    spliceIndex = 0;
	                }
	                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
	                output = output.join('');
	            } else {
	                output = languages[currentLanguage].currency.symbol + space + output;
	            }
	        } else {
	            if (output.indexOf(')') > -1) {
	                output = output.split('');
	                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
	                output = output.join('');
	            } else {
	                output = output + space + languages[currentLanguage].currency.symbol;
	            }
	        }

	        return output;
	    }

	    function formatPercentage (n, format, roundingFunction) {
	        var space = '',
	            output,
	            value = n._value * 100;

	        // check for space before %
	        if (format.indexOf(' %') > -1) {
	            space = ' ';
	            format = format.replace(' %', '');
	        } else {
	            format = format.replace('%', '');
	        }

	        output = formatNumber(value, format, roundingFunction);

	        if (output.indexOf(')') > -1 ) {
	            output = output.split('');
	            output.splice(-1, 0, space + '%');
	            output = output.join('');
	        } else {
	            output = output + space + '%';
	        }

	        return output;
	    }

	    function formatTime (n) {
	        var hours = Math.floor(n._value/60/60),
	            minutes = Math.floor((n._value - (hours * 60 * 60))/60),
	            seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));
	        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);
	    }

	    function unformatTime (string) {
	        var timeArray = string.split(':'),
	            seconds = 0;
	        // turn hours and minutes into seconds and add them all up
	        if (timeArray.length === 3) {
	            // hours
	            seconds = seconds + (Number(timeArray[0]) * 60 * 60);
	            // minutes
	            seconds = seconds + (Number(timeArray[1]) * 60);
	            // seconds
	            seconds = seconds + Number(timeArray[2]);
	        } else if (timeArray.length === 2) {
	            // minutes
	            seconds = seconds + (Number(timeArray[0]) * 60);
	            // seconds
	            seconds = seconds + Number(timeArray[1]);
	        }
	        return Number(seconds);
	    }

	    function formatNumber (value, format, roundingFunction) {
	        var negP = false,
	            signed = false,
	            optDec = false,
	            abbr = '',
	            abbrK = false, // force abbreviation to thousands
	            abbrM = false, // force abbreviation to millions
	            abbrB = false, // force abbreviation to billions
	            abbrT = false, // force abbreviation to trillions
	            abbrForce = false, // force abbreviation
	            bytes = '',
	            ord = '',
	            abs = Math.abs(value),
	            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
	            min,
	            max,
	            power,
	            w,
	            precision,
	            thousands,
	            d = '',
	            neg = false;

	        // check if number is zero and a custom zero format has been set
	        if (value === 0 && zeroFormat !== null) {
	            return zeroFormat;
	        } else {
	            // see if we should use parentheses for negative number or if we should prefix with a sign
	            // if both are present we default to parentheses
	            if (format.indexOf('(') > -1) {
	                negP = true;
	                format = format.slice(1, -1);
	            } else if (format.indexOf('+') > -1) {
	                signed = true;
	                format = format.replace(/\+/g, '');
	            }

	            // see if abbreviation is wanted
	            if (format.indexOf('a') > -1) {
	                // check if abbreviation is specified
	                abbrK = format.indexOf('aK') >= 0;
	                abbrM = format.indexOf('aM') >= 0;
	                abbrB = format.indexOf('aB') >= 0;
	                abbrT = format.indexOf('aT') >= 0;
	                abbrForce = abbrK || abbrM || abbrB || abbrT;

	                // check for space before abbreviation
	                if (format.indexOf(' a') > -1) {
	                    abbr = ' ';
	                    format = format.replace(' a', '');
	                } else {
	                    format = format.replace('a', '');
	                }

	                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
	                    // trillion
	                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
	                    value = value / Math.pow(10, 12);
	                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
	                    // billion
	                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
	                    value = value / Math.pow(10, 9);
	                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
	                    // million
	                    abbr = abbr + languages[currentLanguage].abbreviations.million;
	                    value = value / Math.pow(10, 6);
	                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
	                    // thousand
	                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
	                    value = value / Math.pow(10, 3);
	                }
	            }

	            // see if we are formatting bytes
	            if (format.indexOf('b') > -1) {
	                // check for space before
	                if (format.indexOf(' b') > -1) {
	                    bytes = ' ';
	                    format = format.replace(' b', '');
	                } else {
	                    format = format.replace('b', '');
	                }

	                for (power = 0; power <= suffixes.length; power++) {
	                    min = Math.pow(1024, power);
	                    max = Math.pow(1024, power+1);

	                    if (value >= min && value < max) {
	                        bytes = bytes + suffixes[power];
	                        if (min > 0) {
	                            value = value / min;
	                        }
	                        break;
	                    }
	                }
	            }

	            // see if ordinal is wanted
	            if (format.indexOf('o') > -1) {
	                // check for space before
	                if (format.indexOf(' o') > -1) {
	                    ord = ' ';
	                    format = format.replace(' o', '');
	                } else {
	                    format = format.replace('o', '');
	                }

	                ord = ord + languages[currentLanguage].ordinal(value);
	            }

	            if (format.indexOf('[.]') > -1) {
	                optDec = true;
	                format = format.replace('[.]', '.');
	            }

	            w = value.toString().split('.')[0];
	            precision = format.split('.')[1];
	            thousands = format.indexOf(',');

	            if (precision) {
	                if (precision.indexOf('[') > -1) {
	                    precision = precision.replace(']', '');
	                    precision = precision.split('[');
	                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
	                } else {
	                    d = toFixed(value, precision.length, roundingFunction);
	                }

	                w = d.split('.')[0];

	                if (d.split('.')[1].length) {
	                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
	                } else {
	                    d = '';
	                }

	                if (optDec && Number(d.slice(1)) === 0) {
	                    d = '';
	                }
	            } else {
	                w = toFixed(value, null, roundingFunction);
	            }

	            // format number
	            if (w.indexOf('-') > -1) {
	                w = w.slice(1);
	                neg = true;
	            }

	            if (thousands > -1) {
	                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
	            }

	            if (format.indexOf('.') === 0) {
	                w = '';
	            }

	            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + ((!neg && signed) ? '+' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');
	        }
	    }

	    /************************************
	        Top Level Functions
	    ************************************/

	    numeral = function (input) {
	        if (numeral.isNumeral(input)) {
	            input = input.value();
	        } else if (input === 0 || typeof input === 'undefined') {
	            input = 0;
	        } else if (!Number(input)) {
	            input = numeral.fn.unformat(input);
	        }

	        return new Numeral(Number(input));
	    };

	    // version number
	    numeral.version = VERSION;

	    // compare numeral object
	    numeral.isNumeral = function (obj) {
	        return obj instanceof Numeral;
	    };

	    // This function will load languages and then set the global language.  If
	    // no arguments are passed in, it will simply return the current global
	    // language key.
	    numeral.language = function (key, values) {
	        if (!key) {
	            return currentLanguage;
	        }

	        if (key && !values) {
	            if(!languages[key]) {
	                throw new Error('Unknown language : ' + key);
	            }
	            currentLanguage = key;
	        }

	        if (values || !languages[key]) {
	            loadLanguage(key, values);
	        }

	        return numeral;
	    };

	    // This function provides access to the loaded language data.  If
	    // no arguments are passed in, it will simply return the current
	    // global language object.
	    numeral.languageData = function (key) {
	        if (!key) {
	            return languages[currentLanguage];
	        }

	        if (!languages[key]) {
	            throw new Error('Unknown language : ' + key);
	        }

	        return languages[key];
	    };

	    numeral.language('en', {
	        delimiters: {
	            thousands: ',',
	            decimal: '.'
	        },
	        abbreviations: {
	            thousand: 'k',
	            million: 'm',
	            billion: 'b',
	            trillion: 't'
	        },
	        ordinal: function (number) {
	            var b = number % 10;
	            return (~~ (number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	        },
	        currency: {
	            symbol: '$'
	        }
	    });

	    numeral.zeroFormat = function (format) {
	        zeroFormat = typeof(format) === 'string' ? format : null;
	    };

	    numeral.defaultFormat = function (format) {
	        defaultFormat = typeof(format) === 'string' ? format : '0.0';
	    };

	    numeral.validate = function(val, culture) {

	        var _decimalSep,
	          _thousandSep,
	          _currSymbol,
	          _valArray,
	          _abbrObj,
	          _thousandRegEx,
	          languageData,
	          temp;

	        //coerce val to string
	        if (typeof val !== 'string') {
	            val += '';
	            if (console.warn) {
	                console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);
	            }
	        }

	        //trim whitespaces from either sides
	        val = val.trim();


	        //if val is empty return false
	        if (val === '') {
	            return false;
	        }

	        //replace the initial '+' or '-' sign if present
	        val = val.replace(/^[+-]?/, '');


	        //get the decimal and thousands separator from numeral.languageData
	        try {
	            //check if the culture is understood by numeral. if not, default it to current language
	            languageData = numeral.languageData(culture);
	        } catch (e) {
	            languageData = numeral.languageData(numeral.language());
	        }

	        //setup the delimiters and currency symbol based on culture/language
	        _currSymbol = languageData.currency.symbol;
	        _abbrObj = languageData.abbreviations;
	        _decimalSep = languageData.delimiters.decimal;
	        if (languageData.delimiters.thousands === '.') {
	            _thousandSep = '\\.';
	        } else {
	            _thousandSep = languageData.delimiters.thousands;
	        }

	        //validating currency symbol
	        temp = val.match(/^[^\d\.\,]+/);
	        if (temp !== null) {
	            //chuck the currency symbol away
	            val = val.substr(1);
	            if (temp[0] !== _currSymbol) {
	                return false;
	            }
	        }

	        //validating abbreviation symbol
	        temp = val.match(/[^\d]+$/);
	        if (temp !== null) {
	            val = val.slice(0, - 1);
	            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
	                return false;
	            }
	        }

	        //if val is just digits the return true
	        if ( !! val.match(/^\d+$/)) {
	            return true;
	        }
	        _thousandRegEx = new RegExp(_thousandSep + '{2}');

	        if (!val.match(/[^\d.,]/g)) {
	            _valArray = val.split(_decimalSep);
	            if (_valArray.length > 2) {
	                return false;
	            } else {
	                if (_valArray.length < 2) {
	                    return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx));
	                } else {
	                    // for values without leading zero eg. .984
	                    if (_valArray[0] === '') {
	                        return ( !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
	                    } else if (_valArray[0].length === 1) {
	                        return ( !! _valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
	                    } else {
	                        return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
	                    }
	                }
	            }
	        }

	        return false;
	    };

	    /************************************
	        Helpers
	    ************************************/

	    function loadLanguage(key, values) {
	        languages[key] = values;
	    }

	    /************************************
	        Floating-point helpers
	    ************************************/

	    // The floating-point helper functions and implementation
	    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

	    /**
	     * Array.prototype.reduce for browsers that don't support it
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
	     */
	    if ('function' !== typeof Array.prototype.reduce) {
	        Array.prototype.reduce = function (callback, opt_initialValue) {
	            'use strict';

	            if (null === this || 'undefined' === typeof this) {
	                // At the moment all modern browsers, that support strict mode, have
	                // native implementation of Array.prototype.reduce. For instance, IE8
	                // does not support strict mode, so this check is actually useless.
	                throw new TypeError('Array.prototype.reduce called on null or undefined');
	            }

	            if ('function' !== typeof callback) {
	                throw new TypeError(callback + ' is not a function');
	            }

	            var index,
	                value,
	                length = this.length >>> 0,
	                isValueSet = false;

	            if (1 < arguments.length) {
	                value = opt_initialValue;
	                isValueSet = true;
	            }

	            for (index = 0; length > index; ++index) {
	                if (this.hasOwnProperty(index)) {
	                    if (isValueSet) {
	                        value = callback(value, this[index], index, this);
	                    } else {
	                        value = this[index];
	                        isValueSet = true;
	                    }
	                }
	            }

	            if (!isValueSet) {
	                throw new TypeError('Reduce of empty array with no initial value');
	            }

	            return value;
	        };
	    }


	    /**
	     * Computes the multiplier necessary to make x >= 1,
	     * effectively eliminating miscalculations caused by
	     * finite precision.
	     */
	    function multiplier(x) {
	        var parts = x.toString().split('.');
	        if (parts.length < 2) {
	            return 1;
	        }
	        return Math.pow(10, parts[1].length);
	    }

	    /**
	     * Given a variable number of arguments, returns the maximum
	     * multiplier that must be used to normalize an operation involving
	     * all of them.
	     */
	    function correctionFactor() {
	        var args = Array.prototype.slice.call(arguments);
	        return args.reduce(function (prev, next) {
	            var mp = multiplier(prev),
	                mn = multiplier(next);
	        return mp > mn ? mp : mn;
	        }, -Infinity);
	    }


	    /************************************
	        Numeral Prototype
	    ************************************/


	    numeral.fn = Numeral.prototype = {

	        clone : function () {
	            return numeral(this);
	        },

	        format : function (inputString, roundingFunction) {
	            return formatNumeral(this,
	                  inputString ? inputString : defaultFormat,
	                  (roundingFunction !== undefined) ? roundingFunction : Math.round
	              );
	        },

	        unformat : function (inputString) {
	            if (Object.prototype.toString.call(inputString) === '[object Number]') {
	                return inputString;
	            }
	            return unformatNumeral(this, inputString ? inputString : defaultFormat);
	        },

	        value : function () {
	            return this._value;
	        },

	        valueOf : function () {
	            return this._value;
	        },

	        set : function (value) {
	            this._value = Number(value);
	            return this;
	        },

	        add : function (value) {
	            var corrFactor = correctionFactor.call(null, this._value, value);

	            function cback(accum, curr, currI, O) {
	                return accum + corrFactor * curr;
	            }
	            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
	            return this;
	        },

	        subtract : function (value) {
	            var corrFactor = correctionFactor.call(null, this._value, value);

	            function cback(accum, curr, currI, O) {
	                return accum - corrFactor * curr;
	            }
	            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;
	            return this;
	        },

	        multiply : function (value) {
	            function cback(accum, curr, currI, O) {
	                var corrFactor = correctionFactor(accum, curr);
	                return (accum * corrFactor) * (curr * corrFactor) /
	                    (corrFactor * corrFactor);
	            }
	            this._value = [this._value, value].reduce(cback, 1);
	            return this;
	        },

	        divide : function (value) {
	            function cback(accum, curr, currI, O) {
	                var corrFactor = correctionFactor(accum, curr);
	                return (accum * corrFactor) / (curr * corrFactor);
	            }
	            this._value = [this._value, value].reduce(cback);
	            return this;
	        },

	        difference : function (value) {
	            return Math.abs(numeral(this._value).subtract(value).value());
	        }

	    };

	    /************************************
	        Exposing Numeral
	    ************************************/

	    // CommonJS module is defined
	    if (hasModule) {
	        module.exports = numeral;
	    }

	    /*global ender:false */
	    if (typeof ender === 'undefined') {
	        // here, `this` means `window` in the browser, or `global` on the server
	        // add `numeral` as a global object via a string identifier,
	        // for Closure Compiler 'advanced' mode
	        this['numeral'] = numeral;
	    }

	    /*global define:false */
	    if (typeof define === 'function' && define.amd) {
	        define([], function () {
	            return numeral;
	        });
	    }
	}).call(window);

	},{}],"pikaday":[function(_dereq_,module,exports){
	/*!
	 * Pikaday
	 *
	 * Copyright © 2014 David Bushell | BSD & MIT license | https://github.com/dbushell/Pikaday
	 */

	(function (root, factory)
	{
	    'use strict';

	    var moment;
	    if (typeof exports === 'object') {
	        // CommonJS module
	        // Load moment.js as an optional dependency
	        try { moment = _dereq_('moment'); } catch (e) {}
	        module.exports = factory(moment);
	    } else if (typeof define === 'function' && define.amd) {
	        // AMD. Register as an anonymous module.
	        define(function (req)
	        {
	            // Load moment.js as an optional dependency
	            var id = 'moment';
	            try { moment = req(id); } catch (e) {}
	            return factory(moment);
	        });
	    } else {
	        root.Pikaday = factory(root.moment);
	    }
	}(this, function (moment)
	{
	    'use strict';

	    /**
	     * feature detection and helper functions
	     */
	    var hasMoment = typeof moment === 'function',

	    hasEventListeners = !!window.addEventListener,

	    document = window.document,

	    sto = window.setTimeout,

	    addEvent = function(el, e, callback, capture)
	    {
	        if (hasEventListeners) {
	            el.addEventListener(e, callback, !!capture);
	        } else {
	            el.attachEvent('on' + e, callback);
	        }
	    },

	    removeEvent = function(el, e, callback, capture)
	    {
	        if (hasEventListeners) {
	            el.removeEventListener(e, callback, !!capture);
	        } else {
	            el.detachEvent('on' + e, callback);
	        }
	    },

	    fireEvent = function(el, eventName, data)
	    {
	        var ev;

	        if (document.createEvent) {
	            ev = document.createEvent('HTMLEvents');
	            ev.initEvent(eventName, true, false);
	            ev = extend(ev, data);
	            el.dispatchEvent(ev);
	        } else if (document.createEventObject) {
	            ev = document.createEventObject();
	            ev = extend(ev, data);
	            el.fireEvent('on' + eventName, ev);
	        }
	    },

	    trim = function(str)
	    {
	        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g,'');
	    },

	    hasClass = function(el, cn)
	    {
	        return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;
	    },

	    addClass = function(el, cn)
	    {
	        if (!hasClass(el, cn)) {
	            el.className = (el.className === '') ? cn : el.className + ' ' + cn;
	        }
	    },

	    removeClass = function(el, cn)
	    {
	        el.className = trim((' ' + el.className + ' ').replace(' ' + cn + ' ', ' '));
	    },

	    isArray = function(obj)
	    {
	        return (/Array/).test(Object.prototype.toString.call(obj));
	    },

	    isDate = function(obj)
	    {
	        return (/Date/).test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
	    },

	    isWeekend = function(date)
	    {
	        var day = date.getDay();
	        return day === 0 || day === 6;
	    },

	    isLeapYear = function(year)
	    {
	        // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951
	        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
	    },

	    getDaysInMonth = function(year, month)
	    {
	        return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
	    },

	    setToStartOfDay = function(date)
	    {
	        if (isDate(date)) date.setHours(0,0,0,0);
	    },

	    compareDates = function(a,b)
	    {
	        // weak date comparison (use setToStartOfDay(date) to ensure correct result)
	        return a.getTime() === b.getTime();
	    },

	    extend = function(to, from, overwrite)
	    {
	        var prop, hasProp;
	        for (prop in from) {
	            hasProp = to[prop] !== undefined;
	            if (hasProp && typeof from[prop] === 'object' && from[prop] !== null && from[prop].nodeName === undefined) {
	                if (isDate(from[prop])) {
	                    if (overwrite) {
	                        to[prop] = new Date(from[prop].getTime());
	                    }
	                }
	                else if (isArray(from[prop])) {
	                    if (overwrite) {
	                        to[prop] = from[prop].slice(0);
	                    }
	                } else {
	                    to[prop] = extend({}, from[prop], overwrite);
	                }
	            } else if (overwrite || !hasProp) {
	                to[prop] = from[prop];
	            }
	        }
	        return to;
	    },

	    adjustCalendar = function(calendar) {
	        if (calendar.month < 0) {
	            calendar.year -= Math.ceil(Math.abs(calendar.month)/12);
	            calendar.month += 12;
	        }
	        if (calendar.month > 11) {
	            calendar.year += Math.floor(Math.abs(calendar.month)/12);
	            calendar.month -= 12;
	        }
	        return calendar;
	    },

	    /**
	     * defaults and localisation
	     */
	    defaults = {

	        // bind the picker to a form field
	        field: null,

	        // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
	        bound: undefined,

	        // position of the datepicker, relative to the field (default to bottom & left)
	        // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
	        position: 'bottom left',

	        // automatically fit in the viewport even if it means repositioning from the position option
	        reposition: true,

	        // the default output format for `.toString()` and `field` value
	        format: 'YYYY-MM-DD',

	        // the initial date to view when first opened
	        defaultDate: null,

	        // make the `defaultDate` the initial selected value
	        setDefaultDate: false,

	        // first day of week (0: Sunday, 1: Monday etc)
	        firstDay: 0,

	        // the minimum/earliest date that can be selected
	        minDate: null,
	        // the maximum/latest date that can be selected
	        maxDate: null,

	        // number of years either side, or array of upper/lower range
	        yearRange: 10,

	        // show week numbers at head of row
	        showWeekNumber: false,

	        // used internally (don't config outside)
	        minYear: 0,
	        maxYear: 9999,
	        minMonth: undefined,
	        maxMonth: undefined,

	        startRange: null,
	        endRange: null,

	        isRTL: false,

	        // Additional text to append to the year in the calendar title
	        yearSuffix: '',

	        // Render the month after year in the calendar title
	        showMonthAfterYear: false,

	        // how many months are visible
	        numberOfMonths: 1,

	        // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
	        // only used for the first display or when a selected date is not visible
	        mainCalendar: 'left',

	        // Specify a DOM element to render the calendar in
	        container: undefined,

	        // internationalization
	        i18n: {
	            previousMonth : 'Previous Month',
	            nextMonth     : 'Next Month',
	            months        : ['January','February','March','April','May','June','July','August','September','October','November','December'],
	            weekdays      : ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
	            weekdaysShort : ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']
	        },

	        // Theme Classname
	        theme: null,

	        // callback function
	        onSelect: null,
	        onOpen: null,
	        onClose: null,
	        onDraw: null
	    },


	    /**
	     * templating functions to abstract HTML rendering
	     */
	    renderDayName = function(opts, day, abbr)
	    {
	        day += opts.firstDay;
	        while (day >= 7) {
	            day -= 7;
	        }
	        return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
	    },

	    renderDay = function(opts)
	    {
	        if (opts.isEmpty) {
	            return '<td class="is-empty"></td>';
	        }
	        var arr = [];
	        if (opts.isDisabled) {
	            arr.push('is-disabled');
	        }
	        if (opts.isToday) {
	            arr.push('is-today');
	        }
	        if (opts.isSelected) {
	            arr.push('is-selected');
	        }
	        if (opts.isInRange) {
	            arr.push('is-inrange');
	        }
	        if (opts.isStartRange) {
	            arr.push('is-startrange');
	        }
	        if (opts.isEndRange) {
	            arr.push('is-endrange');
	        }
	        return '<td data-day="' + opts.day + '" class="' + arr.join(' ') + '">' +
	                 '<button class="pika-button pika-day" type="button" ' +
	                    'data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' +
	                        opts.day +
	                 '</button>' +
	               '</td>';
	    },

	    renderWeek = function (d, m, y) {
	        // Lifted from http://javascript.about.com/library/blweekyear.htm, lightly modified.
	        var onejan = new Date(y, 0, 1),
	            weekNum = Math.ceil((((new Date(y, m, d) - onejan) / 86400000) + onejan.getDay()+1)/7);
	        return '<td class="pika-week">' + weekNum + '</td>';
	    },

	    renderRow = function(days, isRTL)
	    {
	        return '<tr>' + (isRTL ? days.reverse() : days).join('') + '</tr>';
	    },

	    renderBody = function(rows)
	    {
	        return '<tbody>' + rows.join('') + '</tbody>';
	    },

	    renderHead = function(opts)
	    {
	        var i, arr = [];
	        if (opts.showWeekNumber) {
	            arr.push('<th></th>');
	        }
	        for (i = 0; i < 7; i++) {
	            arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + '</abbr></th>');
	        }
	        return '<thead>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</thead>';
	    },

	    renderTitle = function(instance, c, year, month, refYear)
	    {
	        var i, j, arr,
	            opts = instance._o,
	            isMinYear = year === opts.minYear,
	            isMaxYear = year === opts.maxYear,
	            html = '<div class="pika-title">',
	            monthHtml,
	            yearHtml,
	            prev = true,
	            next = true;

	        for (arr = [], i = 0; i < 12; i++) {
	            arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' +
	                (i === month ? ' selected': '') +
	                ((isMinYear && i < opts.minMonth) || (isMaxYear && i > opts.maxMonth) ? 'disabled' : '') + '>' +
	                opts.i18n.months[i] + '</option>');
	        }
	        monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join('') + '</select></div>';

	        if (isArray(opts.yearRange)) {
	            i = opts.yearRange[0];
	            j = opts.yearRange[1] + 1;
	        } else {
	            i = year - opts.yearRange;
	            j = 1 + year + opts.yearRange;
	        }

	        for (arr = []; i < j && i <= opts.maxYear; i++) {
	            if (i >= opts.minYear) {
	                arr.push('<option value="' + i + '"' + (i === year ? ' selected': '') + '>' + (i) + '</option>');
	            }
	        }
	        yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join('') + '</select></div>';

	        if (opts.showMonthAfterYear) {
	            html += yearHtml + monthHtml;
	        } else {
	            html += monthHtml + yearHtml;
	        }

	        if (isMinYear && (month === 0 || opts.minMonth >= month)) {
	            prev = false;
	        }

	        if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
	            next = false;
	        }

	        if (c === 0) {
	            html += '<button class="pika-prev' + (prev ? '' : ' is-disabled') + '" type="button">' + opts.i18n.previousMonth + '</button>';
	        }
	        if (c === (instance._o.numberOfMonths - 1) ) {
	            html += '<button class="pika-next' + (next ? '' : ' is-disabled') + '" type="button">' + opts.i18n.nextMonth + '</button>';
	        }

	        return html += '</div>';
	    },

	    renderTable = function(opts, data)
	    {
	        return '<table cellpadding="0" cellspacing="0" class="pika-table">' + renderHead(opts) + renderBody(data) + '</table>';
	    },


	    /**
	     * Pikaday constructor
	     */
	    Pikaday = function(options)
	    {
	        var self = this,
	            opts = self.config(options);

	        self._onMouseDown = function(e)
	        {
	            if (!self._v) {
	                return;
	            }
	            e = e || window.event;
	            var target = e.target || e.srcElement;
	            if (!target) {
	                return;
	            }

	            if (!hasClass(target, 'is-disabled')) {
	                if (hasClass(target, 'pika-button') && !hasClass(target, 'is-empty')) {
	                    self.setDate(new Date(target.getAttribute('data-pika-year'), target.getAttribute('data-pika-month'), target.getAttribute('data-pika-day')));
	                    if (opts.bound) {
	                        sto(function() {
	                            self.hide();
	                            if (opts.field) {
	                                opts.field.blur();
	                            }
	                        }, 100);
	                    }
	                }
	                else if (hasClass(target, 'pika-prev')) {
	                    self.prevMonth();
	                }
	                else if (hasClass(target, 'pika-next')) {
	                    self.nextMonth();
	                }
	            }
	            if (!hasClass(target, 'pika-select')) {
	                // if this is touch event prevent mouse events emulation
	                if (e.preventDefault) {
	                    e.preventDefault();
	                } else {
	                    e.returnValue = false;
	                    return false;
	                }
	            } else {
	                self._c = true;
	            }
	        };

	        self._onChange = function(e)
	        {
	            e = e || window.event;
	            var target = e.target || e.srcElement;
	            if (!target) {
	                return;
	            }
	            if (hasClass(target, 'pika-select-month')) {
	                self.gotoMonth(target.value);
	            }
	            else if (hasClass(target, 'pika-select-year')) {
	                self.gotoYear(target.value);
	            }
	        };

	        self._onInputChange = function(e)
	        {
	            var date;

	            if (e.firedBy === self) {
	                return;
	            }
	            if (hasMoment) {
	                date = moment(opts.field.value, opts.format);
	                date = (date && date.isValid()) ? date.toDate() : null;
	            }
	            else {
	                date = new Date(Date.parse(opts.field.value));
	            }
	            if (isDate(date)) {
	              self.setDate(date);
	            }
	            if (!self._v) {
	                self.show();
	            }
	        };

	        self._onInputFocus = function()
	        {
	            self.show();
	        };

	        self._onInputClick = function()
	        {
	            self.show();
	        };

	        self._onInputBlur = function()
	        {
	            // IE allows pika div to gain focus; catch blur the input field
	            var pEl = document.activeElement;
	            do {
	                if (hasClass(pEl, 'pika-single')) {
	                    return;
	                }
	            }
	            while ((pEl = pEl.parentNode));

	            if (!self._c) {
	                self._b = sto(function() {
	                    self.hide();
	                }, 50);
	            }
	            self._c = false;
	        };

	        self._onClick = function(e)
	        {
	            e = e || window.event;
	            var target = e.target || e.srcElement,
	                pEl = target;
	            if (!target) {
	                return;
	            }
	            if (!hasEventListeners && hasClass(target, 'pika-select')) {
	                if (!target.onchange) {
	                    target.setAttribute('onchange', 'return;');
	                    addEvent(target, 'change', self._onChange);
	                }
	            }
	            do {
	                if (hasClass(pEl, 'pika-single') || pEl === opts.trigger) {
	                    return;
	                }
	            }
	            while ((pEl = pEl.parentNode));
	            if (self._v && target !== opts.trigger && pEl !== opts.trigger) {
	                self.hide();
	            }
	        };

	        self.el = document.createElement('div');
	        self.el.className = 'pika-single' + (opts.isRTL ? ' is-rtl' : '') + (opts.theme ? ' ' + opts.theme : '');

	        addEvent(self.el, 'mousedown', self._onMouseDown, true);
	        addEvent(self.el, 'touchend', self._onMouseDown, true);
	        addEvent(self.el, 'change', self._onChange);

	        if (opts.field) {
	            if (opts.container) {
	                opts.container.appendChild(self.el);
	            } else if (opts.bound) {
	                document.body.appendChild(self.el);
	            } else {
	                opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling);
	            }
	            addEvent(opts.field, 'change', self._onInputChange);

	            if (!opts.defaultDate) {
	                if (hasMoment && opts.field.value) {
	                    opts.defaultDate = moment(opts.field.value, opts.format).toDate();
	                } else {
	                    opts.defaultDate = new Date(Date.parse(opts.field.value));
	                }
	                opts.setDefaultDate = true;
	            }
	        }

	        var defDate = opts.defaultDate;

	        if (isDate(defDate)) {
	            if (opts.setDefaultDate) {
	                self.setDate(defDate, true);
	            } else {
	                self.gotoDate(defDate);
	            }
	        } else {
	            self.gotoDate(new Date());
	        }

	        if (opts.bound) {
	            this.hide();
	            self.el.className += ' is-bound';
	            addEvent(opts.trigger, 'click', self._onInputClick);
	            addEvent(opts.trigger, 'focus', self._onInputFocus);
	            addEvent(opts.trigger, 'blur', self._onInputBlur);
	        } else {
	            this.show();
	        }
	    };


	    /**
	     * public Pikaday API
	     */
	    Pikaday.prototype = {


	        /**
	         * configure functionality
	         */
	        config: function(options)
	        {
	            if (!this._o) {
	                this._o = extend({}, defaults, true);
	            }

	            var opts = extend(this._o, options, true);

	            opts.isRTL = !!opts.isRTL;

	            opts.field = (opts.field && opts.field.nodeName) ? opts.field : null;

	            opts.theme = (typeof opts.theme) === 'string' && opts.theme ? opts.theme : null;

	            opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);

	            opts.trigger = (opts.trigger && opts.trigger.nodeName) ? opts.trigger : opts.field;

	            opts.disableWeekends = !!opts.disableWeekends;

	            opts.disableDayFn = (typeof opts.disableDayFn) === 'function' ? opts.disableDayFn : null;

	            var nom = parseInt(opts.numberOfMonths, 10) || 1;
	            opts.numberOfMonths = nom > 4 ? 4 : nom;

	            if (!isDate(opts.minDate)) {
	                opts.minDate = false;
	            }
	            if (!isDate(opts.maxDate)) {
	                opts.maxDate = false;
	            }
	            if ((opts.minDate && opts.maxDate) && opts.maxDate < opts.minDate) {
	                opts.maxDate = opts.minDate = false;
	            }
	            if (opts.minDate) {
	                this.setMinDate(opts.minDate);
	            }
	            if (opts.maxDate) {
	                this.setMaxDate(opts.maxDate);
	            }

	            if (isArray(opts.yearRange)) {
	                var fallback = new Date().getFullYear() - 10;
	                opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
	                opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
	            } else {
	                opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
	                if (opts.yearRange > 100) {
	                    opts.yearRange = 100;
	                }
	            }

	            return opts;
	        },

	        /**
	         * return a formatted string of the current selection (using Moment.js if available)
	         */
	        toString: function(format)
	        {
	            return !isDate(this._d) ? '' : hasMoment ? moment(this._d).format(format || this._o.format) : this._d.toDateString();
	        },

	        /**
	         * return a Moment.js object of the current selection (if available)
	         */
	        getMoment: function()
	        {
	            return hasMoment ? moment(this._d) : null;
	        },

	        /**
	         * set the current selection from a Moment.js object (if available)
	         */
	        setMoment: function(date, preventOnSelect)
	        {
	            if (hasMoment && moment.isMoment(date)) {
	                this.setDate(date.toDate(), preventOnSelect);
	            }
	        },

	        /**
	         * return a Date object of the current selection
	         */
	        getDate: function()
	        {
	            return isDate(this._d) ? new Date(this._d.getTime()) : null;
	        },

	        /**
	         * set the current selection
	         */
	        setDate: function(date, preventOnSelect)
	        {
	            if (!date) {
	                this._d = null;

	                if (this._o.field) {
	                    this._o.field.value = '';
	                    fireEvent(this._o.field, 'change', { firedBy: this });
	                }

	                return this.draw();
	            }
	            if (typeof date === 'string') {
	                date = new Date(Date.parse(date));
	            }
	            if (!isDate(date)) {
	                return;
	            }

	            var min = this._o.minDate,
	                max = this._o.maxDate;

	            if (isDate(min) && date < min) {
	                date = min;
	            } else if (isDate(max) && date > max) {
	                date = max;
	            }

	            this._d = new Date(date.getTime());
	            setToStartOfDay(this._d);
	            this.gotoDate(this._d);

	            if (this._o.field) {
	                this._o.field.value = this.toString();
	                fireEvent(this._o.field, 'change', { firedBy: this });
	            }
	            if (!preventOnSelect && typeof this._o.onSelect === 'function') {
	                this._o.onSelect.call(this, this.getDate());
	            }
	        },

	        /**
	         * change view to a specific date
	         */
	        gotoDate: function(date)
	        {
	            var newCalendar = true;

	            if (!isDate(date)) {
	                return;
	            }

	            if (this.calendars) {
	                var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
	                    lastVisibleDate = new Date(this.calendars[this.calendars.length-1].year, this.calendars[this.calendars.length-1].month, 1),
	                    visibleDate = date.getTime();
	                // get the end of the month
	                lastVisibleDate.setMonth(lastVisibleDate.getMonth()+1);
	                lastVisibleDate.setDate(lastVisibleDate.getDate()-1);
	                newCalendar = (visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate);
	            }

	            if (newCalendar) {
	                this.calendars = [{
	                    month: date.getMonth(),
	                    year: date.getFullYear()
	                }];
	                if (this._o.mainCalendar === 'right') {
	                    this.calendars[0].month += 1 - this._o.numberOfMonths;
	                }
	            }

	            this.adjustCalendars();
	        },

	        adjustCalendars: function() {
	            this.calendars[0] = adjustCalendar(this.calendars[0]);
	            for (var c = 1; c < this._o.numberOfMonths; c++) {
	                this.calendars[c] = adjustCalendar({
	                    month: this.calendars[0].month + c,
	                    year: this.calendars[0].year
	                });
	            }
	            this.draw();
	        },

	        gotoToday: function()
	        {
	            this.gotoDate(new Date());
	        },

	        /**
	         * change view to a specific month (zero-index, e.g. 0: January)
	         */
	        gotoMonth: function(month)
	        {
	            if (!isNaN(month)) {
	                this.calendars[0].month = parseInt(month, 10);
	                this.adjustCalendars();
	            }
	        },

	        nextMonth: function()
	        {
	            this.calendars[0].month++;
	            this.adjustCalendars();
	        },

	        prevMonth: function()
	        {
	            this.calendars[0].month--;
	            this.adjustCalendars();
	        },

	        /**
	         * change view to a specific full year (e.g. "2012")
	         */
	        gotoYear: function(year)
	        {
	            if (!isNaN(year)) {
	                this.calendars[0].year = parseInt(year, 10);
	                this.adjustCalendars();
	            }
	        },

	        /**
	         * change the minDate
	         */
	        setMinDate: function(value)
	        {
	            setToStartOfDay(value);
	            this._o.minDate = value;
	            this._o.minYear  = value.getFullYear();
	            this._o.minMonth = value.getMonth();
	            this.draw();
	        },

	        /**
	         * change the maxDate
	         */
	        setMaxDate: function(value)
	        {
	            setToStartOfDay(value);
	            this._o.maxDate = value;
	            this._o.maxYear = value.getFullYear();
	            this._o.maxMonth = value.getMonth();
	            this.draw();
	        },

	        setStartRange: function(value)
	        {
	            this._o.startRange = value;
	        },

	        setEndRange: function(value)
	        {
	            this._o.endRange = value;
	        },

	        /**
	         * refresh the HTML
	         */
	        draw: function(force)
	        {
	            if (!this._v && !force) {
	                return;
	            }
	            var opts = this._o,
	                minYear = opts.minYear,
	                maxYear = opts.maxYear,
	                minMonth = opts.minMonth,
	                maxMonth = opts.maxMonth,
	                html = '';

	            if (this._y <= minYear) {
	                this._y = minYear;
	                if (!isNaN(minMonth) && this._m < minMonth) {
	                    this._m = minMonth;
	                }
	            }
	            if (this._y >= maxYear) {
	                this._y = maxYear;
	                if (!isNaN(maxMonth) && this._m > maxMonth) {
	                    this._m = maxMonth;
	                }
	            }

	            for (var c = 0; c < opts.numberOfMonths; c++) {
	                html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year) + this.render(this.calendars[c].year, this.calendars[c].month) + '</div>';
	            }

	            this.el.innerHTML = html;

	            if (opts.bound) {
	                if(opts.field.type !== 'hidden') {
	                    sto(function() {
	                        opts.trigger.focus();
	                    }, 1);
	                }
	            }

	            if (typeof this._o.onDraw === 'function') {
	                var self = this;
	                sto(function() {
	                    self._o.onDraw.call(self);
	                }, 0);
	            }
	        },

	        adjustPosition: function()
	        {
	            var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect;

	            if (this._o.container) return;

	            this.el.style.position = 'absolute';

	            field = this._o.trigger;
	            pEl = field;
	            width = this.el.offsetWidth;
	            height = this.el.offsetHeight;
	            viewportWidth = window.innerWidth || document.documentElement.clientWidth;
	            viewportHeight = window.innerHeight || document.documentElement.clientHeight;
	            scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;

	            if (typeof field.getBoundingClientRect === 'function') {
	                clientRect = field.getBoundingClientRect();
	                left = clientRect.left + window.pageXOffset;
	                top = clientRect.bottom + window.pageYOffset;
	            } else {
	                left = pEl.offsetLeft;
	                top  = pEl.offsetTop + pEl.offsetHeight;
	                while((pEl = pEl.offsetParent)) {
	                    left += pEl.offsetLeft;
	                    top  += pEl.offsetTop;
	                }
	            }

	            // default position is bottom & left
	            if ((this._o.reposition && left + width > viewportWidth) ||
	                (
	                    this._o.position.indexOf('right') > -1 &&
	                    left - width + field.offsetWidth > 0
	                )
	            ) {
	                left = left - width + field.offsetWidth;
	            }
	            if ((this._o.reposition && top + height > viewportHeight + scrollTop) ||
	                (
	                    this._o.position.indexOf('top') > -1 &&
	                    top - height - field.offsetHeight > 0
	                )
	            ) {
	                top = top - height - field.offsetHeight;
	            }

	            this.el.style.left = left + 'px';
	            this.el.style.top = top + 'px';
	        },

	        /**
	         * render HTML for a particular month
	         */
	        render: function(year, month)
	        {
	            var opts   = this._o,
	                now    = new Date(),
	                days   = getDaysInMonth(year, month),
	                before = new Date(year, month, 1).getDay(),
	                data   = [],
	                row    = [];
	            setToStartOfDay(now);
	            if (opts.firstDay > 0) {
	                before -= opts.firstDay;
	                if (before < 0) {
	                    before += 7;
	                }
	            }
	            var cells = days + before,
	                after = cells;
	            while(after > 7) {
	                after -= 7;
	            }
	            cells += 7 - after;
	            for (var i = 0, r = 0; i < cells; i++)
	            {
	                var day = new Date(year, month, 1 + (i - before)),
	                    isSelected = isDate(this._d) ? compareDates(day, this._d) : false,
	                    isToday = compareDates(day, now),
	                    isEmpty = i < before || i >= (days + before),
	                    isStartRange = opts.startRange && compareDates(opts.startRange, day),
	                    isEndRange = opts.endRange && compareDates(opts.endRange, day),
	                    isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,
	                    isDisabled = (opts.minDate && day < opts.minDate) ||
	                                 (opts.maxDate && day > opts.maxDate) ||
	                                 (opts.disableWeekends && isWeekend(day)) ||
	                                 (opts.disableDayFn && opts.disableDayFn(day)),
	                    dayConfig = {
	                        day: 1 + (i - before),
	                        month: month,
	                        year: year,
	                        isSelected: isSelected,
	                        isToday: isToday,
	                        isDisabled: isDisabled,
	                        isEmpty: isEmpty,
	                        isStartRange: isStartRange,
	                        isEndRange: isEndRange,
	                        isInRange: isInRange
	                    };

	                row.push(renderDay(dayConfig));

	                if (++r === 7) {
	                    if (opts.showWeekNumber) {
	                        row.unshift(renderWeek(i - before, month, year));
	                    }
	                    data.push(renderRow(row, opts.isRTL));
	                    row = [];
	                    r = 0;
	                }
	            }
	            return renderTable(opts, data);
	        },

	        isVisible: function()
	        {
	            return this._v;
	        },

	        show: function()
	        {
	            if (!this._v) {
	                removeClass(this.el, 'is-hidden');
	                this._v = true;
	                this.draw();
	                if (this._o.bound) {
	                    addEvent(document, 'click', this._onClick);
	                    this.adjustPosition();
	                }
	                if (typeof this._o.onOpen === 'function') {
	                    this._o.onOpen.call(this);
	                }
	            }
	        },

	        hide: function()
	        {
	            var v = this._v;
	            if (v !== false) {
	                if (this._o.bound) {
	                    removeEvent(document, 'click', this._onClick);
	                }
	                this.el.style.position = 'static'; // reset
	                this.el.style.left = 'auto';
	                this.el.style.top = 'auto';
	                addClass(this.el, 'is-hidden');
	                this._v = false;
	                if (v !== undefined && typeof this._o.onClose === 'function') {
	                    this._o.onClose.call(this);
	                }
	            }
	        },

	        /**
	         * GAME OVER
	         */
	        destroy: function()
	        {
	            this.hide();
	            removeEvent(this.el, 'mousedown', this._onMouseDown, true);
	            removeEvent(this.el, 'touchend', this._onMouseDown, true);
	            removeEvent(this.el, 'change', this._onChange);
	            if (this._o.field) {
	                removeEvent(this._o.field, 'change', this._onInputChange);
	                if (this._o.bound) {
	                    removeEvent(this._o.trigger, 'click', this._onInputClick);
	                    removeEvent(this._o.trigger, 'focus', this._onInputFocus);
	                    removeEvent(this._o.trigger, 'blur', this._onInputBlur);
	                }
	            }
	            if (this.el.parentNode) {
	                this.el.parentNode.removeChild(this.el);
	            }
	        }

	    };

	    return Pikaday;

	}));

	},{"moment":"moment"}],"zeroclipboard":[function(_dereq_,module,exports){
	/*!
	 * ZeroClipboard
	 * The ZeroClipboard library provides an easy way to copy text to the clipboard using an invisible Adobe Flash movie and a JavaScript interface.
	 * Copyright (c) 2009-2014 Jon Rohan, James M. Greene
	 * Licensed MIT
	 * http://zeroclipboard.org/
	 * v2.2.0
	 */
	(function(window, undefined) {
	  "use strict";
	  /**
	 * Store references to critically important global functions that may be
	 * overridden on certain web pages.
	 */
	  var _window = window, _document = _window.document, _navigator = _window.navigator, _setTimeout = _window.setTimeout, _clearTimeout = _window.clearTimeout, _setInterval = _window.setInterval, _clearInterval = _window.clearInterval, _getComputedStyle = _window.getComputedStyle, _encodeURIComponent = _window.encodeURIComponent, _ActiveXObject = _window.ActiveXObject, _Error = _window.Error, _parseInt = _window.Number.parseInt || _window.parseInt, _parseFloat = _window.Number.parseFloat || _window.parseFloat, _isNaN = _window.Number.isNaN || _window.isNaN, _now = _window.Date.now, _keys = _window.Object.keys, _defineProperty = _window.Object.defineProperty, _hasOwn = _window.Object.prototype.hasOwnProperty, _slice = _window.Array.prototype.slice, _unwrap = function() {
	    var unwrapper = function(el) {
	      return el;
	    };
	    if (typeof _window.wrap === "function" && typeof _window.unwrap === "function") {
	      try {
	        var div = _document.createElement("div");
	        var unwrappedDiv = _window.unwrap(div);
	        if (div.nodeType === 1 && unwrappedDiv && unwrappedDiv.nodeType === 1) {
	          unwrapper = _window.unwrap;
	        }
	      } catch (e) {}
	    }
	    return unwrapper;
	  }();
	  /**
	 * Convert an `arguments` object into an Array.
	 *
	 * @returns The arguments as an Array
	 * @private
	 */
	  var _args = function(argumentsObj) {
	    return _slice.call(argumentsObj, 0);
	  };
	  /**
	 * Shallow-copy the owned, enumerable properties of one object over to another, similar to jQuery's `$.extend`.
	 *
	 * @returns The target object, augmented
	 * @private
	 */
	  var _extend = function() {
	    var i, len, arg, prop, src, copy, args = _args(arguments), target = args[0] || {};
	    for (i = 1, len = args.length; i < len; i++) {
	      if ((arg = args[i]) != null) {
	        for (prop in arg) {
	          if (_hasOwn.call(arg, prop)) {
	            src = target[prop];
	            copy = arg[prop];
	            if (target !== copy && copy !== undefined) {
	              target[prop] = copy;
	            }
	          }
	        }
	      }
	    }
	    return target;
	  };
	  /**
	 * Return a deep copy of the source object or array.
	 *
	 * @returns Object or Array
	 * @private
	 */
	  var _deepCopy = function(source) {
	    var copy, i, len, prop;
	    if (typeof source !== "object" || source == null || typeof source.nodeType === "number") {
	      copy = source;
	    } else if (typeof source.length === "number") {
	      copy = [];
	      for (i = 0, len = source.length; i < len; i++) {
	        if (_hasOwn.call(source, i)) {
	          copy[i] = _deepCopy(source[i]);
	        }
	      }
	    } else {
	      copy = {};
	      for (prop in source) {
	        if (_hasOwn.call(source, prop)) {
	          copy[prop] = _deepCopy(source[prop]);
	        }
	      }
	    }
	    return copy;
	  };
	  /**
	 * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to keep.
	 * The inverse of `_omit`, mostly. The big difference is that these properties do NOT need to be enumerable to
	 * be kept.
	 *
	 * @returns A new filtered object.
	 * @private
	 */
	  var _pick = function(obj, keys) {
	    var newObj = {};
	    for (var i = 0, len = keys.length; i < len; i++) {
	      if (keys[i] in obj) {
	        newObj[keys[i]] = obj[keys[i]];
	      }
	    }
	    return newObj;
	  };
	  /**
	 * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to omit.
	 * The inverse of `_pick`.
	 *
	 * @returns A new filtered object.
	 * @private
	 */
	  var _omit = function(obj, keys) {
	    var newObj = {};
	    for (var prop in obj) {
	      if (keys.indexOf(prop) === -1) {
	        newObj[prop] = obj[prop];
	      }
	    }
	    return newObj;
	  };
	  /**
	 * Remove all owned, enumerable properties from an object.
	 *
	 * @returns The original object without its owned, enumerable properties.
	 * @private
	 */
	  var _deleteOwnProperties = function(obj) {
	    if (obj) {
	      for (var prop in obj) {
	        if (_hasOwn.call(obj, prop)) {
	          delete obj[prop];
	        }
	      }
	    }
	    return obj;
	  };
	  /**
	 * Determine if an element is contained within another element.
	 *
	 * @returns Boolean
	 * @private
	 */
	  var _containedBy = function(el, ancestorEl) {
	    if (el && el.nodeType === 1 && el.ownerDocument && ancestorEl && (ancestorEl.nodeType === 1 && ancestorEl.ownerDocument && ancestorEl.ownerDocument === el.ownerDocument || ancestorEl.nodeType === 9 && !ancestorEl.ownerDocument && ancestorEl === el.ownerDocument)) {
	      do {
	        if (el === ancestorEl) {
	          return true;
	        }
	        el = el.parentNode;
	      } while (el);
	    }
	    return false;
	  };
	  /**
	 * Get the URL path's parent directory.
	 *
	 * @returns String or `undefined`
	 * @private
	 */
	  var _getDirPathOfUrl = function(url) {
	    var dir;
	    if (typeof url === "string" && url) {
	      dir = url.split("#")[0].split("?")[0];
	      dir = url.slice(0, url.lastIndexOf("/") + 1);
	    }
	    return dir;
	  };
	  /**
	 * Get the current script's URL by throwing an `Error` and analyzing it.
	 *
	 * @returns String or `undefined`
	 * @private
	 */
	  var _getCurrentScriptUrlFromErrorStack = function(stack) {
	    var url, matches;
	    if (typeof stack === "string" && stack) {
	      matches = stack.match(/^(?:|[^:@]*@|.+\)@(?=http[s]?|file)|.+?\s+(?: at |@)(?:[^:\(]+ )*[\(]?)((?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/);
	      if (matches && matches[1]) {
	        url = matches[1];
	      } else {
	        matches = stack.match(/\)@((?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/);
	        if (matches && matches[1]) {
	          url = matches[1];
	        }
	      }
	    }
	    return url;
	  };
	  /**
	 * Get the current script's URL by throwing an `Error` and analyzing it.
	 *
	 * @returns String or `undefined`
	 * @private
	 */
	  var _getCurrentScriptUrlFromError = function() {
	    var url, err;
	    try {
	      throw new _Error();
	    } catch (e) {
	      err = e;
	    }
	    if (err) {
	      url = err.sourceURL || err.fileName || _getCurrentScriptUrlFromErrorStack(err.stack);
	    }
	    return url;
	  };
	  /**
	 * Get the current script's URL.
	 *
	 * @returns String or `undefined`
	 * @private
	 */
	  var _getCurrentScriptUrl = function() {
	    var jsPath, scripts, i;
	    if (_document.currentScript && (jsPath = _document.currentScript.src)) {
	      return jsPath;
	    }
	    scripts = _document.getElementsByTagName("script");
	    if (scripts.length === 1) {
	      return scripts[0].src || undefined;
	    }
	    if ("readyState" in scripts[0]) {
	      for (i = scripts.length; i--; ) {
	        if (scripts[i].readyState === "interactive" && (jsPath = scripts[i].src)) {
	          return jsPath;
	        }
	      }
	    }
	    if (_document.readyState === "loading" && (jsPath = scripts[scripts.length - 1].src)) {
	      return jsPath;
	    }
	    if (jsPath = _getCurrentScriptUrlFromError()) {
	      return jsPath;
	    }
	    return undefined;
	  };
	  /**
	 * Get the unanimous parent directory of ALL script tags.
	 * If any script tags are either (a) inline or (b) from differing parent
	 * directories, this method must return `undefined`.
	 *
	 * @returns String or `undefined`
	 * @private
	 */
	  var _getUnanimousScriptParentDir = function() {
	    var i, jsDir, jsPath, scripts = _document.getElementsByTagName("script");
	    for (i = scripts.length; i--; ) {
	      if (!(jsPath = scripts[i].src)) {
	        jsDir = null;
	        break;
	      }
	      jsPath = _getDirPathOfUrl(jsPath);
	      if (jsDir == null) {
	        jsDir = jsPath;
	      } else if (jsDir !== jsPath) {
	        jsDir = null;
	        break;
	      }
	    }
	    return jsDir || undefined;
	  };
	  /**
	 * Get the presumed location of the "ZeroClipboard.swf" file, based on the location
	 * of the executing JavaScript file (e.g. "ZeroClipboard.js", etc.).
	 *
	 * @returns String
	 * @private
	 */
	  var _getDefaultSwfPath = function() {
	    var jsDir = _getDirPathOfUrl(_getCurrentScriptUrl()) || _getUnanimousScriptParentDir() || "";
	    return jsDir + "ZeroClipboard.swf";
	  };
	  /**
	 * Keep track of if the page is framed (in an `iframe`). This can never change.
	 * @private
	 */
	  var _pageIsFramed = function() {
	    return window.opener == null && (!!window.top && window != window.top || !!window.parent && window != window.parent);
	  }();
	  /**
	 * Keep track of the state of the Flash object.
	 * @private
	 */
	  var _flashState = {
	    bridge: null,
	    version: "0.0.0",
	    pluginType: "unknown",
	    disabled: null,
	    outdated: null,
	    sandboxed: null,
	    unavailable: null,
	    degraded: null,
	    deactivated: null,
	    overdue: null,
	    ready: null
	  };
	  /**
	 * The minimum Flash Player version required to use ZeroClipboard completely.
	 * @readonly
	 * @private
	 */
	  var _minimumFlashVersion = "11.0.0";
	  /**
	 * The ZeroClipboard library version number, as reported by Flash, at the time the SWF was compiled.
	 */
	  var _zcSwfVersion;
	  /**
	 * Keep track of all event listener registrations.
	 * @private
	 */
	  var _handlers = {};
	  /**
	 * Keep track of the currently activated element.
	 * @private
	 */
	  var _currentElement;
	  /**
	 * Keep track of the element that was activated when a `copy` process started.
	 * @private
	 */
	  var _copyTarget;
	  /**
	 * Keep track of data for the pending clipboard transaction.
	 * @private
	 */
	  var _clipData = {};
	  /**
	 * Keep track of data formats for the pending clipboard transaction.
	 * @private
	 */
	  var _clipDataFormatMap = null;
	  /**
	 * Keep track of the Flash availability check timeout.
	 * @private
	 */
	  var _flashCheckTimeout = 0;
	  /**
	 * Keep track of SWF network errors interval polling.
	 * @private
	 */
	  var _swfFallbackCheckInterval = 0;
	  /**
	 * The `message` store for events
	 * @private
	 */
	  var _eventMessages = {
	    ready: "Flash communication is established",
	    error: {
	      "flash-disabled": "Flash is disabled or not installed. May also be attempting to run Flash in a sandboxed iframe, which is impossible.",
	      "flash-outdated": "Flash is too outdated to support ZeroClipboard",
	      "flash-sandboxed": "Attempting to run Flash in a sandboxed iframe, which is impossible",
	      "flash-unavailable": "Flash is unable to communicate bidirectionally with JavaScript",
	      "flash-degraded": "Flash is unable to preserve data fidelity when communicating with JavaScript",
	      "flash-deactivated": "Flash is too outdated for your browser and/or is configured as click-to-activate.\nThis may also mean that the ZeroClipboard SWF object could not be loaded, so please check your `swfPath` configuration and/or network connectivity.\nMay also be attempting to run Flash in a sandboxed iframe, which is impossible.",
	      "flash-overdue": "Flash communication was established but NOT within the acceptable time limit",
	      "version-mismatch": "ZeroClipboard JS version number does not match ZeroClipboard SWF version number",
	      "clipboard-error": "At least one error was thrown while ZeroClipboard was attempting to inject your data into the clipboard",
	      "config-mismatch": "ZeroClipboard configuration does not match Flash's reality",
	      "swf-not-found": "The ZeroClipboard SWF object could not be loaded, so please check your `swfPath` configuration and/or network connectivity"
	    }
	  };
	  /**
	 * The `name`s of `error` events that can only occur is Flash has at least
	 * been able to load the SWF successfully.
	 * @private
	 */
	  var _errorsThatOnlyOccurAfterFlashLoads = [ "flash-unavailable", "flash-degraded", "flash-overdue", "version-mismatch", "config-mismatch", "clipboard-error" ];
	  /**
	 * The `name`s of `error` events that should likely result in the `_flashState`
	 * variable's property values being updated.
	 * @private
	 */
	  var _flashStateErrorNames = [ "flash-disabled", "flash-outdated", "flash-sandboxed", "flash-unavailable", "flash-degraded", "flash-deactivated", "flash-overdue" ];
	  /**
	 * A RegExp to match the `name` property of `error` events related to Flash.
	 * @private
	 */
	  var _flashStateErrorNameMatchingRegex = new RegExp("^flash-(" + _flashStateErrorNames.map(function(errorName) {
	    return errorName.replace(/^flash-/, "");
	  }).join("|") + ")$");
	  /**
	 * A RegExp to match the `name` property of `error` events related to Flash,
	 * which is enabled.
	 * @private
	 */
	  var _flashStateEnabledErrorNameMatchingRegex = new RegExp("^flash-(" + _flashStateErrorNames.slice(1).map(function(errorName) {
	    return errorName.replace(/^flash-/, "");
	  }).join("|") + ")$");
	  /**
	 * ZeroClipboard configuration defaults for the Core module.
	 * @private
	 */
	  var _globalConfig = {
	    swfPath: _getDefaultSwfPath(),
	    trustedDomains: window.location.host ? [ window.location.host ] : [],
	    cacheBust: true,
	    forceEnhancedClipboard: false,
	    flashLoadTimeout: 3e4,
	    autoActivate: true,
	    bubbleEvents: true,
	    containerId: "global-zeroclipboard-html-bridge",
	    containerClass: "global-zeroclipboard-container",
	    swfObjectId: "global-zeroclipboard-flash-bridge",
	    hoverClass: "zeroclipboard-is-hover",
	    activeClass: "zeroclipboard-is-active",
	    forceHandCursor: false,
	    title: null,
	    zIndex: 999999999
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.config`.
	 * @private
	 */
	  var _config = function(options) {
	    if (typeof options === "object" && options !== null) {
	      for (var prop in options) {
	        if (_hasOwn.call(options, prop)) {
	          if (/^(?:forceHandCursor|title|zIndex|bubbleEvents)$/.test(prop)) {
	            _globalConfig[prop] = options[prop];
	          } else if (_flashState.bridge == null) {
	            if (prop === "containerId" || prop === "swfObjectId") {
	              if (_isValidHtml4Id(options[prop])) {
	                _globalConfig[prop] = options[prop];
	              } else {
	                throw new Error("The specified `" + prop + "` value is not valid as an HTML4 Element ID");
	              }
	            } else {
	              _globalConfig[prop] = options[prop];
	            }
	          }
	        }
	      }
	    }
	    if (typeof options === "string" && options) {
	      if (_hasOwn.call(_globalConfig, options)) {
	        return _globalConfig[options];
	      }
	      return;
	    }
	    return _deepCopy(_globalConfig);
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.state`.
	 * @private
	 */
	  var _state = function() {
	    _detectSandbox();
	    return {
	      browser: _pick(_navigator, [ "userAgent", "platform", "appName" ]),
	      flash: _omit(_flashState, [ "bridge" ]),
	      zeroclipboard: {
	        version: ZeroClipboard.version,
	        config: ZeroClipboard.config()
	      }
	    };
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.isFlashUnusable`.
	 * @private
	 */
	  var _isFlashUnusable = function() {
	    return !!(_flashState.disabled || _flashState.outdated || _flashState.sandboxed || _flashState.unavailable || _flashState.degraded || _flashState.deactivated);
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.on`.
	 * @private
	 */
	  var _on = function(eventType, listener) {
	    var i, len, events, added = {};
	    if (typeof eventType === "string" && eventType) {
	      events = eventType.toLowerCase().split(/\s+/);
	    } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
	      for (i in eventType) {
	        if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
	          ZeroClipboard.on(i, eventType[i]);
	        }
	      }
	    }
	    if (events && events.length) {
	      for (i = 0, len = events.length; i < len; i++) {
	        eventType = events[i].replace(/^on/, "");
	        added[eventType] = true;
	        if (!_handlers[eventType]) {
	          _handlers[eventType] = [];
	        }
	        _handlers[eventType].push(listener);
	      }
	      if (added.ready && _flashState.ready) {
	        ZeroClipboard.emit({
	          type: "ready"
	        });
	      }
	      if (added.error) {
	        for (i = 0, len = _flashStateErrorNames.length; i < len; i++) {
	          if (_flashState[_flashStateErrorNames[i].replace(/^flash-/, "")] === true) {
	            ZeroClipboard.emit({
	              type: "error",
	              name: _flashStateErrorNames[i]
	            });
	            break;
	          }
	        }
	        if (_zcSwfVersion !== undefined && ZeroClipboard.version !== _zcSwfVersion) {
	          ZeroClipboard.emit({
	            type: "error",
	            name: "version-mismatch",
	            jsVersion: ZeroClipboard.version,
	            swfVersion: _zcSwfVersion
	          });
	        }
	      }
	    }
	    return ZeroClipboard;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.off`.
	 * @private
	 */
	  var _off = function(eventType, listener) {
	    var i, len, foundIndex, events, perEventHandlers;
	    if (arguments.length === 0) {
	      events = _keys(_handlers);
	    } else if (typeof eventType === "string" && eventType) {
	      events = eventType.split(/\s+/);
	    } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
	      for (i in eventType) {
	        if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
	          ZeroClipboard.off(i, eventType[i]);
	        }
	      }
	    }
	    if (events && events.length) {
	      for (i = 0, len = events.length; i < len; i++) {
	        eventType = events[i].toLowerCase().replace(/^on/, "");
	        perEventHandlers = _handlers[eventType];
	        if (perEventHandlers && perEventHandlers.length) {
	          if (listener) {
	            foundIndex = perEventHandlers.indexOf(listener);
	            while (foundIndex !== -1) {
	              perEventHandlers.splice(foundIndex, 1);
	              foundIndex = perEventHandlers.indexOf(listener, foundIndex);
	            }
	          } else {
	            perEventHandlers.length = 0;
	          }
	        }
	      }
	    }
	    return ZeroClipboard;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.handlers`.
	 * @private
	 */
	  var _listeners = function(eventType) {
	    var copy;
	    if (typeof eventType === "string" && eventType) {
	      copy = _deepCopy(_handlers[eventType]) || null;
	    } else {
	      copy = _deepCopy(_handlers);
	    }
	    return copy;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.emit`.
	 * @private
	 */
	  var _emit = function(event) {
	    var eventCopy, returnVal, tmp;
	    event = _createEvent(event);
	    if (!event) {
	      return;
	    }
	    if (_preprocessEvent(event)) {
	      return;
	    }
	    if (event.type === "ready" && _flashState.overdue === true) {
	      return ZeroClipboard.emit({
	        type: "error",
	        name: "flash-overdue"
	      });
	    }
	    eventCopy = _extend({}, event);
	    _dispatchCallbacks.call(this, eventCopy);
	    if (event.type === "copy") {
	      tmp = _mapClipDataToFlash(_clipData);
	      returnVal = tmp.data;
	      _clipDataFormatMap = tmp.formatMap;
	    }
	    return returnVal;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.create`.
	 * @private
	 */
	  var _create = function() {
	    var previousState = _flashState.sandboxed;
	    _detectSandbox();
	    if (typeof _flashState.ready !== "boolean") {
	      _flashState.ready = false;
	    }
	    if (_flashState.sandboxed !== previousState && _flashState.sandboxed === true) {
	      _flashState.ready = false;
	      ZeroClipboard.emit({
	        type: "error",
	        name: "flash-sandboxed"
	      });
	    } else if (!ZeroClipboard.isFlashUnusable() && _flashState.bridge === null) {
	      var maxWait = _globalConfig.flashLoadTimeout;
	      if (typeof maxWait === "number" && maxWait >= 0) {
	        _flashCheckTimeout = _setTimeout(function() {
	          if (typeof _flashState.deactivated !== "boolean") {
	            _flashState.deactivated = true;
	          }
	          if (_flashState.deactivated === true) {
	            ZeroClipboard.emit({
	              type: "error",
	              name: "flash-deactivated"
	            });
	          }
	        }, maxWait);
	      }
	      _flashState.overdue = false;
	      _embedSwf();
	    }
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.destroy`.
	 * @private
	 */
	  var _destroy = function() {
	    ZeroClipboard.clearData();
	    ZeroClipboard.blur();
	    ZeroClipboard.emit("destroy");
	    _unembedSwf();
	    ZeroClipboard.off();
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.setData`.
	 * @private
	 */
	  var _setData = function(format, data) {
	    var dataObj;
	    if (typeof format === "object" && format && typeof data === "undefined") {
	      dataObj = format;
	      ZeroClipboard.clearData();
	    } else if (typeof format === "string" && format) {
	      dataObj = {};
	      dataObj[format] = data;
	    } else {
	      return;
	    }
	    for (var dataFormat in dataObj) {
	      if (typeof dataFormat === "string" && dataFormat && _hasOwn.call(dataObj, dataFormat) && typeof dataObj[dataFormat] === "string" && dataObj[dataFormat]) {
	        _clipData[dataFormat] = dataObj[dataFormat];
	      }
	    }
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.clearData`.
	 * @private
	 */
	  var _clearData = function(format) {
	    if (typeof format === "undefined") {
	      _deleteOwnProperties(_clipData);
	      _clipDataFormatMap = null;
	    } else if (typeof format === "string" && _hasOwn.call(_clipData, format)) {
	      delete _clipData[format];
	    }
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.getData`.
	 * @private
	 */
	  var _getData = function(format) {
	    if (typeof format === "undefined") {
	      return _deepCopy(_clipData);
	    } else if (typeof format === "string" && _hasOwn.call(_clipData, format)) {
	      return _clipData[format];
	    }
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.focus`/`ZeroClipboard.activate`.
	 * @private
	 */
	  var _focus = function(element) {
	    if (!(element && element.nodeType === 1)) {
	      return;
	    }
	    if (_currentElement) {
	      _removeClass(_currentElement, _globalConfig.activeClass);
	      if (_currentElement !== element) {
	        _removeClass(_currentElement, _globalConfig.hoverClass);
	      }
	    }
	    _currentElement = element;
	    _addClass(element, _globalConfig.hoverClass);
	    var newTitle = element.getAttribute("title") || _globalConfig.title;
	    if (typeof newTitle === "string" && newTitle) {
	      var htmlBridge = _getHtmlBridge(_flashState.bridge);
	      if (htmlBridge) {
	        htmlBridge.setAttribute("title", newTitle);
	      }
	    }
	    var useHandCursor = _globalConfig.forceHandCursor === true || _getStyle(element, "cursor") === "pointer";
	    _setHandCursor(useHandCursor);
	    _reposition();
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.blur`/`ZeroClipboard.deactivate`.
	 * @private
	 */
	  var _blur = function() {
	    var htmlBridge = _getHtmlBridge(_flashState.bridge);
	    if (htmlBridge) {
	      htmlBridge.removeAttribute("title");
	      htmlBridge.style.left = "0px";
	      htmlBridge.style.top = "-9999px";
	      htmlBridge.style.width = "1px";
	      htmlBridge.style.height = "1px";
	    }
	    if (_currentElement) {
	      _removeClass(_currentElement, _globalConfig.hoverClass);
	      _removeClass(_currentElement, _globalConfig.activeClass);
	      _currentElement = null;
	    }
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.activeElement`.
	 * @private
	 */
	  var _activeElement = function() {
	    return _currentElement || null;
	  };
	  /**
	 * Check if a value is a valid HTML4 `ID` or `Name` token.
	 * @private
	 */
	  var _isValidHtml4Id = function(id) {
	    return typeof id === "string" && id && /^[A-Za-z][A-Za-z0-9_:\-\.]*$/.test(id);
	  };
	  /**
	 * Create or update an `event` object, based on the `eventType`.
	 * @private
	 */
	  var _createEvent = function(event) {
	    var eventType;
	    if (typeof event === "string" && event) {
	      eventType = event;
	      event = {};
	    } else if (typeof event === "object" && event && typeof event.type === "string" && event.type) {
	      eventType = event.type;
	    }
	    if (!eventType) {
	      return;
	    }
	    eventType = eventType.toLowerCase();
	    if (!event.target && (/^(copy|aftercopy|_click)$/.test(eventType) || eventType === "error" && event.name === "clipboard-error")) {
	      event.target = _copyTarget;
	    }
	    _extend(event, {
	      type: eventType,
	      target: event.target || _currentElement || null,
	      relatedTarget: event.relatedTarget || null,
	      currentTarget: _flashState && _flashState.bridge || null,
	      timeStamp: event.timeStamp || _now() || null
	    });
	    var msg = _eventMessages[event.type];
	    if (event.type === "error" && event.name && msg) {
	      msg = msg[event.name];
	    }
	    if (msg) {
	      event.message = msg;
	    }
	    if (event.type === "ready") {
	      _extend(event, {
	        target: null,
	        version: _flashState.version
	      });
	    }
	    if (event.type === "error") {
	      if (_flashStateErrorNameMatchingRegex.test(event.name)) {
	        _extend(event, {
	          target: null,
	          minimumVersion: _minimumFlashVersion
	        });
	      }
	      if (_flashStateEnabledErrorNameMatchingRegex.test(event.name)) {
	        _extend(event, {
	          version: _flashState.version
	        });
	      }
	    }
	    if (event.type === "copy") {
	      event.clipboardData = {
	        setData: ZeroClipboard.setData,
	        clearData: ZeroClipboard.clearData
	      };
	    }
	    if (event.type === "aftercopy") {
	      event = _mapClipResultsFromFlash(event, _clipDataFormatMap);
	    }
	    if (event.target && !event.relatedTarget) {
	      event.relatedTarget = _getRelatedTarget(event.target);
	    }
	    return _addMouseData(event);
	  };
	  /**
	 * Get a relatedTarget from the target's `data-clipboard-target` attribute
	 * @private
	 */
	  var _getRelatedTarget = function(targetEl) {
	    var relatedTargetId = targetEl && targetEl.getAttribute && targetEl.getAttribute("data-clipboard-target");
	    return relatedTargetId ? _document.getElementById(relatedTargetId) : null;
	  };
	  /**
	 * Add element and position data to `MouseEvent` instances
	 * @private
	 */
	  var _addMouseData = function(event) {
	    if (event && /^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) {
	      var srcElement = event.target;
	      var fromElement = event.type === "_mouseover" && event.relatedTarget ? event.relatedTarget : undefined;
	      var toElement = event.type === "_mouseout" && event.relatedTarget ? event.relatedTarget : undefined;
	      var pos = _getElementPosition(srcElement);
	      var screenLeft = _window.screenLeft || _window.screenX || 0;
	      var screenTop = _window.screenTop || _window.screenY || 0;
	      var scrollLeft = _document.body.scrollLeft + _document.documentElement.scrollLeft;
	      var scrollTop = _document.body.scrollTop + _document.documentElement.scrollTop;
	      var pageX = pos.left + (typeof event._stageX === "number" ? event._stageX : 0);
	      var pageY = pos.top + (typeof event._stageY === "number" ? event._stageY : 0);
	      var clientX = pageX - scrollLeft;
	      var clientY = pageY - scrollTop;
	      var screenX = screenLeft + clientX;
	      var screenY = screenTop + clientY;
	      var moveX = typeof event.movementX === "number" ? event.movementX : 0;
	      var moveY = typeof event.movementY === "number" ? event.movementY : 0;
	      delete event._stageX;
	      delete event._stageY;
	      _extend(event, {
	        srcElement: srcElement,
	        fromElement: fromElement,
	        toElement: toElement,
	        screenX: screenX,
	        screenY: screenY,
	        pageX: pageX,
	        pageY: pageY,
	        clientX: clientX,
	        clientY: clientY,
	        x: clientX,
	        y: clientY,
	        movementX: moveX,
	        movementY: moveY,
	        offsetX: 0,
	        offsetY: 0,
	        layerX: 0,
	        layerY: 0
	      });
	    }
	    return event;
	  };
	  /**
	 * Determine if an event's registered handlers should be execute synchronously or asynchronously.
	 *
	 * @returns {boolean}
	 * @private
	 */
	  var _shouldPerformAsync = function(event) {
	    var eventType = event && typeof event.type === "string" && event.type || "";
	    return !/^(?:(?:before)?copy|destroy)$/.test(eventType);
	  };
	  /**
	 * Control if a callback should be executed asynchronously or not.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _dispatchCallback = function(func, context, args, async) {
	    if (async) {
	      _setTimeout(function() {
	        func.apply(context, args);
	      }, 0);
	    } else {
	      func.apply(context, args);
	    }
	  };
	  /**
	 * Handle the actual dispatching of events to client instances.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _dispatchCallbacks = function(event) {
	    if (!(typeof event === "object" && event && event.type)) {
	      return;
	    }
	    var async = _shouldPerformAsync(event);
	    var wildcardTypeHandlers = _handlers["*"] || [];
	    var specificTypeHandlers = _handlers[event.type] || [];
	    var handlers = wildcardTypeHandlers.concat(specificTypeHandlers);
	    if (handlers && handlers.length) {
	      var i, len, func, context, eventCopy, originalContext = this;
	      for (i = 0, len = handlers.length; i < len; i++) {
	        func = handlers[i];
	        context = originalContext;
	        if (typeof func === "string" && typeof _window[func] === "function") {
	          func = _window[func];
	        }
	        if (typeof func === "object" && func && typeof func.handleEvent === "function") {
	          context = func;
	          func = func.handleEvent;
	        }
	        if (typeof func === "function") {
	          eventCopy = _extend({}, event);
	          _dispatchCallback(func, context, [ eventCopy ], async);
	        }
	      }
	    }
	    return this;
	  };
	  /**
	 * Check an `error` event's `name` property to see if Flash has
	 * already loaded, which rules out possible `iframe` sandboxing.
	 * @private
	 */
	  var _getSandboxStatusFromErrorEvent = function(event) {
	    var isSandboxed = null;
	    if (_pageIsFramed === false || event && event.type === "error" && event.name && _errorsThatOnlyOccurAfterFlashLoads.indexOf(event.name) !== -1) {
	      isSandboxed = false;
	    }
	    return isSandboxed;
	  };
	  /**
	 * Preprocess any special behaviors, reactions, or state changes after receiving this event.
	 * Executes only once per event emitted, NOT once per client.
	 * @private
	 */
	  var _preprocessEvent = function(event) {
	    var element = event.target || _currentElement || null;
	    var sourceIsSwf = event._source === "swf";
	    delete event._source;
	    switch (event.type) {
	     case "error":
	      var isSandboxed = event.name === "flash-sandboxed" || _getSandboxStatusFromErrorEvent(event);
	      if (typeof isSandboxed === "boolean") {
	        _flashState.sandboxed = isSandboxed;
	      }
	      if (_flashStateErrorNames.indexOf(event.name) !== -1) {
	        _extend(_flashState, {
	          disabled: event.name === "flash-disabled",
	          outdated: event.name === "flash-outdated",
	          unavailable: event.name === "flash-unavailable",
	          degraded: event.name === "flash-degraded",
	          deactivated: event.name === "flash-deactivated",
	          overdue: event.name === "flash-overdue",
	          ready: false
	        });
	      } else if (event.name === "version-mismatch") {
	        _zcSwfVersion = event.swfVersion;
	        _extend(_flashState, {
	          disabled: false,
	          outdated: false,
	          unavailable: false,
	          degraded: false,
	          deactivated: false,
	          overdue: false,
	          ready: false
	        });
	      }
	      _clearTimeoutsAndPolling();
	      break;

	     case "ready":
	      _zcSwfVersion = event.swfVersion;
	      var wasDeactivated = _flashState.deactivated === true;
	      _extend(_flashState, {
	        disabled: false,
	        outdated: false,
	        sandboxed: false,
	        unavailable: false,
	        degraded: false,
	        deactivated: false,
	        overdue: wasDeactivated,
	        ready: !wasDeactivated
	      });
	      _clearTimeoutsAndPolling();
	      break;

	     case "beforecopy":
	      _copyTarget = element;
	      break;

	     case "copy":
	      var textContent, htmlContent, targetEl = event.relatedTarget;
	      if (!(_clipData["text/html"] || _clipData["text/plain"]) && targetEl && (htmlContent = targetEl.value || targetEl.outerHTML || targetEl.innerHTML) && (textContent = targetEl.value || targetEl.textContent || targetEl.innerText)) {
	        event.clipboardData.clearData();
	        event.clipboardData.setData("text/plain", textContent);
	        if (htmlContent !== textContent) {
	          event.clipboardData.setData("text/html", htmlContent);
	        }
	      } else if (!_clipData["text/plain"] && event.target && (textContent = event.target.getAttribute("data-clipboard-text"))) {
	        event.clipboardData.clearData();
	        event.clipboardData.setData("text/plain", textContent);
	      }
	      break;

	     case "aftercopy":
	      _queueEmitClipboardErrors(event);
	      ZeroClipboard.clearData();
	      if (element && element !== _safeActiveElement() && element.focus) {
	        element.focus();
	      }
	      break;

	     case "_mouseover":
	      ZeroClipboard.focus(element);
	      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
	        if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) {
	          _fireMouseEvent(_extend({}, event, {
	            type: "mouseenter",
	            bubbles: false,
	            cancelable: false
	          }));
	        }
	        _fireMouseEvent(_extend({}, event, {
	          type: "mouseover"
	        }));
	      }
	      break;

	     case "_mouseout":
	      ZeroClipboard.blur();
	      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
	        if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) {
	          _fireMouseEvent(_extend({}, event, {
	            type: "mouseleave",
	            bubbles: false,
	            cancelable: false
	          }));
	        }
	        _fireMouseEvent(_extend({}, event, {
	          type: "mouseout"
	        }));
	      }
	      break;

	     case "_mousedown":
	      _addClass(element, _globalConfig.activeClass);
	      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
	        _fireMouseEvent(_extend({}, event, {
	          type: event.type.slice(1)
	        }));
	      }
	      break;

	     case "_mouseup":
	      _removeClass(element, _globalConfig.activeClass);
	      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
	        _fireMouseEvent(_extend({}, event, {
	          type: event.type.slice(1)
	        }));
	      }
	      break;

	     case "_click":
	      _copyTarget = null;
	      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
	        _fireMouseEvent(_extend({}, event, {
	          type: event.type.slice(1)
	        }));
	      }
	      break;

	     case "_mousemove":
	      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
	        _fireMouseEvent(_extend({}, event, {
	          type: event.type.slice(1)
	        }));
	      }
	      break;
	    }
	    if (/^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) {
	      return true;
	    }
	  };
	  /**
	 * Check an "aftercopy" event for clipboard errors and emit a corresponding "error" event.
	 * @private
	 */
	  var _queueEmitClipboardErrors = function(aftercopyEvent) {
	    if (aftercopyEvent.errors && aftercopyEvent.errors.length > 0) {
	      var errorEvent = _deepCopy(aftercopyEvent);
	      _extend(errorEvent, {
	        type: "error",
	        name: "clipboard-error"
	      });
	      delete errorEvent.success;
	      _setTimeout(function() {
	        ZeroClipboard.emit(errorEvent);
	      }, 0);
	    }
	  };
	  /**
	 * Dispatch a synthetic MouseEvent.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _fireMouseEvent = function(event) {
	    if (!(event && typeof event.type === "string" && event)) {
	      return;
	    }
	    var e, target = event.target || null, doc = target && target.ownerDocument || _document, defaults = {
	      view: doc.defaultView || _window,
	      canBubble: true,
	      cancelable: true,
	      detail: event.type === "click" ? 1 : 0,
	      button: typeof event.which === "number" ? event.which - 1 : typeof event.button === "number" ? event.button : doc.createEvent ? 0 : 1
	    }, args = _extend(defaults, event);
	    if (!target) {
	      return;
	    }
	    if (doc.createEvent && target.dispatchEvent) {
	      args = [ args.type, args.canBubble, args.cancelable, args.view, args.detail, args.screenX, args.screenY, args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey, args.button, args.relatedTarget ];
	      e = doc.createEvent("MouseEvents");
	      if (e.initMouseEvent) {
	        e.initMouseEvent.apply(e, args);
	        e._source = "js";
	        target.dispatchEvent(e);
	      }
	    }
	  };
	  /**
	 * Continuously poll the DOM until either:
	 *  (a) the fallback content becomes visible, or
	 *  (b) we receive an event from SWF (handled elsewhere)
	 *
	 * IMPORTANT:
	 * This is NOT a necessary check but it can result in significantly faster
	 * detection of bad `swfPath` configuration and/or network/server issues [in
	 * supported browsers] than waiting for the entire `flashLoadTimeout` duration
	 * to elapse before detecting that the SWF cannot be loaded. The detection
	 * duration can be anywhere from 10-30 times faster [in supported browsers] by
	 * using this approach.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _watchForSwfFallbackContent = function() {
	    var maxWait = _globalConfig.flashLoadTimeout;
	    if (typeof maxWait === "number" && maxWait >= 0) {
	      var pollWait = Math.min(1e3, maxWait / 10);
	      var fallbackContentId = _globalConfig.swfObjectId + "_fallbackContent";
	      _swfFallbackCheckInterval = _setInterval(function() {
	        var el = _document.getElementById(fallbackContentId);
	        if (_isElementVisible(el)) {
	          _clearTimeoutsAndPolling();
	          _flashState.deactivated = null;
	          ZeroClipboard.emit({
	            type: "error",
	            name: "swf-not-found"
	          });
	        }
	      }, pollWait);
	    }
	  };
	  /**
	 * Create the HTML bridge element to embed the Flash object into.
	 * @private
	 */
	  var _createHtmlBridge = function() {
	    var container = _document.createElement("div");
	    container.id = _globalConfig.containerId;
	    container.className = _globalConfig.containerClass;
	    container.style.position = "absolute";
	    container.style.left = "0px";
	    container.style.top = "-9999px";
	    container.style.width = "1px";
	    container.style.height = "1px";
	    container.style.zIndex = "" + _getSafeZIndex(_globalConfig.zIndex);
	    return container;
	  };
	  /**
	 * Get the HTML element container that wraps the Flash bridge object/element.
	 * @private
	 */
	  var _getHtmlBridge = function(flashBridge) {
	    var htmlBridge = flashBridge && flashBridge.parentNode;
	    while (htmlBridge && htmlBridge.nodeName === "OBJECT" && htmlBridge.parentNode) {
	      htmlBridge = htmlBridge.parentNode;
	    }
	    return htmlBridge || null;
	  };
	  /**
	 * Create the SWF object.
	 *
	 * @returns The SWF object reference.
	 * @private
	 */
	  var _embedSwf = function() {
	    var len, flashBridge = _flashState.bridge, container = _getHtmlBridge(flashBridge);
	    if (!flashBridge) {
	      var allowScriptAccess = _determineScriptAccess(_window.location.host, _globalConfig);
	      var allowNetworking = allowScriptAccess === "never" ? "none" : "all";
	      var flashvars = _vars(_extend({
	        jsVersion: ZeroClipboard.version
	      }, _globalConfig));
	      var swfUrl = _globalConfig.swfPath + _cacheBust(_globalConfig.swfPath, _globalConfig);
	      container = _createHtmlBridge();
	      var divToBeReplaced = _document.createElement("div");
	      container.appendChild(divToBeReplaced);
	      _document.body.appendChild(container);
	      var tmpDiv = _document.createElement("div");
	      var usingActiveX = _flashState.pluginType === "activex";
	      tmpDiv.innerHTML = '<object id="' + _globalConfig.swfObjectId + '" name="' + _globalConfig.swfObjectId + '" ' + 'width="100%" height="100%" ' + (usingActiveX ? 'classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000"' : 'type="application/x-shockwave-flash" data="' + swfUrl + '"') + ">" + (usingActiveX ? '<param name="movie" value="' + swfUrl + '"/>' : "") + '<param name="allowScriptAccess" value="' + allowScriptAccess + '"/>' + '<param name="allowNetworking" value="' + allowNetworking + '"/>' + '<param name="menu" value="false"/>' + '<param name="wmode" value="transparent"/>' + '<param name="flashvars" value="' + flashvars + '"/>' + '<div id="' + _globalConfig.swfObjectId + '_fallbackContent">&nbsp;</div>' + "</object>";
	      flashBridge = tmpDiv.firstChild;
	      tmpDiv = null;
	      _unwrap(flashBridge).ZeroClipboard = ZeroClipboard;
	      container.replaceChild(flashBridge, divToBeReplaced);
	      _watchForSwfFallbackContent();
	    }
	    if (!flashBridge) {
	      flashBridge = _document[_globalConfig.swfObjectId];
	      if (flashBridge && (len = flashBridge.length)) {
	        flashBridge = flashBridge[len - 1];
	      }
	      if (!flashBridge && container) {
	        flashBridge = container.firstChild;
	      }
	    }
	    _flashState.bridge = flashBridge || null;
	    return flashBridge;
	  };
	  /**
	 * Destroy the SWF object.
	 * @private
	 */
	  var _unembedSwf = function() {
	    var flashBridge = _flashState.bridge;
	    if (flashBridge) {
	      var htmlBridge = _getHtmlBridge(flashBridge);
	      if (htmlBridge) {
	        if (_flashState.pluginType === "activex" && "readyState" in flashBridge) {
	          flashBridge.style.display = "none";
	          (function removeSwfFromIE() {
	            if (flashBridge.readyState === 4) {
	              for (var prop in flashBridge) {
	                if (typeof flashBridge[prop] === "function") {
	                  flashBridge[prop] = null;
	                }
	              }
	              if (flashBridge.parentNode) {
	                flashBridge.parentNode.removeChild(flashBridge);
	              }
	              if (htmlBridge.parentNode) {
	                htmlBridge.parentNode.removeChild(htmlBridge);
	              }
	            } else {
	              _setTimeout(removeSwfFromIE, 10);
	            }
	          })();
	        } else {
	          if (flashBridge.parentNode) {
	            flashBridge.parentNode.removeChild(flashBridge);
	          }
	          if (htmlBridge.parentNode) {
	            htmlBridge.parentNode.removeChild(htmlBridge);
	          }
	        }
	      }
	      _clearTimeoutsAndPolling();
	      _flashState.ready = null;
	      _flashState.bridge = null;
	      _flashState.deactivated = null;
	      _zcSwfVersion = undefined;
	    }
	  };
	  /**
	 * Map the data format names of the "clipData" to Flash-friendly names.
	 *
	 * @returns A new transformed object.
	 * @private
	 */
	  var _mapClipDataToFlash = function(clipData) {
	    var newClipData = {}, formatMap = {};
	    if (!(typeof clipData === "object" && clipData)) {
	      return;
	    }
	    for (var dataFormat in clipData) {
	      if (dataFormat && _hasOwn.call(clipData, dataFormat) && typeof clipData[dataFormat] === "string" && clipData[dataFormat]) {
	        switch (dataFormat.toLowerCase()) {
	         case "text/plain":
	         case "text":
	         case "air:text":
	         case "flash:text":
	          newClipData.text = clipData[dataFormat];
	          formatMap.text = dataFormat;
	          break;

	         case "text/html":
	         case "html":
	         case "air:html":
	         case "flash:html":
	          newClipData.html = clipData[dataFormat];
	          formatMap.html = dataFormat;
	          break;

	         case "application/rtf":
	         case "text/rtf":
	         case "rtf":
	         case "richtext":
	         case "air:rtf":
	         case "flash:rtf":
	          newClipData.rtf = clipData[dataFormat];
	          formatMap.rtf = dataFormat;
	          break;

	         default:
	          break;
	        }
	      }
	    }
	    return {
	      data: newClipData,
	      formatMap: formatMap
	    };
	  };
	  /**
	 * Map the data format names from Flash-friendly names back to their original "clipData" names (via a format mapping).
	 *
	 * @returns A new transformed object.
	 * @private
	 */
	  var _mapClipResultsFromFlash = function(clipResults, formatMap) {
	    if (!(typeof clipResults === "object" && clipResults && typeof formatMap === "object" && formatMap)) {
	      return clipResults;
	    }
	    var newResults = {};
	    for (var prop in clipResults) {
	      if (_hasOwn.call(clipResults, prop)) {
	        if (prop === "errors") {
	          newResults[prop] = clipResults[prop] ? clipResults[prop].slice() : [];
	          for (var i = 0, len = newResults[prop].length; i < len; i++) {
	            newResults[prop][i].format = formatMap[newResults[prop][i].format];
	          }
	        } else if (prop !== "success" && prop !== "data") {
	          newResults[prop] = clipResults[prop];
	        } else {
	          newResults[prop] = {};
	          var tmpHash = clipResults[prop];
	          for (var dataFormat in tmpHash) {
	            if (dataFormat && _hasOwn.call(tmpHash, dataFormat) && _hasOwn.call(formatMap, dataFormat)) {
	              newResults[prop][formatMap[dataFormat]] = tmpHash[dataFormat];
	            }
	          }
	        }
	      }
	    }
	    return newResults;
	  };
	  /**
	 * Will look at a path, and will create a "?noCache={time}" or "&noCache={time}"
	 * query param string to return. Does NOT append that string to the original path.
	 * This is useful because ExternalInterface often breaks when a Flash SWF is cached.
	 *
	 * @returns The `noCache` query param with necessary "?"/"&" prefix.
	 * @private
	 */
	  var _cacheBust = function(path, options) {
	    var cacheBust = options == null || options && options.cacheBust === true;
	    if (cacheBust) {
	      return (path.indexOf("?") === -1 ? "?" : "&") + "noCache=" + _now();
	    } else {
	      return "";
	    }
	  };
	  /**
	 * Creates a query string for the FlashVars param.
	 * Does NOT include the cache-busting query param.
	 *
	 * @returns FlashVars query string
	 * @private
	 */
	  var _vars = function(options) {
	    var i, len, domain, domains, str = "", trustedOriginsExpanded = [];
	    if (options.trustedDomains) {
	      if (typeof options.trustedDomains === "string") {
	        domains = [ options.trustedDomains ];
	      } else if (typeof options.trustedDomains === "object" && "length" in options.trustedDomains) {
	        domains = options.trustedDomains;
	      }
	    }
	    if (domains && domains.length) {
	      for (i = 0, len = domains.length; i < len; i++) {
	        if (_hasOwn.call(domains, i) && domains[i] && typeof domains[i] === "string") {
	          domain = _extractDomain(domains[i]);
	          if (!domain) {
	            continue;
	          }
	          if (domain === "*") {
	            trustedOriginsExpanded.length = 0;
	            trustedOriginsExpanded.push(domain);
	            break;
	          }
	          trustedOriginsExpanded.push.apply(trustedOriginsExpanded, [ domain, "//" + domain, _window.location.protocol + "//" + domain ]);
	        }
	      }
	    }
	    if (trustedOriginsExpanded.length) {
	      str += "trustedOrigins=" + _encodeURIComponent(trustedOriginsExpanded.join(","));
	    }
	    if (options.forceEnhancedClipboard === true) {
	      str += (str ? "&" : "") + "forceEnhancedClipboard=true";
	    }
	    if (typeof options.swfObjectId === "string" && options.swfObjectId) {
	      str += (str ? "&" : "") + "swfObjectId=" + _encodeURIComponent(options.swfObjectId);
	    }
	    if (typeof options.jsVersion === "string" && options.jsVersion) {
	      str += (str ? "&" : "") + "jsVersion=" + _encodeURIComponent(options.jsVersion);
	    }
	    return str;
	  };
	  /**
	 * Extract the domain (e.g. "github.com") from an origin (e.g. "https://github.com") or
	 * URL (e.g. "https://github.com/zeroclipboard/zeroclipboard/").
	 *
	 * @returns the domain
	 * @private
	 */
	  var _extractDomain = function(originOrUrl) {
	    if (originOrUrl == null || originOrUrl === "") {
	      return null;
	    }
	    originOrUrl = originOrUrl.replace(/^\s+|\s+$/g, "");
	    if (originOrUrl === "") {
	      return null;
	    }
	    var protocolIndex = originOrUrl.indexOf("//");
	    originOrUrl = protocolIndex === -1 ? originOrUrl : originOrUrl.slice(protocolIndex + 2);
	    var pathIndex = originOrUrl.indexOf("/");
	    originOrUrl = pathIndex === -1 ? originOrUrl : protocolIndex === -1 || pathIndex === 0 ? null : originOrUrl.slice(0, pathIndex);
	    if (originOrUrl && originOrUrl.slice(-4).toLowerCase() === ".swf") {
	      return null;
	    }
	    return originOrUrl || null;
	  };
	  /**
	 * Set `allowScriptAccess` based on `trustedDomains` and `window.location.host` vs. `swfPath`.
	 *
	 * @returns The appropriate script access level.
	 * @private
	 */
	  var _determineScriptAccess = function() {
	    var _extractAllDomains = function(origins) {
	      var i, len, tmp, resultsArray = [];
	      if (typeof origins === "string") {
	        origins = [ origins ];
	      }
	      if (!(typeof origins === "object" && origins && typeof origins.length === "number")) {
	        return resultsArray;
	      }
	      for (i = 0, len = origins.length; i < len; i++) {
	        if (_hasOwn.call(origins, i) && (tmp = _extractDomain(origins[i]))) {
	          if (tmp === "*") {
	            resultsArray.length = 0;
	            resultsArray.push("*");
	            break;
	          }
	          if (resultsArray.indexOf(tmp) === -1) {
	            resultsArray.push(tmp);
	          }
	        }
	      }
	      return resultsArray;
	    };
	    return function(currentDomain, configOptions) {
	      var swfDomain = _extractDomain(configOptions.swfPath);
	      if (swfDomain === null) {
	        swfDomain = currentDomain;
	      }
	      var trustedDomains = _extractAllDomains(configOptions.trustedDomains);
	      var len = trustedDomains.length;
	      if (len > 0) {
	        if (len === 1 && trustedDomains[0] === "*") {
	          return "always";
	        }
	        if (trustedDomains.indexOf(currentDomain) !== -1) {
	          if (len === 1 && currentDomain === swfDomain) {
	            return "sameDomain";
	          }
	          return "always";
	        }
	      }
	      return "never";
	    };
	  }();
	  /**
	 * Get the currently active/focused DOM element.
	 *
	 * @returns the currently active/focused element, or `null`
	 * @private
	 */
	  var _safeActiveElement = function() {
	    try {
	      return _document.activeElement;
	    } catch (err) {
	      return null;
	    }
	  };
	  /**
	 * Add a class to an element, if it doesn't already have it.
	 *
	 * @returns The element, with its new class added.
	 * @private
	 */
	  var _addClass = function(element, value) {
	    var c, cl, className, classNames = [];
	    if (typeof value === "string" && value) {
	      classNames = value.split(/\s+/);
	    }
	    if (element && element.nodeType === 1 && classNames.length > 0) {
	      if (element.classList) {
	        for (c = 0, cl = classNames.length; c < cl; c++) {
	          element.classList.add(classNames[c]);
	        }
	      } else if (element.hasOwnProperty("className")) {
	        className = " " + element.className + " ";
	        for (c = 0, cl = classNames.length; c < cl; c++) {
	          if (className.indexOf(" " + classNames[c] + " ") === -1) {
	            className += classNames[c] + " ";
	          }
	        }
	        element.className = className.replace(/^\s+|\s+$/g, "");
	      }
	    }
	    return element;
	  };
	  /**
	 * Remove a class from an element, if it has it.
	 *
	 * @returns The element, with its class removed.
	 * @private
	 */
	  var _removeClass = function(element, value) {
	    var c, cl, className, classNames = [];
	    if (typeof value === "string" && value) {
	      classNames = value.split(/\s+/);
	    }
	    if (element && element.nodeType === 1 && classNames.length > 0) {
	      if (element.classList && element.classList.length > 0) {
	        for (c = 0, cl = classNames.length; c < cl; c++) {
	          element.classList.remove(classNames[c]);
	        }
	      } else if (element.className) {
	        className = (" " + element.className + " ").replace(/[\r\n\t]/g, " ");
	        for (c = 0, cl = classNames.length; c < cl; c++) {
	          className = className.replace(" " + classNames[c] + " ", " ");
	        }
	        element.className = className.replace(/^\s+|\s+$/g, "");
	      }
	    }
	    return element;
	  };
	  /**
	 * Attempt to interpret the element's CSS styling. If `prop` is `"cursor"`,
	 * then we assume that it should be a hand ("pointer") cursor if the element
	 * is an anchor element ("a" tag).
	 *
	 * @returns The computed style property.
	 * @private
	 */
	  var _getStyle = function(el, prop) {
	    var value = _getComputedStyle(el, null).getPropertyValue(prop);
	    if (prop === "cursor") {
	      if (!value || value === "auto") {
	        if (el.nodeName === "A") {
	          return "pointer";
	        }
	      }
	    }
	    return value;
	  };
	  /**
	 * Get the absolutely positioned coordinates of a DOM element.
	 *
	 * @returns Object containing the element's position, width, and height.
	 * @private
	 */
	  var _getElementPosition = function(el) {
	    var pos = {
	      left: 0,
	      top: 0,
	      width: 0,
	      height: 0
	    };
	    if (el.getBoundingClientRect) {
	      var elRect = el.getBoundingClientRect();
	      var pageXOffset = _window.pageXOffset;
	      var pageYOffset = _window.pageYOffset;
	      var leftBorderWidth = _document.documentElement.clientLeft || 0;
	      var topBorderWidth = _document.documentElement.clientTop || 0;
	      var leftBodyOffset = 0;
	      var topBodyOffset = 0;
	      if (_getStyle(_document.body, "position") === "relative") {
	        var bodyRect = _document.body.getBoundingClientRect();
	        var htmlRect = _document.documentElement.getBoundingClientRect();
	        leftBodyOffset = bodyRect.left - htmlRect.left || 0;
	        topBodyOffset = bodyRect.top - htmlRect.top || 0;
	      }
	      pos.left = elRect.left + pageXOffset - leftBorderWidth - leftBodyOffset;
	      pos.top = elRect.top + pageYOffset - topBorderWidth - topBodyOffset;
	      pos.width = "width" in elRect ? elRect.width : elRect.right - elRect.left;
	      pos.height = "height" in elRect ? elRect.height : elRect.bottom - elRect.top;
	    }
	    return pos;
	  };
	  /**
	 * Determine is an element is visible somewhere within the document (page).
	 *
	 * @returns Boolean
	 * @private
	 */
	  var _isElementVisible = function(el) {
	    if (!el) {
	      return false;
	    }
	    var styles = _getComputedStyle(el, null);
	    var hasCssHeight = _parseFloat(styles.height) > 0;
	    var hasCssWidth = _parseFloat(styles.width) > 0;
	    var hasCssTop = _parseFloat(styles.top) >= 0;
	    var hasCssLeft = _parseFloat(styles.left) >= 0;
	    var cssKnows = hasCssHeight && hasCssWidth && hasCssTop && hasCssLeft;
	    var rect = cssKnows ? null : _getElementPosition(el);
	    var isVisible = styles.display !== "none" && styles.visibility !== "collapse" && (cssKnows || !!rect && (hasCssHeight || rect.height > 0) && (hasCssWidth || rect.width > 0) && (hasCssTop || rect.top >= 0) && (hasCssLeft || rect.left >= 0));
	    return isVisible;
	  };
	  /**
	 * Clear all existing timeouts and interval polling delegates.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _clearTimeoutsAndPolling = function() {
	    _clearTimeout(_flashCheckTimeout);
	    _flashCheckTimeout = 0;
	    _clearInterval(_swfFallbackCheckInterval);
	    _swfFallbackCheckInterval = 0;
	  };
	  /**
	 * Reposition the Flash object to cover the currently activated element.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _reposition = function() {
	    var htmlBridge;
	    if (_currentElement && (htmlBridge = _getHtmlBridge(_flashState.bridge))) {
	      var pos = _getElementPosition(_currentElement);
	      _extend(htmlBridge.style, {
	        width: pos.width + "px",
	        height: pos.height + "px",
	        top: pos.top + "px",
	        left: pos.left + "px",
	        zIndex: "" + _getSafeZIndex(_globalConfig.zIndex)
	      });
	    }
	  };
	  /**
	 * Sends a signal to the Flash object to display the hand cursor if `true`.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _setHandCursor = function(enabled) {
	    if (_flashState.ready === true) {
	      if (_flashState.bridge && typeof _flashState.bridge.setHandCursor === "function") {
	        _flashState.bridge.setHandCursor(enabled);
	      } else {
	        _flashState.ready = false;
	      }
	    }
	  };
	  /**
	 * Get a safe value for `zIndex`
	 *
	 * @returns an integer, or "auto"
	 * @private
	 */
	  var _getSafeZIndex = function(val) {
	    if (/^(?:auto|inherit)$/.test(val)) {
	      return val;
	    }
	    var zIndex;
	    if (typeof val === "number" && !_isNaN(val)) {
	      zIndex = val;
	    } else if (typeof val === "string") {
	      zIndex = _getSafeZIndex(_parseInt(val, 10));
	    }
	    return typeof zIndex === "number" ? zIndex : "auto";
	  };
	  /**
	 * Attempt to detect if ZeroClipboard is executing inside of a sandboxed iframe.
	 * If it is, Flash Player cannot be used, so ZeroClipboard is dead in the water.
	 *
	 * @see {@link http://lists.w3.org/Archives/Public/public-whatwg-archive/2014Dec/0002.html}
	 * @see {@link https://github.com/zeroclipboard/zeroclipboard/issues/511}
	 * @see {@link http://zeroclipboard.org/test-iframes.html}
	 *
	 * @returns `true` (is sandboxed), `false` (is not sandboxed), or `null` (uncertain) 
	 * @private
	 */
	  var _detectSandbox = function(doNotReassessFlashSupport) {
	    var effectiveScriptOrigin, frame, frameError, previousState = _flashState.sandboxed, isSandboxed = null;
	    doNotReassessFlashSupport = doNotReassessFlashSupport === true;
	    if (_pageIsFramed === false) {
	      isSandboxed = false;
	    } else {
	      try {
	        frame = window.frameElement || null;
	      } catch (e) {
	        frameError = {
	          name: e.name,
	          message: e.message
	        };
	      }
	      if (frame && frame.nodeType === 1 && frame.nodeName === "IFRAME") {
	        try {
	          isSandboxed = frame.hasAttribute("sandbox");
	        } catch (e) {
	          isSandboxed = null;
	        }
	      } else {
	        try {
	          effectiveScriptOrigin = document.domain || null;
	        } catch (e) {
	          effectiveScriptOrigin = null;
	        }
	        if (effectiveScriptOrigin === null || frameError && frameError.name === "SecurityError" && /(^|[\s\(\[@])sandbox(es|ed|ing|[\s\.,!\)\]@]|$)/.test(frameError.message.toLowerCase())) {
	          isSandboxed = true;
	        }
	      }
	    }
	    _flashState.sandboxed = isSandboxed;
	    if (previousState !== isSandboxed && !doNotReassessFlashSupport) {
	      _detectFlashSupport(_ActiveXObject);
	    }
	    return isSandboxed;
	  };
	  /**
	 * Detect the Flash Player status, version, and plugin type.
	 *
	 * @see {@link https://code.google.com/p/doctype-mirror/wiki/ArticleDetectFlash#The_code}
	 * @see {@link http://stackoverflow.com/questions/12866060/detecting-pepper-ppapi-flash-with-javascript}
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _detectFlashSupport = function(ActiveXObject) {
	    var plugin, ax, mimeType, hasFlash = false, isActiveX = false, isPPAPI = false, flashVersion = "";
	    /**
	   * Derived from Apple's suggested sniffer.
	   * @param {String} desc e.g. "Shockwave Flash 7.0 r61"
	   * @returns {String} "7.0.61"
	   * @private
	   */
	    function parseFlashVersion(desc) {
	      var matches = desc.match(/[\d]+/g);
	      matches.length = 3;
	      return matches.join(".");
	    }
	    function isPepperFlash(flashPlayerFileName) {
	      return !!flashPlayerFileName && (flashPlayerFileName = flashPlayerFileName.toLowerCase()) && (/^(pepflashplayer\.dll|libpepflashplayer\.so|pepperflashplayer\.plugin)$/.test(flashPlayerFileName) || flashPlayerFileName.slice(-13) === "chrome.plugin");
	    }
	    function inspectPlugin(plugin) {
	      if (plugin) {
	        hasFlash = true;
	        if (plugin.version) {
	          flashVersion = parseFlashVersion(plugin.version);
	        }
	        if (!flashVersion && plugin.description) {
	          flashVersion = parseFlashVersion(plugin.description);
	        }
	        if (plugin.filename) {
	          isPPAPI = isPepperFlash(plugin.filename);
	        }
	      }
	    }
	    if (_navigator.plugins && _navigator.plugins.length) {
	      plugin = _navigator.plugins["Shockwave Flash"];
	      inspectPlugin(plugin);
	      if (_navigator.plugins["Shockwave Flash 2.0"]) {
	        hasFlash = true;
	        flashVersion = "2.0.0.11";
	      }
	    } else if (_navigator.mimeTypes && _navigator.mimeTypes.length) {
	      mimeType = _navigator.mimeTypes["application/x-shockwave-flash"];
	      plugin = mimeType && mimeType.enabledPlugin;
	      inspectPlugin(plugin);
	    } else if (typeof ActiveXObject !== "undefined") {
	      isActiveX = true;
	      try {
	        ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");
	        hasFlash = true;
	        flashVersion = parseFlashVersion(ax.GetVariable("$version"));
	      } catch (e1) {
	        try {
	          ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6");
	          hasFlash = true;
	          flashVersion = "6.0.21";
	        } catch (e2) {
	          try {
	            ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
	            hasFlash = true;
	            flashVersion = parseFlashVersion(ax.GetVariable("$version"));
	          } catch (e3) {
	            isActiveX = false;
	          }
	        }
	      }
	    }
	    _flashState.disabled = hasFlash !== true;
	    _flashState.outdated = flashVersion && _parseFloat(flashVersion) < _parseFloat(_minimumFlashVersion);
	    _flashState.version = flashVersion || "0.0.0";
	    _flashState.pluginType = isPPAPI ? "pepper" : isActiveX ? "activex" : hasFlash ? "netscape" : "unknown";
	  };
	  /**
	 * Invoke the Flash detection algorithms immediately upon inclusion so we're not waiting later.
	 */
	  _detectFlashSupport(_ActiveXObject);
	  /**
	 * Always assess the `sandboxed` state of the page at important Flash-related moments.
	 */
	  _detectSandbox(true);
	  /**
	 * A shell constructor for `ZeroClipboard` client instances.
	 *
	 * @constructor
	 */
	  var ZeroClipboard = function() {
	    if (!(this instanceof ZeroClipboard)) {
	      return new ZeroClipboard();
	    }
	    if (typeof ZeroClipboard._createClient === "function") {
	      ZeroClipboard._createClient.apply(this, _args(arguments));
	    }
	  };
	  /**
	 * The ZeroClipboard library's version number.
	 *
	 * @static
	 * @readonly
	 * @property {string}
	 */
	  _defineProperty(ZeroClipboard, "version", {
	    value: "2.2.0",
	    writable: false,
	    configurable: true,
	    enumerable: true
	  });
	  /**
	 * Update or get a copy of the ZeroClipboard global configuration.
	 * Returns a copy of the current/updated configuration.
	 *
	 * @returns Object
	 * @static
	 */
	  ZeroClipboard.config = function() {
	    return _config.apply(this, _args(arguments));
	  };
	  /**
	 * Diagnostic method that describes the state of the browser, Flash Player, and ZeroClipboard.
	 *
	 * @returns Object
	 * @static
	 */
	  ZeroClipboard.state = function() {
	    return _state.apply(this, _args(arguments));
	  };
	  /**
	 * Check if Flash is unusable for any reason: disabled, outdated, deactivated, etc.
	 *
	 * @returns Boolean
	 * @static
	 */
	  ZeroClipboard.isFlashUnusable = function() {
	    return _isFlashUnusable.apply(this, _args(arguments));
	  };
	  /**
	 * Register an event listener.
	 *
	 * @returns `ZeroClipboard`
	 * @static
	 */
	  ZeroClipboard.on = function() {
	    return _on.apply(this, _args(arguments));
	  };
	  /**
	 * Unregister an event listener.
	 * If no `listener` function/object is provided, it will unregister all listeners for the provided `eventType`.
	 * If no `eventType` is provided, it will unregister all listeners for every event type.
	 *
	 * @returns `ZeroClipboard`
	 * @static
	 */
	  ZeroClipboard.off = function() {
	    return _off.apply(this, _args(arguments));
	  };
	  /**
	 * Retrieve event listeners for an `eventType`.
	 * If no `eventType` is provided, it will retrieve all listeners for every event type.
	 *
	 * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null`
	 */
	  ZeroClipboard.handlers = function() {
	    return _listeners.apply(this, _args(arguments));
	  };
	  /**
	 * Event emission receiver from the Flash object, forwarding to any registered JavaScript event listeners.
	 *
	 * @returns For the "copy" event, returns the Flash-friendly "clipData" object; otherwise `undefined`.
	 * @static
	 */
	  ZeroClipboard.emit = function() {
	    return _emit.apply(this, _args(arguments));
	  };
	  /**
	 * Create and embed the Flash object.
	 *
	 * @returns The Flash object
	 * @static
	 */
	  ZeroClipboard.create = function() {
	    return _create.apply(this, _args(arguments));
	  };
	  /**
	 * Self-destruct and clean up everything, including the embedded Flash object.
	 *
	 * @returns `undefined`
	 * @static
	 */
	  ZeroClipboard.destroy = function() {
	    return _destroy.apply(this, _args(arguments));
	  };
	  /**
	 * Set the pending data for clipboard injection.
	 *
	 * @returns `undefined`
	 * @static
	 */
	  ZeroClipboard.setData = function() {
	    return _setData.apply(this, _args(arguments));
	  };
	  /**
	 * Clear the pending data for clipboard injection.
	 * If no `format` is provided, all pending data formats will be cleared.
	 *
	 * @returns `undefined`
	 * @static
	 */
	  ZeroClipboard.clearData = function() {
	    return _clearData.apply(this, _args(arguments));
	  };
	  /**
	 * Get a copy of the pending data for clipboard injection.
	 * If no `format` is provided, a copy of ALL pending data formats will be returned.
	 *
	 * @returns `String` or `Object`
	 * @static
	 */
	  ZeroClipboard.getData = function() {
	    return _getData.apply(this, _args(arguments));
	  };
	  /**
	 * Sets the current HTML object that the Flash object should overlay. This will put the global
	 * Flash object on top of the current element; depending on the setup, this may also set the
	 * pending clipboard text data as well as the Flash object's wrapping element's title attribute
	 * based on the underlying HTML element and ZeroClipboard configuration.
	 *
	 * @returns `undefined`
	 * @static
	 */
	  ZeroClipboard.focus = ZeroClipboard.activate = function() {
	    return _focus.apply(this, _args(arguments));
	  };
	  /**
	 * Un-overlays the Flash object. This will put the global Flash object off-screen; depending on
	 * the setup, this may also unset the Flash object's wrapping element's title attribute based on
	 * the underlying HTML element and ZeroClipboard configuration.
	 *
	 * @returns `undefined`
	 * @static
	 */
	  ZeroClipboard.blur = ZeroClipboard.deactivate = function() {
	    return _blur.apply(this, _args(arguments));
	  };
	  /**
	 * Returns the currently focused/"activated" HTML element that the Flash object is wrapping.
	 *
	 * @returns `HTMLElement` or `null`
	 * @static
	 */
	  ZeroClipboard.activeElement = function() {
	    return _activeElement.apply(this, _args(arguments));
	  };
	  /**
	 * Keep track of the ZeroClipboard client instance counter.
	 */
	  var _clientIdCounter = 0;
	  /**
	 * Keep track of the state of the client instances.
	 *
	 * Entry structure:
	 *   _clientMeta[client.id] = {
	 *     instance: client,
	 *     elements: [],
	 *     handlers: {}
	 *   };
	 */
	  var _clientMeta = {};
	  /**
	 * Keep track of the ZeroClipboard clipped elements counter.
	 */
	  var _elementIdCounter = 0;
	  /**
	 * Keep track of the state of the clipped element relationships to clients.
	 *
	 * Entry structure:
	 *   _elementMeta[element.zcClippingId] = [client1.id, client2.id];
	 */
	  var _elementMeta = {};
	  /**
	 * Keep track of the state of the mouse event handlers for clipped elements.
	 *
	 * Entry structure:
	 *   _mouseHandlers[element.zcClippingId] = {
	 *     mouseover:  function(event) {},
	 *     mouseout:   function(event) {},
	 *     mouseenter: function(event) {},
	 *     mouseleave: function(event) {},
	 *     mousemove:  function(event) {}
	 *   };
	 */
	  var _mouseHandlers = {};
	  /**
	 * Extending the ZeroClipboard configuration defaults for the Client module.
	 */
	  _extend(_globalConfig, {
	    autoActivate: true
	  });
	  /**
	 * The real constructor for `ZeroClipboard` client instances.
	 * @private
	 */
	  var _clientConstructor = function(elements) {
	    var client = this;
	    client.id = "" + _clientIdCounter++;
	    _clientMeta[client.id] = {
	      instance: client,
	      elements: [],
	      handlers: {}
	    };
	    if (elements) {
	      client.clip(elements);
	    }
	    ZeroClipboard.on("*", function(event) {
	      return client.emit(event);
	    });
	    ZeroClipboard.on("destroy", function() {
	      client.destroy();
	    });
	    ZeroClipboard.create();
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.Client.prototype.on`.
	 * @private
	 */
	  var _clientOn = function(eventType, listener) {
	    var i, len, events, added = {}, meta = _clientMeta[this.id], handlers = meta && meta.handlers;
	    if (!meta) {
	      throw new Error("Attempted to add new listener(s) to a destroyed ZeroClipboard client instance");
	    }
	    if (typeof eventType === "string" && eventType) {
	      events = eventType.toLowerCase().split(/\s+/);
	    } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
	      for (i in eventType) {
	        if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
	          this.on(i, eventType[i]);
	        }
	      }
	    }
	    if (events && events.length) {
	      for (i = 0, len = events.length; i < len; i++) {
	        eventType = events[i].replace(/^on/, "");
	        added[eventType] = true;
	        if (!handlers[eventType]) {
	          handlers[eventType] = [];
	        }
	        handlers[eventType].push(listener);
	      }
	      if (added.ready && _flashState.ready) {
	        this.emit({
	          type: "ready",
	          client: this
	        });
	      }
	      if (added.error) {
	        for (i = 0, len = _flashStateErrorNames.length; i < len; i++) {
	          if (_flashState[_flashStateErrorNames[i].replace(/^flash-/, "")]) {
	            this.emit({
	              type: "error",
	              name: _flashStateErrorNames[i],
	              client: this
	            });
	            break;
	          }
	        }
	        if (_zcSwfVersion !== undefined && ZeroClipboard.version !== _zcSwfVersion) {
	          this.emit({
	            type: "error",
	            name: "version-mismatch",
	            jsVersion: ZeroClipboard.version,
	            swfVersion: _zcSwfVersion
	          });
	        }
	      }
	    }
	    return this;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.Client.prototype.off`.
	 * @private
	 */
	  var _clientOff = function(eventType, listener) {
	    var i, len, foundIndex, events, perEventHandlers, meta = _clientMeta[this.id], handlers = meta && meta.handlers;
	    if (!handlers) {
	      return this;
	    }
	    if (arguments.length === 0) {
	      events = _keys(handlers);
	    } else if (typeof eventType === "string" && eventType) {
	      events = eventType.split(/\s+/);
	    } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
	      for (i in eventType) {
	        if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
	          this.off(i, eventType[i]);
	        }
	      }
	    }
	    if (events && events.length) {
	      for (i = 0, len = events.length; i < len; i++) {
	        eventType = events[i].toLowerCase().replace(/^on/, "");
	        perEventHandlers = handlers[eventType];
	        if (perEventHandlers && perEventHandlers.length) {
	          if (listener) {
	            foundIndex = perEventHandlers.indexOf(listener);
	            while (foundIndex !== -1) {
	              perEventHandlers.splice(foundIndex, 1);
	              foundIndex = perEventHandlers.indexOf(listener, foundIndex);
	            }
	          } else {
	            perEventHandlers.length = 0;
	          }
	        }
	      }
	    }
	    return this;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.Client.prototype.handlers`.
	 * @private
	 */
	  var _clientListeners = function(eventType) {
	    var copy = null, handlers = _clientMeta[this.id] && _clientMeta[this.id].handlers;
	    if (handlers) {
	      if (typeof eventType === "string" && eventType) {
	        copy = handlers[eventType] ? handlers[eventType].slice(0) : [];
	      } else {
	        copy = _deepCopy(handlers);
	      }
	    }
	    return copy;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.Client.prototype.emit`.
	 * @private
	 */
	  var _clientEmit = function(event) {
	    if (_clientShouldEmit.call(this, event)) {
	      if (typeof event === "object" && event && typeof event.type === "string" && event.type) {
	        event = _extend({}, event);
	      }
	      var eventCopy = _extend({}, _createEvent(event), {
	        client: this
	      });
	      _clientDispatchCallbacks.call(this, eventCopy);
	    }
	    return this;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.Client.prototype.clip`.
	 * @private
	 */
	  var _clientClip = function(elements) {
	    if (!_clientMeta[this.id]) {
	      throw new Error("Attempted to clip element(s) to a destroyed ZeroClipboard client instance");
	    }
	    elements = _prepClip(elements);
	    for (var i = 0; i < elements.length; i++) {
	      if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) {
	        if (!elements[i].zcClippingId) {
	          elements[i].zcClippingId = "zcClippingId_" + _elementIdCounter++;
	          _elementMeta[elements[i].zcClippingId] = [ this.id ];
	          if (_globalConfig.autoActivate === true) {
	            _addMouseHandlers(elements[i]);
	          }
	        } else if (_elementMeta[elements[i].zcClippingId].indexOf(this.id) === -1) {
	          _elementMeta[elements[i].zcClippingId].push(this.id);
	        }
	        var clippedElements = _clientMeta[this.id] && _clientMeta[this.id].elements;
	        if (clippedElements.indexOf(elements[i]) === -1) {
	          clippedElements.push(elements[i]);
	        }
	      }
	    }
	    return this;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.Client.prototype.unclip`.
	 * @private
	 */
	  var _clientUnclip = function(elements) {
	    var meta = _clientMeta[this.id];
	    if (!meta) {
	      return this;
	    }
	    var clippedElements = meta.elements;
	    var arrayIndex;
	    if (typeof elements === "undefined") {
	      elements = clippedElements.slice(0);
	    } else {
	      elements = _prepClip(elements);
	    }
	    for (var i = elements.length; i--; ) {
	      if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) {
	        arrayIndex = 0;
	        while ((arrayIndex = clippedElements.indexOf(elements[i], arrayIndex)) !== -1) {
	          clippedElements.splice(arrayIndex, 1);
	        }
	        var clientIds = _elementMeta[elements[i].zcClippingId];
	        if (clientIds) {
	          arrayIndex = 0;
	          while ((arrayIndex = clientIds.indexOf(this.id, arrayIndex)) !== -1) {
	            clientIds.splice(arrayIndex, 1);
	          }
	          if (clientIds.length === 0) {
	            if (_globalConfig.autoActivate === true) {
	              _removeMouseHandlers(elements[i]);
	            }
	            delete elements[i].zcClippingId;
	          }
	        }
	      }
	    }
	    return this;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.Client.prototype.elements`.
	 * @private
	 */
	  var _clientElements = function() {
	    var meta = _clientMeta[this.id];
	    return meta && meta.elements ? meta.elements.slice(0) : [];
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.Client.prototype.destroy`.
	 * @private
	 */
	  var _clientDestroy = function() {
	    if (!_clientMeta[this.id]) {
	      return;
	    }
	    this.unclip();
	    this.off();
	    delete _clientMeta[this.id];
	  };
	  /**
	 * Inspect an Event to see if the Client (`this`) should honor it for emission.
	 * @private
	 */
	  var _clientShouldEmit = function(event) {
	    if (!(event && event.type)) {
	      return false;
	    }
	    if (event.client && event.client !== this) {
	      return false;
	    }
	    var meta = _clientMeta[this.id];
	    var clippedEls = meta && meta.elements;
	    var hasClippedEls = !!clippedEls && clippedEls.length > 0;
	    var goodTarget = !event.target || hasClippedEls && clippedEls.indexOf(event.target) !== -1;
	    var goodRelTarget = event.relatedTarget && hasClippedEls && clippedEls.indexOf(event.relatedTarget) !== -1;
	    var goodClient = event.client && event.client === this;
	    if (!meta || !(goodTarget || goodRelTarget || goodClient)) {
	      return false;
	    }
	    return true;
	  };
	  /**
	 * Handle the actual dispatching of events to a client instance.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _clientDispatchCallbacks = function(event) {
	    var meta = _clientMeta[this.id];
	    if (!(typeof event === "object" && event && event.type && meta)) {
	      return;
	    }
	    var async = _shouldPerformAsync(event);
	    var wildcardTypeHandlers = meta && meta.handlers["*"] || [];
	    var specificTypeHandlers = meta && meta.handlers[event.type] || [];
	    var handlers = wildcardTypeHandlers.concat(specificTypeHandlers);
	    if (handlers && handlers.length) {
	      var i, len, func, context, eventCopy, originalContext = this;
	      for (i = 0, len = handlers.length; i < len; i++) {
	        func = handlers[i];
	        context = originalContext;
	        if (typeof func === "string" && typeof _window[func] === "function") {
	          func = _window[func];
	        }
	        if (typeof func === "object" && func && typeof func.handleEvent === "function") {
	          context = func;
	          func = func.handleEvent;
	        }
	        if (typeof func === "function") {
	          eventCopy = _extend({}, event);
	          _dispatchCallback(func, context, [ eventCopy ], async);
	        }
	      }
	    }
	  };
	  /**
	 * Prepares the elements for clipping/unclipping.
	 *
	 * @returns An Array of elements.
	 * @private
	 */
	  var _prepClip = function(elements) {
	    if (typeof elements === "string") {
	      elements = [];
	    }
	    return typeof elements.length !== "number" ? [ elements ] : elements;
	  };
	  /**
	 * Add a `mouseover` handler function for a clipped element.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _addMouseHandlers = function(element) {
	    if (!(element && element.nodeType === 1)) {
	      return;
	    }
	    var _suppressMouseEvents = function(event) {
	      if (!(event || (event = _window.event))) {
	        return;
	      }
	      if (event._source !== "js") {
	        event.stopImmediatePropagation();
	        event.preventDefault();
	      }
	      delete event._source;
	    };
	    var _elementMouseOver = function(event) {
	      if (!(event || (event = _window.event))) {
	        return;
	      }
	      _suppressMouseEvents(event);
	      ZeroClipboard.focus(element);
	    };
	    element.addEventListener("mouseover", _elementMouseOver, false);
	    element.addEventListener("mouseout", _suppressMouseEvents, false);
	    element.addEventListener("mouseenter", _suppressMouseEvents, false);
	    element.addEventListener("mouseleave", _suppressMouseEvents, false);
	    element.addEventListener("mousemove", _suppressMouseEvents, false);
	    _mouseHandlers[element.zcClippingId] = {
	      mouseover: _elementMouseOver,
	      mouseout: _suppressMouseEvents,
	      mouseenter: _suppressMouseEvents,
	      mouseleave: _suppressMouseEvents,
	      mousemove: _suppressMouseEvents
	    };
	  };
	  /**
	 * Remove a `mouseover` handler function for a clipped element.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _removeMouseHandlers = function(element) {
	    if (!(element && element.nodeType === 1)) {
	      return;
	    }
	    var mouseHandlers = _mouseHandlers[element.zcClippingId];
	    if (!(typeof mouseHandlers === "object" && mouseHandlers)) {
	      return;
	    }
	    var key, val, mouseEvents = [ "move", "leave", "enter", "out", "over" ];
	    for (var i = 0, len = mouseEvents.length; i < len; i++) {
	      key = "mouse" + mouseEvents[i];
	      val = mouseHandlers[key];
	      if (typeof val === "function") {
	        element.removeEventListener(key, val, false);
	      }
	    }
	    delete _mouseHandlers[element.zcClippingId];
	  };
	  /**
	 * Creates a new ZeroClipboard client instance.
	 * Optionally, auto-`clip` an element or collection of elements.
	 *
	 * @constructor
	 */
	  ZeroClipboard._createClient = function() {
	    _clientConstructor.apply(this, _args(arguments));
	  };
	  /**
	 * Register an event listener to the client.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.on = function() {
	    return _clientOn.apply(this, _args(arguments));
	  };
	  /**
	 * Unregister an event handler from the client.
	 * If no `listener` function/object is provided, it will unregister all handlers for the provided `eventType`.
	 * If no `eventType` is provided, it will unregister all handlers for every event type.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.off = function() {
	    return _clientOff.apply(this, _args(arguments));
	  };
	  /**
	 * Retrieve event listeners for an `eventType` from the client.
	 * If no `eventType` is provided, it will retrieve all listeners for every event type.
	 *
	 * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null`
	 */
	  ZeroClipboard.prototype.handlers = function() {
	    return _clientListeners.apply(this, _args(arguments));
	  };
	  /**
	 * Event emission receiver from the Flash object for this client's registered JavaScript event listeners.
	 *
	 * @returns For the "copy" event, returns the Flash-friendly "clipData" object; otherwise `undefined`.
	 */
	  ZeroClipboard.prototype.emit = function() {
	    return _clientEmit.apply(this, _args(arguments));
	  };
	  /**
	 * Register clipboard actions for new element(s) to the client.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.clip = function() {
	    return _clientClip.apply(this, _args(arguments));
	  };
	  /**
	 * Unregister the clipboard actions of previously registered element(s) on the page.
	 * If no elements are provided, ALL registered elements will be unregistered.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.unclip = function() {
	    return _clientUnclip.apply(this, _args(arguments));
	  };
	  /**
	 * Get all of the elements to which this client is clipped.
	 *
	 * @returns array of clipped elements
	 */
	  ZeroClipboard.prototype.elements = function() {
	    return _clientElements.apply(this, _args(arguments));
	  };
	  /**
	 * Self-destruct and clean up everything for a single client.
	 * This will NOT destroy the embedded Flash object.
	 *
	 * @returns `undefined`
	 */
	  ZeroClipboard.prototype.destroy = function() {
	    return _clientDestroy.apply(this, _args(arguments));
	  };
	  /**
	 * Stores the pending plain text to inject into the clipboard.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.setText = function(text) {
	    if (!_clientMeta[this.id]) {
	      throw new Error("Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance");
	    }
	    ZeroClipboard.setData("text/plain", text);
	    return this;
	  };
	  /**
	 * Stores the pending HTML text to inject into the clipboard.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.setHtml = function(html) {
	    if (!_clientMeta[this.id]) {
	      throw new Error("Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance");
	    }
	    ZeroClipboard.setData("text/html", html);
	    return this;
	  };
	  /**
	 * Stores the pending rich text (RTF) to inject into the clipboard.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.setRichText = function(richText) {
	    if (!_clientMeta[this.id]) {
	      throw new Error("Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance");
	    }
	    ZeroClipboard.setData("application/rtf", richText);
	    return this;
	  };
	  /**
	 * Stores the pending data to inject into the clipboard.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.setData = function() {
	    if (!_clientMeta[this.id]) {
	      throw new Error("Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance");
	    }
	    ZeroClipboard.setData.apply(this, _args(arguments));
	    return this;
	  };
	  /**
	 * Clears the pending data to inject into the clipboard.
	 * If no `format` is provided, all pending data formats will be cleared.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.clearData = function() {
	    if (!_clientMeta[this.id]) {
	      throw new Error("Attempted to clear pending clipboard data from a destroyed ZeroClipboard client instance");
	    }
	    ZeroClipboard.clearData.apply(this, _args(arguments));
	    return this;
	  };
	  /**
	 * Gets a copy of the pending data to inject into the clipboard.
	 * If no `format` is provided, a copy of ALL pending data formats will be returned.
	 *
	 * @returns `String` or `Object`
	 */
	  ZeroClipboard.prototype.getData = function() {
	    if (!_clientMeta[this.id]) {
	      throw new Error("Attempted to get pending clipboard data from a destroyed ZeroClipboard client instance");
	    }
	    return ZeroClipboard.getData.apply(this, _args(arguments));
	  };
	  if (typeof define === "function" && define.amd) {
	    define(function() {
	      return ZeroClipboard;
	    });
	  } else if (typeof module === "object" && module && typeof module.exports === "object" && module.exports) {
	    module.exports = ZeroClipboard;
	  } else {
	    window.ZeroClipboard = ZeroClipboard;
	  }
	})(function() {
	  return this || window;
	}());
	},{}]},{},[23,61,63,62,64,85,86,87,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,88,89,90,91,105,106,107,108,94,95,96,97,98,99,31,35,32,33,40,34,36,37,38,39])(23)
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8), __webpack_require__(37), (function() { return this; }())))

/***/ },
/* 37 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(39);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(35)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js?minimize!./handsontable.full.css", function() {
				var newContent = require("!!./../../css-loader/index.js?minimize!./handsontable.full.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(14)();
	// imports


	// module
	exports.push([module.id, "@charset \"UTF-8\";\n/*!\n(The MIT License)\n\nCopyright (c) 2012-2014 Marcin Warpechowski\nCopyright (c) 2015 Handsoncode sp. z o.o. <hello@handsoncode.net>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/.handsontable{position:relative}.handsontable .hide{display:none}.handsontable .relative{position:relative}.handsontable.htAutoSize{visibility:hidden;left:-99000px;position:absolute;top:-99000px}.handsontable .wtHider{width:0}.handsontable .wtSpreader{position:relative;width:0;height:auto}.handsontable div,.handsontable input,.handsontable table,.handsontable tbody,.handsontable td,.handsontable textarea,.handsontable th,.handsontable thead{box-sizing:content-box;-webkit-box-sizing:content-box;-moz-box-sizing:content-box}.handsontable input,.handsontable textarea{min-height:initial}.handsontable table.htCore{border-collapse:separate;border-spacing:0;margin:0;border-width:0;table-layout:fixed;width:0;outline-width:0;max-width:none;max-height:none}.handsontable col,.handsontable col.rowHeader{width:50px}.handsontable td,.handsontable th{border-top-width:0;border-left-width:0;border-right:1px solid #ccc;border-bottom:1px solid #ccc;height:22px;empty-cells:show;line-height:21px;padding:0 4px;background-color:#fff;vertical-align:top;overflow:hidden;outline-width:0;white-space:pre-line}.handsontable td.htInvalid{background-color:#ff4c42!important}.handsontable td.htNoWrap{white-space:nowrap}.handsontable th:last-child{border-right:1px solid #ccc;border-bottom:1px solid #ccc}.handsontable th.htNoFrame,.handsontable th:first-child.htNoFrame,.handsontable tr:first-child th.htNoFrame{border-left-width:0;background-color:#fff;border-color:#fff}.handsontable .htNoFrame+td,.handsontable .htNoFrame+th,.handsontable.htRowHeaders thead tr th:nth-child(2),.handsontable td:first-of-type,.handsontable th:first-child{border-left:1px solid #ccc}.handsontable tr:first-child td,.handsontable tr:first-child th{border-top:1px solid #ccc}.ht_master:not(.innerBorderLeft)~.handsontable:not(.ht_clone_top) thead tr th:first-child,.ht_master:not(.innerBorderLeft)~.handsontable tbody tr th{border-right-width:0}.ht_master:not(.innerBorderTop) thead tr.lastChild th,.ht_master:not(.innerBorderTop) thead tr:last-child th,.ht_master:not(.innerBorderTop)~.handsontable thead tr.lastChild th,.ht_master:not(.innerBorderTop)~.handsontable thead tr:last-child th{border-bottom-width:0}.handsontable th{background-color:#eee;color:#222;text-align:center;font-weight:400;white-space:nowrap}.handsontable thead th{padding:0}.handsontable th.active{background-color:#ccc}.handsontable thead th .relative{padding:2px 4px}.handsontable .manualColumnMover{left:0;width:5px;height:25px}.handsontable .manualColumnMover,.handsontable .manualRowMover{position:fixed;top:0;background-color:transparent;z-index:999;cursor:move}.handsontable .manualRowMover{left:-4px;height:5px;width:50px}.handsontable .manualColumnMoverGuide,.handsontable .manualRowMoverGuide{position:fixed;left:0;top:0;background-color:#ccc;width:25px;height:25px;opacity:.7;display:none}.handsontable .manualColumnMoverGuide.active,.handsontable .manualRowMoverGuide.active{display:block;z-index:199}.handsontable .manualColumnMover.active,.handsontable .manualColumnMover:hover,.handsontable .manualRowMover.active,.handsontable .manualRowMover:hover{background-color:#88f}.handsontable .manualColumnResizer{position:fixed;top:0;cursor:col-resize;z-index:110;width:5px;height:25px}.handsontable .manualRowResizer{position:fixed;left:0;cursor:row-resize;z-index:110;height:5px;width:50px}.handsontable .manualColumnResizer.active,.handsontable .manualColumnResizer:hover,.handsontable .manualRowResizer.active,.handsontable .manualRowResizer:hover{background-color:#aab}.handsontable .manualColumnResizerGuide{position:fixed;right:0;top:0;background-color:#aab;display:none;width:0;border-right:1px dashed #777;margin-left:5px}.handsontable .manualRowResizerGuide{position:fixed;left:0;bottom:0;background-color:#aab;display:none;height:0;border-bottom:1px dashed #777;margin-top:5px}.handsontable .manualColumnResizerGuide.active,.handsontable .manualRowResizerGuide.active{display:block;z-index:199}.handsontable .columnSorting{position:relative}.handsontable .columnSorting:hover{text-decoration:underline;cursor:pointer}.handsontable .columnSorting.ascending:after{content:'\\25B2';color:#5f5f5f;position:absolute;right:-15px}.handsontable .columnSorting.descending:after{content:'\\25BC';color:#5f5f5f;position:absolute;right:-15px}.handsontable th.beforeHiddenColumn{position:relative}.handsontable th.afterHiddenColumn:before,.handsontable th.beforeHiddenColumn:after{content:'\\25C0';color:#bbb;position:absolute;right:1px;top:2px;font-size:5pt}.handsontable th.afterHiddenColumn{position:relative}.handsontable th.afterHiddenColumn:before{left:1px;top:2px;right:auto;content:'\\25B6'}.handsontable td.afterHiddenColumn.firstVisible{border-left:1px solid #ccc}.handsontable thead th.hiddenHeader{display:none}.handsontable .wtBorder{position:absolute;font-size:0}.handsontable .wtBorder.hidden{display:none!important}.handsontable td.area{background:-webkit-gradient(linear,left top,left bottom,color-stop(0,rgba(181,209,255,.34)),color-stop(100%,rgba(181,209,255,.34)));background:-webkit-linear-gradient(top,rgba(181,209,255,.34),rgba(181,209,255,.34));background:linear-gradient(180deg,rgba(181,209,255,.34) 0,rgba(181,209,255,.34));filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#57b5d1ff',endColorstr='#57b5d1ff',GradientType=0);background-color:#fff}.handsontable .wtBorder.corner{font-size:0;cursor:crosshair}.handsontable .htBorder.htFillBorder{background:red;width:1px;height:1px}.handsontableInput{border:none;outline-width:0;margin:0;padding:1px 5px 0;font-family:inherit;line-height:21px;font-size:inherit;box-shadow:inset 0 0 0 2px #5292f7;resize:none;display:inline-block;color:#000;border-radius:0;background-color:#fff}.handsontableInputHolder{position:absolute;top:0;left:0;z-index:100}.htSelectEditor{-webkit-appearance:menulist-button!important;position:absolute;width:auto}.handsontable .htDimmed{color:#777}.handsontable .htSubmenu{position:relative}.handsontable .htSubmenu :after{content:'\\25B6';color:#777;position:absolute;right:5px}.handsontable .htLeft{text-align:left}.handsontable .htCenter{text-align:center}.handsontable .htRight{text-align:right}.handsontable .htJustify{text-align:justify}.handsontable .htTop{vertical-align:top}.handsontable .htMiddle{vertical-align:middle}.handsontable .htBottom{vertical-align:bottom}.handsontable .htPlaceholder{color:#999}.handsontable .htAutocompleteArrow{float:right;font-size:10px;color:#eee;cursor:default;width:16px;text-align:center}.handsontable td .htAutocompleteArrow:hover{color:#777}.handsontable td.area .htAutocompleteArrow{color:#d3d3d3}.handsontable .htCheckboxRendererInput.noValue{opacity:.5}.handsontable .htCheckboxRendererLabel{cursor:pointer;display:inline-block;width:100%}.handsontable .htNumeric{text-align:right}.htCommentCell{position:relative}.htCommentCell:after{content:'';position:absolute;top:0;right:0;border-left:6px solid transparent;border-top:6px solid red}@-webkit-keyframes opacity-hide{0%{opacity:1}to{opacity:0}}@keyframes opacity-hide{0%{opacity:1}to{opacity:0}}@-webkit-keyframes opacity-show{0%{opacity:0}to{opacity:1}}@keyframes opacity-show{0%{opacity:0}to{opacity:1}}.handsontable .handsontable.ht_clone_top .wtHider{padding:0 0 5px}.handsontable .autocompleteEditor.handsontable{padding-right:17px}.handsontable .autocompleteEditor.handsontable.htMacScroll{padding-right:15px}.handsontable.listbox{margin:0}.handsontable.listbox .ht_master table{border:1px solid #ccc;border-collapse:separate;background:#fff}.handsontable.listbox td,.handsontable.listbox th,.handsontable.listbox tr:first-child td,.handsontable.listbox tr:first-child th,.handsontable.listbox tr:last-child th{border-color:transparent}.handsontable.listbox td,.handsontable.listbox th{white-space:nowrap;text-overflow:ellipsis}.handsontable.listbox td.htDimmed{cursor:default;color:inherit;font-style:inherit}.handsontable.listbox .wtBorder{visibility:hidden}.handsontable.listbox tr:hover td,.handsontable.listbox tr td.current{background:#eee}.ht_clone_top{z-index:101}.ht_clone_left{z-index:102}.ht_clone_bottom_left_corner,.ht_clone_debug,.ht_clone_top_left_corner{z-index:103}.handsontable td.htSearchResult{background:#fcedd9;color:#583707}.htBordered{border-width:1px}.htBordered.htTopBorderSolid{border-top-style:solid;border-top-color:#000}.htBordered.htRightBorderSolid{border-right-style:solid;border-right-color:#000}.htBordered.htBottomBorderSolid{border-bottom-style:solid;border-bottom-color:#000}.htBordered.htLeftBorderSolid{border-left-style:solid;border-left-color:#000}.htCommentTextArea{-moz-box-shadow:1px 1px 2px #bbb;-webkit-box-shadow:1px 1px 2px #bbb;background-color:#fffacd;border:1px solid #999;box-shadow:1px 1px 2px #bbb;font-family:Arial}.handsontable tbody tr th:nth-last-child(2){border-right:1px solid #ccc}.handsontable thead tr:nth-last-child(2) th.htGroupIndicatorContainer{border-bottom:1px solid #ccc;padding-bottom:5px}.ht_clone_top_left_corner thead tr th:nth-last-child(2){border-right:1px solid #ccc}.htCollapseButton{width:10px;height:10px;line-height:10px;text-align:center;border-radius:5px;border:1px solid #f3f3f3;box-shadow:1px 1px 3px rgba(0,0,0,.4);cursor:pointer;margin-bottom:3px;position:relative}.htCollapseButton:after{content:\"\";height:300%;width:1px;display:block;background:#ccc;margin-left:4px;position:absolute;bottom:10px}thead .htCollapseButton{right:5px;position:absolute;top:5px;background:#fff}thead .htCollapseButton:after{height:1px;width:700%;right:10px;top:4px}.handsontable tr th .htExpandButton{position:absolute;width:10px;height:10px;line-height:10px;text-align:center;border-radius:5px;border:1px solid #f3f3f3;box-shadow:1px 1px 3px rgba(0,0,0,.4);cursor:pointer;top:0;display:none}.handsontable thead tr th .htExpandButton{top:5px}.handsontable tr th .htExpandButton.clickable{display:block}.collapsibleIndicator{position:absolute;top:50%;transform:translateY(-50%);right:5px;border:1px solid #a6a6a6;line-height:10px;color:#222;border-radius:10px;font-size:10px;width:10px;height:10px;cursor:pointer;box-shadow:0 0 0 6px #eee;background:#eee}.handsontable col.hidden{width:0!important}.handsontable table tr th.lightRightBorder{border-right:1px solid #e6e6e6}.handsontable tr.hidden,.handsontable tr.hidden td,.handsontable tr.hidden th{display:none}.ht_clone_bottom,.ht_clone_left,.ht_clone_top,.ht_master{overflow:hidden}.ht_master .wtHolder{overflow:auto}.ht_clone_left .wtHolder{overflow-x:hidden;overflow-y:auto}.ht_clone_bottom .wtHolder,.ht_clone_top .wtHolder{overflow-x:auto;overflow-y:hidden}.wtDebugHidden{display:none}.wtDebugVisible{display:block;-webkit-animation-duration:.5s;-webkit-animation-name:wtFadeInFromNone;animation-duration:.5s;animation-name:wtFadeInFromNone}@keyframes wtFadeInFromNone{0%{display:none;opacity:0}1%{display:block;opacity:0}to{display:block;opacity:1}}@-webkit-keyframes wtFadeInFromNone{0%{display:none;opacity:0}1%{display:block;opacity:0}to{display:block;opacity:1}}.handsontable.mobile,.handsontable.mobile .wtHolder{-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-overflow-scrolling:touch}.htMobileEditorContainer{display:none;position:absolute;top:0;width:70%;height:54pt;background:#f8f8f8;border-radius:20px;border:1px solid #ebebeb;z-index:999;box-sizing:border-box;-webkit-box-sizing:border-box;-webkit-text-size-adjust:none}.topLeftSelectionHandle-HitArea:not(.ht_master .topLeftSelectionHandle-HitArea),.topLeftSelectionHandle:not(.ht_master .topLeftSelectionHandle){z-index:9999}.bottomRightSelectionHandle,.bottomRightSelectionHandle-HitArea,.topLeftSelectionHandle,.topLeftSelectionHandle-HitArea{left:-10000px;top:-10000px}.htMobileEditorContainer.active{display:block}.htMobileEditorContainer .inputs{position:absolute;right:210pt;bottom:10pt;top:10pt;left:14px;height:34pt}.htMobileEditorContainer .inputs textarea{font-size:13pt;border:1px solid #a1a1a1;-webkit-appearance:none;box-shadow:none;position:absolute;left:14px;right:14px;top:0;bottom:0;padding:7pt}.htMobileEditorContainer .cellPointer{position:absolute;top:-13pt;height:0;width:0;left:30px;border-left:13pt solid transparent;border-right:13pt solid transparent;border-bottom:13pt solid #ebebeb}.htMobileEditorContainer .cellPointer.hidden{display:none}.htMobileEditorContainer .cellPointer:before{content:'';display:block;position:absolute;top:2px;height:0;width:0;left:-13pt;border-left:13pt solid transparent;border-right:13pt solid transparent;border-bottom:13pt solid #f8f8f8}.htMobileEditorContainer .moveHandle{position:absolute;top:10pt;left:5px;width:30px;bottom:0;cursor:move;z-index:9999}.htMobileEditorContainer .moveHandle:after{content:\"..a..a..a..\";white-space:pre;line-height:10px;font-size:20pt;display:inline-block;margin-top:-8px;color:#ebebeb}.htMobileEditorContainer .positionControls{width:205pt;position:absolute;right:5pt;top:0;bottom:0}.htMobileEditorContainer .positionControls>div{width:50pt;height:100%;float:left}.htMobileEditorContainer .positionControls>div:after{content:\" \";display:block;width:15pt;height:15pt;text-align:center;line-height:50pt}.htMobileEditorContainer .downButton:after,.htMobileEditorContainer .leftButton:after,.htMobileEditorContainer .rightButton:after,.htMobileEditorContainer .upButton:after{transform-origin:5pt 5pt;-webkit-transform-origin:5pt 5pt;margin:21pt 0 0 21pt}.htMobileEditorContainer .leftButton:after{border-top:2px solid #288ffe;border-left:2px solid #288ffe;-webkit-transform:rotate(-45deg)}.htMobileEditorContainer .leftButton:active:after{border-color:#cfcfcf}.htMobileEditorContainer .rightButton:after{border-top:2px solid #288ffe;border-left:2px solid #288ffe;-webkit-transform:rotate(135deg)}.htMobileEditorContainer .rightButton:active:after{border-color:#cfcfcf}.htMobileEditorContainer .upButton:after{border-top:2px solid #288ffe;border-left:2px solid #288ffe;-webkit-transform:rotate(45deg)}.htMobileEditorContainer .upButton:active:after{border-color:#cfcfcf}.htMobileEditorContainer .downButton:after{border-top:2px solid #288ffe;border-left:2px solid #288ffe;-webkit-transform:rotate(225deg)}.htMobileEditorContainer .downButton:active:after{border-color:#cfcfcf}.handsontable.hide-tween{-webkit-animation:opacity-hide .3s;animation:opacity-hide .3s;animation-fill-mode:forwards;-webkit-animation-fill-mode:forwards}.handsontable.show-tween{-webkit-animation:opacity-show .3s;animation:opacity-show .3s;animation-fill-mode:forwards;-webkit-animation-fill-mode:forwards}\n/*!\n * Handsontable ContextMenu\n */.htContextMenu{display:none;position:absolute;z-index:1060}.htContextMenu .ht_clone_corner,.htContextMenu .ht_clone_debug,.htContextMenu .ht_clone_left,.htContextMenu .ht_clone_top{display:none}.htContextMenu table.htCore{border:1px solid #bbb;border-bottom-width:2px;border-right-width:2px}.htContextMenu .wtBorder{visibility:hidden}.htContextMenu table tbody tr td{background:#fff;border-width:0;padding:4px 6px 0;cursor:pointer;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.htContextMenu table tbody tr td:first-child{border:0}.htContextMenu table tbody tr td.htDimmed{font-style:normal;color:#323232}.htContextMenu table tbody tr td.current,.htContextMenu table tbody tr td.zeroclipboard-is-hover{background:#e9e9e9}.htContextMenu table tbody tr td.htSeparator{border-top:1px solid #bbb;height:0;padding:0;cursor:default}.htContextMenu table tbody tr td.htDisabled{color:#999}.htContextMenu table tbody tr td.htDisabled:hover{background:#fff;color:#999;cursor:default}.htContextMenu table tbody tr.htHidden{display:none}.htContextMenu table tbody tr td .htItemWrapper{margin-left:10px;margin-right:6px}.htContextMenu table tbody tr td div span.selected{margin-top:-2px;position:absolute;left:4px}.htContextMenu .ht_master .wtHolder{overflow:hidden}\n\n/*!\n * Pikaday\n * Copyright © 2014 David Bushell | BSD & MIT license | http://dbushell.com/\n */.pika-single{z-index:9999;display:block;position:relative;color:#333;background:#fff;border:1px solid #ccc;border-bottom-color:#bbb;font-family:Helvetica Neue,Helvetica,Arial,sans-serif}.pika-single:after,.pika-single:before{content:\" \";display:table}.pika-single:after{clear:both}.pika-single{*zoom:1}.pika-single.is-hidden{display:none}.pika-single.is-bound{position:absolute;box-shadow:0 5px 15px -5px rgba(0,0,0,.5)}.pika-lendar{float:left;width:240px;margin:8px}.pika-title{position:relative;text-align:center}.pika-label{display:inline-block;*display:inline;position:relative;z-index:9999;overflow:hidden;margin:0;padding:5px 3px;font-size:14px;line-height:20px;font-weight:700;background-color:#fff}.pika-title select{cursor:pointer;position:absolute;z-index:9998;margin:0;left:0;top:5px;filter:alpha(opacity=0);opacity:0}.pika-next,.pika-prev{display:block;cursor:pointer;position:relative;outline:none;border:0;padding:0;width:20px;height:30px;text-indent:20px;white-space:nowrap;overflow:hidden;background-color:transparent;background-position:50%;background-repeat:no-repeat;background-size:75% 75%;opacity:.5;*position:absolute;*top:0}.pika-next:hover,.pika-prev:hover{opacity:1}.is-rtl .pika-next,.pika-prev{float:left;background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAAUklEQVR42u3VMQoAIBADQf8Pgj+OD9hG2CtONJB2ymQkKe0HbwAP0xucDiQWARITIDEBEnMgMQ8S8+AqBIl6kKgHiXqQqAeJepBo/z38J/U0uAHlaBkBl9I4GwAAAABJRU5ErkJggg==');*left:0}.is-rtl .pika-prev,.pika-next{float:right;background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAAU0lEQVR42u3VOwoAMAgE0dwfAnNjU26bYkBCFGwfiL9VVWoO+BJ4Gf3gtsEKKoFBNTCoCAYVwaAiGNQGMUHMkjGbgjk2mIONuXo0nC8XnCf1JXgArVIZAQh5TKYAAAAASUVORK5CYII=');*right:0}.pika-next.is-disabled,.pika-prev.is-disabled{cursor:default;opacity:.2}.pika-select{display:inline-block;*display:inline}.pika-table{width:100%;border-collapse:collapse;border-spacing:0;border:0}.pika-table td,.pika-table th{width:14.285714285714286%;padding:0}.pika-table th{color:#999;font-size:12px;line-height:25px;font-weight:700;text-align:center}.pika-button{cursor:pointer;display:block;box-sizing:border-box;-moz-box-sizing:border-box;outline:none;border:0;margin:0;width:100%;padding:5px;color:#666;font-size:12px;line-height:15px;text-align:right;background:#f5f5f5}.pika-week{font-size:11px;color:#999}.is-today .pika-button{color:#3af;font-weight:700}.is-selected .pika-button{color:#fff;font-weight:700;background:#3af;box-shadow:inset 0 1px 3px #178fe5;border-radius:3px}.is-inrange .pika-button{background:#d5e9f7}.is-startrange .pika-button{color:#fff;background:#6cb31d;box-shadow:none;border-radius:3px}.is-endrange .pika-button{color:#fff;background:#3af;box-shadow:none;border-radius:3px}.is-disabled .pika-button{pointer-events:none;cursor:default;color:#999;opacity:.3}.pika-button:hover{color:#fff;background:#ff8000;box-shadow:none;border-radius:3px}.pika-table abbr{border-bottom:none;cursor:help}", ""]);

	// exports


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Encoding.js
	 *
	 * @description    Converts character encoding.
	 * @fileoverview   Encoding library
	 * @author         polygon planet
	 * @version        1.0.24
	 * @date           2015-09-22
	 * @link           https://github.com/polygonplanet/encoding.js
	 * @copyright      Copyright (c) 2013-2015 polygon planet <polygon.planet.aqua@gmail.com>
	 * @license        licensed under the MIT license.
	 *
	 * Based:
	 *   - mbstring library
	 *   - posql charset library
	 *   - libxml2
	 *   - pot.js
	 */

	/*jshint bitwise:false,eqnull:true,newcap:false */

	(function (name, context, factory) {

	// Supports UMD. AMD, CommonJS/Node.js and browser context
	if (true) {
	  if (typeof module !== 'undefined' && module.exports) {
	    module.exports = factory();
	  } else {
	    exports[name] = factory();
	  }
	} else if (typeof define === 'function' && define.amd) {
	  define(factory);
	} else {
	  context[name] = factory();
	}

	})('Encoding', this, function () {
	'use strict';

	var UTF8_UNKNOWN = '?'.charCodeAt(0);

	var fromCharCode = String.fromCharCode;
	var slice = Array.prototype.slice;
	var toString = Object.prototype.toString;
	var hasOwnProperty = Object.prototype.hasOwnProperty;

	var HAS_TYPED = typeof Uint8Array !== 'undefined' &&
	                typeof Uint16Array !== 'undefined';

	// Test for String.fromCharCode.apply.
	var CAN_CHARCODE_APPLY = false;
	var CAN_CHARCODE_APPLY_TYPED = false;

	try {
	  if (fromCharCode.apply(null, [0x61]) === 'a') {
	    CAN_CHARCODE_APPLY = true;
	  }
	} catch (e) {}

	if (HAS_TYPED) {
	  try {
	    if (fromCharCode.apply(null, new Uint8Array([0x61])) === 'a') {
	      CAN_CHARCODE_APPLY_TYPED = true;
	    }
	  } catch (e) {}
	}

	// Function.prototype.apply stack max range
	var APPLY_BUFFER_SIZE = 65533;
	var APPLY_BUFFER_SIZE_OK = null;


	/**
	 * Encoding names.
	 *
	 * @ignore
	 */
	var EncodingNames = {
	  UTF32: {
	    order: 0
	  },
	  UTF32BE: {
	    alias: ['UCS4']
	  },
	  UTF32LE: null,
	  UTF16: {
	    order: 1
	  },
	  UTF16BE: {
	    alias: ['UCS2']
	  },
	  UTF16LE: null,
	  BINARY: {
	    order: 2
	  },
	  ASCII: {
	    order: 3,
	    alias: ['ISO646', 'CP367']
	  },
	  JIS: {
	    order: 4,
	    alias: ['ISO2022JP']
	  },
	  UTF8: {
	    order: 5
	  },
	  EUCJP: {
	    order: 6
	  },
	  SJIS: {
	    order: 7,
	    alias: ['CP932', 'MSKANJI', 'WINDOWS31J']
	  },
	  UNICODE: {
	    order: 8
	  }
	};

	/**
	 * Encoding alias names.
	 *
	 * @ignore
	 */
	var EncodingAliases = {};

	/**
	 * Encoding orders.
	 *
	 * @ignore
	 */
	var EncodingOrders = (function() {
	  var aliases = EncodingAliases;

	  var names = getKeys(EncodingNames);
	  var orders = [];
	  var name, encoding, j, l;

	  for (var i = 0, len = names.length; i < len; i++) {
	    name = names[i];
	    aliases[name] = name;

	    encoding = EncodingNames[name];
	    if (encoding != null) {
	      if (typeof encoding.order !== 'undefined') {
	        orders[orders.length] = name;
	      }

	      if (encoding.alias) {
	        // Create the encoding aliases.
	        for (j = 0, l = encoding.alias.length; j < l; j++) {
	          aliases[encoding.alias[j]] = name;
	        }
	      }
	    }
	  }

	  orders.sort(function(a, b) {
	    return EncodingNames[a].order - EncodingNames[b].order;
	  });

	  return orders;
	}());


	/**
	 * Encoding.
	 *
	 * @name Encoding
	 * @type {Object}
	 * @public
	 * @class
	 */
	var Encoding = {
	  /**
	   * @lends Encoding
	   */
	  /**
	   * Encoding orders.
	   *
	   * @ignore
	   */
	  orders: EncodingOrders,
	  /**
	   * Detects character encoding.
	   *
	   * If encodings is "AUTO", or the encoding-list as an array, or
	   *   comma separated list string it will be detected automatically.
	   *
	   * @param {Array.<number>|TypedArray|string} data The data being detected.
	   * @param {(Object|string|Array.<string>)=} [encodings] The encoding-list of
	   *   character encoding.
	   * @return {string|boolean} The detected character encoding, or false.
	   *
	   * @public
	   * @function
	   */
	  detect: function(data, encodings) {
	    if (data == null || data.length === 0) {
	      return false;
	    }

	    if (isObject(encodings)) {
	      encodings = encodings.encoding;
	    }

	    if (isString(data)) {
	      data = stringToBuffer(data);
	    }

	    if (encodings == null) {
	      encodings = Encoding.orders;
	    } else {
	      if (isString(encodings)) {
	        encodings = encodings.toUpperCase();
	        if (encodings === 'AUTO') {
	          encodings = Encoding.orders;
	        } else if (~encodings.indexOf(',')) {
	          encodings = encodings.split(/\s*,\s*/);
	        } else {
	          encodings = [encodings];
	        }
	      }
	    }

	    var len = encodings.length;
	    var e, encoding, method;
	    for (var i = 0; i < len; i++) {
	      e = encodings[i];
	      encoding = assignEncodingName(e);
	      if (!encoding) {
	        continue;
	      }

	      method = 'is' + encoding;
	      if (!hasOwnProperty.call(EncodingDetect, method)) {
	        throw new Error('Undefined encoding: ' + e);
	      }

	      if (EncodingDetect[method](data)) {
	        return encoding;
	      }
	    }

	    return false;
	  },
	  /**
	   * Convert character encoding.
	   *
	   * If `from` is "AUTO", or the encoding-list as an array, or
	   *   comma separated list string it will be detected automatically.
	   *
	   * @param {Array.<number>|TypedArray|string} data The data being converted.
	   * @param {(string|Object)} to The name of encoding to.
	   * @param {(string|Array.<string>)=} [from] The encoding-list of
	   *   character encoding.
	   * @return {Array|TypedArray|string} The converted data.
	   *
	   * @public
	   * @function
	   */
	  convert: function(data, to, from) {
	    var result;
	    var type;
	    var options = {};

	    if (isObject(to)) {
	      options = to;
	      from = options.from;
	      to = options.to;
	      if (options.type) {
	        type = options.type;
	      }
	    }

	    if (isString(data)) {
	      type = type || 'string';
	      data = stringToBuffer(data);
	    } else if (data == null || data.length === 0) {
	      data = [];
	    }

	    var encodingFrom;
	    if (from != null && isString(from) &&
	        from.toUpperCase() !== 'AUTO' && !~from.indexOf(',')) {
	      encodingFrom = assignEncodingName(from);
	    } else {
	      encodingFrom = Encoding.detect(data);
	    }

	    var encodingTo = assignEncodingName(to);
	    var method = encodingFrom + 'To' + encodingTo;

	    if (hasOwnProperty.call(EncodingConvert, method)) {
	      result = EncodingConvert[method](data, options);
	    } else {
	      // Returns the raw data if the method is undefined.
	      result = data;
	    }

	    switch (('' + type).toLowerCase()) {
	      case 'string':
	        return codeToString_fast(result);
	      case 'arraybuffer':
	        return codeToBuffer(result);
	      case 'array':
	        /* falls through */
	      default:
	        return bufferToCode(result);
	    }
	  },
	  /**
	   * Encode a character code array to URL string like encodeURIComponent.
	   *
	   * @param {Array.<number>|TypedArray} data The data being encoded.
	   * @return {string} The percent encoded string.
	   *
	   * @public
	   * @function
	   */
	  urlEncode: function(data) {
	    if (isString(data)) {
	      data = stringToBuffer(data);
	    }

	    var alpha = stringToCode('0123456789ABCDEF');
	    var results = [];
	    var i = 0;
	    var len = data && data.length;
	    var b;

	    for (; i < len; i++) {
	      b = data[i];

	      //FIXME: JavaScript UTF-16 encoding
	      if (b > 0xFF) {
	        return encodeURIComponent(codeToString_fast(data));
	      }

	      if ((b >= 0x61 /*a*/ && b <= 0x7A /*z*/) ||
	          (b >= 0x41 /*A*/ && b <= 0x5A /*Z*/) ||
	          (b >= 0x30 /*0*/ && b <= 0x39 /*9*/) ||
	          b === 0x21 /*!*/ ||
	          (b >= 0x27 /*'*/ && b <= 0x2A /***/) ||
	          b === 0x2D /*-*/ || b === 0x2E /*.*/ ||
	          b === 0x5F /*_*/ || b === 0x7E /*~*/
	      ) {
	        results[results.length] = b;
	      } else {
	        results[results.length] = 0x25; /*%*/
	        if (b < 0x10) {
	          results[results.length] = 0x30; /*0*/
	          results[results.length] = alpha[b];
	        } else {
	          results[results.length] = alpha[b >> 4 & 0xF];
	          results[results.length] = alpha[b & 0xF];
	        }
	      }
	    }

	    return codeToString_fast(results);
	  },
	  /**
	   * Decode a percent encoded string to
	   *  character code array like decodeURIComponent.
	   *
	   * @param {string} string The data being decoded.
	   * @return {Array.<number>} The decoded array.
	   *
	   * @public
	   * @function
	   */
	  urlDecode: function(string) {
	    var results = [];
	    var i = 0;
	    var len = string && string.length;
	    var c;

	    while (i < len) {
	      c = string.charCodeAt(i++);
	      if (c === 0x25 /*%*/) {
	        results[results.length] = parseInt(
	          string.charAt(i++) + string.charAt(i++), 16);
	      } else {
	        results[results.length] = c;
	      }
	    }

	    return results;
	  },
	  /**
	   * Encode a character code array to Base64 encoded string.
	   *
	   * @param {Array.<number>|TypedArray} data The data being encoded.
	   * @return {string} The Base64 encoded string.
	   *
	   * @public
	   * @function
	   */
	  base64Encode: function(data) {
	    if (isString(data)) {
	      data = stringToBuffer(data);
	    }
	    return base64encode(data);
	  },
	  /**
	   * Decode a Base64 encoded string to character code array.
	   *
	   * @param {string} string The data being decoded.
	   * @return {Array.<number>} The decoded array.
	   *
	   * @public
	   * @function
	   */
	  base64Decode: function(string) {
	    return base64decode(string);
	  },
	  /**
	   * Joins a character code array to string.
	   *
	   * @param {Array.<number>|TypedArray} data The data being joined.
	   * @return {String} The joined string.
	   *
	   * @public
	   * @function
	   */
	  codeToString: codeToString_fast,
	  /**
	   * Splits string to an array of character codes.
	   *
	   * @param {string} string The input string.
	   * @return {Array.<number>} The character code array.
	   *
	   * @public
	   * @function
	   */
	  stringToCode: stringToCode,
	  /**
	   * 全角英数記号文字を半角英数記号文字に変換
	   *
	   * Convert the ascii symbols and alphanumeric characters to
	   *   the zenkaku symbols and alphanumeric characters.
	   *
	   * @example
	   *   console.log(Encoding.toHankakuCase('Ｈｅｌｌｏ Ｗｏｒｌｄ！ １２３４５'));
	   *   // 'Hello World! 12345'
	   *
	   * @param {Array.<number>|TypedArray|string} data The input unicode data.
	   * @return {Array.<number>|string} The conveted data.
	   *
	   * @public
	   * @function
	   */
	  toHankakuCase: function(data) {
	    var asString = false;
	    if (isString(data)) {
	      asString = true;
	      data = stringToBuffer(data);
	    }

	    var results = [];
	    var len = data && data.length;
	    var i = 0;
	    var c;

	    while (i < len) {
	      c = data[i++];
	      if (c >= 0xFF01 && c <= 0xFF5E) {
	        c -= 0xFEE0;
	      }
	      results[results.length] = c;
	    }

	    return asString ? codeToString_fast(results) : results;
	  },
	  /**
	   * 半角英数記号文字を全角英数記号文字に変換
	   *
	   * Convert to the zenkaku symbols and alphanumeric characters
	   *  from the ascii symbols and alphanumeric characters.
	   *
	   * @example
	   *   console.log(Encoding.toZenkakuCase('Hello World! 12345'));
	   *   // 'Ｈｅｌｌｏ Ｗｏｒｌｄ！ １２３４５'
	   *
	   * @param {Array.<number>|TypedArray|string} data The input unicode data.
	   * @return {Array.<number>|string} The conveted data.
	   *
	   * @public
	   * @function
	   */
	  toZenkakuCase: function(data) {
	    var asString = false;
	    if (isString(data)) {
	      asString = true;
	      data = stringToBuffer(data);
	    }

	    var results = [];
	    var len = data && data.length;
	    var i = 0;
	    var c;

	    while (i < len) {
	      c = data[i++];
	      if (c >= 0x21 && c <= 0x7E) {
	        c += 0xFEE0;
	      }
	      results[results.length] = c;
	    }

	    return asString ? codeToString_fast(results) : results;
	  },
	  /**
	   * 全角カタカナを全角ひらがなに変換
	   *
	   * Convert to the zenkaku hiragana from the zenkaku katakana.
	   *
	   * @example
	   *   console.log(Encoding.toHiraganaCase('ボポヴァアィイゥウェエォオ'));
	   *   // 'ぼぽう゛ぁあぃいぅうぇえぉお'
	   *
	   * @param {Array.<number>|TypedArray|string} data The input unicode data.
	   * @return {Array.<number>|string} The conveted data.
	   *
	   * @public
	   * @function
	   */
	  toHiraganaCase: function(data) {
	    var asString = false;
	    if (isString(data)) {
	      asString = true;
	      data = stringToBuffer(data);
	    }

	    var results = [];
	    var len = data && data.length;
	    var i = 0;
	    var c;

	    while (i < len) {
	      c = data[i++];
	      if (c >= 0x30A1 && c <= 0x30F6) {
	        c -= 0x0060;
	      // 「ワ゛」 => 「わ」 + 「゛」
	      } else if (c === 0x30F7) {
	        results[results.length] = 0x308F;
	        c = 0x309B;
	      // 「ヲ゛」 => 「を」 + 「゛」
	      } else if (c === 0x30FA) {
	        results[results.length] = 0x3092;
	        c = 0x309B;
	      }
	      results[results.length] = c;
	    }

	    return asString ? codeToString_fast(results) : results;
	  },
	  /**
	   * 全角ひらがなを全角カタカナに変換
	   *
	   * Convert to the zenkaku katakana from the zenkaku hiragana.
	   *
	   * @example
	   *   console.log(Encoding.toKatakanaCase('ぼぽう゛ぁあぃいぅうぇえぉお'));
	   *   // 'ボポヴァアィイゥウェエォオ'
	   *
	   * @param {Array.<number>|TypedArray|string} data The input unicode data.
	   * @return {Array.<number>|string} The conveted data.
	   *
	   * @public
	   * @function
	   */
	  toKatakanaCase: function(data) {
	    var asString = false;
	    if (isString(data)) {
	      asString = true;
	      data = stringToBuffer(data);
	    }

	    var results = [];
	    var len = data && data.length;
	    var i = 0;
	    var c;

	    while (i < len) {
	      c = data[i++];
	      if (c >= 0x3041 && c <= 0x3096) {
	        if ((c === 0x308F || // 「わ」 + 「゛」 => 「ワ゛」
	             c === 0x3092) && // 「を」 + 「゛」 => 「ヲ゛」
	            i < len && data[i] === 0x309B) {
	          c = c === 0x308F ? 0x30F7 : 0x30FA;
	          i++;
	        } else {
	          c += 0x0060;
	        }
	      }
	      results[results.length] = c;
	    }

	    return asString ? codeToString_fast(results) : results;
	  },
	  /**
	   * 全角カタカナを半角ｶﾀｶﾅに変換
	   *
	   * Convert to the hankaku katakana from the zenkaku katakana.
	   *
	   * @example
	   *   console.log(Encoding.toHankanaCase('ボポヴァアィイゥウェエォオ'));
	   *   // 'ﾎﾞﾎﾟｳﾞｧｱｨｲｩｳｪｴｫｵ'
	   *
	   * @param {Array.<number>|TypedArray|string} data The input unicode data.
	   * @return {Array.<number>|string} The conveted data.
	   *
	   * @public
	   * @function
	   */
	  toHankanaCase: function(data) {
	    var asString = false;
	    if (isString(data)) {
	      asString = true;
	      data = stringToBuffer(data);
	    }

	    var results = [];
	    var len = data && data.length;
	    var i = 0;
	    var c, d, t;

	    while (i < len) {
	      c = data[i++];

	      if (c >= 0x3001 && c <= 0x30FC) {
	        t = hankanaCase_table[c];
	        if (t !== void 0) {
	          results[results.length] = t;
	          continue;
	        }
	      }

	      // 「ヴ」, 「ワ」+「゛」, 「ヲ」+「゛」
	      if (c === 0x30F4 || c === 0x30F7 || c === 0x30FA) {
	        results[results.length] = hankanaCase_sonants[c];
	        results[results.length] = 0xFF9E;
	        // 「カ」 - 「ド」
	      } else if (c >= 0x30AB && c <= 0x30C9) {
	        results[results.length] = hankanaCase_table[c - 1];
	        results[results.length] = 0xFF9E;
	        // 「ハ」 - 「ポ」
	      } else if (c >= 0x30CF && c <= 0x30DD) {
	        d = c % 3;
	        results[results.length] = hankanaCase_table[c - d];
	        results[results.length] = hankanaCase_marks[d - 1];
	      } else {
	        results[results.length] = c;
	      }
	    }

	    return asString ? codeToString_fast(results) : results;
	  },
	  /**
	   * 半角ｶﾀｶﾅを全角カタカナに変換 (濁音含む)
	   *
	   * Convert to the zenkaku katakana from the hankaku katakana.
	   *
	   * @example
	   *   console.log(Encoding.toZenkanaCase('ﾎﾞﾎﾟｳﾞｧｱｨｲｩｳｪｴｫｵ'));
	   *   // 'ボポヴァアィイゥウェエォオ'
	   *
	   * @param {Array.<number>|TypedArray|string} data The input unicode data.
	   * @return {Array.<number>|string} The conveted data.
	   *
	   * @public
	   * @function
	   */
	  toZenkanaCase: function(data) {
	    var asString = false;
	    if (isString(data)) {
	      asString = true;
	      data = stringToBuffer(data);
	    }

	    var results = [];
	    var len = data && data.length;
	    var i = 0;
	    var c, code, next;

	    for (i = 0; i < len; i++) {
	      c = data[i];
	      // Hankaku katakana
	      if (c > 0xFF60 && c < 0xFFA0) {
	        code = zenkanaCase_table[c - 0xFF61];
	        if (i + 1 < len) {
	          next = data[i + 1];
	          // 「ﾞ」 + 「ヴ」
	          if (next === 0xFF9E && c === 0xFF73) {
	            code = 0x30F4;
	            i++;
	          // 「ﾞ」 + 「ワ゛」
	          } else if (next === 0xFF9E && c === 0xFF9C) {
	            code = 0x30F7;
	            i++;
	          // 「ﾞ」 + 「ｦ゛」
	          } else if (next === 0xFF9E && c === 0xFF66) {
	            code = 0x30FA;
	            i++;
	            // 「ﾞ」 + 「カ」 - 「コ」 or 「ハ」 - 「ホ」
	          } else if (next === 0xFF9E &&
	                     ((c > 0xFF75 && c < 0xFF85) ||
	                      (c > 0xFF89 && c < 0xFF8F))) {
	            code++;
	            i++;
	            // 「ﾟ」 + 「ハ」 - 「ホ」
	          } else if (next === 0xFF9F &&
	                     (c > 0xFF89 && c < 0xFF8F)) {
	            code += 2;
	            i++;
	          }
	        }
	        c = code;
	      }
	      results[results.length] = c;
	    }

	    return asString ? codeToString_fast(results) : results;
	  },
	  /**
	   * 全角スペースを半角スペースに変換
	   *
	   * Convert the em space(U+3000) to the single space(U+0020).
	   *
	   * @param {Array.<number>|TypedArray|string} data The input unicode data.
	   * @return {Array.<number>|string} The conveted data.
	   *
	   * @public
	   * @function
	   */
	  toHankakuSpace: function(data) {
	    if (isString(data)) {
	      return data.replace(/\u3000/g, ' ');
	    }

	    var results = [];
	    var len = data && data.length;
	    var i = 0;
	    var c;

	    while (i < len) {
	      c = data[i++];
	      if (c === 0x3000) {
	        c = 0x20;
	      }
	      results[results.length] = c;
	    }

	    return results;
	  },
	  /**
	   * 半角スペースを全角スペースに変換
	   *
	   * Convert the single space(U+0020) to the em space(U+3000).
	   *
	   * @param {Array.<number>|TypedArray|string} data The input unicode data.
	   * @return {Array.<number>|string} The conveted data.
	   *
	   * @public
	   * @function
	   */
	  toZenkakuSpace: function(data) {
	    if (isString(data)) {
	      return data.replace(/\u0020/g, '\u3000');
	    }

	    var results = [];
	    var len = data && data.length;
	    var i = 0;
	    var c;

	    while (i < len) {
	      c = data[i++];
	      if (c === 0x20) {
	        c = 0x3000;
	      }
	      results[results.length] = c;
	    }

	    return results;
	  }
	};


	/**
	 * @private
	 * @ignore
	 */
	var EncodingDetect = {
	  isBINARY: isBINARY,
	  isASCII: isASCII,
	  isJIS: isJIS,
	  isEUCJP: isEUCJP,
	  isSJIS: isSJIS,
	  isUTF8: isUTF8,
	  isUTF16: isUTF16,
	  isUTF16BE: isUTF16BE,
	  isUTF16LE: isUTF16LE,
	  isUTF32: isUTF32,
	  isUNICODE: isUNICODE
	};

	/**
	 * @private
	 * @ignore
	 */
	var EncodingConvert = {
	  // JIS, EUCJP, SJIS
	  JISToEUCJP: JISToEUCJP,
	  EUCJPToJIS: EUCJPToJIS,
	  JISToSJIS: JISToSJIS,
	  SJISToJIS: SJISToJIS,
	  EUCJPToSJIS: EUCJPToSJIS,
	  SJISToEUCJP: SJISToEUCJP,

	  // UTF8
	  JISToUTF8: JISToUTF8,
	  UTF8ToJIS: UTF8ToJIS,
	  EUCJPToUTF8: EUCJPToUTF8,
	  UTF8ToEUCJP: UTF8ToEUCJP,
	  SJISToUTF8: SJISToUTF8,
	  UTF8ToSJIS: UTF8ToSJIS,

	  // UNICODE
	  UNICODEToUTF8: UNICODEToUTF8,
	  UTF8ToUNICODE: UTF8ToUNICODE,
	  UNICODEToJIS: UNICODEToJIS,
	  JISToUNICODE: JISToUNICODE,
	  UNICODEToEUCJP: UNICODEToEUCJP,
	  EUCJPToUNICODE: EUCJPToUNICODE,
	  UNICODEToSJIS: UNICODEToSJIS,
	  SJISToUNICODE: SJISToUNICODE,

	  // UTF16, UNICODE
	  UNICODEToUTF16: UNICODEToUTF16,
	  UTF16ToUNICODE: UTF16ToUNICODE,
	  UNICODEToUTF16BE: UNICODEToUTF16BE,
	  UTF16BEToUNICODE: UTF16BEToUNICODE,
	  UNICODEToUTF16LE: UNICODEToUTF16LE,
	  UTF16LEToUNICODE: UTF16LEToUNICODE,

	  // UTF16, UTF16BE, UTF16LE
	  UTF8ToUTF16: UTF8ToUTF16,
	  UTF16ToUTF8: UTF16ToUTF8,
	  UTF8ToUTF16BE: UTF8ToUTF16BE,
	  UTF16BEToUTF8: UTF16BEToUTF8,
	  UTF8ToUTF16LE: UTF8ToUTF16LE,
	  UTF16LEToUTF8: UTF16LEToUTF8,
	  UTF16ToUTF16BE: UTF16ToUTF16BE,
	  UTF16BEToUTF16: UTF16BEToUTF16,
	  UTF16ToUTF16LE: UTF16ToUTF16LE,
	  UTF16LEToUTF16: UTF16LEToUTF16,
	  UTF16BEToUTF16LE: UTF16BEToUTF16LE,
	  UTF16LEToUTF16BE: UTF16LEToUTF16BE,

	  // UTF16, JIS
	  JISToUTF16: JISToUTF16,
	  UTF16ToJIS: UTF16ToJIS,
	  JISToUTF16BE: JISToUTF16BE,
	  UTF16BEToJIS: UTF16BEToJIS,
	  JISToUTF16LE: JISToUTF16LE,
	  UTF16LEToJIS: UTF16LEToJIS,

	  // UTF16, EUCJP
	  EUCJPToUTF16: EUCJPToUTF16,
	  UTF16ToEUCJP: UTF16ToEUCJP,
	  EUCJPToUTF16BE: EUCJPToUTF16BE,
	  UTF16BEToEUCJP: UTF16BEToEUCJP,
	  EUCJPToUTF16LE: EUCJPToUTF16LE,
	  UTF16LEToEUCJP: UTF16LEToEUCJP,

	  // UTF16, SJIS
	  SJISToUTF16: SJISToUTF16,
	  UTF16ToSJIS: UTF16ToSJIS,
	  SJISToUTF16BE: SJISToUTF16BE,
	  UTF16BEToSJIS: UTF16BEToSJIS,
	  SJISToUTF16LE: SJISToUTF16LE,
	  UTF16LEToSJIS: UTF16LEToSJIS
	};


	/**
	 * Binary (exe, images and so, etc.)
	 *
	 * Note:
	 *   This function is not considered for Unicode
	 *
	 * @private
	 * @ignore
	 */
	function isBINARY(data) {
	  var i = 0;
	  var len = data && data.length;
	  var c;

	  for (; i < len; i++) {
	    c = data[i];
	    if (c > 0xFF) {
	      return false;
	    }

	    if ((c >= 0x00 && c <= 0x07) || c === 0xFF) {
	      return true;
	    }
	  }

	  return false;
	}

	/**
	 * ASCII (ISO-646)
	 *
	 * @private
	 * @ignore
	 */
	function isASCII(data) {
	  var i = 0;
	  var len = data && data.length;
	  var b;

	  for (; i < len; i++) {
	    b = data[i];
	    if (b > 0xFF ||
	        (b >= 0x80 && b <= 0xFF) ||
	        b === 0x1B) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * ISO-2022-JP (JIS)
	 *
	 * RFC1468 Japanese Character Encoding for Internet Messages
	 * RFC1554 ISO-2022-JP-2: Multilingual Extension of ISO-2022-JP
	 * RFC2237 Japanese Character Encoding for Internet Messages
	 *
	 * @private
	 * @ignore
	 */
	function isJIS(data) {
	  var i = 0;
	  var len = data && data.length;
	  var b, esc1, esc2;

	  for (; i < len; i++) {
	    b = data[i];
	    if (b > 0xFF || (b >= 0x80 && b <= 0xFF)) {
	      return false;
	    }

	    if (b === 0x1B) {
	      if (i + 2 >= len) {
	        return false;
	      }

	      esc1 = data[i + 1];
	      esc2 = data[i + 2];
	      if (esc1 === 0x24) {
	        if (esc2 === 0x28 ||  // JIS X 0208-1990/2000/2004
	            esc2 === 0x40 ||  // JIS X 0208-1978
	            esc2 === 0x42) {  // JIS X 0208-1983
	          return true;
	        }
	      } else if (esc1 === 0x26 && // JIS X 0208-1990
	                 esc2 === 0x40) {
	        return true;
	      } else if (esc1 === 0x28) {
	        if (esc2 === 0x42 || // ASCII
	            esc2 === 0x49 || // JIS X 0201 Halfwidth Katakana
	            esc2 === 0x4A) { // JIS X 0201-1976 Roman set
	          return true;
	        }
	      }
	    }
	  }

	  return false;
	}

	/**
	 * EUC-JP
	 *
	 * @private
	 * @ignore
	 */
	function isEUCJP(data) {
	  var i = 0;
	  var len = data && data.length;
	  var b;

	  for (; i < len; i++) {
	    b = data[i];
	    if (b < 0x80) {
	      continue;
	    }

	    if (b > 0xFF || b < 0x8E) {
	      return false;
	    }

	    if (b === 0x8E) {
	      if (i + 1 >= len) {
	        return false;
	      }

	      b = data[++i];
	      if (b < 0xA1 || 0xDF < b) {
	        return false;
	      }
	    } else if (b === 0x8F) {
	      if (i + 2 >= len) {
	        return false;
	      }

	      b = data[++i];
	      if (b < 0xA2 || 0xED < b) {
	        return false;
	      }

	      b = data[++i];
	      if (b < 0xA1 || 0xFE < b) {
	        return false;
	      }
	    } else if (0xA1 <= b && b <= 0xFE) {
	      if (i + 1 >= len) {
	        return false;
	      }

	      b = data[++i];
	      if (b < 0xA1 || 0xFE < b) {
	        return false;
	      }
	    } else {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Shift-JIS (SJIS)
	 *
	 * @private
	 * @ignore
	 */
	function isSJIS(data) {
	  var i = 0;
	  var len = data && data.length;
	  var b;

	  while (i < len && data[i] > 0x80) {
	    if (data[i++] > 0xFF) {
	      return false;
	    }
	  }

	  for (; i < len; i++) {
	    b = data[i];
	    if (b <= 0x80 ||
	        (0xA1 <= b && b <= 0xDF)) {
	      continue;
	    }

	    if (b === 0xA0 || b > 0xEF || i + 1 >= len) {
	      return false;
	    }

	    b = data[++i];
	    if (b < 0x40 || b === 0x7F || b > 0xFC) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * UTF-8
	 *
	 * @private
	 * @ignore
	 */
	function isUTF8(data) {
	  var i = 0;
	  var len = data && data.length;
	  var b;

	  for (; i < len; i++) {
	    b = data[i];
	    if (b > 0xFF) {
	      return false;
	    }

	    if (b === 0x09 || b === 0x0A || b === 0x0D ||
	        (b >= 0x20 && b <= 0x7E)) {
	      continue;
	    }

	    if (b >= 0xC2 && b <= 0xDF) {
	      if (i + 1 >= len || data[i + 1] < 0x80 || data[i + 1] > 0xBF) {
	        return false;
	      }
	      i++;
	    } else if (b === 0xE0) {
	      if (i + 2 >= len ||
	          data[i + 1] < 0xA0 || data[i + 1] > 0xBF ||
	          data[i + 2] < 0x80 || data[i + 2] > 0xBF) {
	        return false;
	      }
	      i += 2;
	    } else if ((b >= 0xE1 && b <= 0xEC) ||
	                b === 0xEE || b === 0xEF) {
	      if (i + 2 >= len ||
	          data[i + 1] < 0x80 || data[i + 1] > 0xBF ||
	          data[i + 2] < 0x80 || data[i + 2] > 0xBF) {
	        return false;
	      }
	      i += 2;
	    } else if (b === 0xED) {
	      if (i + 2 >= len ||
	          data[i + 1] < 0x80 || data[i + 1] > 0x9F ||
	          data[i + 2] < 0x80 || data[i + 2] > 0xBF) {
	        return false;
	      }
	      i += 2;
	    } else if (b === 0xF0) {
	      if (i + 3 >= len ||
	          data[i + 1] < 0x90 || data[i + 1] > 0xBF ||
	          data[i + 2] < 0x80 || data[i + 2] > 0xBF ||
	          data[i + 3] < 0x80 || data[i + 3] > 0xBF) {
	        return false;
	      }
	      i += 3;
	    } else if (b >= 0xF1 && b <= 0xF3) {
	      if (i + 3 >= len ||
	          data[i + 1] < 0x80 || data[i + 1] > 0xBF ||
	          data[i + 2] < 0x80 || data[i + 2] > 0xBF ||
	          data[i + 3] < 0x80 || data[i + 3] > 0xBF) {
	        return false;
	      }
	      i += 3;
	    } else if (b === 0xF4) {
	      if (i + 3 >= len ||
	          data[i + 1] < 0x80 || data[i + 1] > 0x8F ||
	          data[i + 2] < 0x80 || data[i + 2] > 0xBF ||
	          data[i + 3] < 0x80 || data[i + 3] > 0xBF) {
	        return false;
	      }
	      i += 3;
	    } else {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * UTF-16 (LE or BE)
	 *
	 * RFC2781: UTF-16, an encoding of ISO 10646
	 *
	 * @link http://www.ietf.org/rfc/rfc2781.txt
	 * @private
	 * @ignore
	 */
	function isUTF16(data) {
	  var i = 0;
	  var len = data && data.length;
	  var pos = null;
	  var b1, b2, next, prev;

	  if (len < 2) {
	    if (data[0] > 0xFF) {
	      return false;
	    }
	  } else {
	    b1 = data[0];
	    b2 = data[1];
	    if (b1 === 0xFF && // BOM (little-endian)
	        b2 === 0xFE) {
	      return true;
	    }
	    if (b1 === 0xFE && // BOM (big-endian)
	        b2 === 0xFF) {
	      return true;
	    }

	    for (; i < len; i++) {
	      if (data[i] === 0x00) {
	        pos = i;
	        break;
	      } else if (data[i] > 0xFF) {
	        return false;
	      }
	    }

	    if (pos === null) {
	      return false; // Non ASCII
	    }

	    next = data[pos + 1]; // BE
	    if (next !== void 0 && next > 0x00 && next < 0x80) {
	      return true;
	    }

	    prev = data[pos - 1]; // LE
	    if (prev !== void 0 && prev > 0x00 && prev < 0x80) {
	      return true;
	    }
	  }

	  return false;
	}

	/**
	 * UTF-16BE (big-endian)
	 *
	 * RFC 2781 4.3 Interpreting text labelled as UTF-16
	 * Text labelled "UTF-16BE" can always be interpreted as being big-endian
	 *  when BOM does not founds (SHOULD)
	 *
	 * @link http://www.ietf.org/rfc/rfc2781.txt
	 * @private
	 * @ignore
	 */
	function isUTF16BE(data) {
	  var i = 0;
	  var len = data && data.length;
	  var pos = null;
	  var b1, b2;

	  if (len < 2) {
	    if (data[0] > 0xFF) {
	      return false;
	    }
	  } else {
	    b1 = data[0];
	    b2 = data[1];
	    if (b1 === 0xFE && // BOM
	        b2 === 0xFF) {
	      return true;
	    }

	    for (; i < len; i++) {
	      if (data[i] === 0x00) {
	        pos = i;
	        break;
	      } else if (data[i] > 0xFF) {
	        return false;
	      }
	    }

	    if (pos === null) {
	      return false; // Non ASCII
	    }

	    if (pos % 2 === 0) {
	      return true;
	    }
	  }

	  return false;
	}

	/**
	 * UTF-16LE (little-endian)
	 *
	 * @see isUTF16BE
	 * @private
	 * @ignore
	 */
	function isUTF16LE(data) {
	  var i = 0;
	  var len = data && data.length;
	  var pos = null;
	  var b1, b2;

	  if (len < 2) {
	    if (data[0] > 0xFF) {
	      return false;
	    }
	  } else {
	    b1 = data[0];
	    b2 = data[1];
	    if (b1 === 0xFF && // BOM
	        b2 === 0xFE) {
	      return true;
	    }

	    for (; i < len; i++) {
	      if (data[i] === 0x00) {
	        pos = i;
	        break;
	      } else if (data[i] > 0xFF) {
	        return false;
	      }
	    }

	    if (pos === null) {
	      return false; // Non ASCII
	    }

	    if (pos % 2 !== 0) {
	      return true;
	    }
	  }

	  return false;
	}

	/**
	 * UTF-32
	 *
	 * Unicode 3.2.0: Unicode Standard Annex #19
	 *
	 * @link http://www.iana.org/assignments/charset-reg/UTF-32
	 * @link http://www.unicode.org/reports/tr19/tr19-9.html
	 * @private
	 * @ignore
	 */
	function isUTF32(data) {
	  var i = 0;
	  var len = data && data.length;
	  var pos = null;
	  var b1, b2, b3, b4;
	  var next, prev;

	  if (len < 4) {
	    for (; i < len; i++) {
	      if (data[i] > 0xFF) {
	        return false;
	      }
	    }
	  } else {
	    b1 = data[0];
	    b2 = data[1];
	    b3 = data[2];
	    b4 = data[3];
	    if (b1 === 0x00 && b2 === 0x00 && // BOM (big-endian)
	        b3 === 0xFE && b4 === 0xFF) {
	      return true;
	    }

	    if (b1 === 0xFF && b2 === 0xFE && // BOM (little-endian)
	        b3 === 0x00 && b4 === 0x00) {
	      return true;
	    }

	    for (; i < len; i++) {
	      if (data[i] === 0x00 && data[i + 1] === 0x00 && data[i + 2] === 0x00) {
	        pos = i;
	        break;
	      } else if (data[i] > 0xFF) {
	        return false;
	      }
	    }

	    if (pos === null) {
	      return false;
	    }

	    // The byte order should be the big-endian when BOM is not detected.
	    next = data[pos + 3];
	    if (next !== void 0 && next > 0x00 && next <= 0x7F) {
	      // big-endian
	      return data[pos + 2] === 0x00 && data[pos + 1] === 0x00;
	    }

	    prev = data[pos - 1];
	    if (prev !== void 0 && prev > 0x00 && prev <= 0x7F) {
	      // little-endian
	      return data[pos + 1] === 0x00 && data[pos + 2] === 0x00;
	    }
	  }

	  return false;
	}

	/**
	 * JavaScript Unicode array
	 *
	 * @private
	 * @ignore
	 */
	function isUNICODE(data) {
	  var i = 0;
	  var len = data && data.length;
	  var c;

	  for (; i < len; i++) {
	    c = data[i];
	    if (c < 0 || c > 0x10FFFF) {
	      return false;
	    }
	  }

	  return true;
	}


	/**
	 * JIS to SJIS
	 *
	 * @private
	 * @ignore
	 */
	function JISToSJIS(data) {
	  var results = [];
	  var index = 0;
	  var i = 0;
	  var len = data && data.length;
	  var b1, b2;

	  for (; i < len; i++) {
	    // escape sequence
	    while (data[i] === 0x1B) {
	      if ((data[i + 1] === 0x24 && data[i + 2] === 0x42) ||
	          (data[i + 1] === 0x24 && data[i + 2] === 0x40)) {
	        index = 1;
	      } else if ((data[i + 1] === 0x28 && data[i + 2] === 0x49)) {
	        index = 2;
	      } else if (data[i + 1] === 0x24 && data[i + 2] === 0x28 &&
	                 data[i + 3] === 0x44) {
	        index = 3;
	        i++;
	      } else {
	        index = 0;
	      }

	      i += 3;
	      if (data[i] === void 0) {
	        return results;
	      }
	    }

	    if (index === 1) {
	      b1 = data[i];
	      b2 = data[++i];
	      if (b1 & 0x01) {
	        b1 >>= 1;
	        if (b1 < 0x2F) {
	          b1 += 0x71;
	        } else {
	          b1 -= 0x4F;
	        }
	        if (b2 > 0x5F) {
	          b2 += 0x20;
	        } else {
	          b2 += 0x1F;
	        }
	      } else {
	        b1 >>= 1;
	        if (b1 <= 0x2F) {
	          b1 += 0x70;
	        } else {
	          b1 -= 0x50;
	        }
	        b2 += 0x7E;
	      }
	      results[results.length] = b1 & 0xFF;
	      results[results.length] = b2 & 0xFF;
	    } else if (index === 2) {
	      results[results.length] = data[i] + 0x80 & 0xFF;
	    } else if (index === 3) {
	      // Shift_JIS cannot convert JIS X 0212:1990.
	      results[results.length] = UTF8_UNKNOWN;
	    } else {
	      results[results.length] = data[i] & 0xFF;
	    }
	  }

	  return results;
	}

	/**
	 * JIS to EUCJP
	 *
	 * @private
	 * @ignore
	 */
	function JISToEUCJP(data) {
	  var results = [];
	  var index = 0;
	  var len = data && data.length;
	  var i = 0;

	  for (; i < len; i++) {

	    // escape sequence
	    while (data[i] === 0x1B) {
	      if ((data[i + 1] === 0x24 && data[i + 2] === 0x42) ||
	          (data[i + 1] === 0x24 && data[i + 2] === 0x40)) {
	        index = 1;
	      } else if ((data[i + 1] === 0x28 && data[i + 2] === 0x49)) {
	        index = 2;
	      } else if (data[i + 1] === 0x24 && data[i + 2] === 0x28 &&
	                 data[i + 3] === 0x44) {
	        index = 3;
	        i++;
	      } else {
	        index = 0;
	      }

	      i += 3;
	      if (data[i] === void 0) {
	        return results;
	      }
	    }

	    if (index === 1) {
	      results[results.length] = data[i] + 0x80 & 0xFF;
	      results[results.length] = data[++i] + 0x80 & 0xFF;
	    } else if (index === 2) {
	      results[results.length] = 0x8E;
	      results[results.length] = data[i] + 0x80 & 0xFF;
	    } else if (index === 3) {
	      results[results.length] = 0x8F;
	      results[results.length] = data[i] + 0x80 & 0xFF;
	      results[results.length] = data[++i] + 0x80 & 0xFF;
	    } else {
	      results[results.length] = data[i] & 0xFF;
	    }
	  }

	  return results;
	}

	/**
	 * SJIS to JIS
	 *
	 * @private
	 * @ignore
	 */
	function SJISToJIS(data) {
	  var results = [];
	  var index = 0;
	  var len = data && data.length;
	  var i = 0;
	  var b1, b2;

	  var esc = [
	    0x1B, 0x28, 0x42,
	    0x1B, 0x24, 0x42,
	    0x1B, 0x28, 0x49
	  ];

	  for (; i < len; i++) {
	    b1 = data[i];
	    if (b1 >= 0xA1 && b1 <= 0xDF) {
	      if (index !== 2) {
	        index = 2;
	        results[results.length] = esc[6];
	        results[results.length] = esc[7];
	        results[results.length] = esc[8];
	      }
	      results[results.length] = b1 - 0x80 & 0xFF;
	    } else if (b1 >= 0x80) {
	      if (index !== 1) {
	        index = 1;
	        results[results.length] = esc[3];
	        results[results.length] = esc[4];
	        results[results.length] = esc[5];
	      }

	      b1 <<= 1;
	      b2 = data[++i];
	      if (b2 < 0x9F) {
	        if (b1 < 0x13F) {
	          b1 -= 0xE1;
	        } else {
	          b1 -= 0x61;
	        }
	        if (b2 > 0x7E) {
	          b2 -= 0x20;
	        } else {
	          b2 -= 0x1F;
	        }
	      } else {
	        if (b1 < 0x13F) {
	          b1 -= 0xE0;
	        } else {
	          b1 -= 0x60;
	        }
	        b2 -= 0x7E;
	      }
	      results[results.length] = b1 & 0xFF;
	      results[results.length] = b2 & 0xFF;
	    } else {
	      if (index !== 0) {
	        index = 0;
	        results[results.length] = esc[0];
	        results[results.length] = esc[1];
	        results[results.length] = esc[2];
	      }
	      results[results.length] = b1 & 0xFF;
	    }
	  }

	  if (index !== 0) {
	    results[results.length] = esc[0];
	    results[results.length] = esc[1];
	    results[results.length] = esc[2];
	  }

	  return results;
	}

	/**
	 * SJIS to EUCJP
	 *
	 * @private
	 * @ignore
	 */
	function SJISToEUCJP(data) {
	  var results = [];
	  var len = data && data.length;
	  var i = 0;
	  var b1, b2;

	  for (; i < len; i++) {
	    b1 = data[i];
	    if (b1 >= 0xA1 && b1 <= 0xDF) {
	      results[results.length] = 0x8E;
	      results[results.length] = b1;
	    } else if (b1 >= 0x81) {
	      b2 = data[++i];
	      b1 <<= 1;
	      if (b2 < 0x9F) {
	        if (b1 < 0x13F) {
	          b1 -= 0x61;
	        } else {
	          b1 -= 0xE1;
	        }

	        if (b2 > 0x7E) {
	          b2 += 0x60;
	        } else {
	          b2 += 0x61;
	        }
	      } else {
	        if (b1 < 0x13F) {
	          b1 -= 0x60;
	        } else {
	          b1 -= 0xE0;
	        }
	        b2 += 0x02;
	      }
	      results[results.length] = b1 & 0xFF;
	      results[results.length] = b2 & 0xFF;
	    } else {
	      results[results.length] = b1 & 0xFF;
	    }
	  }

	  return results;
	}

	/**
	 * EUCJP to JIS
	 *
	 * @private
	 * @ignore
	 */
	function EUCJPToJIS(data) {
	  var results = [];
	  var index = 0;
	  var len = data && data.length;
	  var i = 0;
	  var b;

	  // escape sequence
	  var esc = [
	    0x1B, 0x28, 0x42,
	    0x1B, 0x24, 0x42,
	    0x1B, 0x28, 0x49,
	    0x1B, 0x24, 0x28, 0x44
	  ];

	  for (; i < len; i++) {
	    b = data[i];
	    if (b === 0x8E) {
	      if (index !== 2) {
	        index = 2;
	        results[results.length] = esc[6];
	        results[results.length] = esc[7];
	        results[results.length] = esc[8];
	      }
	      results[results.length] = data[++i] - 0x80 & 0xFF;
	    } else if (b === 0x8F) {
	      if (index !== 3) {
	        index = 3;
	        results[results.length] = esc[9];
	        results[results.length] = esc[10];
	        results[results.length] = esc[11];
	        results[results.length] = esc[12];
	      }
	      results[results.length] = data[++i] - 0x80 & 0xFF;
	      results[results.length] = data[++i] - 0x80 & 0xFF;
	    } else if (b > 0x8E) {
	      if (index !== 1) {
	        index = 1;
	        results[results.length] = esc[3];
	        results[results.length] = esc[4];
	        results[results.length] = esc[5];
	      }
	      results[results.length] = b - 0x80 & 0xFF;
	      results[results.length] = data[++i] - 0x80 & 0xFF;
	    } else {
	      if (index !== 0) {
	        index = 0;
	        results[results.length] = esc[0];
	        results[results.length] = esc[1];
	        results[results.length] = esc[2];
	      }
	      results[results.length] = b & 0xFF;
	    }
	  }

	  if (index !== 0) {
	    results[results.length] = esc[0];
	    results[results.length] = esc[1];
	    results[results.length] = esc[2];
	  }

	  return results;
	}

	/**
	 * EUCJP to SJIS
	 *
	 * @private
	 * @ignore
	 */
	function EUCJPToSJIS(data) {
	  var results = [];
	  var len = data && data.length;
	  var i = 0;
	  var b1, b2;

	  for (; i < len; i++) {
	    b1 = data[i];
	    if (b1 === 0x8F) {
	      results[results.length] = UTF8_UNKNOWN;
	      i += 2;
	    } else if (b1 > 0x8E) {
	      b2 = data[++i];
	      if (b1 & 0x01) {
	        b1 >>= 1;
	        if (b1 < 0x6F) {
	          b1 += 0x31;
	        } else {
	          b1 += 0x71;
	        }

	        if (b2 > 0xDF) {
	          b2 -= 0x60;
	        } else {
	          b2 -= 0x61;
	        }
	      } else {
	        b1 >>= 1;
	        if (b1 <= 0x6F) {
	          b1 += 0x30;
	        } else {
	          b1 += 0x70;
	        }
	        b2 -= 0x02;
	      }
	      results[results.length] = b1 & 0xFF;
	      results[results.length] = b2 & 0xFF;
	    } else if (b1 === 0x8E) {
	      results[results.length] = data[++i] & 0xFF;
	    } else {
	      results[results.length] = b1 & 0xFF;
	    }
	  }

	  return results;
	}

	/**
	 * SJIS To UTF-8
	 *
	 * @private
	 * @ignore
	 */
	function SJISToUTF8(data) {
	  init_JIS_TO_UTF8_TABLE();

	  var results = [];
	  var i = 0;
	  var len = data && data.length;
	  var b, b1, b2, u2, u3, jis, utf8;

	  for (; i < len; i++) {
	    b = data[i];
	    if (b >= 0xA1 && b <= 0xDF) {
	      b2 = b - 0x40;
	      u2 = 0xBC | ((b2 >> 6) & 0x03);
	      u3 = 0x80 | (b2 & 0x3F);

	      results[results.length] = 0xEF;
	      results[results.length] = u2 & 0xFF;
	      results[results.length] = u3 & 0xFF;
	    } else if (b >= 0x80) {
	      b1 = b << 1;
	      b2 = data[++i];

	      if (b2 < 0x9F) {
	        if (b1 < 0x13F) {
	          b1 -= 0xE1;
	        } else {
	          b1 -= 0x61;
	        }

	        if (b2 > 0x7E) {
	          b2 -= 0x20;
	        } else {
	          b2 -= 0x1F;
	        }
	      } else {
	        if (b1 < 0x13F) {
	          b1 -= 0xE0;
	        } else {
	          b1 -= 0x60;
	        }
	        b2 -= 0x7E;
	      }

	      b1 &= 0xFF;
	      jis = (b1 << 8) + b2;

	      utf8 = JIS_TO_UTF8_TABLE[jis];
	      if (utf8 === void 0) {
	        results[results.length] = UTF8_UNKNOWN;
	      } else {
	        if (utf8 < 0xFFFF) {
	          results[results.length] = utf8 >> 8 & 0xFF;
	          results[results.length] = utf8 & 0xFF;
	        } else {
	          results[results.length] = utf8 >> 16 & 0xFF;
	          results[results.length] = utf8 >> 8 & 0xFF;
	          results[results.length] = utf8 & 0xFF;
	        }
	      }
	    } else {
	      results[results.length] = data[i] & 0xFF;
	    }
	  }

	  return results;
	}

	/**
	 * EUC-JP to UTF-8
	 *
	 * @private
	 * @ignore
	 */
	function EUCJPToUTF8(data) {
	  init_JIS_TO_UTF8_TABLE();

	  var results = [];
	  var i = 0;
	  var len = data && data.length;
	  var b, b2, u2, u3, j2, j3, jis, utf8;

	  for (; i < len; i++) {
	    b = data[i];
	    if (b === 0x8E) {
	      b2 = data[++i] - 0x40;
	      u2 = 0xBC | ((b2 >> 6) & 0x03);
	      u3 = 0x80 | (b2 & 0x3F);

	      results[results.length] = 0xEF;
	      results[results.length] = u2 & 0xFF;
	      results[results.length] = u3 & 0xFF;
	    } else if (b === 0x8F) {
	      j2 = data[++i] - 0x80;
	      j3 = data[++i] - 0x80;
	      jis = (j2 << 8) + j3;

	      utf8 = JISX0212_TO_UTF8_TABLE[jis];
	      if (utf8 === void 0) {
	        results[results.length] = UTF8_UNKNOWN;
	      } else {
	        if (utf8 < 0xFFFF) {
	          results[results.length] = utf8 >> 8 & 0xFF;
	          results[results.length] = utf8 & 0xFF;
	        } else {
	          results[results.length] = utf8 >> 16 & 0xFF;
	          results[results.length] = utf8 >>  8 & 0xFF;
	          results[results.length] = utf8 & 0xFF;
	        }
	      }
	    } else if (b >= 0x80) {
	      jis = ((b - 0x80) << 8) + (data[++i] - 0x80);

	      utf8 = JIS_TO_UTF8_TABLE[jis];
	      if (utf8 === void 0) {
	        results[results.length] = UTF8_UNKNOWN;
	      } else {
	        if (utf8 < 0xFFFF) {
	          results[results.length] = utf8 >> 8 & 0xFF;
	          results[results.length] = utf8 & 0xFF;
	        } else {
	          results[results.length] = utf8 >> 16 & 0xFF;
	          results[results.length] = utf8 >>  8 & 0xFF;
	          results[results.length] = utf8 & 0xFF;
	        }
	      }
	    } else {
	      results[results.length] = data[i] & 0xFF;
	    }
	  }

	  return results;
	}

	/**
	 * JIS to UTF-8
	 *
	 * @private
	 * @ignore
	 */
	function JISToUTF8(data) {
	  init_JIS_TO_UTF8_TABLE();

	  var results = [];
	  var index = 0;
	  var i = 0;
	  var len = data && data.length;
	  var b2, u2, u3, jis, utf8;

	  for (; i < len; i++) {
	    while (data[i] === 0x1B) {
	      if ((data[i + 1] === 0x24 && data[i + 2] === 0x42) ||
	          (data[i + 1] === 0x24 && data[i + 2] === 0x40)) {
	        index = 1;
	      } else if (data[i + 1] === 0x28 && data[i + 2] === 0x49) {
	        index = 2;
	      } else if (data[i + 1] === 0x24 && data[i + 2] === 0x28 &&
	                 data[i + 3] === 0x44) {
	        index = 3;
	        i++;
	      } else {
	        index = 0;
	      }

	      i += 3;
	      if (data[i] === void 0) {
	        return results;
	      }
	    }

	    if (index === 1) {
	      jis = (data[i] << 8) + data[++i];

	      utf8 = JIS_TO_UTF8_TABLE[jis];
	      if (utf8 === void 0) {
	        results[results.length] = UTF8_UNKNOWN;
	      } else {
	        if (utf8 < 0xFFFF) {
	          results[results.length] = utf8 >> 8 & 0xFF;
	          results[results.length] = utf8 & 0xFF;
	        } else {
	          results[results.length] = utf8 >> 16 & 0xFF;
	          results[results.length] = utf8 >>  8 & 0xFF;
	          results[results.length] = utf8 & 0xFF;
	        }
	      }
	    } else if (index === 2) {
	      b2 = data[i] + 0x40;
	      u2 = 0xBC | ((b2 >> 6) & 0x03);
	      u3 = 0x80 | (b2 & 0x3F);

	      results[results.length] = 0xEF;
	      results[results.length] = u2 & 0xFF;
	      results[results.length] = u3 & 0xFF;
	    } else if (index === 3) {
	      jis = (data[i] << 8) + data[++i];

	      utf8 = JISX0212_TO_UTF8_TABLE[jis];
	      if (utf8 === void 0) {
	        results[results.length] = UTF8_UNKNOWN;
	      } else {
	        if (utf8 < 0xFFFF) {
	          results[results.length] = utf8 >> 8 & 0xFF;
	          results[results.length] = utf8 & 0xFF;
	        } else {
	          results[results.length] = utf8 >> 16 & 0xFF;
	          results[results.length] = utf8 >>  8 & 0xFF;
	          results[results.length] = utf8 & 0xFF;
	        }
	      }
	    } else {
	      results[results.length] = data[i] & 0xFF;
	    }
	  }

	  return results;
	}

	/**
	 * UTF-8 to SJIS
	 *
	 * @private
	 * @ignore
	 */
	function UTF8ToSJIS(data) {
	  var results = [];
	  var i = 0;
	  var len = data && data.length;
	  var b, b1, b2, utf8, jis;

	  for (; i < len; i++) {
	    b = data[i];
	    if (b >= 0x80) {
	      if (b <= 0xDF) {
	        // 2 bytes.
	        utf8 = (b << 8) + data[++i];
	      } else {
	        // 3 bytes.
	        utf8 = (b << 16) +
	               (data[++i] << 8) +
	               (data[++i] & 0xFF);
	      }

	      jis = UTF8_TO_JIS_TABLE[utf8];
	      if (jis === void 0) {
	        results[results.length] = UTF8_UNKNOWN;
	      } else {
	        if (jis < 0xFF) {
	          results[results.length] = jis + 0x80;
	        } else {
	          if (jis > 0x10000) {
	            jis -= 0x10000;
	          }

	          b1 = jis >> 8;
	          b2 = jis & 0xFF;
	          if (b1 & 0x01) {
	            b1 >>= 1;
	            if (b1 < 0x2F) {
	              b1 += 0x71;
	            } else {
	              b1 -= 0x4F;
	            }

	            if (b2 > 0x5F) {
	              b2 += 0x20;
	            } else {
	              b2 += 0x1F;
	            }
	          } else {
	            b1 >>= 1;
	            if (b1 <= 0x2F) {
	              b1 += 0x70;
	            } else {
	              b1 -= 0x50;
	            }
	            b2 += 0x7E;
	          }
	          results[results.length] = b1 & 0xFF;
	          results[results.length] = b2 & 0xFF;
	        }
	      }
	    } else {
	      results[results.length] = data[i] & 0xFF;
	    }
	  }

	  return results;
	}

	/**
	 * UTF-8 to EUC-JP
	 *
	 * @private
	 * @ignore
	 */
	function UTF8ToEUCJP(data) {
	  var results = [];
	  var i = 0;
	  var len = data && data.length;
	  var b, utf8, jis;

	  for (; i < len; i++) {
	    b = data[i];
	    if (b >= 0x80) {
	      if (b <= 0xDF) {
	        utf8 = (data[i++] << 8) + data[i];
	      } else {
	        utf8 = (data[i++] << 16) +
	               (data[i++] << 8) +
	               (data[i] & 0xFF);
	      }

	      jis = UTF8_TO_JIS_TABLE[utf8];
	      if (jis === void 0) {
	        jis = UTF8_TO_JISX0212_TABLE[utf8];
	        if (jis === void 0) {
	          results[results.length] = UTF8_UNKNOWN;
	        } else {
	          results[results.length] = 0x8F;
	          results[results.length] = (jis >> 8) - 0x80 & 0xFF;
	          results[results.length] = (jis & 0xFF) - 0x80 & 0xFF;
	        }
	      } else {
	        if (jis > 0x10000) {
	          jis -= 0x10000;
	        }
	        if (jis < 0xFF) {
	          results[results.length] = 0x8E;
	          results[results.length] = jis - 0x80 & 0xFF;
	        } else {
	          results[results.length] = (jis >> 8) - 0x80 & 0xFF;
	          results[results.length] = (jis & 0xFF) - 0x80 & 0xFF;
	        }
	      }
	    } else {
	      results[results.length] = data[i] & 0xFF;
	    }
	  }

	  return results;
	}

	/**
	 * UTF-8 to JIS
	 *
	 * @private
	 * @ignore
	 */
	function UTF8ToJIS(data) {
	  var results = [];
	  var index = 0;
	  var len = data && data.length;
	  var i = 0;
	  var b, utf8, jis;
	  var esc = [
	    0x1B, 0x28, 0x42,
	    0x1B, 0x24, 0x42,
	    0x1B, 0x28, 0x49,
	    0x1B, 0x24, 0x28, 0x44
	  ];

	  for (; i < len; i++) {
	    b = data[i];
	    if (b < 0x80) {
	      if (index !== 0) {
	        index = 0;
	        results[results.length] = esc[0];
	        results[results.length] = esc[1];
	        results[results.length] = esc[2];
	      }
	      results[results.length] = b & 0xFF;
	    } else {
	      if (b <= 0xDF) {
	        utf8 = (data[i] << 8) + data[++i];
	      } else {
	        utf8 = (data[i] << 16) + (data[++i] << 8) + data[++i];
	      }

	      jis = UTF8_TO_JIS_TABLE[utf8];
	      if (jis === void 0) {
	        jis = UTF8_TO_JISX0212_TABLE[utf8];
	        if (jis === void 0) {
	          if (index !== 0) {
	            index = 0;
	            results[results.length] = esc[0];
	            results[results.length] = esc[1];
	            results[results.length] = esc[2];
	          }
	          results[results.length] = UTF8_UNKNOWN;
	        } else {
	          // JIS X 0212:1990
	          if (index !== 3) {
	            index = 3;
	            results[results.length] = esc[9];
	            results[results.length] = esc[10];
	            results[results.length] = esc[11];
	            results[results.length] = esc[12];
	          }
	          results[results.length] = jis >> 8 & 0xFF;
	          results[results.length] = jis & 0xFF;
	        }
	      } else {
	        if (jis > 0x10000) {
	          jis -= 0x10000;
	        }
	        if (jis < 0xFF) {
	          // Halfwidth Katakana
	          if (index !== 2) {
	            index = 2;
	            results[results.length] = esc[6];
	            results[results.length] = esc[7];
	            results[results.length] = esc[8];
	          }
	          results[results.length] = jis & 0xFF;
	        } else {
	          if (index !== 1) {
	            index = 1;
	            results[results.length] = esc[3];
	            results[results.length] = esc[4];
	            results[results.length] = esc[5];
	          }
	          results[results.length] = jis >> 8 & 0xFF;
	          results[results.length] = jis & 0xFF;
	        }
	      }
	    }
	  }

	  if (index !== 0) {
	    results[results.length] = esc[0];
	    results[results.length] = esc[1];
	    results[results.length] = esc[2];
	  }

	  return results;
	}

	/**
	 * UTF-16 (JavaScript Unicode array) to UTF-8
	 *
	 * @private
	 * @ignore
	 */
	function UNICODEToUTF8(data) {
	  var results = [];
	  var i = 0;
	  var len = data && data.length;
	  var c, second;

	  for (; i < len; i++) {
	    c = data[i];

	    // high surrogate
	    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < len) {
	      second = data[i + 1];
	      // low surrogate
	      if (second >= 0xDC00 && second <= 0xDFFF) {
	        c = (c - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	        i++;
	      }
	    }

	    if (c < 0x80) {
	      results[results.length] = c;
	    } else if (c < 0x800) {
	      results[results.length] = 0xC0 | ((c >> 6) & 0x1F);
	      results[results.length] = 0x80 | (c & 0x3F);
	    } else if (c < 0x10000) {
	      results[results.length] = 0xE0 | ((c >> 12) & 0xF);
	      results[results.length] = 0x80 | ((c >> 6) & 0x3F);
	      results[results.length] = 0x80 | (c & 0x3F);
	    } else if (c < 0x200000) {
	      results[results.length] = 0xF0 | ((c >> 18) & 0xF);
	      results[results.length] = 0x80 | ((c >> 12) & 0x3F);
	      results[results.length] = 0x80 | ((c >> 6) & 0x3F);
	      results[results.length] = 0x80 | (c & 0x3F);
	    }
	  }

	  return results;
	}

	/**
	 * UTF-8 to UTF-16 (JavaScript Unicode array)
	 *
	 * @private
	 * @ignore
	 */
	function UTF8ToUNICODE(data) {
	  var results = [];
	  var i = 0;
	  var len = data && data.length;
	  var n, c, c2, c3, c4, code;

	  while (i < len) {
	    c = data[i++];
	    n = c >> 4;
	    if (n >= 0 && n <= 7) {
	      // 0xxx xxxx
	      code = c;
	    } else if (n === 12 || n === 13) {
	      // 110x xxxx
	      // 10xx xxxx
	      c2 = data[i++];
	      code = ((c & 0x1F) << 6) | (c2 & 0x3F);
	    } else if (n === 14) {
	      // 1110 xxxx
	      // 10xx xxxx
	      // 10xx xxxx
	      c2 = data[i++];
	      c3 = data[i++];
	      code = ((c & 0x0F) << 12) |
	             ((c2 & 0x3F) << 6) |
	              (c3 & 0x3F);
	    } else if (n === 15) {
	      // 1111 0xxx
	      // 10xx xxxx
	      // 10xx xxxx
	      // 10xx xxxx
	      c2 = data[i++];
	      c3 = data[i++];
	      c4 = data[i++];
	      code = ((c & 0x7) << 18)   |
	             ((c2 & 0x3F) << 12) |
	             ((c3 & 0x3F) << 6)  |
	              (c4 & 0x3F);
	    }

	    if (code <= 0xFFFF) {
	      results[results.length] = code;
	    } else {
	      // Split in surrogate halves
	      code -= 0x10000;
	      results[results.length] = (code >> 10) + 0xD800; // High surrogate
	      results[results.length] = (code % 0x400) + 0xDC00; // Low surrogate
	    }
	  }

	  return results;
	}

	/**
	 * UTF-16 (JavaScript Unicode array) to UTF-16
	 *
	 * UTF-16BE (big-endian)
	 * Note: this function does not prepend the BOM by default.
	 *
	 * RFC 2781 4.3 Interpreting text labelled as UTF-16
	 *   If the first two octets of the text is not 0xFE followed by
	 *   0xFF, and is not 0xFF followed by 0xFE, then the text SHOULD be
	 *   interpreted as being big-endian.
	 *
	 * @link https://www.ietf.org/rfc/rfc2781.txt
	 * UTF-16, an encoding of ISO 10646
	 *
	 * @private
	 * @ignore
	 */
	function UNICODEToUTF16(data, options) {
	  var results;

	  if (options && options.bom) {
	    var optBom = options.bom;
	    if (!isString(optBom)) {
	      optBom = 'BE';
	    }

	    var bom, utf16;
	    if (optBom.charAt(0).toUpperCase() === 'B') {
	      // Big-endian
	      bom = [0xFE, 0xFF];
	      utf16 = UNICODEToUTF16BE(data);
	    } else {
	      // Little-endian
	      bom = [0xFF, 0xFE];
	      utf16 = UNICODEToUTF16LE(data);
	    }

	    results = [];
	    results[0] = bom[0];
	    results[1] = bom[1];

	    for (var i = 0, len = utf16.length; i < len; i++) {
	      results[results.length] = utf16[i];
	    }
	  } else {
	    // Without BOM: Convert as BE (SHOULD).
	    results = UNICODEToUTF16BE(data);
	  }

	  return results;
	}

	/**
	 * UTF-16 (JavaScript Unicode array) to UTF-16BE
	 *
	 * @link https://www.ietf.org/rfc/rfc2781.txt
	 * UTF-16, an encoding of ISO 10646
	 *
	 * @private
	 * @ignore
	 */
	function UNICODEToUTF16BE(data) {
	  var results = [];
	  var i = 0;
	  var len = data && data.length;
	  var c;

	  while (i < len) {
	    c = data[i++];
	    if (c <= 0xFF) {
	      results[results.length] = 0;
	      results[results.length] = c;
	    } else if (c <= 0xFFFF) {
	      results[results.length] = c >> 8 & 0xFF;
	      results[results.length] = c & 0xFF;
	    }
	  }

	  return results;
	}

	/**
	 * UTF-16 (JavaScript Unicode array) to UTF-16LE
	 *
	 * @link https://www.ietf.org/rfc/rfc2781.txt
	 * UTF-16, an encoding of ISO 10646
	 *
	 * @private
	 * @ignore
	 */
	function UNICODEToUTF16LE(data) {
	  var results = [];
	  var i = 0;
	  var len = data && data.length;
	  var c;

	  while (i < len) {
	    c = data[i++];
	    if (c <= 0xFF) {
	      results[results.length] = c;
	      results[results.length] = 0;
	    } else if (c <= 0xFFFF) {
	      results[results.length] = c & 0xFF;
	      results[results.length] = c >> 8 & 0xFF;
	    }
	  }

	  return results;
	}

	/**
	 * UTF-16BE to UTF-16 (JavaScript Unicode array)
	 *
	 * @link https://www.ietf.org/rfc/rfc2781.txt
	 * UTF-16, an encoding of ISO 10646
	 *
	 * @private
	 * @ignore
	 */
	function UTF16BEToUNICODE(data) {
	  var results = [];
	  var i = 0;
	  var len = data && data.length;
	  var c1, c2;

	  if (len >= 2 &&
	      ((data[0] === 0xFE && data[1] === 0xFF) ||
	       (data[0] === 0xFF && data[1] === 0xFE))
	  ) {
	    i = 2;
	  }

	  while (i < len) {
	    c1 = data[i++];
	    c2 = data[i++];
	    if (c1 === 0) {
	      results[results.length] = c2;
	    } else {
	      results[results.length] = ((c1 & 0xFF) << 8) | (c2 & 0xFF);
	    }
	  }

	  return results;
	}

	/**
	 * UTF-16LE to UTF-16 (JavaScript Unicode array)
	 *
	 * @link https://www.ietf.org/rfc/rfc2781.txt
	 * UTF-16, an encoding of ISO 10646
	 *
	 * @private
	 * @ignore
	 */
	function UTF16LEToUNICODE(data) {
	  var results = [];
	  var i = 0;
	  var len = data && data.length;
	  var c1, c2;

	  if (len >= 2 &&
	      ((data[0] === 0xFE && data[1] === 0xFF) ||
	       (data[0] === 0xFF && data[1] === 0xFE))
	  ) {
	    i = 2;
	  }

	  while (i < len) {
	    c1 = data[i++];
	    c2 = data[i++];
	    if (c2 === 0) {
	      results[results.length] = c1;
	    } else {
	      results[results.length] = ((c2 & 0xFF) << 8) | (c1 & 0xFF);
	    }
	  }

	  return results;
	}

	/**
	 * UTF-16 to UTF-16 (JavaScript Unicode array)
	 *
	 * @link https://www.ietf.org/rfc/rfc2781.txt
	 * UTF-16, an encoding of ISO 10646
	 *
	 * @private
	 * @ignore
	 */
	function UTF16ToUNICODE(data) {
	  var results = [];
	  var i = 0;
	  var len = data && data.length;
	  var isLE = false;
	  var first = true;
	  var c1, c2;

	  while (i < len) {
	    c1 = data[i++];
	    c2 = data[i++];

	    if (first && i === 2) {
	      first = false;
	      if (c1 === 0xFE && c2 === 0xFF) {
	        isLE = false;
	      } else if (c1 === 0xFF && c2 === 0xFE) {
	        // Little-endian
	        isLE = true;
	      } else {
	        isLE = isUTF16LE(data);
	        i = 0;
	      }
	      continue;
	    }

	    if (isLE) {
	      if (c2 === 0) {
	        results[results.length] = c1;
	      } else {
	        results[results.length] = ((c2 & 0xFF) << 8) | (c1 & 0xFF);
	      }
	    } else {
	      if (c1 === 0) {
	        results[results.length] = c2;
	      } else {
	        results[results.length] = ((c1 & 0xFF) << 8) | (c2 & 0xFF);
	      }
	    }
	  }

	  return results;
	}

	/**
	 * UTF-16 to UTF-16BE
	 *
	 * @private
	 * @ignore
	 */
	function UTF16ToUTF16BE(data) {
	  var results = [];
	  var i = 0;
	  var len = data && data.length;
	  var isLE = false;
	  var first = true;
	  var c1, c2;

	  while (i < len) {
	    c1 = data[i++];
	    c2 = data[i++];

	    if (first && i === 2) {
	      first = false;
	      if (c1 === 0xFE && c2 === 0xFF) {
	        isLE = false;
	      } else if (c1 === 0xFF && c2 === 0xFE) {
	        // Little-endian
	        isLE = true;
	      } else {
	        isLE = isUTF16LE(data);
	        i = 0;
	      }
	      continue;
	    }

	    if (isLE) {
	      results[results.length] = c2;
	      results[results.length] = c1;
	    } else {
	      results[results.length] = c1;
	      results[results.length] = c2;
	    }
	  }

	  return results;
	}

	/**
	 * UTF-16BE to UTF-16
	 *
	 * @private
	 * @ignore
	 */
	function UTF16BEToUTF16(data, options) {
	  var isLE = false;
	  var bom;

	  if (options && options.bom) {
	    var optBom = options.bom;
	    if (!isString(optBom)) {
	      optBom = 'BE';
	    }

	    if (optBom.charAt(0).toUpperCase() === 'B') {
	      // Big-endian
	      bom = [0xFE, 0xFF];
	    } else {
	      // Little-endian
	      bom = [0xFF, 0xFE];
	      isLE = true;
	    }
	  }

	  var results = [];
	  var len = data && data.length;
	  var i = 0;

	  if (len >= 2 &&
	      ((data[0] === 0xFE && data[1] === 0xFF) ||
	       (data[0] === 0xFF && data[1] === 0xFE))
	  ) {
	    i = 2;
	  }

	  if (bom) {
	    results[0] = bom[0];
	    results[1] = bom[1];
	  }

	  var c1, c2;
	  while (i < len) {
	    c1 = data[i++];
	    c2 = data[i++];

	    if (isLE) {
	      results[results.length] = c2;
	      results[results.length] = c1;
	    } else {
	      results[results.length] = c1;
	      results[results.length] = c2;
	    }
	  }

	  return results;
	}

	/**
	 * UTF-16 to UTF-16LE
	 *
	 * @private
	 * @ignore
	 */
	function UTF16ToUTF16LE(data) {
	  var results = [];
	  var i = 0;
	  var len = data && data.length;
	  var isLE = false;
	  var first = true;
	  var c1, c2;

	  while (i < len) {
	    c1 = data[i++];
	    c2 = data[i++];

	    if (first && i === 2) {
	      first = false;
	      if (c1 === 0xFE && c2 === 0xFF) {
	        isLE = false;
	      } else if (c1 === 0xFF && c2 === 0xFE) {
	        // Little-endian
	        isLE = true;
	      } else {
	        isLE = isUTF16LE(data);
	        i = 0;
	      }
	      continue;
	    }

	    if (isLE) {
	      results[results.length] = c1;
	      results[results.length] = c2;
	    } else {
	      results[results.length] = c2;
	      results[results.length] = c1;
	    }
	  }

	  return results;
	}

	/**
	 * UTF-16LE to UTF-16
	 *
	 * @private
	 * @ignore
	 */
	function UTF16LEToUTF16(data, options) {
	  var isLE = false;
	  var bom;

	  if (options && options.bom) {
	    var optBom = options.bom;
	    if (!isString(optBom)) {
	      optBom = 'BE';
	    }

	    if (optBom.charAt(0).toUpperCase() === 'B') {
	      // Big-endian
	      bom = [0xFE, 0xFF];
	    } else {
	      // Little-endian
	      bom = [0xFF, 0xFE];
	      isLE = true;
	    }
	  }

	  var results = [];
	  var len = data && data.length;
	  var i = 0;

	  if (len >= 2 &&
	      ((data[0] === 0xFE && data[1] === 0xFF) ||
	       (data[0] === 0xFF && data[1] === 0xFE))
	  ) {
	    i = 2;
	  }

	  if (bom) {
	    results[0] = bom[0];
	    results[1] = bom[1];
	  }

	  var c1, c2;
	  while (i < len) {
	    c1 = data[i++];
	    c2 = data[i++];

	    if (isLE) {
	      results[results.length] = c1;
	      results[results.length] = c2;
	    } else {
	      results[results.length] = c2;
	      results[results.length] = c1;
	    }
	  }

	  return results;
	}

	/**
	 * UTF-16BE to UTF-16LE
	 *
	 * @private
	 * @ignore
	 */
	function UTF16BEToUTF16LE(data) {
	  var results = [];
	  var i = 0;
	  var len = data && data.length;
	  var c1, c2;

	  if (len >= 2 &&
	      ((data[0] === 0xFE && data[1] === 0xFF) ||
	       (data[0] === 0xFF && data[1] === 0xFE))
	  ) {
	    i = 2;
	  }

	  while (i < len) {
	    c1 = data[i++];
	    c2 = data[i++];
	    results[results.length] = c2;
	    results[results.length] = c1;
	  }

	  return results;
	}

	/**
	 * UTF-16LE to UTF-16BE
	 *
	 * @private
	 * @ignore
	 */
	function UTF16LEToUTF16BE(data) {
	  return UTF16BEToUTF16LE(data);
	}


	/**
	 * UTF-16 (JavaScript Unicode array) to JIS
	 *
	 * @private
	 * @ignore
	 */
	function UNICODEToJIS(data) {
	  return UTF8ToJIS(UNICODEToUTF8(data));
	}

	/**
	 * JIS to UTF-16 (JavaScript Unicode array)
	 *
	 * @private
	 * @ignore
	 */
	function JISToUNICODE(data) {
	  return UTF8ToUNICODE(JISToUTF8(data));
	}

	/**
	 * UTF-16 (JavaScript Unicode array) to EUCJP
	 *
	 * @private
	 * @ignore
	 */
	function UNICODEToEUCJP(data) {
	  return UTF8ToEUCJP(UNICODEToUTF8(data));
	}

	/**
	 * EUCJP to UTF-16 (JavaScript Unicode array)
	 *
	 * @private
	 * @ignore
	 */
	function EUCJPToUNICODE(data) {
	  return UTF8ToUNICODE(EUCJPToUTF8(data));
	}

	/**
	 * UTF-16 (JavaScript Unicode array) to SJIS
	 *
	 * @private
	 * @ignore
	 */
	function UNICODEToSJIS(data) {
	  return UTF8ToSJIS(UNICODEToUTF8(data));
	}

	/**
	 * SJIS to UTF-16 (JavaScript Unicode array)
	 *
	 * @private
	 * @ignore
	 */
	function SJISToUNICODE(data) {
	  return UTF8ToUNICODE(SJISToUTF8(data));
	}

	/**
	 * UTF-8 to UTF-16
	 *
	 * @private
	 * @ignore
	 */
	function UTF8ToUTF16(data, options) {
	  return UNICODEToUTF16(UTF8ToUNICODE(data), options);
	}

	/**
	 * UTF-16 to UTF-8
	 *
	 * @private
	 * @ignore
	 */
	function UTF16ToUTF8(data) {
	  return UNICODEToUTF8(UTF16ToUNICODE(data));
	}

	/**
	 * UTF-8 to UTF-16BE
	 *
	 * @private
	 * @ignore
	 */
	function UTF8ToUTF16BE(data) {
	  return UNICODEToUTF16BE(UTF8ToUNICODE(data));
	}

	/**
	 * UTF-16BE to UTF-8
	 *
	 * @private
	 * @ignore
	 */
	function UTF16BEToUTF8(data) {
	  return UNICODEToUTF8(UTF16BEToUNICODE(data));
	}

	/**
	 * UTF-8 to UTF-16LE
	 *
	 * @private
	 * @ignore
	 */
	function UTF8ToUTF16LE(data) {
	  return UNICODEToUTF16LE(UTF8ToUNICODE(data));
	}

	/**
	 * UTF-16LE to UTF-8
	 *
	 * @private
	 * @ignore
	 */
	function UTF16LEToUTF8(data) {
	  return UNICODEToUTF8(UTF16LEToUNICODE(data));
	}

	/**
	 * JIS to UTF-16
	 *
	 * @private
	 * @ignore
	 */
	function JISToUTF16(data, options) {
	  return UTF8ToUTF16(JISToUTF8(data), options);
	}

	/**
	 * UTF-16 to JIS
	 *
	 * @private
	 * @ignore
	 */
	function UTF16ToJIS(data) {
	  return UTF8ToJIS(UTF16ToUTF8(data));
	}

	/**
	 * JIS to UTF-16BE
	 *
	 * @private
	 * @ignore
	 */
	function JISToUTF16BE(data) {
	  return UTF8ToUTF16BE(JISToUTF8(data));
	}

	/**
	 * UTF-16BE to JIS
	 *
	 * @private
	 * @ignore
	 */
	function UTF16BEToJIS(data) {
	  return UTF8ToJIS(UTF16BEToUTF8(data));
	}

	/**
	 * JIS to UTF-16LE
	 *
	 * @private
	 * @ignore
	 */
	function JISToUTF16LE(data) {
	  return UTF8ToUTF16LE(JISToUTF8(data));
	}

	/**
	 * UTF-16LE to JIS
	 *
	 * @private
	 * @ignore
	 */
	function UTF16LEToJIS(data) {
	  return UTF8ToJIS(UTF16LEToUTF8(data));
	}

	/**
	 * EUC-JP to UTF-16
	 *
	 * @private
	 * @ignore
	 */
	function EUCJPToUTF16(data, options) {
	  return UTF8ToUTF16(EUCJPToUTF8(data), options);
	}

	/**
	 * UTF-16 to EUC-JP
	 *
	 * @private
	 * @ignore
	 */
	function UTF16ToEUCJP(data) {
	  return UTF8ToEUCJP(UTF16ToUTF8(data));
	}

	/**
	 * EUC-JP to UTF-16BE
	 *
	 * @private
	 * @ignore
	 */
	function EUCJPToUTF16BE(data) {
	  return UTF8ToUTF16BE(EUCJPToUTF8(data));
	}

	/**
	 * UTF-16BE to EUC-JP
	 *
	 * @private
	 * @ignore
	 */
	function UTF16BEToEUCJP(data) {
	  return UTF8ToEUCJP(UTF16BEToUTF8(data));
	}

	/**
	 * EUC-JP to UTF-16LE
	 *
	 * @private
	 * @ignore
	 */
	function EUCJPToUTF16LE(data) {
	  return UTF8ToUTF16LE(EUCJPToUTF8(data));
	}

	/**
	 * UTF-16LE to EUC-JP
	 *
	 * @private
	 * @ignore
	 */
	function UTF16LEToEUCJP(data) {
	  return UTF8ToEUCJP(UTF16LEToUTF8(data));
	}

	/**
	 * SJIS to UTF-16
	 *
	 * @private
	 * @ignore
	 */
	function SJISToUTF16(data, options) {
	  return UTF8ToUTF16(SJISToUTF8(data), options);
	}

	/**
	 * UTF-16 to SJIS
	 *
	 * @private
	 * @ignore
	 */
	function UTF16ToSJIS(data) {
	  return UTF8ToSJIS(UTF16ToUTF8(data));
	}

	/**
	 * SJIS to UTF-16BE
	 *
	 * @private
	 * @ignore
	 */
	function SJISToUTF16BE(data) {
	  return UTF8ToUTF16BE(SJISToUTF8(data));
	}

	/**
	 * UTF-16BE to SJIS
	 *
	 * @private
	 * @ignore
	 */
	function UTF16BEToSJIS(data) {
	  return UTF8ToSJIS(UTF16BEToUTF8(data));
	}

	/**
	 * SJIS to UTF-16LE
	 *
	 * @private
	 * @ignore
	 */
	function SJISToUTF16LE(data) {
	  return UTF8ToUTF16LE(SJISToUTF8(data));
	}

	/**
	 * UTF-16LE to SJIS
	 *
	 * @private
	 * @ignore
	 */
	function UTF16LEToSJIS(data) {
	  return UTF8ToSJIS(UTF16LEToUTF8(data));
	}


	/**
	 * Assign the internal encoding name from the argument encoding name.
	 *
	 * @private
	 * @ignore
	 */
	function assignEncodingName(target) {
	  var name = '';
	  var expect = ('' + target).toUpperCase().replace(/[^A-Z0-9]+/g, '');
	  var aliasNames = getKeys(EncodingAliases);
	  var len = aliasNames.length;
	  var hit = 0;
	  var encoding, encodingLen, j;

	  for (var i = 0; i < len; i++) {
	    encoding = aliasNames[i];
	    if (encoding === expect) {
	      name = encoding;
	      break;
	    }

	    encodingLen = encoding.length;
	    for (j = hit; j < encodingLen; j++) {
	      if (encoding.slice(0, j) === expect.slice(0, j) ||
	          encoding.slice(-j) === expect.slice(-j)) {
	        name = encoding;
	        hit = j;
	      }
	    }
	  }

	  if (hasOwnProperty.call(EncodingAliases, name)) {
	    return EncodingAliases[name];
	  }

	  return name;
	}


	// Helpers

	function isObject(x) {
	  var type = typeof x;
	  return type === 'function' || type === 'object' && !!x;
	}

	function isArray(x) {
	  return Array.isArray ? Array.isArray(x) :
	    toString.call(x) === '[object Array]';
	}

	function isString(x) {
	  return typeof x === 'string' || toString.call(x) === '[object String]';
	}


	function getKeys(object) {
	  if (Object.keys) {
	    return Object.keys(object);
	  }

	  var keys = [];
	  for (var key in object) {
	    if (hasOwnProperty.call(object, key)) {
	      keys[keys.length] = key;
	    }
	  }

	  return keys;
	}


	function createBuffer(bits, size) {
	  if (!HAS_TYPED) {
	    return new Array(size);
	  }

	  switch (bits) {
	    case 8: return new Uint8Array(size);
	    case 16: return new Uint16Array(size);
	  }
	}


	function stringToBuffer(string) {
	  var length = string.length;
	  var buffer = createBuffer(16, length);

	  for (var i = 0; i < length; i++) {
	    buffer[i] = string.charCodeAt(i);
	  }

	  return buffer;
	}


	function codeToString_fast(code) {
	  if (CAN_CHARCODE_APPLY && CAN_CHARCODE_APPLY_TYPED) {
	    var len = code && code.length;
	    if (len < APPLY_BUFFER_SIZE) {
	      if (APPLY_BUFFER_SIZE_OK) {
	        return fromCharCode.apply(null, code);
	      }

	      if (APPLY_BUFFER_SIZE_OK === null) {
	        try {
	          var s = fromCharCode.apply(null, code);
	          if (len > APPLY_BUFFER_SIZE) {
	            APPLY_BUFFER_SIZE_OK = true;
	          }
	          return s;
	        } catch (e) {
	          // Ignore RangeError: arguments too large
	          APPLY_BUFFER_SIZE_OK = false;
	        }
	      }
	    }
	  }

	  return codeToString_chunked(code);
	}


	function codeToString_chunked(code) {
	  var string = '';
	  var length = code && code.length;
	  var i = 0;
	  var sub;

	  while (i < length) {
	    if (code.subarray) {
	      sub = code.subarray(i, i + APPLY_BUFFER_SIZE);
	    } else {
	      sub = code.slice(i, i + APPLY_BUFFER_SIZE);
	    }
	    i += APPLY_BUFFER_SIZE;

	    if (APPLY_BUFFER_SIZE_OK) {
	      string += fromCharCode.apply(null, sub);
	      continue;
	    }

	    if (APPLY_BUFFER_SIZE_OK === null) {
	      try {
	        string += fromCharCode.apply(null, sub);
	        if (sub.length > APPLY_BUFFER_SIZE) {
	          APPLY_BUFFER_SIZE_OK = true;
	        }
	        continue;
	      } catch (e) {
	        APPLY_BUFFER_SIZE_OK = false;
	      }
	    }

	    return codeToString_slow(code);
	  }

	  return string;
	}


	function codeToString_slow(code) {
	  var string = '';
	  var length = code && code.length;

	  for (var i = 0; i < length; i++) {
	    string += fromCharCode(code[i]);
	  }

	  return string;
	}


	function stringToCode(string) {
	  var code = [];
	  var len = string && string.length;

	  for (var i = 0; i < len; i++) {
	    code[i] = string.charCodeAt(i);
	  }

	  return code;
	}


	function codeToBuffer(code) {
	  if (HAS_TYPED) {
	    // Use Uint16Array for Unicode codepoint.
	    return new Uint16Array(code);
	  } else {
	    if (isArray(code)) {
	      return code;
	    }
	  }

	  var length = code && code.length;
	  var buffer = [];

	  for (var i = 0; i < length; i++) {
	    buffer[i] = code[i];
	  }

	  return buffer;
	}


	function bufferToCode(buffer) {
	  if (isArray(buffer)) {
	    return buffer;
	  }

	  return slice.call(buffer);
	}

	// Base64
	/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
	 * Version: 1.0
	 * LastModified: Dec 25 1999
	 * This library is free.  You can redistribute it and/or modify it.
	 */
	// -- Masanao Izumo Copyright 1999 "free"
	// Modified to add support for Binary Array for Encoding.js

	var base64EncodeChars = [
	  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,
	  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,
	  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
	 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,
	  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  43,  47
	];

	var base64DecodeChars = [
	  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
	  52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
	  -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
	  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
	  -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
	  41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1
	];

	var base64EncodePadding = '='.charCodeAt(0);


	function base64encode(data) {
	  var out, i, len;
	  var c1, c2, c3;

	  len = data && data.length;
	  i = 0;
	  out = [];

	  while (i < len) {
	    c1 = data[i++];
	    if (i == len) {
	      out[out.length] = base64EncodeChars[c1 >> 2];
	      out[out.length] = base64EncodeChars[(c1 & 0x3) << 4];
	      out[out.length] = base64EncodePadding;
	      out[out.length] = base64EncodePadding;
	      break;
	    }

	    c2 = data[i++];
	    if (i == len) {
	      out[out.length] = base64EncodeChars[c1 >> 2];
	      out[out.length] = base64EncodeChars[((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4)];
	      out[out.length] = base64EncodeChars[(c2 & 0xF) << 2];
	      out[out.length] = base64EncodePadding;
	      break;
	    }

	    c3 = data[i++];
	    out[out.length] = base64EncodeChars[c1 >> 2];
	    out[out.length] = base64EncodeChars[((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4)];
	    out[out.length] = base64EncodeChars[((c2 & 0xF) << 2) | ((c3 & 0xC0) >> 6)];
	    out[out.length] = base64EncodeChars[c3 & 0x3F];
	  }

	  return codeToString_fast(out);
	}


	function base64decode(str) {
	  var c1, c2, c3, c4;
	  var i, len, out;

	  len = str && str.length;
	  i = 0;
	  out = [];

	  while (i < len) {
	    /* c1 */
	    do {
	      c1 = base64DecodeChars[str.charCodeAt(i++) & 0xFF];
	    } while (i < len && c1 == -1);

	    if (c1 == -1) {
	      break;
	    }

	    /* c2 */
	    do {
	      c2 = base64DecodeChars[str.charCodeAt(i++) & 0xFF];
	    } while (i < len && c2 == -1);

	    if (c2 == -1) {
	      break;
	    }

	    out[out.length] = (c1 << 2) | ((c2 & 0x30) >> 4);

	    /* c3 */
	    do {
	      c3 = str.charCodeAt(i++) & 0xFF;
	      if (c3 == 61) {
	        return out;
	      }
	      c3 = base64DecodeChars[c3];
	    } while (i < len && c3 == -1);

	    if (c3 == -1) {
	      break;
	    }

	    out[out.length] = ((c2 & 0xF) << 4) | ((c3 & 0x3C) >> 2);

	    /* c4 */
	    do {
	      c4 = str.charCodeAt(i++) & 0xFF;
	      if (c4 == 61) {
	        return out;
	      }
	      c4 = base64DecodeChars[c4];
	    } while (i < len && c4 == -1);

	    if (c4 == -1) {
	      break;
	    }

	    out[out.length] = ((c3 & 0x03) << 6) | c4;
	  }

	  return out;
	}


	/**
	 * Encoding conversion table for UTF-8 to JIS.
	 *
	 * @ignore
	 */
	var UTF8_TO_JIS_TABLE = {
	0xEFBDA1:0x21,0xEFBDA2:0x22,0xEFBDA3:0x23,0xEFBDA4:0x24,0xEFBDA5:0x25,
	0xEFBDA6:0x26,0xEFBDA7:0x27,0xEFBDA8:0x28,0xEFBDA9:0x29,0xEFBDAA:0x2A,
	0xEFBDAB:0x2B,0xEFBDAC:0x2C,0xEFBDAD:0x2D,0xEFBDAE:0x2E,0xEFBDAF:0x2F,
	0xEFBDB0:0x30,0xEFBDB1:0x31,0xEFBDB2:0x32,0xEFBDB3:0x33,0xEFBDB4:0x34,
	0xEFBDB5:0x35,0xEFBDB6:0x36,0xEFBDB7:0x37,0xEFBDB8:0x38,0xEFBDB9:0x39,
	0xEFBDBA:0x3A,0xEFBDBB:0x3B,0xEFBDBC:0x3C,0xEFBDBD:0x3D,0xEFBDBE:0x3E,
	0xEFBDBF:0x3F,0xEFBE80:0x40,0xEFBE81:0x41,0xEFBE82:0x42,0xEFBE83:0x43,
	0xEFBE84:0x44,0xEFBE85:0x45,0xEFBE86:0x46,0xEFBE87:0x47,0xEFBE88:0x48,
	0xEFBE89:0x49,0xEFBE8A:0x4A,0xEFBE8B:0x4B,0xEFBE8C:0x4C,0xEFBE8D:0x4D,
	0xEFBE8E:0x4E,0xEFBE8F:0x4F,0xEFBE90:0x50,0xEFBE91:0x51,0xEFBE92:0x52,
	0xEFBE93:0x53,0xEFBE94:0x54,0xEFBE95:0x55,0xEFBE96:0x56,0xEFBE97:0x57,
	0xEFBE98:0x58,0xEFBE99:0x59,0xEFBE9A:0x5A,0xEFBE9B:0x5B,0xEFBE9C:0x5C,
	0xEFBE9D:0x5D,0xEFBE9E:0x5E,0xEFBE9F:0x5F,

	0xE291A0:0x2D21,0xE291A1:0x2D22,0xE291A2:0x2D23,0xE291A3:0x2D24,0xE291A4:0x2D25,
	0xE291A5:0x2D26,0xE291A6:0x2D27,0xE291A7:0x2D28,0xE291A8:0x2D29,0xE291A9:0x2D2A,
	0xE291AA:0x2D2B,0xE291AB:0x2D2C,0xE291AC:0x2D2D,0xE291AD:0x2D2E,0xE291AE:0x2D2F,
	0xE291AF:0x2D30,0xE291B0:0x2D31,0xE291B1:0x2D32,0xE291B2:0x2D33,0xE291B3:0x2D34,
	0xE285A0:0x2D35,0xE285A1:0x2D36,0xE285A2:0x2D37,0xE285A3:0x2D38,0xE285A4:0x2D39,
	0xE285A5:0x2D3A,0xE285A6:0x2D3B,0xE285A7:0x2D3C,0xE285A8:0x2D3D,0xE285A9:0x2D3E,
	0xE38D89:0x2D40,0xE38C94:0x2D41,0xE38CA2:0x2D42,0xE38D8D:0x2D43,0xE38C98:0x2D44,
	0xE38CA7:0x2D45,0xE38C83:0x2D46,0xE38CB6:0x2D47,0xE38D91:0x2D48,0xE38D97:0x2D49,
	0xE38C8D:0x2D4A,0xE38CA6:0x2D4B,0xE38CA3:0x2D4C,0xE38CAB:0x2D4D,0xE38D8A:0x2D4E,
	0xE38CBB:0x2D4F,0xE38E9C:0x2D50,0xE38E9D:0x2D51,0xE38E9E:0x2D52,0xE38E8E:0x2D53,
	0xE38E8F:0x2D54,0xE38F84:0x2D55,0xE38EA1:0x2D56,0xE38DBB:0x2D5F,0xE3809D:0x2D60,
	0xE3809F:0x2D61,0xE28496:0x2D62,0xE38F8D:0x2D63,0xE284A1:0x2D64,0xE38AA4:0x2D65,
	0xE38AA5:0x2D66,0xE38AA6:0x2D67,0xE38AA7:0x2D68,0xE38AA8:0x2D69,0xE388B1:0x2D6A,
	0xE388B2:0x2D6B,0xE388B9:0x2D6C,0xE38DBE:0x2D6D,0xE38DBD:0x2D6E,0xE38DBC:0x2D6F,
	0xE288AE:0x2D73,0xE28891:0x2D74,0xE2889F:0x2D78,0xE28ABF:0x2D79,

	0xE38080:0x2121,0xE38081:0x2122,0xE38082:0x2123,0xEFBC8C:0x2124,0xEFBC8E:0x2125,
	0xE383BB:0x2126,0xEFBC9A:0x2127,0xEFBC9B:0x2128,0xEFBC9F:0x2129,0xEFBC81:0x212A,
	0xE3829B:0x212B,0xE3829C:0x212C,0xC2B4:0x212D,0xEFBD80:0x212E,0xC2A8:0x212F,
	0xEFBCBE:0x2130,0xEFBFA3:0x2131,0xEFBCBF:0x2132,0xE383BD:0x2133,0xE383BE:0x2134,
	0xE3829D:0x2135,0xE3829E:0x2136,0xE38083:0x2137,0xE4BB9D:0x2138,0xE38085:0x2139,
	0xE38086:0x213A,0xE38087:0x213B,0xE383BC:0x213C,0xE28095:0x213D,0xE28090:0x213E,
	0xEFBC8F:0x213F,0xEFBCBC:0x2140,0xEFBD9E:0x2141,0xE28096:0x2142,0xEFBD9C:0x2143,
	0xE280A6:0x2144,0xE280A5:0x2145,0xE28098:0x2146,0xE28099:0x2147,0xE2809C:0x2148,
	0xE2809D:0x2149,0xEFBC88:0x214A,0xEFBC89:0x214B,0xE38094:0x214C,0xE38095:0x214D,
	0xEFBCBB:0x214E,0xEFBCBD:0x214F,0xEFBD9B:0x2150,0xEFBD9D:0x2151,0xE38088:0x2152,
	0xE38089:0x2153,0xE3808A:0x2154,0xE3808B:0x2155,0xE3808C:0x2156,0xE3808D:0x2157,
	0xE3808E:0x2158,0xE3808F:0x2159,0xE38090:0x215A,0xE38091:0x215B,0xEFBC8B:0x215C,
	0xEFBC8D:0x215D,0xC2B1:0x215E,0xC397:0x215F,0xC3B7:0x2160,0xEFBC9D:0x2161,
	0xE289A0:0x2162,0xEFBC9C:0x2163,0xEFBC9E:0x2164,0xE289A6:0x2165,0xE289A7:0x2166,
	0xE2889E:0x2167,0xE288B4:0x2168,0xE29982:0x2169,0xE29980:0x216A,0xC2B0:0x216B,
	0xE280B2:0x216C,0xE280B3:0x216D,0xE28483:0x216E,0xEFBFA5:0x216F,0xEFBC84:0x2170,
	0xEFBFA0:0x2171,0xEFBFA1:0x2172,0xEFBC85:0x2173,0xEFBC83:0x2174,0xEFBC86:0x2175,
	0xEFBC8A:0x2176,0xEFBCA0:0x2177,0xC2A7:0x2178,0xE29886:0x2179,0xE29885:0x217A,
	0xE2978B:0x217B,0xE2978F:0x217C,0xE2978E:0x217D,0xE29787:0x217E,0xE29786:0x2221,
	0xE296A1:0x2222,0xE296A0:0x2223,0xE296B3:0x2224,0xE296B2:0x2225,0xE296BD:0x2226,
	0xE296BC:0x2227,0xE280BB:0x2228,0xE38092:0x2229,0xE28692:0x222A,0xE28690:0x222B,
	0xE28691:0x222C,0xE28693:0x222D,0xE38093:0x222E,0xE28888:0x223A,0xE2888B:0x223B,
	0xE28A86:0x223C,0xE28A87:0x223D,0xE28A82:0x223E,0xE28A83:0x223F,0xE288AA:0x2240,
	0xE288A9:0x2241,0xE288A7:0x224A,0xE288A8:0x224B,0xC2AC:0x224C,0xE28792:0x224D,
	0xE28794:0x224E,0xE28880:0x224F,0xE28883:0x2250,0xE288A0:0x225C,0xE28AA5:0x225D,
	0xE28C92:0x225E,0xE28882:0x225F,0xE28887:0x2260,0xE289A1:0x2261,0xE28992:0x2262,
	0xE289AA:0x2263,0xE289AB:0x2264,0xE2889A:0x2265,0xE288BD:0x2266,0xE2889D:0x2267,
	0xE288B5:0x2268,0xE288AB:0x2269,0xE288AC:0x226A,0xE284AB:0x2272,0xE280B0:0x2273,
	0xE299AF:0x2274,0xE299AD:0x2275,0xE299AA:0x2276,0xE280A0:0x2277,0xE280A1:0x2278,
	0xC2B6:0x2279,0xE297AF:0x227E,0xEFBC90:0x2330,0xEFBC91:0x2331,0xEFBC92:0x2332,
	0xEFBC93:0x2333,0xEFBC94:0x2334,0xEFBC95:0x2335,0xEFBC96:0x2336,0xEFBC97:0x2337,
	0xEFBC98:0x2338,0xEFBC99:0x2339,0xEFBCA1:0x2341,0xEFBCA2:0x2342,0xEFBCA3:0x2343,
	0xEFBCA4:0x2344,0xEFBCA5:0x2345,0xEFBCA6:0x2346,0xEFBCA7:0x2347,0xEFBCA8:0x2348,
	0xEFBCA9:0x2349,0xEFBCAA:0x234A,0xEFBCAB:0x234B,0xEFBCAC:0x234C,0xEFBCAD:0x234D,
	0xEFBCAE:0x234E,0xEFBCAF:0x234F,0xEFBCB0:0x2350,0xEFBCB1:0x2351,0xEFBCB2:0x2352,
	0xEFBCB3:0x2353,0xEFBCB4:0x2354,0xEFBCB5:0x2355,0xEFBCB6:0x2356,0xEFBCB7:0x2357,
	0xEFBCB8:0x2358,0xEFBCB9:0x2359,0xEFBCBA:0x235A,0xEFBD81:0x2361,0xEFBD82:0x2362,
	0xEFBD83:0x2363,0xEFBD84:0x2364,0xEFBD85:0x2365,0xEFBD86:0x2366,0xEFBD87:0x2367,
	0xEFBD88:0x2368,0xEFBD89:0x2369,0xEFBD8A:0x236A,0xEFBD8B:0x236B,0xEFBD8C:0x236C,
	0xEFBD8D:0x236D,0xEFBD8E:0x236E,0xEFBD8F:0x236F,0xEFBD90:0x2370,0xEFBD91:0x2371,
	0xEFBD92:0x2372,0xEFBD93:0x2373,0xEFBD94:0x2374,0xEFBD95:0x2375,0xEFBD96:0x2376,
	0xEFBD97:0x2377,0xEFBD98:0x2378,0xEFBD99:0x2379,0xEFBD9A:0x237A,0xE38181:0x2421,
	0xE38182:0x2422,0xE38183:0x2423,0xE38184:0x2424,0xE38185:0x2425,0xE38186:0x2426,
	0xE38187:0x2427,0xE38188:0x2428,0xE38189:0x2429,0xE3818A:0x242A,0xE3818B:0x242B,
	0xE3818C:0x242C,0xE3818D:0x242D,0xE3818E:0x242E,0xE3818F:0x242F,0xE38190:0x2430,
	0xE38191:0x2431,0xE38192:0x2432,0xE38193:0x2433,0xE38194:0x2434,0xE38195:0x2435,
	0xE38196:0x2436,0xE38197:0x2437,0xE38198:0x2438,0xE38199:0x2439,0xE3819A:0x243A,
	0xE3819B:0x243B,0xE3819C:0x243C,0xE3819D:0x243D,0xE3819E:0x243E,0xE3819F:0x243F,
	0xE381A0:0x2440,0xE381A1:0x2441,0xE381A2:0x2442,0xE381A3:0x2443,0xE381A4:0x2444,
	0xE381A5:0x2445,0xE381A6:0x2446,0xE381A7:0x2447,0xE381A8:0x2448,0xE381A9:0x2449,
	0xE381AA:0x244A,0xE381AB:0x244B,0xE381AC:0x244C,0xE381AD:0x244D,0xE381AE:0x244E,
	0xE381AF:0x244F,0xE381B0:0x2450,0xE381B1:0x2451,0xE381B2:0x2452,0xE381B3:0x2453,
	0xE381B4:0x2454,0xE381B5:0x2455,0xE381B6:0x2456,0xE381B7:0x2457,0xE381B8:0x2458,
	0xE381B9:0x2459,0xE381BA:0x245A,0xE381BB:0x245B,0xE381BC:0x245C,0xE381BD:0x245D,
	0xE381BE:0x245E,0xE381BF:0x245F,0xE38280:0x2460,0xE38281:0x2461,0xE38282:0x2462,
	0xE38283:0x2463,0xE38284:0x2464,0xE38285:0x2465,0xE38286:0x2466,0xE38287:0x2467,
	0xE38288:0x2468,0xE38289:0x2469,0xE3828A:0x246A,0xE3828B:0x246B,0xE3828C:0x246C,
	0xE3828D:0x246D,0xE3828E:0x246E,0xE3828F:0x246F,0xE38290:0x2470,0xE38291:0x2471,
	0xE38292:0x2472,0xE38293:0x2473,0xE382A1:0x2521,0xE382A2:0x2522,0xE382A3:0x2523,
	0xE382A4:0x2524,0xE382A5:0x2525,0xE382A6:0x2526,0xE382A7:0x2527,0xE382A8:0x2528,
	0xE382A9:0x2529,0xE382AA:0x252A,0xE382AB:0x252B,0xE382AC:0x252C,0xE382AD:0x252D,
	0xE382AE:0x252E,0xE382AF:0x252F,0xE382B0:0x2530,0xE382B1:0x2531,0xE382B2:0x2532,
	0xE382B3:0x2533,0xE382B4:0x2534,0xE382B5:0x2535,0xE382B6:0x2536,0xE382B7:0x2537,
	0xE382B8:0x2538,0xE382B9:0x2539,0xE382BA:0x253A,0xE382BB:0x253B,0xE382BC:0x253C,
	0xE382BD:0x253D,0xE382BE:0x253E,0xE382BF:0x253F,0xE38380:0x2540,0xE38381:0x2541,
	0xE38382:0x2542,0xE38383:0x2543,0xE38384:0x2544,0xE38385:0x2545,0xE38386:0x2546,
	0xE38387:0x2547,0xE38388:0x2548,0xE38389:0x2549,0xE3838A:0x254A,0xE3838B:0x254B,
	0xE3838C:0x254C,0xE3838D:0x254D,0xE3838E:0x254E,0xE3838F:0x254F,0xE38390:0x2550,
	0xE38391:0x2551,0xE38392:0x2552,0xE38393:0x2553,0xE38394:0x2554,0xE38395:0x2555,
	0xE38396:0x2556,0xE38397:0x2557,0xE38398:0x2558,0xE38399:0x2559,0xE3839A:0x255A,
	0xE3839B:0x255B,0xE3839C:0x255C,0xE3839D:0x255D,0xE3839E:0x255E,0xE3839F:0x255F,
	0xE383A0:0x2560,0xE383A1:0x2561,0xE383A2:0x2562,0xE383A3:0x2563,0xE383A4:0x2564,
	0xE383A5:0x2565,0xE383A6:0x2566,0xE383A7:0x2567,0xE383A8:0x2568,0xE383A9:0x2569,
	0xE383AA:0x256A,0xE383AB:0x256B,0xE383AC:0x256C,0xE383AD:0x256D,0xE383AE:0x256E,
	0xE383AF:0x256F,0xE383B0:0x2570,0xE383B1:0x2571,0xE383B2:0x2572,0xE383B3:0x2573,
	0xE383B4:0x2574,0xE383B5:0x2575,0xE383B6:0x2576,0xCE91:0x2621,0xCE92:0x2622,
	0xCE93:0x2623,0xCE94:0x2624,0xCE95:0x2625,0xCE96:0x2626,0xCE97:0x2627,
	0xCE98:0x2628,0xCE99:0x2629,0xCE9A:0x262A,0xCE9B:0x262B,0xCE9C:0x262C,
	0xCE9D:0x262D,0xCE9E:0x262E,0xCE9F:0x262F,0xCEA0:0x2630,0xCEA1:0x2631,
	0xCEA3:0x2632,0xCEA4:0x2633,0xCEA5:0x2634,0xCEA6:0x2635,0xCEA7:0x2636,
	0xCEA8:0x2637,0xCEA9:0x2638,0xCEB1:0x2641,0xCEB2:0x2642,0xCEB3:0x2643,
	0xCEB4:0x2644,0xCEB5:0x2645,0xCEB6:0x2646,0xCEB7:0x2647,0xCEB8:0x2648,
	0xCEB9:0x2649,0xCEBA:0x264A,0xCEBB:0x264B,0xCEBC:0x264C,0xCEBD:0x264D,
	0xCEBE:0x264E,0xCEBF:0x264F,0xCF80:0x2650,0xCF81:0x2651,0xCF83:0x2652,
	0xCF84:0x2653,0xCF85:0x2654,0xCF86:0x2655,0xCF87:0x2656,0xCF88:0x2657,
	0xCF89:0x2658,0xD090:0x2721,0xD091:0x2722,0xD092:0x2723,0xD093:0x2724,
	0xD094:0x2725,0xD095:0x2726,0xD081:0x2727,0xD096:0x2728,0xD097:0x2729,
	0xD098:0x272A,0xD099:0x272B,0xD09A:0x272C,0xD09B:0x272D,0xD09C:0x272E,
	0xD09D:0x272F,0xD09E:0x2730,0xD09F:0x2731,0xD0A0:0x2732,0xD0A1:0x2733,
	0xD0A2:0x2734,0xD0A3:0x2735,0xD0A4:0x2736,0xD0A5:0x2737,0xD0A6:0x2738,
	0xD0A7:0x2739,0xD0A8:0x273A,0xD0A9:0x273B,0xD0AA:0x273C,0xD0AB:0x273D,
	0xD0AC:0x273E,0xD0AD:0x273F,0xD0AE:0x2740,0xD0AF:0x2741,0xD0B0:0x2751,
	0xD0B1:0x2752,0xD0B2:0x2753,0xD0B3:0x2754,0xD0B4:0x2755,0xD0B5:0x2756,
	0xD191:0x2757,0xD0B6:0x2758,0xD0B7:0x2759,0xD0B8:0x275A,0xD0B9:0x275B,
	0xD0BA:0x275C,0xD0BB:0x275D,0xD0BC:0x275E,0xD0BD:0x275F,0xD0BE:0x2760,
	0xD0BF:0x2761,0xD180:0x2762,0xD181:0x2763,0xD182:0x2764,0xD183:0x2765,
	0xD184:0x2766,0xD185:0x2767,0xD186:0x2768,0xD187:0x2769,0xD188:0x276A,
	0xD189:0x276B,0xD18A:0x276C,0xD18B:0x276D,0xD18C:0x276E,0xD18D:0x276F,
	0xD18E:0x2770,0xD18F:0x2771,0xE29480:0x2821,0xE29482:0x2822,0xE2948C:0x2823,
	0xE29490:0x2824,0xE29498:0x2825,0xE29494:0x2826,0xE2949C:0x2827,0xE294AC:0x2828,
	0xE294A4:0x2829,0xE294B4:0x282A,0xE294BC:0x282B,0xE29481:0x282C,0xE29483:0x282D,
	0xE2948F:0x282E,0xE29493:0x282F,0xE2949B:0x2830,0xE29497:0x2831,0xE294A3:0x2832,
	0xE294B3:0x2833,0xE294AB:0x2834,0xE294BB:0x2835,0xE2958B:0x2836,0xE294A0:0x2837,
	0xE294AF:0x2838,0xE294A8:0x2839,0xE294B7:0x283A,0xE294BF:0x283B,0xE2949D:0x283C,
	0xE294B0:0x283D,0xE294A5:0x283E,0xE294B8:0x283F,0xE29582:0x2840,0xE4BA9C:0x3021,
	0xE59496:0x3022,0xE5A883:0x3023,0xE998BF:0x3024,0xE59380:0x3025,0xE6849B:0x3026,
	0xE68CA8:0x3027,0xE5A7B6:0x3028,0xE980A2:0x3029,0xE891B5:0x302A,0xE88C9C:0x302B,
	0xE7A990:0x302C,0xE682AA:0x302D,0xE68FA1:0x302E,0xE6B8A5:0x302F,0xE697AD:0x3030,
	0xE891A6:0x3031,0xE88AA6:0x3032,0xE9AFB5:0x3033,0xE6A293:0x3034,0xE59CA7:0x3035,
	0xE696A1:0x3036,0xE689B1:0x3037,0xE5AE9B:0x3038,0xE5A790:0x3039,0xE899BB:0x303A,
	0xE9A3B4:0x303B,0xE7B5A2:0x303C,0xE7B6BE:0x303D,0xE9AE8E:0x303E,0xE68896:0x303F,
	0xE7B29F:0x3040,0xE8A2B7:0x3041,0xE5AE89:0x3042,0xE5BAB5:0x3043,0xE68C89:0x3044,
	0xE69A97:0x3045,0xE6A188:0x3046,0xE99787:0x3047,0xE99E8D:0x3048,0xE69D8F:0x3049,
	0xE4BBA5:0x304A,0xE4BC8A:0x304B,0xE4BD8D:0x304C,0xE4BE9D:0x304D,0xE58189:0x304E,
	0xE59BB2:0x304F,0xE5A4B7:0x3050,0xE5A794:0x3051,0xE5A881:0x3052,0xE5B089:0x3053,
	0xE6839F:0x3054,0xE6848F:0x3055,0xE685B0:0x3056,0xE69893:0x3057,0xE6A485:0x3058,
	0xE782BA:0x3059,0xE7958F:0x305A,0xE795B0:0x305B,0xE7A7BB:0x305C,0xE7B6AD:0x305D,
	0xE7B7AF:0x305E,0xE88383:0x305F,0xE8908E:0x3060,0xE8A1A3:0x3061,0xE8AC82:0x3062,
	0xE98195:0x3063,0xE981BA:0x3064,0xE58CBB:0x3065,0xE4BA95:0x3066,0xE4BAA5:0x3067,
	0xE59F9F:0x3068,0xE882B2:0x3069,0xE98381:0x306A,0xE7A3AF:0x306B,0xE4B880:0x306C,
	0xE5A3B1:0x306D,0xE6BAA2:0x306E,0xE980B8:0x306F,0xE7A8B2:0x3070,0xE88CA8:0x3071,
	0xE88A8B:0x3072,0xE9B0AF:0x3073,0xE58581:0x3074,0xE58DB0:0x3075,0xE592BD:0x3076,
	0xE593A1:0x3077,0xE59BA0:0x3078,0xE5A7BB:0x3079,0xE5BC95:0x307A,0xE9A3B2:0x307B,
	0xE6B7AB:0x307C,0xE883A4:0x307D,0xE894AD:0x307E,0xE999A2:0x3121,0xE999B0:0x3122,
	0xE99AA0:0x3123,0xE99FBB:0x3124,0xE5908B:0x3125,0xE58FB3:0x3126,0xE5AE87:0x3127,
	0xE7838F:0x3128,0xE7BEBD:0x3129,0xE8BF82:0x312A,0xE99BA8:0x312B,0xE58DAF:0x312C,
	0xE9B59C:0x312D,0xE7AABA:0x312E,0xE4B891:0x312F,0xE7A293:0x3130,0xE887BC:0x3131,
	0xE6B8A6:0x3132,0xE59898:0x3133,0xE59484:0x3134,0xE6AC9D:0x3135,0xE8949A:0x3136,
	0xE9B0BB:0x3137,0xE5A7A5:0x3138,0xE58EA9:0x3139,0xE6B5A6:0x313A,0xE7939C:0x313B,
	0xE9968F:0x313C,0xE59982:0x313D,0xE4BA91:0x313E,0xE9818B:0x313F,0xE99BB2:0x3140,
	0xE88D8F:0x3141,0xE9A48C:0x3142,0xE58FA1:0x3143,0xE596B6:0x3144,0xE5ACB0:0x3145,
	0xE5BDB1:0x3146,0xE698A0:0x3147,0xE69BB3:0x3148,0xE6A084:0x3149,0xE6B0B8:0x314A,
	0xE6B3B3:0x314B,0xE6B4A9:0x314C,0xE7919B:0x314D,0xE79B88:0x314E,0xE7A98E:0x314F,
	0xE9A0B4:0x3150,0xE88BB1:0x3151,0xE8A19B:0x3152,0xE8A9A0:0x3153,0xE98BAD:0x3154,
	0xE6B6B2:0x3155,0xE796AB:0x3156,0xE79B8A:0x3157,0xE9A785:0x3158,0xE682A6:0x3159,
	0xE8AC81:0x315A,0xE8B68A:0x315B,0xE996B2:0x315C,0xE6A68E:0x315D,0xE58EAD:0x315E,
	0xE58686:0x315F,0xE59C92:0x3160,0xE5A0B0:0x3161,0xE5A584:0x3162,0xE5AEB4:0x3163,
	0xE5BBB6:0x3164,0xE680A8:0x3165,0xE68EA9:0x3166,0xE68FB4:0x3167,0xE6B2BF:0x3168,
	0xE6BC94:0x3169,0xE7828E:0x316A,0xE78494:0x316B,0xE78599:0x316C,0xE78795:0x316D,
	0xE78CBF:0x316E,0xE7B881:0x316F,0xE889B6:0x3170,0xE88B91:0x3171,0xE89697:0x3172,
	0xE981A0:0x3173,0xE9899B:0x3174,0xE9B49B:0x3175,0xE5A1A9:0x3176,0xE696BC:0x3177,
	0xE6B19A:0x3178,0xE794A5:0x3179,0xE587B9:0x317A,0xE5A4AE:0x317B,0xE5A5A5:0x317C,
	0xE5BE80:0x317D,0xE5BF9C:0x317E,0xE68ABC:0x3221,0xE697BA:0x3222,0xE6A8AA:0x3223,
	0xE6ACA7:0x3224,0xE6AEB4:0x3225,0xE78E8B:0x3226,0xE7BF81:0x3227,0xE8A596:0x3228,
	0xE9B4AC:0x3229,0xE9B48E:0x322A,0xE9BB84:0x322B,0xE5B2A1:0x322C,0xE6B296:0x322D,
	0xE88DBB:0x322E,0xE58484:0x322F,0xE5B18B:0x3230,0xE686B6:0x3231,0xE88786:0x3232,
	0xE6A1B6:0x3233,0xE789A1:0x3234,0xE4B999:0x3235,0xE4BFBA:0x3236,0xE58DB8:0x3237,
	0xE681A9:0x3238,0xE6B8A9:0x3239,0xE7A98F:0x323A,0xE99FB3:0x323B,0xE4B88B:0x323C,
	0xE58C96:0x323D,0xE4BBAE:0x323E,0xE4BD95:0x323F,0xE4BCBD:0x3240,0xE4BEA1:0x3241,
	0xE4BDB3:0x3242,0xE58AA0:0x3243,0xE58FAF:0x3244,0xE59889:0x3245,0xE5A48F:0x3246,
	0xE5AB81:0x3247,0xE5AEB6:0x3248,0xE5AFA1:0x3249,0xE7A791:0x324A,0xE69A87:0x324B,
	0xE69E9C:0x324C,0xE69EB6:0x324D,0xE6AD8C:0x324E,0xE6B2B3:0x324F,0xE781AB:0x3250,
	0xE78F82:0x3251,0xE7A68D:0x3252,0xE7A6BE:0x3253,0xE7A8BC:0x3254,0xE7AE87:0x3255,
	0xE88AB1:0x3256,0xE88B9B:0x3257,0xE88C84:0x3258,0xE88DB7:0x3259,0xE88FAF:0x325A,
	0xE88F93:0x325B,0xE89DA6:0x325C,0xE8AAB2:0x325D,0xE598A9:0x325E,0xE8B2A8:0x325F,
	0xE8BFA6:0x3260,0xE9818E:0x3261,0xE99C9E:0x3262,0xE89A8A:0x3263,0xE4BF84:0x3264,
	0xE5B3A8:0x3265,0xE68891:0x3266,0xE78999:0x3267,0xE794BB:0x3268,0xE887A5:0x3269,
	0xE88ABD:0x326A,0xE89BBE:0x326B,0xE8B380:0x326C,0xE99B85:0x326D,0xE9A493:0x326E,
	0xE9A795:0x326F,0xE4BB8B:0x3270,0xE4BC9A:0x3271,0xE8A7A3:0x3272,0xE59B9E:0x3273,
	0xE5A18A:0x3274,0xE5A38A:0x3275,0xE5BBBB:0x3276,0xE5BFAB:0x3277,0xE680AA:0x3278,
	0xE68294:0x3279,0xE681A2:0x327A,0xE68790:0x327B,0xE68892:0x327C,0xE68B90:0x327D,
	0xE694B9:0x327E,0xE9AD81:0x3321,0xE699A6:0x3322,0xE6A2B0:0x3323,0xE6B5B7:0x3324,
	0xE781B0:0x3325,0xE7958C:0x3326,0xE79A86:0x3327,0xE7B5B5:0x3328,0xE88AA5:0x3329,
	0xE89FB9:0x332A,0xE9968B:0x332B,0xE99A8E:0x332C,0xE8B29D:0x332D,0xE587B1:0x332E,
	0xE58ABE:0x332F,0xE5A496:0x3330,0xE592B3:0x3331,0xE5AEB3:0x3332,0xE5B496:0x3333,
	0xE685A8:0x3334,0xE6A682:0x3335,0xE6B6AF:0x3336,0xE7A28D:0x3337,0xE8938B:0x3338,
	0xE8A197:0x3339,0xE8A9B2:0x333A,0xE98EA7:0x333B,0xE9AAB8:0x333C,0xE6B5AC:0x333D,
	0xE9A6A8:0x333E,0xE89B99:0x333F,0xE59EA3:0x3340,0xE69FBF:0x3341,0xE89B8E:0x3342,
	0xE9888E:0x3343,0xE58A83:0x3344,0xE59A87:0x3345,0xE59084:0x3346,0xE5BB93:0x3347,
	0xE68BA1:0x3348,0xE692B9:0x3349,0xE6A0BC:0x334A,0xE6A0B8:0x334B,0xE6AEBB:0x334C,
	0xE78DB2:0x334D,0xE7A2BA:0x334E,0xE7A9AB:0x334F,0xE8A69A:0x3350,0xE8A792:0x3351,
	0xE8B5AB:0x3352,0xE8BC83:0x3353,0xE983AD:0x3354,0xE996A3:0x3355,0xE99A94:0x3356,
	0xE99DA9:0x3357,0xE5ADA6:0x3358,0xE5B2B3:0x3359,0xE6A5BD:0x335A,0xE9A18D:0x335B,
	0xE9A18E:0x335C,0xE68E9B:0x335D,0xE7ACA0:0x335E,0xE6A8AB:0x335F,0xE6A9BF:0x3360,
	0xE6A2B6:0x3361,0xE9B08D:0x3362,0xE6BD9F:0x3363,0xE589B2:0x3364,0xE5969D:0x3365,
	0xE681B0:0x3366,0xE68BAC:0x3367,0xE6B4BB:0x3368,0xE6B887:0x3369,0xE6BB91:0x336A,
	0xE8919B:0x336B,0xE8A490:0x336C,0xE8BD84:0x336D,0xE4B894:0x336E,0xE9B0B9:0x336F,
	0xE58FB6:0x3370,0xE6A49B:0x3371,0xE6A8BA:0x3372,0xE99E84:0x3373,0xE6A0AA:0x3374,
	0xE5859C:0x3375,0xE7AB83:0x3376,0xE892B2:0x3377,0xE9879C:0x3378,0xE98E8C:0x3379,
	0xE5999B:0x337A,0xE9B4A8:0x337B,0xE6A0A2:0x337C,0xE88C85:0x337D,0xE890B1:0x337E,
	0xE7B2A5:0x3421,0xE58888:0x3422,0xE88B85:0x3423,0xE793A6:0x3424,0xE4B9BE:0x3425,
	0xE4BE83:0x3426,0xE586A0:0x3427,0xE5AF92:0x3428,0xE5888A:0x3429,0xE58B98:0x342A,
	0xE58BA7:0x342B,0xE5B7BB:0x342C,0xE5969A:0x342D,0xE5A0AA:0x342E,0xE5A7A6:0x342F,
	0xE5AE8C:0x3430,0xE5AE98:0x3431,0xE5AF9B:0x3432,0xE5B9B2:0x3433,0xE5B9B9:0x3434,
	0xE682A3:0x3435,0xE6849F:0x3436,0xE685A3:0x3437,0xE686BE:0x3438,0xE68F9B:0x3439,
	0xE695A2:0x343A,0xE69F91:0x343B,0xE6A193:0x343C,0xE6A3BA:0x343D,0xE6ACBE:0x343E,
	0xE6AD93:0x343F,0xE6B197:0x3440,0xE6BCA2:0x3441,0xE6BE97:0x3442,0xE6BD85:0x3443,
	0xE792B0:0x3444,0xE79498:0x3445,0xE79BA3:0x3446,0xE79C8B:0x3447,0xE7ABBF:0x3448,
	0xE7AEA1:0x3449,0xE7B0A1:0x344A,0xE7B7A9:0x344B,0xE7BCB6:0x344C,0xE7BFB0:0x344D,
	0xE8829D:0x344E,0xE889A6:0x344F,0xE88E9E:0x3450,0xE8A6B3:0x3451,0xE8AB8C:0x3452,
	0xE8B2AB:0x3453,0xE98284:0x3454,0xE99191:0x3455,0xE99693:0x3456,0xE99691:0x3457,
	0xE996A2:0x3458,0xE999A5:0x3459,0xE99F93:0x345A,0xE9A4A8:0x345B,0xE88898:0x345C,
	0xE4B8B8:0x345D,0xE590AB:0x345E,0xE5B2B8:0x345F,0xE5B78C:0x3460,0xE78EA9:0x3461,
	0xE7998C:0x3462,0xE79CBC:0x3463,0xE5B2A9:0x3464,0xE7BFAB:0x3465,0xE8B48B:0x3466,
	0xE99B81:0x3467,0xE9A091:0x3468,0xE9A194:0x3469,0xE9A198:0x346A,0xE4BC81:0x346B,
	0xE4BC8E:0x346C,0xE58DB1:0x346D,0xE5969C:0x346E,0xE599A8:0x346F,0xE59FBA:0x3470,
	0xE5A587:0x3471,0xE5AC89:0x3472,0xE5AF84:0x3473,0xE5B290:0x3474,0xE5B88C:0x3475,
	0xE5B9BE:0x3476,0xE5BF8C:0x3477,0xE68FAE:0x3478,0xE69CBA:0x3479,0xE69797:0x347A,
	0xE697A2:0x347B,0xE69C9F:0x347C,0xE6A38B:0x347D,0xE6A384:0x347E,0xE6A99F:0x3521,
	0xE5B8B0:0x3522,0xE6AF85:0x3523,0xE6B097:0x3524,0xE6B1BD:0x3525,0xE795BF:0x3526,
	0xE7A588:0x3527,0xE5ADA3:0x3528,0xE7A880:0x3529,0xE7B480:0x352A,0xE5BEBD:0x352B,
	0xE8A68F:0x352C,0xE8A898:0x352D,0xE8B2B4:0x352E,0xE8B5B7:0x352F,0xE8BB8C:0x3530,
	0xE8BC9D:0x3531,0xE9A3A2:0x3532,0xE9A88E:0x3533,0xE9ACBC:0x3534,0xE4BA80:0x3535,
	0xE581BD:0x3536,0xE58480:0x3537,0xE5A693:0x3538,0xE5AE9C:0x3539,0xE688AF:0x353A,
	0xE68A80:0x353B,0xE693AC:0x353C,0xE6ACBA:0x353D,0xE78AA0:0x353E,0xE79691:0x353F,
	0xE7A587:0x3540,0xE7BEA9:0x3541,0xE89FBB:0x3542,0xE8AABC:0x3543,0xE8ADB0:0x3544,
	0xE68EAC:0x3545,0xE88F8A:0x3546,0xE99EA0:0x3547,0xE59089:0x3548,0xE59083:0x3549,
	0xE596AB:0x354A,0xE6A194:0x354B,0xE6A998:0x354C,0xE8A9B0:0x354D,0xE7A0A7:0x354E,
	0xE69DB5:0x354F,0xE9BB8D:0x3550,0xE58DB4:0x3551,0xE5AEA2:0x3552,0xE8849A:0x3553,
	0xE89990:0x3554,0xE98086:0x3555,0xE4B898:0x3556,0xE4B985:0x3557,0xE4BB87:0x3558,
	0xE4BC91:0x3559,0xE58F8A:0x355A,0xE590B8:0x355B,0xE5AEAE:0x355C,0xE5BC93:0x355D,
	0xE680A5:0x355E,0xE69591:0x355F,0xE69CBD:0x3560,0xE6B182:0x3561,0xE6B1B2:0x3562,
	0xE6B3A3:0x3563,0xE781B8:0x3564,0xE79083:0x3565,0xE7A9B6:0x3566,0xE7AAAE:0x3567,
	0xE7AC88:0x3568,0xE7B49A:0x3569,0xE7B3BE:0x356A,0xE7B5A6:0x356B,0xE697A7:0x356C,
	0xE7899B:0x356D,0xE58EBB:0x356E,0xE5B185:0x356F,0xE5B7A8:0x3570,0xE68B92:0x3571,
	0xE68BA0:0x3572,0xE68C99:0x3573,0xE6B8A0:0x3574,0xE8999A:0x3575,0xE8A8B1:0x3576,
	0xE8B79D:0x3577,0xE98BB8:0x3578,0xE6BC81:0x3579,0xE7A6A6:0x357A,0xE9AD9A:0x357B,
	0xE4BAA8:0x357C,0xE4BAAB:0x357D,0xE4BAAC:0x357E,0xE4BE9B:0x3621,0xE4BEA0:0x3622,
	0xE58391:0x3623,0xE58587:0x3624,0xE7ABB6:0x3625,0xE585B1:0x3626,0xE587B6:0x3627,
	0xE58D94:0x3628,0xE58CA1:0x3629,0xE58DBF:0x362A,0xE58FAB:0x362B,0xE596AC:0x362C,
	0xE5A283:0x362D,0xE5B3A1:0x362E,0xE5BCB7:0x362F,0xE5BD8A:0x3630,0xE680AF:0x3631,
	0xE68190:0x3632,0xE681AD:0x3633,0xE68C9F:0x3634,0xE69599:0x3635,0xE6A98B:0x3636,
	0xE6B381:0x3637,0xE78B82:0x3638,0xE78BAD:0x3639,0xE79FAF:0x363A,0xE883B8:0x363B,
	0xE88485:0x363C,0xE88888:0x363D,0xE8958E:0x363E,0xE983B7:0x363F,0xE98FA1:0x3640,
	0xE99FBF:0x3641,0xE9A597:0x3642,0xE9A99A:0x3643,0xE4BBB0:0x3644,0xE5879D:0x3645,
	0xE5B0AD:0x3646,0xE69A81:0x3647,0xE6A5AD:0x3648,0xE5B180:0x3649,0xE69BB2:0x364A,
	0xE6A5B5:0x364B,0xE78E89:0x364C,0xE6A190:0x364D,0xE7B281:0x364E,0xE58385:0x364F,
	0xE58BA4:0x3650,0xE59D87:0x3651,0xE5B7BE:0x3652,0xE98CA6:0x3653,0xE696A4:0x3654,
	0xE6ACA3:0x3655,0xE6ACBD:0x3656,0xE790B4:0x3657,0xE7A681:0x3658,0xE7A6BD:0x3659,
	0xE7AD8B:0x365A,0xE7B78A:0x365B,0xE88AB9:0x365C,0xE88F8C:0x365D,0xE8A1BF:0x365E,
	0xE8A59F:0x365F,0xE8ACB9:0x3660,0xE8BF91:0x3661,0xE98791:0x3662,0xE5909F:0x3663,
	0xE98A80:0x3664,0xE4B99D:0x3665,0xE580B6:0x3666,0xE58FA5:0x3667,0xE58CBA:0x3668,
	0xE78B97:0x3669,0xE78E96:0x366A,0xE79FA9:0x366B,0xE88BA6:0x366C,0xE8BAAF:0x366D,
	0xE9A786:0x366E,0xE9A788:0x366F,0xE9A792:0x3670,0xE585B7:0x3671,0xE6849A:0x3672,
	0xE8999E:0x3673,0xE596B0:0x3674,0xE7A9BA:0x3675,0xE581B6:0x3676,0xE5AF93:0x3677,
	0xE98187:0x3678,0xE99A85:0x3679,0xE4B8B2:0x367A,0xE6AB9B:0x367B,0xE987A7:0x367C,
	0xE5B191:0x367D,0xE5B188:0x367E,0xE68E98:0x3721,0xE7AA9F:0x3722,0xE6B293:0x3723,
	0xE99DB4:0x3724,0xE8BDA1:0x3725,0xE7AAAA:0x3726,0xE7868A:0x3727,0xE99A88:0x3728,
	0xE7B282:0x3729,0xE6A097:0x372A,0xE7B9B0:0x372B,0xE6A191:0x372C,0xE98DAC:0x372D,
	0xE58BB2:0x372E,0xE5909B:0x372F,0xE896AB:0x3730,0xE8A893:0x3731,0xE7BEA4:0x3732,
	0xE8BB8D:0x3733,0xE983A1:0x3734,0xE58DA6:0x3735,0xE8A288:0x3736,0xE7A581:0x3737,
	0xE4BF82:0x3738,0xE582BE:0x3739,0xE58891:0x373A,0xE58584:0x373B,0xE59593:0x373C,
	0xE59CAD:0x373D,0xE78FAA:0x373E,0xE59E8B:0x373F,0xE5A591:0x3740,0xE5BDA2:0x3741,
	0xE5BE84:0x3742,0xE681B5:0x3743,0xE685B6:0x3744,0xE685A7:0x3745,0xE686A9:0x3746,
	0xE68EB2:0x3747,0xE690BA:0x3748,0xE695AC:0x3749,0xE699AF:0x374A,0xE6A182:0x374B,
	0xE6B893:0x374C,0xE795A6:0x374D,0xE7A8BD:0x374E,0xE7B3BB:0x374F,0xE7B58C:0x3750,
	0xE7B699:0x3751,0xE7B98B:0x3752,0xE7BDAB:0x3753,0xE88C8E:0x3754,0xE88D8A:0x3755,
	0xE89B8D:0x3756,0xE8A888:0x3757,0xE8A9A3:0x3758,0xE8ADA6:0x3759,0xE8BBBD:0x375A,
	0xE9A09A:0x375B,0xE9B68F:0x375C,0xE88AB8:0x375D,0xE8BF8E:0x375E,0xE9AFA8:0x375F,
	0xE58A87:0x3760,0xE6889F:0x3761,0xE69283:0x3762,0xE6BF80:0x3763,0xE99A99:0x3764,
	0xE6A181:0x3765,0xE58291:0x3766,0xE6ACA0:0x3767,0xE6B1BA:0x3768,0xE6BD94:0x3769,
	0xE7A9B4:0x376A,0xE7B590:0x376B,0xE8A180:0x376C,0xE8A8A3:0x376D,0xE69C88:0x376E,
	0xE4BBB6:0x376F,0xE580B9:0x3770,0xE580A6:0x3771,0xE581A5:0x3772,0xE585BC:0x3773,
	0xE588B8:0x3774,0xE589A3:0x3775,0xE596A7:0x3776,0xE59C8F:0x3777,0xE5A085:0x3778,
	0xE5AB8C:0x3779,0xE5BBBA:0x377A,0xE686B2:0x377B,0xE687B8:0x377C,0xE68BB3:0x377D,
	0xE68DB2:0x377E,0xE6A49C:0x3821,0xE6A8A9:0x3822,0xE789BD:0x3823,0xE78AAC:0x3824,
	0xE78CAE:0x3825,0xE7A094:0x3826,0xE7A1AF:0x3827,0xE7B5B9:0x3828,0xE79C8C:0x3829,
	0xE882A9:0x382A,0xE8A68B:0x382B,0xE8AC99:0x382C,0xE8B3A2:0x382D,0xE8BB92:0x382E,
	0xE981A3:0x382F,0xE98DB5:0x3830,0xE999BA:0x3831,0xE9A195:0x3832,0xE9A893:0x3833,
	0xE9B9B8:0x3834,0xE58583:0x3835,0xE58E9F:0x3836,0xE58EB3:0x3837,0xE5B9BB:0x3838,
	0xE5BCA6:0x3839,0xE6B89B:0x383A,0xE6BA90:0x383B,0xE78E84:0x383C,0xE78FBE:0x383D,
	0xE7B583:0x383E,0xE888B7:0x383F,0xE8A880:0x3840,0xE8ABBA:0x3841,0xE99990:0x3842,
	0xE4B98E:0x3843,0xE5808B:0x3844,0xE58FA4:0x3845,0xE591BC:0x3846,0xE59BBA:0x3847,
	0xE5A791:0x3848,0xE5ADA4:0x3849,0xE5B7B1:0x384A,0xE5BAAB:0x384B,0xE5BCA7:0x384C,
	0xE688B8:0x384D,0xE69585:0x384E,0xE69EAF:0x384F,0xE6B996:0x3850,0xE78B90:0x3851,
	0xE7B38A:0x3852,0xE8A2B4:0x3853,0xE882A1:0x3854,0xE883A1:0x3855,0xE88FB0:0x3856,
	0xE8998E:0x3857,0xE8AA87:0x3858,0xE8B7A8:0x3859,0xE988B7:0x385A,0xE99B87:0x385B,
	0xE9A1A7:0x385C,0xE9BC93:0x385D,0xE4BA94:0x385E,0xE4BA92:0x385F,0xE4BC8D:0x3860,
	0xE58D88:0x3861,0xE59189:0x3862,0xE590BE:0x3863,0xE5A8AF:0x3864,0xE5BE8C:0x3865,
	0xE5BEA1:0x3866,0xE6829F:0x3867,0xE6A2A7:0x3868,0xE6AA8E:0x3869,0xE7919A:0x386A,
	0xE7A281:0x386B,0xE8AA9E:0x386C,0xE8AAA4:0x386D,0xE8ADB7:0x386E,0xE98690:0x386F,
	0xE4B99E:0x3870,0xE9AF89:0x3871,0xE4BAA4:0x3872,0xE4BDBC:0x3873,0xE4BEAF:0x3874,
	0xE58099:0x3875,0xE58096:0x3876,0xE58589:0x3877,0xE585AC:0x3878,0xE58A9F:0x3879,
	0xE58AB9:0x387A,0xE58BBE:0x387B,0xE58E9A:0x387C,0xE58FA3:0x387D,0xE59091:0x387E,
	0xE5908E:0x3921,0xE59689:0x3922,0xE59D91:0x3923,0xE59EA2:0x3924,0xE5A5BD:0x3925,
	0xE5AD94:0x3926,0xE5AD9D:0x3927,0xE5AE8F:0x3928,0xE5B7A5:0x3929,0xE5B7A7:0x392A,
	0xE5B7B7:0x392B,0xE5B9B8:0x392C,0xE5BA83:0x392D,0xE5BA9A:0x392E,0xE5BAB7:0x392F,
	0xE5BC98:0x3930,0xE68192:0x3931,0xE6858C:0x3932,0xE68A97:0x3933,0xE68B98:0x3934,
	0xE68EA7:0x3935,0xE694BB:0x3936,0xE69882:0x3937,0xE69983:0x3938,0xE69BB4:0x3939,
	0xE69DAD:0x393A,0xE6A0A1:0x393B,0xE6A297:0x393C,0xE6A78B:0x393D,0xE6B19F:0x393E,
	0xE6B4AA:0x393F,0xE6B5A9:0x3940,0xE6B8AF:0x3941,0xE6BA9D:0x3942,0xE794B2:0x3943,
	0xE79A87:0x3944,0xE7A1AC:0x3945,0xE7A8BF:0x3946,0xE7B3A0:0x3947,0xE7B485:0x3948,
	0xE7B498:0x3949,0xE7B59E:0x394A,0xE7B6B1:0x394B,0xE88095:0x394C,0xE88083:0x394D,
	0xE882AF:0x394E,0xE882B1:0x394F,0xE88594:0x3950,0xE8868F:0x3951,0xE888AA:0x3952,
	0xE88D92:0x3953,0xE8A18C:0x3954,0xE8A1A1:0x3955,0xE8AC9B:0x3956,0xE8B2A2:0x3957,
	0xE8B3BC:0x3958,0xE9838A:0x3959,0xE985B5:0x395A,0xE989B1:0x395B,0xE7A0BF:0x395C,
	0xE98BBC:0x395D,0xE996A4:0x395E,0xE9998D:0x395F,0xE9A085:0x3960,0xE9A699:0x3961,
	0xE9AB98:0x3962,0xE9B4BB:0x3963,0xE5899B:0x3964,0xE58AAB:0x3965,0xE58FB7:0x3966,
	0xE59088:0x3967,0xE5A395:0x3968,0xE68BB7:0x3969,0xE6BFA0:0x396A,0xE8B1AA:0x396B,
	0xE8BD9F:0x396C,0xE9BAB9:0x396D,0xE5858B:0x396E,0xE588BB:0x396F,0xE5918A:0x3970,
	0xE59BBD:0x3971,0xE7A980:0x3972,0xE985B7:0x3973,0xE9B5A0:0x3974,0xE9BB92:0x3975,
	0xE78D84:0x3976,0xE6BC89:0x3977,0xE885B0:0x3978,0xE79491:0x3979,0xE5BFBD:0x397A,
	0xE6839A:0x397B,0xE9AAA8:0x397C,0xE78B9B:0x397D,0xE8BEBC:0x397E,0xE6ADA4:0x3A21,
	0xE9A083:0x3A22,0xE4BB8A:0x3A23,0xE59BB0:0x3A24,0xE59DA4:0x3A25,0xE5A2BE:0x3A26,
	0xE5A99A:0x3A27,0xE681A8:0x3A28,0xE68787:0x3A29,0xE6988F:0x3A2A,0xE69886:0x3A2B,
	0xE6A0B9:0x3A2C,0xE6A2B1:0x3A2D,0xE6B7B7:0x3A2E,0xE79795:0x3A2F,0xE7B4BA:0x3A30,
	0xE889AE:0x3A31,0xE9AD82:0x3A32,0xE4BA9B:0x3A33,0xE4BD90:0x3A34,0xE58F89:0x3A35,
	0xE59486:0x3A36,0xE5B5AF:0x3A37,0xE5B7A6:0x3A38,0xE5B7AE:0x3A39,0xE69FBB:0x3A3A,
	0xE6B299:0x3A3B,0xE791B3:0x3A3C,0xE7A082:0x3A3D,0xE8A990:0x3A3E,0xE98E96:0x3A3F,
	0xE8A39F:0x3A40,0xE59D90:0x3A41,0xE5BAA7:0x3A42,0xE68CAB:0x3A43,0xE582B5:0x3A44,
	0xE582AC:0x3A45,0xE5868D:0x3A46,0xE69C80:0x3A47,0xE59389:0x3A48,0xE5A19E:0x3A49,
	0xE5A6BB:0x3A4A,0xE5AEB0:0x3A4B,0xE5BDA9:0x3A4C,0xE6898D:0x3A4D,0xE68EA1:0x3A4E,
	0xE6A0BD:0x3A4F,0xE6ADB3:0x3A50,0xE6B888:0x3A51,0xE781BD:0x3A52,0xE98787:0x3A53,
	0xE78A80:0x3A54,0xE7A095:0x3A55,0xE7A0A6:0x3A56,0xE7A5AD:0x3A57,0xE6968E:0x3A58,
	0xE7B4B0:0x3A59,0xE88F9C:0x3A5A,0xE8A381:0x3A5B,0xE8BC89:0x3A5C,0xE99A9B:0x3A5D,
	0xE589A4:0x3A5E,0xE59CA8:0x3A5F,0xE69D90:0x3A60,0xE7BDAA:0x3A61,0xE8B2A1:0x3A62,
	0xE586B4:0x3A63,0xE59D82:0x3A64,0xE998AA:0x3A65,0xE5A0BA:0x3A66,0xE6A68A:0x3A67,
	0xE882B4:0x3A68,0xE592B2:0x3A69,0xE5B48E:0x3A6A,0xE59FBC:0x3A6B,0xE7A295:0x3A6C,
	0xE9B7BA:0x3A6D,0xE4BD9C:0x3A6E,0xE5898A:0x3A6F,0xE5928B:0x3A70,0xE690BE:0x3A71,
	0xE698A8:0x3A72,0xE69C94:0x3A73,0xE69FB5:0x3A74,0xE7AA84:0x3A75,0xE7AD96:0x3A76,
	0xE7B4A2:0x3A77,0xE98CAF:0x3A78,0xE6A19C:0x3A79,0xE9AEAD:0x3A7A,0xE7ACB9:0x3A7B,
	0xE58C99:0x3A7C,0xE5868A:0x3A7D,0xE588B7:0x3A7E,0xE5AF9F:0x3B21,0xE68BB6:0x3B22,
	0xE692AE:0x3B23,0xE693A6:0x3B24,0xE69CAD:0x3B25,0xE6AEBA:0x3B26,0xE896A9:0x3B27,
	0xE99B91:0x3B28,0xE79A90:0x3B29,0xE9AF96:0x3B2A,0xE68D8C:0x3B2B,0xE98C86:0x3B2C,
	0xE9AEAB:0x3B2D,0xE79ABF:0x3B2E,0xE69992:0x3B2F,0xE4B889:0x3B30,0xE58298:0x3B31,
	0xE58F82:0x3B32,0xE5B1B1:0x3B33,0xE683A8:0x3B34,0xE69292:0x3B35,0xE695A3:0x3B36,
	0xE6A19F:0x3B37,0xE787A6:0x3B38,0xE78F8A:0x3B39,0xE794A3:0x3B3A,0xE7AE97:0x3B3B,
	0xE7BA82:0x3B3C,0xE89A95:0x3B3D,0xE8AE83:0x3B3E,0xE8B39B:0x3B3F,0xE985B8:0x3B40,
	0xE9A490:0x3B41,0xE696AC:0x3B42,0xE69AAB:0x3B43,0xE6AE8B:0x3B44,0xE4BB95:0x3B45,
	0xE4BB94:0x3B46,0xE4BCBA:0x3B47,0xE4BDBF:0x3B48,0xE588BA:0x3B49,0xE58FB8:0x3B4A,
	0xE58FB2:0x3B4B,0xE597A3:0x3B4C,0xE59B9B:0x3B4D,0xE5A3AB:0x3B4E,0xE5A78B:0x3B4F,
	0xE5A789:0x3B50,0xE5A7BF:0x3B51,0xE5AD90:0x3B52,0xE5B18D:0x3B53,0xE5B882:0x3B54,
	0xE5B8AB:0x3B55,0xE5BF97:0x3B56,0xE6809D:0x3B57,0xE68C87:0x3B58,0xE694AF:0x3B59,
	0xE5AD9C:0x3B5A,0xE696AF:0x3B5B,0xE696BD:0x3B5C,0xE697A8:0x3B5D,0xE69E9D:0x3B5E,
	0xE6ADA2:0x3B5F,0xE6ADBB:0x3B60,0xE6B08F:0x3B61,0xE78D85:0x3B62,0xE7A589:0x3B63,
	0xE7A781:0x3B64,0xE7B3B8:0x3B65,0xE7B499:0x3B66,0xE7B4AB:0x3B67,0xE882A2:0x3B68,
	0xE88482:0x3B69,0xE887B3:0x3B6A,0xE8A696:0x3B6B,0xE8A99E:0x3B6C,0xE8A9A9:0x3B6D,
	0xE8A9A6:0x3B6E,0xE8AA8C:0x3B6F,0xE8ABAE:0x3B70,0xE8B387:0x3B71,0xE8B39C:0x3B72,
	0xE99B8C:0x3B73,0xE9A3BC:0x3B74,0xE6ADAF:0x3B75,0xE4BA8B:0x3B76,0xE4BCBC:0x3B77,
	0xE4BE8D:0x3B78,0xE58590:0x3B79,0xE5AD97:0x3B7A,0xE5AFBA:0x3B7B,0xE68588:0x3B7C,
	0xE68C81:0x3B7D,0xE69982:0x3B7E,0xE6ACA1:0x3C21,0xE6BB8B:0x3C22,0xE6B2BB:0x3C23,
	0xE788BE:0x3C24,0xE792BD:0x3C25,0xE79794:0x3C26,0xE7A381:0x3C27,0xE7A4BA:0x3C28,
	0xE8808C:0x3C29,0xE880B3:0x3C2A,0xE887AA:0x3C2B,0xE89294:0x3C2C,0xE8BE9E:0x3C2D,
	0xE6B190:0x3C2E,0xE9B9BF:0x3C2F,0xE5BC8F:0x3C30,0xE8AD98:0x3C31,0xE9B4AB:0x3C32,
	0xE7ABBA:0x3C33,0xE8BBB8:0x3C34,0xE5AE8D:0x3C35,0xE99BAB:0x3C36,0xE4B883:0x3C37,
	0xE58FB1:0x3C38,0xE59FB7:0x3C39,0xE5A4B1:0x3C3A,0xE5AB89:0x3C3B,0xE5AEA4:0x3C3C,
	0xE68289:0x3C3D,0xE6B9BF:0x3C3E,0xE6BC86:0x3C3F,0xE796BE:0x3C40,0xE8B3AA:0x3C41,
	0xE5AE9F:0x3C42,0xE89480:0x3C43,0xE7AFA0:0x3C44,0xE581B2:0x3C45,0xE69FB4:0x3C46,
	0xE88A9D:0x3C47,0xE5B1A1:0x3C48,0xE8958A:0x3C49,0xE7B89E:0x3C4A,0xE8888E:0x3C4B,
	0xE58699:0x3C4C,0xE5B084:0x3C4D,0xE68DA8:0x3C4E,0xE8B5A6:0x3C4F,0xE6969C:0x3C50,
	0xE785AE:0x3C51,0xE7A4BE:0x3C52,0xE7B497:0x3C53,0xE88085:0x3C54,0xE8AC9D:0x3C55,
	0xE8BB8A:0x3C56,0xE981AE:0x3C57,0xE89B87:0x3C58,0xE982AA:0x3C59,0xE5809F:0x3C5A,
	0xE58BBA:0x3C5B,0xE5B0BA:0x3C5C,0xE69D93:0x3C5D,0xE781BC:0x3C5E,0xE788B5:0x3C5F,
	0xE9858C:0x3C60,0xE98788:0x3C61,0xE98CAB:0x3C62,0xE88BA5:0x3C63,0xE5AF82:0x3C64,
	0xE5BCB1:0x3C65,0xE683B9:0x3C66,0xE4B8BB:0x3C67,0xE58F96:0x3C68,0xE5AE88:0x3C69,
	0xE6898B:0x3C6A,0xE69CB1:0x3C6B,0xE6AE8A:0x3C6C,0xE78BA9:0x3C6D,0xE78FA0:0x3C6E,
	0xE7A8AE:0x3C6F,0xE885AB:0x3C70,0xE8B6A3:0x3C71,0xE98592:0x3C72,0xE9A696:0x3C73,
	0xE58492:0x3C74,0xE58F97:0x3C75,0xE591AA:0x3C76,0xE5AFBF:0x3C77,0xE68E88:0x3C78,
	0xE6A8B9:0x3C79,0xE7B6AC:0x3C7A,0xE99C80:0x3C7B,0xE59B9A:0x3C7C,0xE58F8E:0x3C7D,
	0xE591A8:0x3C7E,0xE5AE97:0x3D21,0xE5B0B1:0x3D22,0xE5B79E:0x3D23,0xE4BFAE:0x3D24,
	0xE68481:0x3D25,0xE68BBE:0x3D26,0xE6B4B2:0x3D27,0xE7A780:0x3D28,0xE7A78B:0x3D29,
	0xE7B582:0x3D2A,0xE7B98D:0x3D2B,0xE7BF92:0x3D2C,0xE887AD:0x3D2D,0xE8889F:0x3D2E,
	0xE89290:0x3D2F,0xE8A186:0x3D30,0xE8A5B2:0x3D31,0xE8AE90:0x3D32,0xE8B9B4:0x3D33,
	0xE8BCAF:0x3D34,0xE980B1:0x3D35,0xE9858B:0x3D36,0xE985AC:0x3D37,0xE99B86:0x3D38,
	0xE9869C:0x3D39,0xE4BB80:0x3D3A,0xE4BD8F:0x3D3B,0xE58585:0x3D3C,0xE58D81:0x3D3D,
	0xE5BE93:0x3D3E,0xE6888E:0x3D3F,0xE69F94:0x3D40,0xE6B181:0x3D41,0xE6B88B:0x3D42,
	0xE78DA3:0x3D43,0xE7B8A6:0x3D44,0xE9878D:0x3D45,0xE98A83:0x3D46,0xE58F94:0x3D47,
	0xE5A499:0x3D48,0xE5AEBF:0x3D49,0xE6B791:0x3D4A,0xE7A59D:0x3D4B,0xE7B8AE:0x3D4C,
	0xE7B29B:0x3D4D,0xE5A1BE:0x3D4E,0xE7869F:0x3D4F,0xE587BA:0x3D50,0xE8A193:0x3D51,
	0xE8BFB0:0x3D52,0xE4BF8A:0x3D53,0xE5B3BB:0x3D54,0xE698A5:0x3D55,0xE79EAC:0x3D56,
	0xE7ABA3:0x3D57,0xE8889C:0x3D58,0xE9A7BF:0x3D59,0xE58786:0x3D5A,0xE5BEAA:0x3D5B,
	0xE697AC:0x3D5C,0xE6A5AF:0x3D5D,0xE6AE89:0x3D5E,0xE6B7B3:0x3D5F,0xE6BA96:0x3D60,
	0xE6BDA4:0x3D61,0xE79BBE:0x3D62,0xE7B494:0x3D63,0xE5B7A1:0x3D64,0xE981B5:0x3D65,
	0xE98687:0x3D66,0xE9A086:0x3D67,0xE587A6:0x3D68,0xE5889D:0x3D69,0xE68980:0x3D6A,
	0xE69A91:0x3D6B,0xE69B99:0x3D6C,0xE6B89A:0x3D6D,0xE5BAB6:0x3D6E,0xE7B792:0x3D6F,
	0xE7BDB2:0x3D70,0xE69BB8:0x3D71,0xE896AF:0x3D72,0xE897B7:0x3D73,0xE8ABB8:0x3D74,
	0xE58AA9:0x3D75,0xE58F99:0x3D76,0xE5A5B3:0x3D77,0xE5BA8F:0x3D78,0xE5BE90:0x3D79,
	0xE68195:0x3D7A,0xE98BA4:0x3D7B,0xE999A4:0x3D7C,0xE582B7:0x3D7D,0xE5849F:0x3D7E,
	0xE58B9D:0x3E21,0xE58CA0:0x3E22,0xE58D87:0x3E23,0xE58FAC:0x3E24,0xE593A8:0x3E25,
	0xE59586:0x3E26,0xE594B1:0x3E27,0xE59897:0x3E28,0xE5A5A8:0x3E29,0xE5A6BE:0x3E2A,
	0xE5A8BC:0x3E2B,0xE5AEB5:0x3E2C,0xE5B086:0x3E2D,0xE5B08F:0x3E2E,0xE5B091:0x3E2F,
	0xE5B09A:0x3E30,0xE5BA84:0x3E31,0xE5BA8A:0x3E32,0xE5BBA0:0x3E33,0xE5BDB0:0x3E34,
	0xE689BF:0x3E35,0xE68A84:0x3E36,0xE68B9B:0x3E37,0xE68E8C:0x3E38,0xE68DB7:0x3E39,
	0xE69887:0x3E3A,0xE6988C:0x3E3B,0xE698AD:0x3E3C,0xE699B6:0x3E3D,0xE69DBE:0x3E3E,
	0xE6A2A2:0x3E3F,0xE6A89F:0x3E40,0xE6A8B5:0x3E41,0xE6B2BC:0x3E42,0xE6B688:0x3E43,
	0xE6B889:0x3E44,0xE6B998:0x3E45,0xE784BC:0x3E46,0xE784A6:0x3E47,0xE785A7:0x3E48,
	0xE79787:0x3E49,0xE79C81:0x3E4A,0xE7A19D:0x3E4B,0xE7A481:0x3E4C,0xE7A5A5:0x3E4D,
	0xE7A7B0:0x3E4E,0xE7ABA0:0x3E4F,0xE7AC91:0x3E50,0xE7B2A7:0x3E51,0xE7B4B9:0x3E52,
	0xE88296:0x3E53,0xE88F96:0x3E54,0xE8928B:0x3E55,0xE89589:0x3E56,0xE8A19D:0x3E57,
	0xE8A3B3:0x3E58,0xE8A89F:0x3E59,0xE8A8BC:0x3E5A,0xE8A994:0x3E5B,0xE8A9B3:0x3E5C,
	0xE8B1A1:0x3E5D,0xE8B39E:0x3E5E,0xE986A4:0x3E5F,0xE989A6:0x3E60,0xE98DBE:0x3E61,
	0xE99098:0x3E62,0xE99A9C:0x3E63,0xE99E98:0x3E64,0xE4B88A:0x3E65,0xE4B888:0x3E66,
	0xE4B89E:0x3E67,0xE4B997:0x3E68,0xE58697:0x3E69,0xE589B0:0x3E6A,0xE59F8E:0x3E6B,
	0xE5A0B4:0x3E6C,0xE5A38C:0x3E6D,0xE5ACA2:0x3E6E,0xE5B8B8:0x3E6F,0xE68385:0x3E70,
	0xE693BE:0x3E71,0xE69DA1:0x3E72,0xE69D96:0x3E73,0xE6B584:0x3E74,0xE78AB6:0x3E75,
	0xE795B3:0x3E76,0xE7A9A3:0x3E77,0xE892B8:0x3E78,0xE8ADB2:0x3E79,0xE986B8:0x3E7A,
	0xE98CA0:0x3E7B,0xE598B1:0x3E7C,0xE59FB4:0x3E7D,0xE9A3BE:0x3E7E,0xE68BAD:0x3F21,
	0xE6A48D:0x3F22,0xE6AE96:0x3F23,0xE787AD:0x3F24,0xE7B994:0x3F25,0xE881B7:0x3F26,
	0xE889B2:0x3F27,0xE8A7A6:0x3F28,0xE9A39F:0x3F29,0xE89D95:0x3F2A,0xE8BEB1:0x3F2B,
	0xE5B0BB:0x3F2C,0xE4BCB8:0x3F2D,0xE4BFA1:0x3F2E,0xE4BEB5:0x3F2F,0xE59487:0x3F30,
	0xE5A8A0:0x3F31,0xE5AF9D:0x3F32,0xE5AFA9:0x3F33,0xE5BF83:0x3F34,0xE6858E:0x3F35,
	0xE68CAF:0x3F36,0xE696B0:0x3F37,0xE6998B:0x3F38,0xE6A3AE:0x3F39,0xE6A69B:0x3F3A,
	0xE6B5B8:0x3F3B,0xE6B7B1:0x3F3C,0xE794B3:0x3F3D,0xE796B9:0x3F3E,0xE79C9F:0x3F3F,
	0xE7A59E:0x3F40,0xE7A7A6:0x3F41,0xE7B4B3:0x3F42,0xE887A3:0x3F43,0xE88AAF:0x3F44,
	0xE896AA:0x3F45,0xE8A6AA:0x3F46,0xE8A8BA:0x3F47,0xE8BAAB:0x3F48,0xE8BE9B:0x3F49,
	0xE980B2:0x3F4A,0xE9879D:0x3F4B,0xE99C87:0x3F4C,0xE4BABA:0x3F4D,0xE4BB81:0x3F4E,
	0xE58883:0x3F4F,0xE5A1B5:0x3F50,0xE5A3AC:0x3F51,0xE5B08B:0x3F52,0xE7949A:0x3F53,
	0xE5B0BD:0x3F54,0xE8858E:0x3F55,0xE8A88A:0x3F56,0xE8BF85:0x3F57,0xE999A3:0x3F58,
	0xE99DAD:0x3F59,0xE7ACA5:0x3F5A,0xE8AB8F:0x3F5B,0xE9A088:0x3F5C,0xE985A2:0x3F5D,
	0xE59BB3:0x3F5E,0xE58EA8:0x3F5F,0xE98097:0x3F60,0xE590B9:0x3F61,0xE59E82:0x3F62,
	0xE5B8A5:0x3F63,0xE68EA8:0x3F64,0xE6B0B4:0x3F65,0xE7828A:0x3F66,0xE79DA1:0x3F67,
	0xE7B28B:0x3F68,0xE7BFA0:0x3F69,0xE8A1B0:0x3F6A,0xE98182:0x3F6B,0xE98594:0x3F6C,
	0xE98C90:0x3F6D,0xE98C98:0x3F6E,0xE99A8F:0x3F6F,0xE7919E:0x3F70,0xE9AB84:0x3F71,
	0xE5B487:0x3F72,0xE5B5A9:0x3F73,0xE695B0:0x3F74,0xE69EA2:0x3F75,0xE8B6A8:0x3F76,
	0xE99B9B:0x3F77,0xE68DAE:0x3F78,0xE69D89:0x3F79,0xE6A499:0x3F7A,0xE88F85:0x3F7B,
	0xE9A097:0x3F7C,0xE99B80:0x3F7D,0xE8A3BE:0x3F7E,0xE6BE84:0x4021,0xE691BA:0x4022,
	0xE5AFB8:0x4023,0xE4B896:0x4024,0xE780AC:0x4025,0xE7959D:0x4026,0xE698AF:0x4027,
	0xE58784:0x4028,0xE588B6:0x4029,0xE58BA2:0x402A,0xE5A793:0x402B,0xE5BE81:0x402C,
	0xE680A7:0x402D,0xE68890:0x402E,0xE694BF:0x402F,0xE695B4:0x4030,0xE6989F:0x4031,
	0xE699B4:0x4032,0xE6A3B2:0x4033,0xE6A096:0x4034,0xE6ADA3:0x4035,0xE6B885:0x4036,
	0xE789B2:0x4037,0xE7949F:0x4038,0xE79B9B:0x4039,0xE7B2BE:0x403A,0xE88196:0x403B,
	0xE5A3B0:0x403C,0xE8A3BD:0x403D,0xE8A5BF:0x403E,0xE8AAA0:0x403F,0xE8AA93:0x4040,
	0xE8AB8B:0x4041,0xE9809D:0x4042,0xE98692:0x4043,0xE99D92:0x4044,0xE99D99:0x4045,
	0xE69689:0x4046,0xE7A88E:0x4047,0xE88486:0x4048,0xE99ABB:0x4049,0xE5B8AD:0x404A,
	0xE6839C:0x404B,0xE6889A:0x404C,0xE696A5:0x404D,0xE69894:0x404E,0xE69E90:0x404F,
	0xE79FB3:0x4050,0xE7A98D:0x4051,0xE7B18D:0x4052,0xE7B8BE:0x4053,0xE8848A:0x4054,
	0xE8B2AC:0x4055,0xE8B5A4:0x4056,0xE8B7A1:0x4057,0xE8B99F:0x4058,0xE7A2A9:0x4059,
	0xE58887:0x405A,0xE68B99:0x405B,0xE68EA5:0x405C,0xE69182:0x405D,0xE68A98:0x405E,
	0xE8A8AD:0x405F,0xE7AA83:0x4060,0xE7AF80:0x4061,0xE8AAAC:0x4062,0xE99BAA:0x4063,
	0xE7B5B6:0x4064,0xE8888C:0x4065,0xE89D89:0x4066,0xE4BB99:0x4067,0xE58588:0x4068,
	0xE58D83:0x4069,0xE58DA0:0x406A,0xE5AEA3:0x406B,0xE5B082:0x406C,0xE5B096:0x406D,
	0xE5B79D:0x406E,0xE688A6:0x406F,0xE68987:0x4070,0xE692B0:0x4071,0xE6A093:0x4072,
	0xE6A0B4:0x4073,0xE6B389:0x4074,0xE6B585:0x4075,0xE6B497:0x4076,0xE69F93:0x4077,
	0xE6BD9C:0x4078,0xE7858E:0x4079,0xE785BD:0x407A,0xE6978B:0x407B,0xE7A9BF:0x407C,
	0xE7AEAD:0x407D,0xE7B79A:0x407E,0xE7B98A:0x4121,0xE7BEA8:0x4122,0xE885BA:0x4123,
	0xE8889B:0x4124,0xE888B9:0x4125,0xE896A6:0x4126,0xE8A9AE:0x4127,0xE8B38E:0x4128,
	0xE8B7B5:0x4129,0xE981B8:0x412A,0xE981B7:0x412B,0xE98AAD:0x412C,0xE98A91:0x412D,
	0xE99683:0x412E,0xE9AEAE:0x412F,0xE5898D:0x4130,0xE59684:0x4131,0xE6BCB8:0x4132,
	0xE784B6:0x4133,0xE585A8:0x4134,0xE7A685:0x4135,0xE7B995:0x4136,0xE886B3:0x4137,
	0xE7B38E:0x4138,0xE5998C:0x4139,0xE5A191:0x413A,0xE5B2A8:0x413B,0xE68EAA:0x413C,
	0xE69BBE:0x413D,0xE69BBD:0x413E,0xE6A59A:0x413F,0xE78B99:0x4140,0xE7968F:0x4141,
	0xE7968E:0x4142,0xE7A48E:0x4143,0xE7A596:0x4144,0xE7A79F:0x4145,0xE7B297:0x4146,
	0xE7B4A0:0x4147,0xE7B584:0x4148,0xE89887:0x4149,0xE8A8B4:0x414A,0xE998BB:0x414B,
	0xE981A1:0x414C,0xE9BCA0:0x414D,0xE583A7:0x414E,0xE589B5:0x414F,0xE58F8C:0x4150,
	0xE58FA2:0x4151,0xE58089:0x4152,0xE596AA:0x4153,0xE5A3AE:0x4154,0xE5A58F:0x4155,
	0xE788BD:0x4156,0xE5AE8B:0x4157,0xE5B1A4:0x4158,0xE58C9D:0x4159,0xE683A3:0x415A,
	0xE683B3:0x415B,0xE68D9C:0x415C,0xE68E83:0x415D,0xE68CBF:0x415E,0xE68EBB:0x415F,
	0xE6938D:0x4160,0xE697A9:0x4161,0xE69BB9:0x4162,0xE5B7A3:0x4163,0xE6A78D:0x4164,
	0xE6A7BD:0x4165,0xE6BC95:0x4166,0xE787A5:0x4167,0xE4BA89:0x4168,0xE797A9:0x4169,
	0xE79BB8:0x416A,0xE7AA93:0x416B,0xE7B39F:0x416C,0xE7B78F:0x416D,0xE7B69C:0x416E,
	0xE881A1:0x416F,0xE88D89:0x4170,0xE88D98:0x4171,0xE891AC:0x4172,0xE892BC:0x4173,
	0xE897BB:0x4174,0xE8A385:0x4175,0xE8B5B0:0x4176,0xE98081:0x4177,0xE981AD:0x4178,
	0xE98E97:0x4179,0xE99C9C:0x417A,0xE9A892:0x417B,0xE5838F:0x417C,0xE5A297:0x417D,
	0xE6868E:0x417E,0xE88793:0x4221,0xE894B5:0x4222,0xE8B488:0x4223,0xE980A0:0x4224,
	0xE4BF83:0x4225,0xE581B4:0x4226,0xE58987:0x4227,0xE58DB3:0x4228,0xE681AF:0x4229,
	0xE68D89:0x422A,0xE69D9F:0x422B,0xE6B8AC:0x422C,0xE8B6B3:0x422D,0xE9809F:0x422E,
	0xE4BF97:0x422F,0xE5B19E:0x4230,0xE8B38A:0x4231,0xE6978F:0x4232,0xE7B69A:0x4233,
	0xE58D92:0x4234,0xE8A296:0x4235,0xE585B6:0x4236,0xE68F83:0x4237,0xE5AD98:0x4238,
	0xE5ADAB:0x4239,0xE5B08A:0x423A,0xE6908D:0x423B,0xE69D91:0x423C,0xE9819C:0x423D,
	0xE4BB96:0x423E,0xE5A49A:0x423F,0xE5A4AA:0x4240,0xE6B1B0:0x4241,0xE8A991:0x4242,
	0xE594BE:0x4243,0xE5A095:0x4244,0xE5A6A5:0x4245,0xE683B0:0x4246,0xE68993:0x4247,
	0xE69F81:0x4248,0xE888B5:0x4249,0xE6A595:0x424A,0xE99980:0x424B,0xE9A784:0x424C,
	0xE9A8A8:0x424D,0xE4BD93:0x424E,0xE5A086:0x424F,0xE5AFBE:0x4250,0xE88090:0x4251,
	0xE5B2B1:0x4252,0xE5B8AF:0x4253,0xE5BE85:0x4254,0xE680A0:0x4255,0xE6858B:0x4256,
	0xE688B4:0x4257,0xE69BBF:0x4258,0xE6B3B0:0x4259,0xE6BB9E:0x425A,0xE8838E:0x425B,
	0xE885BF:0x425C,0xE88B94:0x425D,0xE8A28B:0x425E,0xE8B2B8:0x425F,0xE98080:0x4260,
	0xE980AE:0x4261,0xE99A8A:0x4262,0xE9BB9B:0x4263,0xE9AF9B:0x4264,0xE4BBA3:0x4265,
	0xE58FB0:0x4266,0xE5A4A7:0x4267,0xE7ACAC:0x4268,0xE9868D:0x4269,0xE9A18C:0x426A,
	0xE9B7B9:0x426B,0xE6BB9D:0x426C,0xE780A7:0x426D,0xE58D93:0x426E,0xE59584:0x426F,
	0xE5AE85:0x4270,0xE68998:0x4271,0xE68A9E:0x4272,0xE68B93:0x4273,0xE6B2A2:0x4274,
	0xE6BFAF:0x4275,0xE790A2:0x4276,0xE8A897:0x4277,0xE990B8:0x4278,0xE6BF81:0x4279,
	0xE8ABBE:0x427A,0xE88CB8:0x427B,0xE587A7:0x427C,0xE89BB8:0x427D,0xE58FAA:0x427E,
	0xE58FA9:0x4321,0xE4BD86:0x4322,0xE98194:0x4323,0xE8BEB0:0x4324,0xE5A5AA:0x4325,
	0xE884B1:0x4326,0xE5B7BD:0x4327,0xE7ABAA:0x4328,0xE8BEBF:0x4329,0xE6A39A:0x432A,
	0xE8B0B7:0x432B,0xE78BB8:0x432C,0xE9B188:0x432D,0xE6A8BD:0x432E,0xE8AAB0:0x432F,
	0xE4B8B9:0x4330,0xE58D98:0x4331,0xE59886:0x4332,0xE59DA6:0x4333,0xE68B85:0x4334,
	0xE68EA2:0x4335,0xE697A6:0x4336,0xE6AD8E:0x4337,0xE6B7A1:0x4338,0xE6B99B:0x4339,
	0xE782AD:0x433A,0xE79FAD:0x433B,0xE7ABAF:0x433C,0xE7AEAA:0x433D,0xE7B6BB:0x433E,
	0xE880BD:0x433F,0xE88386:0x4340,0xE89B8B:0x4341,0xE8AA95:0x4342,0xE98D9B:0x4343,
	0xE59BA3:0x4344,0xE5A387:0x4345,0xE5BCBE:0x4346,0xE696AD:0x4347,0xE69A96:0x4348,
	0xE6AA80:0x4349,0xE6AEB5:0x434A,0xE794B7:0x434B,0xE8AB87:0x434C,0xE580A4:0x434D,
	0xE79FA5:0x434E,0xE59CB0:0x434F,0xE5BC9B:0x4350,0xE681A5:0x4351,0xE699BA:0x4352,
	0xE6B1A0:0x4353,0xE797B4:0x4354,0xE7A89A:0x4355,0xE7BDAE:0x4356,0xE887B4:0x4357,
	0xE89C98:0x4358,0xE98185:0x4359,0xE9A6B3:0x435A,0xE7AF89:0x435B,0xE7959C:0x435C,
	0xE7ABB9:0x435D,0xE7AD91:0x435E,0xE89384:0x435F,0xE98090:0x4360,0xE7A7A9:0x4361,
	0xE7AA92:0x4362,0xE88CB6:0x4363,0xE5ABA1:0x4364,0xE79D80:0x4365,0xE4B8AD:0x4366,
	0xE4BBB2:0x4367,0xE5AE99:0x4368,0xE5BFA0:0x4369,0xE68ABD:0x436A,0xE698BC:0x436B,
	0xE69FB1:0x436C,0xE6B3A8:0x436D,0xE899AB:0x436E,0xE8A1B7:0x436F,0xE8A8BB:0x4370,
	0xE9858E:0x4371,0xE98BB3:0x4372,0xE9A790:0x4373,0xE6A897:0x4374,0xE780A6:0x4375,
	0xE78CAA:0x4376,0xE88BA7:0x4377,0xE89197:0x4378,0xE8B2AF:0x4379,0xE4B881:0x437A,
	0xE58586:0x437B,0xE5878B:0x437C,0xE5968B:0x437D,0xE5AFB5:0x437E,0xE5B896:0x4421,
	0xE5B8B3:0x4422,0xE5BA81:0x4423,0xE5BC94:0x4424,0xE5BCB5:0x4425,0xE5BDAB:0x4426,
	0xE5BEB4:0x4427,0xE687B2:0x4428,0xE68C91:0x4429,0xE69AA2:0x442A,0xE69C9D:0x442B,
	0xE6BDAE:0x442C,0xE78992:0x442D,0xE794BA:0x442E,0xE79CBA:0x442F,0xE881B4:0x4430,
	0xE884B9:0x4431,0xE885B8:0x4432,0xE89DB6:0x4433,0xE8AABF:0x4434,0xE8AB9C:0x4435,
	0xE8B685:0x4436,0xE8B7B3:0x4437,0xE98A9A:0x4438,0xE995B7:0x4439,0xE9A082:0x443A,
	0xE9B3A5:0x443B,0xE58B85:0x443C,0xE68D97:0x443D,0xE79BB4:0x443E,0xE69C95:0x443F,
	0xE6B288:0x4440,0xE78F8D:0x4441,0xE8B383:0x4442,0xE98EAE:0x4443,0xE999B3:0x4444,
	0xE6B4A5:0x4445,0xE5A29C:0x4446,0xE6A48E:0x4447,0xE6A78C:0x4448,0xE8BFBD:0x4449,
	0xE98E9A:0x444A,0xE7979B:0x444B,0xE9809A:0x444C,0xE5A19A:0x444D,0xE6A082:0x444E,
	0xE68EB4:0x444F,0xE6A7BB:0x4450,0xE4BD83:0x4451,0xE6BCAC:0x4452,0xE69F98:0x4453,
	0xE8BEBB:0x4454,0xE894A6:0x4455,0xE7B6B4:0x4456,0xE98D94:0x4457,0xE6A4BF:0x4458,
	0xE6BDB0:0x4459,0xE59DAA:0x445A,0xE5A3B7:0x445B,0xE5ACAC:0x445C,0xE7B4AC:0x445D,
	0xE788AA:0x445E,0xE5908A:0x445F,0xE987A3:0x4460,0xE9B6B4:0x4461,0xE4BAAD:0x4462,
	0xE4BD8E:0x4463,0xE5819C:0x4464,0xE581B5:0x4465,0xE58983:0x4466,0xE8B29E:0x4467,
	0xE59188:0x4468,0xE5A0A4:0x4469,0xE5AE9A:0x446A,0xE5B89D:0x446B,0xE5BA95:0x446C,
	0xE5BAAD:0x446D,0xE5BBB7:0x446E,0xE5BC9F:0x446F,0xE6828C:0x4470,0xE68AB5:0x4471,
	0xE68CBA:0x4472,0xE68F90:0x4473,0xE6A2AF:0x4474,0xE6B180:0x4475,0xE7A287:0x4476,
	0xE7A68E:0x4477,0xE7A88B:0x4478,0xE7B7A0:0x4479,0xE88987:0x447A,0xE8A882:0x447B,
	0xE8ABA6:0x447C,0xE8B984:0x447D,0xE98093:0x447E,0xE982B8:0x4521,0xE984AD:0x4522,
	0xE98798:0x4523,0xE9BC8E:0x4524,0xE6B3A5:0x4525,0xE69198:0x4526,0xE693A2:0x4527,
	0xE695B5:0x4528,0xE6BBB4:0x4529,0xE79A84:0x452A,0xE7AC9B:0x452B,0xE981A9:0x452C,
	0xE98F91:0x452D,0xE6BABA:0x452E,0xE593B2:0x452F,0xE5BEB9:0x4530,0xE692A4:0x4531,
	0xE8BD8D:0x4532,0xE8BFAD:0x4533,0xE98984:0x4534,0xE585B8:0x4535,0xE5A1AB:0x4536,
	0xE5A4A9:0x4537,0xE5B195:0x4538,0xE5BA97:0x4539,0xE6B7BB:0x453A,0xE7BA8F:0x453B,
	0xE7949C:0x453C,0xE8B2BC:0x453D,0xE8BBA2:0x453E,0xE9A19B:0x453F,0xE782B9:0x4540,
	0xE4BC9D:0x4541,0xE6AEBF:0x4542,0xE6BEB1:0x4543,0xE794B0:0x4544,0xE99BBB:0x4545,
	0xE5858E:0x4546,0xE59090:0x4547,0xE5A0B5:0x4548,0xE5A197:0x4549,0xE5A6AC:0x454A,
	0xE5B1A0:0x454B,0xE5BE92:0x454C,0xE69697:0x454D,0xE69D9C:0x454E,0xE6B8A1:0x454F,
	0xE799BB:0x4550,0xE88F9F:0x4551,0xE8B3AD:0x4552,0xE98094:0x4553,0xE983BD:0x4554,
	0xE98D8D:0x4555,0xE7A0A5:0x4556,0xE7A0BA:0x4557,0xE58AAA:0x4558,0xE5BAA6:0x4559,
	0xE59C9F:0x455A,0xE5A5B4:0x455B,0xE68092:0x455C,0xE58092:0x455D,0xE5859A:0x455E,
	0xE586AC:0x455F,0xE5878D:0x4560,0xE58880:0x4561,0xE59490:0x4562,0xE5A194:0x4563,
	0xE5A198:0x4564,0xE5A597:0x4565,0xE5AE95:0x4566,0xE5B3B6:0x4567,0xE5B68B:0x4568,
	0xE682BC:0x4569,0xE68A95:0x456A,0xE690AD:0x456B,0xE69DB1:0x456C,0xE6A183:0x456D,
	0xE6A2BC:0x456E,0xE6A39F:0x456F,0xE79B97:0x4570,0xE6B798:0x4571,0xE6B9AF:0x4572,
	0xE6B69B:0x4573,0xE781AF:0x4574,0xE78788:0x4575,0xE5BD93:0x4576,0xE79798:0x4577,
	0xE7A5B7:0x4578,0xE7AD89:0x4579,0xE7AD94:0x457A,0xE7AD92:0x457B,0xE7B396:0x457C,
	0xE7B5B1:0x457D,0xE588B0:0x457E,0xE891A3:0x4621,0xE895A9:0x4622,0xE897A4:0x4623,
	0xE8A88E:0x4624,0xE8AC84:0x4625,0xE8B186:0x4626,0xE8B88F:0x4627,0xE98083:0x4628,
	0xE9808F:0x4629,0xE99099:0x462A,0xE999B6:0x462B,0xE9A0AD:0x462C,0xE9A8B0:0x462D,
	0xE99798:0x462E,0xE5838D:0x462F,0xE58B95:0x4630,0xE5908C:0x4631,0xE5A082:0x4632,
	0xE5B08E:0x4633,0xE686A7:0x4634,0xE6929E:0x4635,0xE6B49E:0x4636,0xE79EB3:0x4637,
	0xE7ABA5:0x4638,0xE883B4:0x4639,0xE89084:0x463A,0xE98193:0x463B,0xE98A85:0x463C,
	0xE5B3A0:0x463D,0xE9B487:0x463E,0xE58CBF:0x463F,0xE5BE97:0x4640,0xE5BEB3:0x4641,
	0xE6B69C:0x4642,0xE789B9:0x4643,0xE79DA3:0x4644,0xE7A6BF:0x4645,0xE7AFA4:0x4646,
	0xE6AF92:0x4647,0xE78BAC:0x4648,0xE8AAAD:0x4649,0xE6A083:0x464A,0xE6A9A1:0x464B,
	0xE587B8:0x464C,0xE7AA81:0x464D,0xE6A4B4:0x464E,0xE5B18A:0x464F,0xE9B3B6:0x4650,
	0xE88BAB:0x4651,0xE5AF85:0x4652,0xE98589:0x4653,0xE7809E:0x4654,0xE599B8:0x4655,
	0xE5B1AF:0x4656,0xE68387:0x4657,0xE695A6:0x4658,0xE6B28C:0x4659,0xE8B19A:0x465A,
	0xE98181:0x465B,0xE9A093:0x465C,0xE59191:0x465D,0xE69B87:0x465E,0xE9888D:0x465F,
	0xE5A588:0x4660,0xE982A3:0x4661,0xE58685:0x4662,0xE4B98D:0x4663,0xE587AA:0x4664,
	0xE89699:0x4665,0xE8AC8E:0x4666,0xE78198:0x4667,0xE68DBA:0x4668,0xE98D8B:0x4669,
	0xE6A5A2:0x466A,0xE9A6B4:0x466B,0xE7B884:0x466C,0xE795B7:0x466D,0xE58D97:0x466E,
	0xE6A5A0:0x466F,0xE8BB9F:0x4670,0xE99BA3:0x4671,0xE6B19D:0x4672,0xE4BA8C:0x4673,
	0xE5B0BC:0x4674,0xE5BC90:0x4675,0xE8BFA9:0x4676,0xE58C82:0x4677,0xE8B391:0x4678,
	0xE88289:0x4679,0xE899B9:0x467A,0xE5BBBF:0x467B,0xE697A5:0x467C,0xE4B9B3:0x467D,
	0xE585A5:0x467E,0xE5A682:0x4721,0xE5B0BF:0x4722,0xE99FAE:0x4723,0xE4BBBB:0x4724,
	0xE5A68A:0x4725,0xE5BF8D:0x4726,0xE8AA8D:0x4727,0xE6BFA1:0x4728,0xE7A6B0:0x4729,
	0xE7A5A2:0x472A,0xE5AFA7:0x472B,0xE891B1:0x472C,0xE78CAB:0x472D,0xE786B1:0x472E,
	0xE5B9B4:0x472F,0xE5BFB5:0x4730,0xE68DBB:0x4731,0xE6929A:0x4732,0xE78783:0x4733,
	0xE7B298:0x4734,0xE4B983:0x4735,0xE5BBBC:0x4736,0xE4B98B:0x4737,0xE59F9C:0x4738,
	0xE59AA2:0x4739,0xE682A9:0x473A,0xE6BF83:0x473B,0xE7B48D:0x473C,0xE883BD:0x473D,
	0xE884B3:0x473E,0xE886BF:0x473F,0xE8BEB2:0x4740,0xE8A697:0x4741,0xE89AA4:0x4742,
	0xE5B7B4:0x4743,0xE68A8A:0x4744,0xE692AD:0x4745,0xE8A687:0x4746,0xE69DB7:0x4747,
	0xE6B3A2:0x4748,0xE6B4BE:0x4749,0xE790B6:0x474A,0xE7A0B4:0x474B,0xE5A986:0x474C,
	0xE7BDB5:0x474D,0xE88AAD:0x474E,0xE9A6AC:0x474F,0xE4BFB3:0x4750,0xE5BB83:0x4751,
	0xE68B9D:0x4752,0xE68E92:0x4753,0xE69597:0x4754,0xE69DAF:0x4755,0xE79B83:0x4756,
	0xE7898C:0x4757,0xE8838C:0x4758,0xE882BA:0x4759,0xE8BCA9:0x475A,0xE9858D:0x475B,
	0xE5808D:0x475C,0xE59FB9:0x475D,0xE5AA92:0x475E,0xE6A285:0x475F,0xE6A5B3:0x4760,
	0xE785A4:0x4761,0xE78BBD:0x4762,0xE8B2B7:0x4763,0xE5A3B2:0x4764,0xE8B3A0:0x4765,
	0xE999AA:0x4766,0xE98099:0x4767,0xE89DBF:0x4768,0xE7A7A4:0x4769,0xE79FA7:0x476A,
	0xE890A9:0x476B,0xE4BCAF:0x476C,0xE589A5:0x476D,0xE58D9A:0x476E,0xE68B8D:0x476F,
	0xE69F8F:0x4770,0xE6B38A:0x4771,0xE799BD:0x4772,0xE7AE94:0x4773,0xE7B295:0x4774,
	0xE888B6:0x4775,0xE89684:0x4776,0xE8BFAB:0x4777,0xE69B9D:0x4778,0xE6BCA0:0x4779,
	0xE78886:0x477A,0xE7B89B:0x477B,0xE88EAB:0x477C,0xE9A781:0x477D,0xE9BAA6:0x477E,
	0xE587BD:0x4821,0xE7AEB1:0x4822,0xE7A1B2:0x4823,0xE7AEB8:0x4824,0xE88287:0x4825,
	0xE7AD88:0x4826,0xE6ABA8:0x4827,0xE5B9A1:0x4828,0xE8828C:0x4829,0xE79591:0x482A,
	0xE795A0:0x482B,0xE585AB:0x482C,0xE989A2:0x482D,0xE6BA8C:0x482E,0xE799BA:0x482F,
	0xE98697:0x4830,0xE9ABAA:0x4831,0xE4BC90:0x4832,0xE7BDB0:0x4833,0xE68A9C:0x4834,
	0xE7AD8F:0x4835,0xE996A5:0x4836,0xE9B3A9:0x4837,0xE599BA:0x4838,0xE5A199:0x4839,
	0xE89BA4:0x483A,0xE99ABC:0x483B,0xE4BCB4:0x483C,0xE588A4:0x483D,0xE58D8A:0x483E,
	0xE58F8D:0x483F,0xE58F9B:0x4840,0xE5B886:0x4841,0xE690AC:0x4842,0xE69691:0x4843,
	0xE69DBF:0x4844,0xE6B0BE:0x4845,0xE6B18E:0x4846,0xE78988:0x4847,0xE78AAF:0x4848,
	0xE78FAD:0x4849,0xE79594:0x484A,0xE7B981:0x484B,0xE888AC:0x484C,0xE897A9:0x484D,
	0xE8B2A9:0x484E,0xE7AF84:0x484F,0xE98786:0x4850,0xE785A9:0x4851,0xE9A092:0x4852,
	0xE9A3AF:0x4853,0xE68CBD:0x4854,0xE699A9:0x4855,0xE795AA:0x4856,0xE79BA4:0x4857,
	0xE7A390:0x4858,0xE89583:0x4859,0xE89BAE:0x485A,0xE58CAA:0x485B,0xE58D91:0x485C,
	0xE590A6:0x485D,0xE5A683:0x485E,0xE5BA87:0x485F,0xE5BDBC:0x4860,0xE682B2:0x4861,
	0xE68989:0x4862,0xE689B9:0x4863,0xE68AAB:0x4864,0xE69690:0x4865,0xE6AF94:0x4866,
	0xE6B38C:0x4867,0xE796B2:0x4868,0xE79AAE:0x4869,0xE7A291:0x486A,0xE7A798:0x486B,
	0xE7B78B:0x486C,0xE7BDB7:0x486D,0xE882A5:0x486E,0xE8A2AB:0x486F,0xE8AAB9:0x4870,
	0xE8B2BB:0x4871,0xE981BF:0x4872,0xE99D9E:0x4873,0xE9A39B:0x4874,0xE6A88B:0x4875,
	0xE7B0B8:0x4876,0xE58299:0x4877,0xE5B0BE:0x4878,0xE5BEAE:0x4879,0xE69E87:0x487A,
	0xE6AF98:0x487B,0xE790B5:0x487C,0xE79C89:0x487D,0xE7BE8E:0x487E,0xE9BCBB:0x4921,
	0xE69F8A:0x4922,0xE7A897:0x4923,0xE58CB9:0x4924,0xE7968B:0x4925,0xE9ABAD:0x4926,
	0xE5BDA6:0x4927,0xE8869D:0x4928,0xE88FB1:0x4929,0xE88298:0x492A,0xE5BCBC:0x492B,
	0xE5BF85:0x492C,0xE795A2:0x492D,0xE7AD86:0x492E,0xE980BC:0x492F,0xE6A1A7:0x4930,
	0xE5A7AB:0x4931,0xE5AA9B:0x4932,0xE7B490:0x4933,0xE799BE:0x4934,0xE8ACAC:0x4935,
	0xE4BFB5:0x4936,0xE5BDAA:0x4937,0xE6A899:0x4938,0xE6B0B7:0x4939,0xE6BC82:0x493A,
	0xE793A2:0x493B,0xE7A5A8:0x493C,0xE8A1A8:0x493D,0xE8A995:0x493E,0xE8B1B9:0x493F,
	0xE5BB9F:0x4940,0xE68F8F:0x4941,0xE79785:0x4942,0xE7A792:0x4943,0xE88B97:0x4944,
	0xE98CA8:0x4945,0xE98BB2:0x4946,0xE8929C:0x4947,0xE89BAD:0x4948,0xE9B0AD:0x4949,
	0xE59381:0x494A,0xE5BDAC:0x494B,0xE6968C:0x494C,0xE6B59C:0x494D,0xE78095:0x494E,
	0xE8B2A7:0x494F,0xE8B393:0x4950,0xE9A0BB:0x4951,0xE6958F:0x4952,0xE793B6:0x4953,
	0xE4B88D:0x4954,0xE4BB98:0x4955,0xE59FA0:0x4956,0xE5A4AB:0x4957,0xE5A9A6:0x4958,
	0xE5AF8C:0x4959,0xE586A8:0x495A,0xE5B883:0x495B,0xE5BA9C:0x495C,0xE68096:0x495D,
	0xE689B6:0x495E,0xE695B7:0x495F,0xE696A7:0x4960,0xE699AE:0x4961,0xE6B5AE:0x4962,
	0xE788B6:0x4963,0xE7ACA6:0x4964,0xE88590:0x4965,0xE8869A:0x4966,0xE88A99:0x4967,
	0xE8AD9C:0x4968,0xE8B2A0:0x4969,0xE8B3A6:0x496A,0xE8B5B4:0x496B,0xE9989C:0x496C,
	0xE99984:0x496D,0xE4BEAE:0x496E,0xE692AB:0x496F,0xE6ADA6:0x4970,0xE8889E:0x4971,
	0xE891A1:0x4972,0xE895AA:0x4973,0xE983A8:0x4974,0xE5B081:0x4975,0xE6A593:0x4976,
	0xE9A2A8:0x4977,0xE891BA:0x4978,0xE89597:0x4979,0xE4BC8F:0x497A,0xE589AF:0x497B,
	0xE5BEA9:0x497C,0xE5B985:0x497D,0xE69C8D:0x497E,0xE7A68F:0x4A21,0xE885B9:0x4A22,
	0xE8A487:0x4A23,0xE8A686:0x4A24,0xE6B7B5:0x4A25,0xE5BC97:0x4A26,0xE68995:0x4A27,
	0xE6B2B8:0x4A28,0xE4BB8F:0x4A29,0xE789A9:0x4A2A,0xE9AE92:0x4A2B,0xE58886:0x4A2C,
	0xE590BB:0x4A2D,0xE599B4:0x4A2E,0xE5A2B3:0x4A2F,0xE686A4:0x4A30,0xE689AE:0x4A31,
	0xE7849A:0x4A32,0xE5A5AE:0x4A33,0xE7B289:0x4A34,0xE7B39E:0x4A35,0xE7B49B:0x4A36,
	0xE99BB0:0x4A37,0xE69687:0x4A38,0xE8819E:0x4A39,0xE4B899:0x4A3A,0xE4BDB5:0x4A3B,
	0xE585B5:0x4A3C,0xE5A180:0x4A3D,0xE5B9A3:0x4A3E,0xE5B9B3:0x4A3F,0xE5BC8A:0x4A40,
	0xE69F84:0x4A41,0xE4B8A6:0x4A42,0xE894BD:0x4A43,0xE99689:0x4A44,0xE9999B:0x4A45,
	0xE7B1B3:0x4A46,0xE9A081:0x4A47,0xE583BB:0x4A48,0xE5A381:0x4A49,0xE79996:0x4A4A,
	0xE7A2A7:0x4A4B,0xE588A5:0x4A4C,0xE79EA5:0x4A4D,0xE89491:0x4A4E,0xE7AE86:0x4A4F,
	0xE5818F:0x4A50,0xE5A489:0x4A51,0xE78987:0x4A52,0xE7AF87:0x4A53,0xE7B7A8:0x4A54,
	0xE8BEBA:0x4A55,0xE8BF94:0x4A56,0xE9818D:0x4A57,0xE4BEBF:0x4A58,0xE58B89:0x4A59,
	0xE5A8A9:0x4A5A,0xE5BC81:0x4A5B,0xE99EAD:0x4A5C,0xE4BF9D:0x4A5D,0xE88897:0x4A5E,
	0xE98BAA:0x4A5F,0xE59C83:0x4A60,0xE68D95:0x4A61,0xE6ADA9:0x4A62,0xE794AB:0x4A63,
	0xE8A39C:0x4A64,0xE8BC94:0x4A65,0xE7A982:0x4A66,0xE58B9F:0x4A67,0xE5A293:0x4A68,
	0xE68595:0x4A69,0xE6888A:0x4A6A,0xE69AAE:0x4A6B,0xE6AF8D:0x4A6C,0xE7B0BF:0x4A6D,
	0xE88FA9:0x4A6E,0xE580A3:0x4A6F,0xE4BFB8:0x4A70,0xE58C85:0x4A71,0xE59186:0x4A72,
	0xE5A0B1:0x4A73,0xE5A589:0x4A74,0xE5AE9D:0x4A75,0xE5B3B0:0x4A76,0xE5B3AF:0x4A77,
	0xE5B4A9:0x4A78,0xE5BA96:0x4A79,0xE68AB1:0x4A7A,0xE68DA7:0x4A7B,0xE694BE:0x4A7C,
	0xE696B9:0x4A7D,0xE69C8B:0x4A7E,0xE6B395:0x4B21,0xE6B3A1:0x4B22,0xE783B9:0x4B23,
	0xE7A0B2:0x4B24,0xE7B8AB:0x4B25,0xE8839E:0x4B26,0xE88AB3:0x4B27,0xE8908C:0x4B28,
	0xE893AC:0x4B29,0xE89C82:0x4B2A,0xE8A492:0x4B2B,0xE8A8AA:0x4B2C,0xE8B18A:0x4B2D,
	0xE982A6:0x4B2E,0xE98B92:0x4B2F,0xE9A3BD:0x4B30,0xE9B3B3:0x4B31,0xE9B5AC:0x4B32,
	0xE4B98F:0x4B33,0xE4BAA1:0x4B34,0xE5828D:0x4B35,0xE58996:0x4B36,0xE59D8A:0x4B37,
	0xE5A6A8:0x4B38,0xE5B8BD:0x4B39,0xE5BF98:0x4B3A,0xE5BF99:0x4B3B,0xE688BF:0x4B3C,
	0xE69AB4:0x4B3D,0xE69C9B:0x4B3E,0xE69F90:0x4B3F,0xE6A392:0x4B40,0xE58692:0x4B41,
	0xE7B4A1:0x4B42,0xE882AA:0x4B43,0xE886A8:0x4B44,0xE8AC80:0x4B45,0xE8B28C:0x4B46,
	0xE8B2BF:0x4B47,0xE989BE:0x4B48,0xE998B2:0x4B49,0xE590A0:0x4B4A,0xE9A0AC:0x4B4B,
	0xE58C97:0x4B4C,0xE58395:0x4B4D,0xE58D9C:0x4B4E,0xE5A2A8:0x4B4F,0xE692B2:0x4B50,
	0xE69CB4:0x4B51,0xE789A7:0x4B52,0xE79DA6:0x4B53,0xE7A986:0x4B54,0xE987A6:0x4B55,
	0xE58B83:0x4B56,0xE6B2A1:0x4B57,0xE6AE86:0x4B58,0xE5A080:0x4B59,0xE5B98C:0x4B5A,
	0xE5A594:0x4B5B,0xE69CAC:0x4B5C,0xE7BFBB:0x4B5D,0xE587A1:0x4B5E,0xE79B86:0x4B5F,
	0xE691A9:0x4B60,0xE7A3A8:0x4B61,0xE9AD94:0x4B62,0xE9BABB:0x4B63,0xE59F8B:0x4B64,
	0xE5A6B9:0x4B65,0xE698A7:0x4B66,0xE69E9A:0x4B67,0xE6AF8E:0x4B68,0xE593A9:0x4B69,
	0xE6A799:0x4B6A,0xE5B995:0x4B6B,0xE8869C:0x4B6C,0xE69E95:0x4B6D,0xE9AEAA:0x4B6E,
	0xE69FBE:0x4B6F,0xE9B192:0x4B70,0xE6A19D:0x4B71,0xE4BAA6:0x4B72,0xE4BFA3:0x4B73,
	0xE58F88:0x4B74,0xE68AB9:0x4B75,0xE69CAB:0x4B76,0xE6B2AB:0x4B77,0xE8BF84:0x4B78,
	0xE4BEAD:0x4B79,0xE7B9AD:0x4B7A,0xE9BABF:0x4B7B,0xE4B887:0x4B7C,0xE685A2:0x4B7D,
	0xE6BA80:0x4B7E,0xE6BCAB:0x4C21,0xE89493:0x4C22,0xE591B3:0x4C23,0xE69CAA:0x4C24,
	0xE9AD85:0x4C25,0xE5B7B3:0x4C26,0xE7AE95:0x4C27,0xE5B2AC:0x4C28,0xE5AF86:0x4C29,
	0xE89C9C:0x4C2A,0xE6B98A:0x4C2B,0xE89391:0x4C2C,0xE7A894:0x4C2D,0xE88488:0x4C2E,
	0xE5A699:0x4C2F,0xE7B28D:0x4C30,0xE6B091:0x4C31,0xE79CA0:0x4C32,0xE58B99:0x4C33,
	0xE5A4A2:0x4C34,0xE784A1:0x4C35,0xE7899F:0x4C36,0xE79F9B:0x4C37,0xE99CA7:0x4C38,
	0xE9B5A1:0x4C39,0xE6A48B:0x4C3A,0xE5A9BF:0x4C3B,0xE5A898:0x4C3C,0xE586A5:0x4C3D,
	0xE5908D:0x4C3E,0xE591BD:0x4C3F,0xE6988E:0x4C40,0xE79B9F:0x4C41,0xE8BFB7:0x4C42,
	0xE98A98:0x4C43,0xE9B3B4:0x4C44,0xE5A7AA:0x4C45,0xE7899D:0x4C46,0xE6BB85:0x4C47,
	0xE5858D:0x4C48,0xE6A389:0x4C49,0xE7B6BF:0x4C4A,0xE7B7AC:0x4C4B,0xE99DA2:0x4C4C,
	0xE9BABA:0x4C4D,0xE691B8:0x4C4E,0xE6A8A1:0x4C4F,0xE88C82:0x4C50,0xE5A684:0x4C51,
	0xE5AD9F:0x4C52,0xE6AF9B:0x4C53,0xE78C9B:0x4C54,0xE79BB2:0x4C55,0xE7B6B2:0x4C56,
	0xE88097:0x4C57,0xE89299:0x4C58,0xE584B2:0x4C59,0xE69CA8:0x4C5A,0xE9BB99:0x4C5B,
	0xE79BAE:0x4C5C,0xE69DA2:0x4C5D,0xE58BBF:0x4C5E,0xE9A485:0x4C5F,0xE5B0A4:0x4C60,
	0xE688BB:0x4C61,0xE7B1BE:0x4C62,0xE8B2B0:0x4C63,0xE5958F:0x4C64,0xE682B6:0x4C65,
	0xE7B48B:0x4C66,0xE99680:0x4C67,0xE58C81:0x4C68,0xE4B99F:0x4C69,0xE586B6:0x4C6A,
	0xE5A49C:0x4C6B,0xE788BA:0x4C6C,0xE880B6:0x4C6D,0xE9878E:0x4C6E,0xE5BCA5:0x4C6F,
	0xE79FA2:0x4C70,0xE58E84:0x4C71,0xE5BDB9:0x4C72,0xE7B484:0x4C73,0xE896AC:0x4C74,
	0xE8A8B3:0x4C75,0xE8BA8D:0x4C76,0xE99D96:0x4C77,0xE69FB3:0x4C78,0xE896AE:0x4C79,
	0xE99193:0x4C7A,0xE68489:0x4C7B,0xE68488:0x4C7C,0xE6B2B9:0x4C7D,0xE79992:0x4C7E,
	0xE8ABAD:0x4D21,0xE8BCB8:0x4D22,0xE594AF:0x4D23,0xE4BD91:0x4D24,0xE584AA:0x4D25,
	0xE58B87:0x4D26,0xE58F8B:0x4D27,0xE5AEA5:0x4D28,0xE5B9BD:0x4D29,0xE682A0:0x4D2A,
	0xE68682:0x4D2B,0xE68F96:0x4D2C,0xE69C89:0x4D2D,0xE69F9A:0x4D2E,0xE6B9A7:0x4D2F,
	0xE6B68C:0x4D30,0xE78CB6:0x4D31,0xE78CB7:0x4D32,0xE794B1:0x4D33,0xE7A590:0x4D34,
	0xE8A395:0x4D35,0xE8AA98:0x4D36,0xE9818A:0x4D37,0xE98291:0x4D38,0xE983B5:0x4D39,
	0xE99B84:0x4D3A,0xE89E8D:0x4D3B,0xE5A495:0x4D3C,0xE4BA88:0x4D3D,0xE4BD99:0x4D3E,
	0xE4B88E:0x4D3F,0xE8AA89:0x4D40,0xE8BCBF:0x4D41,0xE9A090:0x4D42,0xE582AD:0x4D43,
	0xE5B9BC:0x4D44,0xE5A696:0x4D45,0xE5AEB9:0x4D46,0xE5BAB8:0x4D47,0xE68F9A:0x4D48,
	0xE68FBA:0x4D49,0xE69381:0x4D4A,0xE69B9C:0x4D4B,0xE6A58A:0x4D4C,0xE6A798:0x4D4D,
	0xE6B48B:0x4D4E,0xE6BAB6:0x4D4F,0xE78694:0x4D50,0xE794A8:0x4D51,0xE7AAAF:0x4D52,
	0xE7BE8A:0x4D53,0xE88080:0x4D54,0xE89189:0x4D55,0xE89389:0x4D56,0xE8A681:0x4D57,
	0xE8ACA1:0x4D58,0xE8B88A:0x4D59,0xE981A5:0x4D5A,0xE999BD:0x4D5B,0xE9A48A:0x4D5C,
	0xE685BE:0x4D5D,0xE68A91:0x4D5E,0xE6ACB2:0x4D5F,0xE6B283:0x4D60,0xE6B5B4:0x4D61,
	0xE7BF8C:0x4D62,0xE7BFBC:0x4D63,0xE6B780:0x4D64,0xE7BE85:0x4D65,0xE89EBA:0x4D66,
	0xE8A3B8:0x4D67,0xE69DA5:0x4D68,0xE88EB1:0x4D69,0xE9A0BC:0x4D6A,0xE99BB7:0x4D6B,
	0xE6B49B:0x4D6C,0xE7B5A1:0x4D6D,0xE890BD:0x4D6E,0xE985AA:0x4D6F,0xE4B9B1:0x4D70,
	0xE58DB5:0x4D71,0xE5B590:0x4D72,0xE6AC84:0x4D73,0xE6BFAB:0x4D74,0xE8978D:0x4D75,
	0xE898AD:0x4D76,0xE8A6A7:0x4D77,0xE588A9:0x4D78,0xE5908F:0x4D79,0xE5B1A5:0x4D7A,
	0xE69D8E:0x4D7B,0xE6A2A8:0x4D7C,0xE79086:0x4D7D,0xE79283:0x4D7E,0xE797A2:0x4E21,
	0xE8A38F:0x4E22,0xE8A3A1:0x4E23,0xE9878C:0x4E24,0xE99BA2:0x4E25,0xE999B8:0x4E26,
	0xE5BE8B:0x4E27,0xE78E87:0x4E28,0xE7AB8B:0x4E29,0xE8918E:0x4E2A,0xE68EA0:0x4E2B,
	0xE795A5:0x4E2C,0xE58A89:0x4E2D,0xE6B581:0x4E2E,0xE6BA9C:0x4E2F,0xE79089:0x4E30,
	0xE79599:0x4E31,0xE7A1AB:0x4E32,0xE7B292:0x4E33,0xE99A86:0x4E34,0xE7AB9C:0x4E35,
	0xE9BE8D:0x4E36,0xE4BEB6:0x4E37,0xE685AE:0x4E38,0xE69785:0x4E39,0xE8999C:0x4E3A,
	0xE4BA86:0x4E3B,0xE4BAAE:0x4E3C,0xE5839A:0x4E3D,0xE4B8A1:0x4E3E,0xE5878C:0x4E3F,
	0xE5AFAE:0x4E40,0xE69699:0x4E41,0xE6A281:0x4E42,0xE6B6BC:0x4E43,0xE78C9F:0x4E44,
	0xE79982:0x4E45,0xE79EAD:0x4E46,0xE7A89C:0x4E47,0xE7B3A7:0x4E48,0xE889AF:0x4E49,
	0xE8AB92:0x4E4A,0xE981BC:0x4E4B,0xE9878F:0x4E4C,0xE999B5:0x4E4D,0xE9A098:0x4E4E,
	0xE58A9B:0x4E4F,0xE7B791:0x4E50,0xE580AB:0x4E51,0xE58E98:0x4E52,0xE69E97:0x4E53,
	0xE6B78B:0x4E54,0xE78790:0x4E55,0xE790B3:0x4E56,0xE887A8:0x4E57,0xE8BCAA:0x4E58,
	0xE99AA3:0x4E59,0xE9B197:0x4E5A,0xE9BA9F:0x4E5B,0xE791A0:0x4E5C,0xE5A181:0x4E5D,
	0xE6B699:0x4E5E,0xE7B4AF:0x4E5F,0xE9A19E:0x4E60,0xE4BBA4:0x4E61,0xE4BCB6:0x4E62,
	0xE4BE8B:0x4E63,0xE586B7:0x4E64,0xE58AB1:0x4E65,0xE5B6BA:0x4E66,0xE6809C:0x4E67,
	0xE78EB2:0x4E68,0xE7A4BC:0x4E69,0xE88B93:0x4E6A,0xE988B4:0x4E6B,0xE99AB7:0x4E6C,
	0xE99BB6:0x4E6D,0xE99C8A:0x4E6E,0xE9BA97:0x4E6F,0xE9BDA2:0x4E70,0xE69AA6:0x4E71,
	0xE6ADB4:0x4E72,0xE58897:0x4E73,0xE58AA3:0x4E74,0xE78388:0x4E75,0xE8A382:0x4E76,
	0xE5BB89:0x4E77,0xE6818B:0x4E78,0xE68690:0x4E79,0xE6BCA3:0x4E7A,0xE78589:0x4E7B,
	0xE7B0BE:0x4E7C,0xE7B7B4:0x4E7D,0xE881AF:0x4E7E,0xE893AE:0x4F21,0xE980A3:0x4F22,
	0xE98CAC:0x4F23,0xE59182:0x4F24,0xE9ADAF:0x4F25,0xE6AB93:0x4F26,0xE78289:0x4F27,
	0xE8B382:0x4F28,0xE8B7AF:0x4F29,0xE99CB2:0x4F2A,0xE58AB4:0x4F2B,0xE5A981:0x4F2C,
	0xE5BB8A:0x4F2D,0xE5BC84:0x4F2E,0xE69C97:0x4F2F,0xE6A5BC:0x4F30,0xE6A694:0x4F31,
	0xE6B5AA:0x4F32,0xE6BC8F:0x4F33,0xE789A2:0x4F34,0xE78BBC:0x4F35,0xE7AFAD:0x4F36,
	0xE88081:0x4F37,0xE881BE:0x4F38,0xE89D8B:0x4F39,0xE9838E:0x4F3A,0xE585AD:0x4F3B,
	0xE9BA93:0x4F3C,0xE7A684:0x4F3D,0xE8828B:0x4F3E,0xE98CB2:0x4F3F,0xE8AB96:0x4F40,
	0xE580AD:0x4F41,0xE5928C:0x4F42,0xE8A9B1:0x4F43,0xE6ADAA:0x4F44,0xE8B384:0x4F45,
	0xE88487:0x4F46,0xE68391:0x4F47,0xE69EA0:0x4F48,0xE9B7B2:0x4F49,0xE4BA99:0x4F4A,
	0xE4BA98:0x4F4B,0xE9B090:0x4F4C,0xE8A9AB:0x4F4D,0xE89781:0x4F4E,0xE895A8:0x4F4F,
	0xE6A480:0x4F50,0xE6B9BE:0x4F51,0xE7A297:0x4F52,0xE88595:0x4F53,0xE5BC8C:0x5021,
	0xE4B890:0x5022,0xE4B895:0x5023,0xE4B8AA:0x5024,0xE4B8B1:0x5025,0xE4B8B6:0x5026,
	0xE4B8BC:0x5027,0xE4B8BF:0x5028,0xE4B982:0x5029,0xE4B996:0x502A,0xE4B998:0x502B,
	0xE4BA82:0x502C,0xE4BA85:0x502D,0xE8B1AB:0x502E,0xE4BA8A:0x502F,0xE88892:0x5030,
	0xE5BC8D:0x5031,0xE4BA8E:0x5032,0xE4BA9E:0x5033,0xE4BA9F:0x5034,0xE4BAA0:0x5035,
	0xE4BAA2:0x5036,0xE4BAB0:0x5037,0xE4BAB3:0x5038,0xE4BAB6:0x5039,0xE4BB8E:0x503A,
	0xE4BB8D:0x503B,0xE4BB84:0x503C,0xE4BB86:0x503D,0xE4BB82:0x503E,0xE4BB97:0x503F,
	0xE4BB9E:0x5040,0xE4BBAD:0x5041,0xE4BB9F:0x5042,0xE4BBB7:0x5043,0xE4BC89:0x5044,
	0xE4BD9A:0x5045,0xE4BCB0:0x5046,0xE4BD9B:0x5047,0xE4BD9D:0x5048,0xE4BD97:0x5049,
	0xE4BD87:0x504A,0xE4BDB6:0x504B,0xE4BE88:0x504C,0xE4BE8F:0x504D,0xE4BE98:0x504E,
	0xE4BDBB:0x504F,0xE4BDA9:0x5050,0xE4BDB0:0x5051,0xE4BE91:0x5052,0xE4BDAF:0x5053,
	0xE4BE86:0x5054,0xE4BE96:0x5055,0xE58498:0x5056,0xE4BF94:0x5057,0xE4BF9F:0x5058,
	0xE4BF8E:0x5059,0xE4BF98:0x505A,0xE4BF9B:0x505B,0xE4BF91:0x505C,0xE4BF9A:0x505D,
	0xE4BF90:0x505E,0xE4BFA4:0x505F,0xE4BFA5:0x5060,0xE5809A:0x5061,0xE580A8:0x5062,
	0xE58094:0x5063,0xE580AA:0x5064,0xE580A5:0x5065,0xE58085:0x5066,0xE4BC9C:0x5067,
	0xE4BFB6:0x5068,0xE580A1:0x5069,0xE580A9:0x506A,0xE580AC:0x506B,0xE4BFBE:0x506C,
	0xE4BFAF:0x506D,0xE58091:0x506E,0xE58086:0x506F,0xE58183:0x5070,0xE58187:0x5071,
	0xE69C83:0x5072,0xE58195:0x5073,0xE58190:0x5074,0xE58188:0x5075,0xE5819A:0x5076,
	0xE58196:0x5077,0xE581AC:0x5078,0xE581B8:0x5079,0xE58280:0x507A,0xE5829A:0x507B,
	0xE58285:0x507C,0xE582B4:0x507D,0xE582B2:0x507E,0xE58389:0x5121,0xE5838A:0x5122,
	0xE582B3:0x5123,0xE58382:0x5124,0xE58396:0x5125,0xE5839E:0x5126,0xE583A5:0x5127,
	0xE583AD:0x5128,0xE583A3:0x5129,0xE583AE:0x512A,0xE583B9:0x512B,0xE583B5:0x512C,
	0xE58489:0x512D,0xE58481:0x512E,0xE58482:0x512F,0xE58496:0x5130,0xE58495:0x5131,
	0xE58494:0x5132,0xE5849A:0x5133,0xE584A1:0x5134,0xE584BA:0x5135,0xE584B7:0x5136,
	0xE584BC:0x5137,0xE584BB:0x5138,0xE584BF:0x5139,0xE58580:0x513A,0xE58592:0x513B,
	0xE5858C:0x513C,0xE58594:0x513D,0xE585A2:0x513E,0xE7ABB8:0x513F,0xE585A9:0x5140,
	0xE585AA:0x5141,0xE585AE:0x5142,0xE58680:0x5143,0xE58682:0x5144,0xE59B98:0x5145,
	0xE5868C:0x5146,0xE58689:0x5147,0xE5868F:0x5148,0xE58691:0x5149,0xE58693:0x514A,
	0xE58695:0x514B,0xE58696:0x514C,0xE586A4:0x514D,0xE586A6:0x514E,0xE586A2:0x514F,
	0xE586A9:0x5150,0xE586AA:0x5151,0xE586AB:0x5152,0xE586B3:0x5153,0xE586B1:0x5154,
	0xE586B2:0x5155,0xE586B0:0x5156,0xE586B5:0x5157,0xE586BD:0x5158,0xE58785:0x5159,
	0xE58789:0x515A,0xE5879B:0x515B,0xE587A0:0x515C,0xE89995:0x515D,0xE587A9:0x515E,
	0xE587AD:0x515F,0xE587B0:0x5160,0xE587B5:0x5161,0xE587BE:0x5162,0xE58884:0x5163,
	0xE5888B:0x5164,0xE58894:0x5165,0xE5888E:0x5166,0xE588A7:0x5167,0xE588AA:0x5168,
	0xE588AE:0x5169,0xE588B3:0x516A,0xE588B9:0x516B,0xE5898F:0x516C,0xE58984:0x516D,
	0xE5898B:0x516E,0xE5898C:0x516F,0xE5899E:0x5170,0xE58994:0x5171,0xE589AA:0x5172,
	0xE589B4:0x5173,0xE589A9:0x5174,0xE589B3:0x5175,0xE589BF:0x5176,0xE589BD:0x5177,
	0xE58A8D:0x5178,0xE58A94:0x5179,0xE58A92:0x517A,0xE589B1:0x517B,0xE58A88:0x517C,
	0xE58A91:0x517D,0xE8BEA8:0x517E,0xE8BEA7:0x5221,0xE58AAC:0x5222,0xE58AAD:0x5223,
	0xE58ABC:0x5224,0xE58AB5:0x5225,0xE58B81:0x5226,0xE58B8D:0x5227,0xE58B97:0x5228,
	0xE58B9E:0x5229,0xE58BA3:0x522A,0xE58BA6:0x522B,0xE9A3AD:0x522C,0xE58BA0:0x522D,
	0xE58BB3:0x522E,0xE58BB5:0x522F,0xE58BB8:0x5230,0xE58BB9:0x5231,0xE58C86:0x5232,
	0xE58C88:0x5233,0xE794B8:0x5234,0xE58C8D:0x5235,0xE58C90:0x5236,0xE58C8F:0x5237,
	0xE58C95:0x5238,0xE58C9A:0x5239,0xE58CA3:0x523A,0xE58CAF:0x523B,0xE58CB1:0x523C,
	0xE58CB3:0x523D,0xE58CB8:0x523E,0xE58D80:0x523F,0xE58D86:0x5240,0xE58D85:0x5241,
	0xE4B897:0x5242,0xE58D89:0x5243,0xE58D8D:0x5244,0xE58796:0x5245,0xE58D9E:0x5246,
	0xE58DA9:0x5247,0xE58DAE:0x5248,0xE5A498:0x5249,0xE58DBB:0x524A,0xE58DB7:0x524B,
	0xE58E82:0x524C,0xE58E96:0x524D,0xE58EA0:0x524E,0xE58EA6:0x524F,0xE58EA5:0x5250,
	0xE58EAE:0x5251,0xE58EB0:0x5252,0xE58EB6:0x5253,0xE58F83:0x5254,0xE7B092:0x5255,
	0xE99B99:0x5256,0xE58F9F:0x5257,0xE69BBC:0x5258,0xE787AE:0x5259,0xE58FAE:0x525A,
	0xE58FA8:0x525B,0xE58FAD:0x525C,0xE58FBA:0x525D,0xE59081:0x525E,0xE590BD:0x525F,
	0xE59180:0x5260,0xE590AC:0x5261,0xE590AD:0x5262,0xE590BC:0x5263,0xE590AE:0x5264,
	0xE590B6:0x5265,0xE590A9:0x5266,0xE5909D:0x5267,0xE5918E:0x5268,0xE5928F:0x5269,
	0xE591B5:0x526A,0xE5928E:0x526B,0xE5919F:0x526C,0xE591B1:0x526D,0xE591B7:0x526E,
	0xE591B0:0x526F,0xE59292:0x5270,0xE591BB:0x5271,0xE59280:0x5272,0xE591B6:0x5273,
	0xE59284:0x5274,0xE59290:0x5275,0xE59286:0x5276,0xE59387:0x5277,0xE592A2:0x5278,
	0xE592B8:0x5279,0xE592A5:0x527A,0xE592AC:0x527B,0xE59384:0x527C,0xE59388:0x527D,
	0xE592A8:0x527E,0xE592AB:0x5321,0xE59382:0x5322,0xE592A4:0x5323,0xE592BE:0x5324,
	0xE592BC:0x5325,0xE59398:0x5326,0xE593A5:0x5327,0xE593A6:0x5328,0xE5948F:0x5329,
	0xE59494:0x532A,0xE593BD:0x532B,0xE593AE:0x532C,0xE593AD:0x532D,0xE593BA:0x532E,
	0xE593A2:0x532F,0xE594B9:0x5330,0xE59580:0x5331,0xE595A3:0x5332,0xE5958C:0x5333,
	0xE594AE:0x5334,0xE5959C:0x5335,0xE59585:0x5336,0xE59596:0x5337,0xE59597:0x5338,
	0xE594B8:0x5339,0xE594B3:0x533A,0xE5959D:0x533B,0xE59699:0x533C,0xE59680:0x533D,
	0xE592AF:0x533E,0xE5968A:0x533F,0xE5969F:0x5340,0xE595BB:0x5341,0xE595BE:0x5342,
	0xE59698:0x5343,0xE5969E:0x5344,0xE596AE:0x5345,0xE595BC:0x5346,0xE59683:0x5347,
	0xE596A9:0x5348,0xE59687:0x5349,0xE596A8:0x534A,0xE5979A:0x534B,0xE59785:0x534C,
	0xE5979F:0x534D,0xE59784:0x534E,0xE5979C:0x534F,0xE597A4:0x5350,0xE59794:0x5351,
	0xE59894:0x5352,0xE597B7:0x5353,0xE59896:0x5354,0xE597BE:0x5355,0xE597BD:0x5356,
	0xE5989B:0x5357,0xE597B9:0x5358,0xE5998E:0x5359,0xE59990:0x535A,0xE7879F:0x535B,
	0xE598B4:0x535C,0xE598B6:0x535D,0xE598B2:0x535E,0xE598B8:0x535F,0xE599AB:0x5360,
	0xE599A4:0x5361,0xE598AF:0x5362,0xE599AC:0x5363,0xE599AA:0x5364,0xE59A86:0x5365,
	0xE59A80:0x5366,0xE59A8A:0x5367,0xE59AA0:0x5368,0xE59A94:0x5369,0xE59A8F:0x536A,
	0xE59AA5:0x536B,0xE59AAE:0x536C,0xE59AB6:0x536D,0xE59AB4:0x536E,0xE59B82:0x536F,
	0xE59ABC:0x5370,0xE59B81:0x5371,0xE59B83:0x5372,0xE59B80:0x5373,0xE59B88:0x5374,
	0xE59B8E:0x5375,0xE59B91:0x5376,0xE59B93:0x5377,0xE59B97:0x5378,0xE59BAE:0x5379,
	0xE59BB9:0x537A,0xE59C80:0x537B,0xE59BBF:0x537C,0xE59C84:0x537D,0xE59C89:0x537E,
	0xE59C88:0x5421,0xE59C8B:0x5422,0xE59C8D:0x5423,0xE59C93:0x5424,0xE59C98:0x5425,
	0xE59C96:0x5426,0xE59787:0x5427,0xE59C9C:0x5428,0xE59CA6:0x5429,0xE59CB7:0x542A,
	0xE59CB8:0x542B,0xE59D8E:0x542C,0xE59CBB:0x542D,0xE59D80:0x542E,0xE59D8F:0x542F,
	0xE59DA9:0x5430,0xE59F80:0x5431,0xE59E88:0x5432,0xE59DA1:0x5433,0xE59DBF:0x5434,
	0xE59E89:0x5435,0xE59E93:0x5436,0xE59EA0:0x5437,0xE59EB3:0x5438,0xE59EA4:0x5439,
	0xE59EAA:0x543A,0xE59EB0:0x543B,0xE59F83:0x543C,0xE59F86:0x543D,0xE59F94:0x543E,
	0xE59F92:0x543F,0xE59F93:0x5440,0xE5A08A:0x5441,0xE59F96:0x5442,0xE59FA3:0x5443,
	0xE5A08B:0x5444,0xE5A099:0x5445,0xE5A09D:0x5446,0xE5A1B2:0x5447,0xE5A0A1:0x5448,
	0xE5A1A2:0x5449,0xE5A18B:0x544A,0xE5A1B0:0x544B,0xE6AF80:0x544C,0xE5A192:0x544D,
	0xE5A0BD:0x544E,0xE5A1B9:0x544F,0xE5A285:0x5450,0xE5A2B9:0x5451,0xE5A29F:0x5452,
	0xE5A2AB:0x5453,0xE5A2BA:0x5454,0xE5A39E:0x5455,0xE5A2BB:0x5456,0xE5A2B8:0x5457,
	0xE5A2AE:0x5458,0xE5A385:0x5459,0xE5A393:0x545A,0xE5A391:0x545B,0xE5A397:0x545C,
	0xE5A399:0x545D,0xE5A398:0x545E,0xE5A3A5:0x545F,0xE5A39C:0x5460,0xE5A3A4:0x5461,
	0xE5A39F:0x5462,0xE5A3AF:0x5463,0xE5A3BA:0x5464,0xE5A3B9:0x5465,0xE5A3BB:0x5466,
	0xE5A3BC:0x5467,0xE5A3BD:0x5468,0xE5A482:0x5469,0xE5A48A:0x546A,0xE5A490:0x546B,
	0xE5A49B:0x546C,0xE6A2A6:0x546D,0xE5A4A5:0x546E,0xE5A4AC:0x546F,0xE5A4AD:0x5470,
	0xE5A4B2:0x5471,0xE5A4B8:0x5472,0xE5A4BE:0x5473,0xE7AB92:0x5474,0xE5A595:0x5475,
	0xE5A590:0x5476,0xE5A58E:0x5477,0xE5A59A:0x5478,0xE5A598:0x5479,0xE5A5A2:0x547A,
	0xE5A5A0:0x547B,0xE5A5A7:0x547C,0xE5A5AC:0x547D,0xE5A5A9:0x547E,0xE5A5B8:0x5521,
	0xE5A681:0x5522,0xE5A69D:0x5523,0xE4BD9E:0x5524,0xE4BEAB:0x5525,0xE5A6A3:0x5526,
	0xE5A6B2:0x5527,0xE5A786:0x5528,0xE5A7A8:0x5529,0xE5A79C:0x552A,0xE5A68D:0x552B,
	0xE5A799:0x552C,0xE5A79A:0x552D,0xE5A8A5:0x552E,0xE5A89F:0x552F,0xE5A891:0x5530,
	0xE5A89C:0x5531,0xE5A889:0x5532,0xE5A89A:0x5533,0xE5A980:0x5534,0xE5A9AC:0x5535,
	0xE5A989:0x5536,0xE5A8B5:0x5537,0xE5A8B6:0x5538,0xE5A9A2:0x5539,0xE5A9AA:0x553A,
	0xE5AA9A:0x553B,0xE5AABC:0x553C,0xE5AABE:0x553D,0xE5AB8B:0x553E,0xE5AB82:0x553F,
	0xE5AABD:0x5540,0xE5ABA3:0x5541,0xE5AB97:0x5542,0xE5ABA6:0x5543,0xE5ABA9:0x5544,
	0xE5AB96:0x5545,0xE5ABBA:0x5546,0xE5ABBB:0x5547,0xE5AC8C:0x5548,0xE5AC8B:0x5549,
	0xE5AC96:0x554A,0xE5ACB2:0x554B,0xE5AB90:0x554C,0xE5ACAA:0x554D,0xE5ACB6:0x554E,
	0xE5ACBE:0x554F,0xE5AD83:0x5550,0xE5AD85:0x5551,0xE5AD80:0x5552,0xE5AD91:0x5553,
	0xE5AD95:0x5554,0xE5AD9A:0x5555,0xE5AD9B:0x5556,0xE5ADA5:0x5557,0xE5ADA9:0x5558,
	0xE5ADB0:0x5559,0xE5ADB3:0x555A,0xE5ADB5:0x555B,0xE5ADB8:0x555C,0xE69688:0x555D,
	0xE5ADBA:0x555E,0xE5AE80:0x555F,0xE5AE83:0x5560,0xE5AEA6:0x5561,0xE5AEB8:0x5562,
	0xE5AF83:0x5563,0xE5AF87:0x5564,0xE5AF89:0x5565,0xE5AF94:0x5566,0xE5AF90:0x5567,
	0xE5AFA4:0x5568,0xE5AFA6:0x5569,0xE5AFA2:0x556A,0xE5AF9E:0x556B,0xE5AFA5:0x556C,
	0xE5AFAB:0x556D,0xE5AFB0:0x556E,0xE5AFB6:0x556F,0xE5AFB3:0x5570,0xE5B085:0x5571,
	0xE5B087:0x5572,0xE5B088:0x5573,0xE5B08D:0x5574,0xE5B093:0x5575,0xE5B0A0:0x5576,
	0xE5B0A2:0x5577,0xE5B0A8:0x5578,0xE5B0B8:0x5579,0xE5B0B9:0x557A,0xE5B181:0x557B,
	0xE5B186:0x557C,0xE5B18E:0x557D,0xE5B193:0x557E,0xE5B190:0x5621,0xE5B18F:0x5622,
	0xE5ADB1:0x5623,0xE5B1AC:0x5624,0xE5B1AE:0x5625,0xE4B9A2:0x5626,0xE5B1B6:0x5627,
	0xE5B1B9:0x5628,0xE5B28C:0x5629,0xE5B291:0x562A,0xE5B294:0x562B,0xE5A69B:0x562C,
	0xE5B2AB:0x562D,0xE5B2BB:0x562E,0xE5B2B6:0x562F,0xE5B2BC:0x5630,0xE5B2B7:0x5631,
	0xE5B385:0x5632,0xE5B2BE:0x5633,0xE5B387:0x5634,0xE5B399:0x5635,0xE5B3A9:0x5636,
	0xE5B3BD:0x5637,0xE5B3BA:0x5638,0xE5B3AD:0x5639,0xE5B68C:0x563A,0xE5B3AA:0x563B,
	0xE5B48B:0x563C,0xE5B495:0x563D,0xE5B497:0x563E,0xE5B59C:0x563F,0xE5B49F:0x5640,
	0xE5B49B:0x5641,0xE5B491:0x5642,0xE5B494:0x5643,0xE5B4A2:0x5644,0xE5B49A:0x5645,
	0xE5B499:0x5646,0xE5B498:0x5647,0xE5B58C:0x5648,0xE5B592:0x5649,0xE5B58E:0x564A,
	0xE5B58B:0x564B,0xE5B5AC:0x564C,0xE5B5B3:0x564D,0xE5B5B6:0x564E,0xE5B687:0x564F,
	0xE5B684:0x5650,0xE5B682:0x5651,0xE5B6A2:0x5652,0xE5B69D:0x5653,0xE5B6AC:0x5654,
	0xE5B6AE:0x5655,0xE5B6BD:0x5656,0xE5B690:0x5657,0xE5B6B7:0x5658,0xE5B6BC:0x5659,
	0xE5B789:0x565A,0xE5B78D:0x565B,0xE5B793:0x565C,0xE5B792:0x565D,0xE5B796:0x565E,
	0xE5B79B:0x565F,0xE5B7AB:0x5660,0xE5B7B2:0x5661,0xE5B7B5:0x5662,0xE5B88B:0x5663,
	0xE5B89A:0x5664,0xE5B899:0x5665,0xE5B891:0x5666,0xE5B89B:0x5667,0xE5B8B6:0x5668,
	0xE5B8B7:0x5669,0xE5B984:0x566A,0xE5B983:0x566B,0xE5B980:0x566C,0xE5B98E:0x566D,
	0xE5B997:0x566E,0xE5B994:0x566F,0xE5B99F:0x5670,0xE5B9A2:0x5671,0xE5B9A4:0x5672,
	0xE5B987:0x5673,0xE5B9B5:0x5674,0xE5B9B6:0x5675,0xE5B9BA:0x5676,0xE9BABC:0x5677,
	0xE5B9BF:0x5678,0xE5BAA0:0x5679,0xE5BB81:0x567A,0xE5BB82:0x567B,0xE5BB88:0x567C,
	0xE5BB90:0x567D,0xE5BB8F:0x567E,0xE5BB96:0x5721,0xE5BBA3:0x5722,0xE5BB9D:0x5723,
	0xE5BB9A:0x5724,0xE5BB9B:0x5725,0xE5BBA2:0x5726,0xE5BBA1:0x5727,0xE5BBA8:0x5728,
	0xE5BBA9:0x5729,0xE5BBAC:0x572A,0xE5BBB1:0x572B,0xE5BBB3:0x572C,0xE5BBB0:0x572D,
	0xE5BBB4:0x572E,0xE5BBB8:0x572F,0xE5BBBE:0x5730,0xE5BC83:0x5731,0xE5BC89:0x5732,
	0xE5BD9D:0x5733,0xE5BD9C:0x5734,0xE5BC8B:0x5735,0xE5BC91:0x5736,0xE5BC96:0x5737,
	0xE5BCA9:0x5738,0xE5BCAD:0x5739,0xE5BCB8:0x573A,0xE5BD81:0x573B,0xE5BD88:0x573C,
	0xE5BD8C:0x573D,0xE5BD8E:0x573E,0xE5BCAF:0x573F,0xE5BD91:0x5740,0xE5BD96:0x5741,
	0xE5BD97:0x5742,0xE5BD99:0x5743,0xE5BDA1:0x5744,0xE5BDAD:0x5745,0xE5BDB3:0x5746,
	0xE5BDB7:0x5747,0xE5BE83:0x5748,0xE5BE82:0x5749,0xE5BDBF:0x574A,0xE5BE8A:0x574B,
	0xE5BE88:0x574C,0xE5BE91:0x574D,0xE5BE87:0x574E,0xE5BE9E:0x574F,0xE5BE99:0x5750,
	0xE5BE98:0x5751,0xE5BEA0:0x5752,0xE5BEA8:0x5753,0xE5BEAD:0x5754,0xE5BEBC:0x5755,
	0xE5BF96:0x5756,0xE5BFBB:0x5757,0xE5BFA4:0x5758,0xE5BFB8:0x5759,0xE5BFB1:0x575A,
	0xE5BF9D:0x575B,0xE682B3:0x575C,0xE5BFBF:0x575D,0xE680A1:0x575E,0xE681A0:0x575F,
	0xE68099:0x5760,0xE68090:0x5761,0xE680A9:0x5762,0xE6808E:0x5763,0xE680B1:0x5764,
	0xE6809B:0x5765,0xE68095:0x5766,0xE680AB:0x5767,0xE680A6:0x5768,0xE6808F:0x5769,
	0xE680BA:0x576A,0xE6819A:0x576B,0xE68181:0x576C,0xE681AA:0x576D,0xE681B7:0x576E,
	0xE6819F:0x576F,0xE6818A:0x5770,0xE68186:0x5771,0xE6818D:0x5772,0xE681A3:0x5773,
	0xE68183:0x5774,0xE681A4:0x5775,0xE68182:0x5776,0xE681AC:0x5777,0xE681AB:0x5778,
	0xE68199:0x5779,0xE68281:0x577A,0xE6828D:0x577B,0xE683A7:0x577C,0xE68283:0x577D,
	0xE6829A:0x577E,0xE68284:0x5821,0xE6829B:0x5822,0xE68296:0x5823,0xE68297:0x5824,
	0xE68292:0x5825,0xE682A7:0x5826,0xE6828B:0x5827,0xE683A1:0x5828,0xE682B8:0x5829,
	0xE683A0:0x582A,0xE68393:0x582B,0xE682B4:0x582C,0xE5BFB0:0x582D,0xE682BD:0x582E,
	0xE68386:0x582F,0xE682B5:0x5830,0xE68398:0x5831,0xE6858D:0x5832,0xE68495:0x5833,
	0xE68486:0x5834,0xE683B6:0x5835,0xE683B7:0x5836,0xE68480:0x5837,0xE683B4:0x5838,
	0xE683BA:0x5839,0xE68483:0x583A,0xE684A1:0x583B,0xE683BB:0x583C,0xE683B1:0x583D,
	0xE6848D:0x583E,0xE6848E:0x583F,0xE68587:0x5840,0xE684BE:0x5841,0xE684A8:0x5842,
	0xE684A7:0x5843,0xE6858A:0x5844,0xE684BF:0x5845,0xE684BC:0x5846,0xE684AC:0x5847,
	0xE684B4:0x5848,0xE684BD:0x5849,0xE68582:0x584A,0xE68584:0x584B,0xE685B3:0x584C,
	0xE685B7:0x584D,0xE68598:0x584E,0xE68599:0x584F,0xE6859A:0x5850,0xE685AB:0x5851,
	0xE685B4:0x5852,0xE685AF:0x5853,0xE685A5:0x5854,0xE685B1:0x5855,0xE6859F:0x5856,
	0xE6859D:0x5857,0xE68593:0x5858,0xE685B5:0x5859,0xE68699:0x585A,0xE68696:0x585B,
	0xE68687:0x585C,0xE686AC:0x585D,0xE68694:0x585E,0xE6869A:0x585F,0xE6868A:0x5860,
	0xE68691:0x5861,0xE686AB:0x5862,0xE686AE:0x5863,0xE6878C:0x5864,0xE6878A:0x5865,
	0xE68789:0x5866,0xE687B7:0x5867,0xE68788:0x5868,0xE68783:0x5869,0xE68786:0x586A,
	0xE686BA:0x586B,0xE6878B:0x586C,0xE7BDB9:0x586D,0xE6878D:0x586E,0xE687A6:0x586F,
	0xE687A3:0x5870,0xE687B6:0x5871,0xE687BA:0x5872,0xE687B4:0x5873,0xE687BF:0x5874,
	0xE687BD:0x5875,0xE687BC:0x5876,0xE687BE:0x5877,0xE68880:0x5878,0xE68888:0x5879,
	0xE68889:0x587A,0xE6888D:0x587B,0xE6888C:0x587C,0xE68894:0x587D,0xE6889B:0x587E,
	0xE6889E:0x5921,0xE688A1:0x5922,0xE688AA:0x5923,0xE688AE:0x5924,0xE688B0:0x5925,
	0xE688B2:0x5926,0xE688B3:0x5927,0xE68981:0x5928,0xE6898E:0x5929,0xE6899E:0x592A,
	0xE689A3:0x592B,0xE6899B:0x592C,0xE689A0:0x592D,0xE689A8:0x592E,0xE689BC:0x592F,
	0xE68A82:0x5930,0xE68A89:0x5931,0xE689BE:0x5932,0xE68A92:0x5933,0xE68A93:0x5934,
	0xE68A96:0x5935,0xE68B94:0x5936,0xE68A83:0x5937,0xE68A94:0x5938,0xE68B97:0x5939,
	0xE68B91:0x593A,0xE68ABB:0x593B,0xE68B8F:0x593C,0xE68BBF:0x593D,0xE68B86:0x593E,
	0xE69394:0x593F,0xE68B88:0x5940,0xE68B9C:0x5941,0xE68B8C:0x5942,0xE68B8A:0x5943,
	0xE68B82:0x5944,0xE68B87:0x5945,0xE68A9B:0x5946,0xE68B89:0x5947,0xE68C8C:0x5948,
	0xE68BAE:0x5949,0xE68BB1:0x594A,0xE68CA7:0x594B,0xE68C82:0x594C,0xE68C88:0x594D,
	0xE68BAF:0x594E,0xE68BB5:0x594F,0xE68D90:0x5950,0xE68CBE:0x5951,0xE68D8D:0x5952,
	0xE6909C:0x5953,0xE68D8F:0x5954,0xE68E96:0x5955,0xE68E8E:0x5956,0xE68E80:0x5957,
	0xE68EAB:0x5958,0xE68DB6:0x5959,0xE68EA3:0x595A,0xE68E8F:0x595B,0xE68E89:0x595C,
	0xE68E9F:0x595D,0xE68EB5:0x595E,0xE68DAB:0x595F,0xE68DA9:0x5960,0xE68EBE:0x5961,
	0xE68FA9:0x5962,0xE68F80:0x5963,0xE68F86:0x5964,0xE68FA3:0x5965,0xE68F89:0x5966,
	0xE68F92:0x5967,0xE68FB6:0x5968,0xE68F84:0x5969,0xE69096:0x596A,0xE690B4:0x596B,
	0xE69086:0x596C,0xE69093:0x596D,0xE690A6:0x596E,0xE690B6:0x596F,0xE6949D:0x5970,
	0xE69097:0x5971,0xE690A8:0x5972,0xE6908F:0x5973,0xE691A7:0x5974,0xE691AF:0x5975,
	0xE691B6:0x5976,0xE6918E:0x5977,0xE694AA:0x5978,0xE69295:0x5979,0xE69293:0x597A,
	0xE692A5:0x597B,0xE692A9:0x597C,0xE69288:0x597D,0xE692BC:0x597E,0xE6939A:0x5A21,
	0xE69392:0x5A22,0xE69385:0x5A23,0xE69387:0x5A24,0xE692BB:0x5A25,0xE69398:0x5A26,
	0xE69382:0x5A27,0xE693B1:0x5A28,0xE693A7:0x5A29,0xE88889:0x5A2A,0xE693A0:0x5A2B,
	0xE693A1:0x5A2C,0xE68AAC:0x5A2D,0xE693A3:0x5A2E,0xE693AF:0x5A2F,0xE694AC:0x5A30,
	0xE693B6:0x5A31,0xE693B4:0x5A32,0xE693B2:0x5A33,0xE693BA:0x5A34,0xE69480:0x5A35,
	0xE693BD:0x5A36,0xE69498:0x5A37,0xE6949C:0x5A38,0xE69485:0x5A39,0xE694A4:0x5A3A,
	0xE694A3:0x5A3B,0xE694AB:0x5A3C,0xE694B4:0x5A3D,0xE694B5:0x5A3E,0xE694B7:0x5A3F,
	0xE694B6:0x5A40,0xE694B8:0x5A41,0xE7958B:0x5A42,0xE69588:0x5A43,0xE69596:0x5A44,
	0xE69595:0x5A45,0xE6958D:0x5A46,0xE69598:0x5A47,0xE6959E:0x5A48,0xE6959D:0x5A49,
	0xE695B2:0x5A4A,0xE695B8:0x5A4B,0xE69682:0x5A4C,0xE69683:0x5A4D,0xE8AE8A:0x5A4E,
	0xE6969B:0x5A4F,0xE6969F:0x5A50,0xE696AB:0x5A51,0xE696B7:0x5A52,0xE69783:0x5A53,
	0xE69786:0x5A54,0xE69781:0x5A55,0xE69784:0x5A56,0xE6978C:0x5A57,0xE69792:0x5A58,
	0xE6979B:0x5A59,0xE69799:0x5A5A,0xE697A0:0x5A5B,0xE697A1:0x5A5C,0xE697B1:0x5A5D,
	0xE69DB2:0x5A5E,0xE6988A:0x5A5F,0xE69883:0x5A60,0xE697BB:0x5A61,0xE69DB3:0x5A62,
	0xE698B5:0x5A63,0xE698B6:0x5A64,0xE698B4:0x5A65,0xE6989C:0x5A66,0xE6998F:0x5A67,
	0xE69984:0x5A68,0xE69989:0x5A69,0xE69981:0x5A6A,0xE6999E:0x5A6B,0xE6999D:0x5A6C,
	0xE699A4:0x5A6D,0xE699A7:0x5A6E,0xE699A8:0x5A6F,0xE6999F:0x5A70,0xE699A2:0x5A71,
	0xE699B0:0x5A72,0xE69A83:0x5A73,0xE69A88:0x5A74,0xE69A8E:0x5A75,0xE69A89:0x5A76,
	0xE69A84:0x5A77,0xE69A98:0x5A78,0xE69A9D:0x5A79,0xE69B81:0x5A7A,0xE69AB9:0x5A7B,
	0xE69B89:0x5A7C,0xE69ABE:0x5A7D,0xE69ABC:0x5A7E,0xE69B84:0x5B21,0xE69AB8:0x5B22,
	0xE69B96:0x5B23,0xE69B9A:0x5B24,0xE69BA0:0x5B25,0xE698BF:0x5B26,0xE69BA6:0x5B27,
	0xE69BA9:0x5B28,0xE69BB0:0x5B29,0xE69BB5:0x5B2A,0xE69BB7:0x5B2B,0xE69C8F:0x5B2C,
	0xE69C96:0x5B2D,0xE69C9E:0x5B2E,0xE69CA6:0x5B2F,0xE69CA7:0x5B30,0xE99CB8:0x5B31,
	0xE69CAE:0x5B32,0xE69CBF:0x5B33,0xE69CB6:0x5B34,0xE69D81:0x5B35,0xE69CB8:0x5B36,
	0xE69CB7:0x5B37,0xE69D86:0x5B38,0xE69D9E:0x5B39,0xE69DA0:0x5B3A,0xE69D99:0x5B3B,
	0xE69DA3:0x5B3C,0xE69DA4:0x5B3D,0xE69E89:0x5B3E,0xE69DB0:0x5B3F,0xE69EA9:0x5B40,
	0xE69DBC:0x5B41,0xE69DAA:0x5B42,0xE69E8C:0x5B43,0xE69E8B:0x5B44,0xE69EA6:0x5B45,
	0xE69EA1:0x5B46,0xE69E85:0x5B47,0xE69EB7:0x5B48,0xE69FAF:0x5B49,0xE69EB4:0x5B4A,
	0xE69FAC:0x5B4B,0xE69EB3:0x5B4C,0xE69FA9:0x5B4D,0xE69EB8:0x5B4E,0xE69FA4:0x5B4F,
	0xE69F9E:0x5B50,0xE69F9D:0x5B51,0xE69FA2:0x5B52,0xE69FAE:0x5B53,0xE69EB9:0x5B54,
	0xE69F8E:0x5B55,0xE69F86:0x5B56,0xE69FA7:0x5B57,0xE6AA9C:0x5B58,0xE6A09E:0x5B59,
	0xE6A186:0x5B5A,0xE6A0A9:0x5B5B,0xE6A180:0x5B5C,0xE6A18D:0x5B5D,0xE6A0B2:0x5B5E,
	0xE6A18E:0x5B5F,0xE6A2B3:0x5B60,0xE6A0AB:0x5B61,0xE6A199:0x5B62,0xE6A1A3:0x5B63,
	0xE6A1B7:0x5B64,0xE6A1BF:0x5B65,0xE6A29F:0x5B66,0xE6A28F:0x5B67,0xE6A2AD:0x5B68,
	0xE6A294:0x5B69,0xE6A29D:0x5B6A,0xE6A29B:0x5B6B,0xE6A283:0x5B6C,0xE6AAAE:0x5B6D,
	0xE6A2B9:0x5B6E,0xE6A1B4:0x5B6F,0xE6A2B5:0x5B70,0xE6A2A0:0x5B71,0xE6A2BA:0x5B72,
	0xE6A48F:0x5B73,0xE6A28D:0x5B74,0xE6A1BE:0x5B75,0xE6A481:0x5B76,0xE6A38A:0x5B77,
	0xE6A488:0x5B78,0xE6A398:0x5B79,0xE6A4A2:0x5B7A,0xE6A4A6:0x5B7B,0xE6A3A1:0x5B7C,
	0xE6A48C:0x5B7D,0xE6A38D:0x5B7E,0xE6A394:0x5C21,0xE6A3A7:0x5C22,0xE6A395:0x5C23,
	0xE6A4B6:0x5C24,0xE6A492:0x5C25,0xE6A484:0x5C26,0xE6A397:0x5C27,0xE6A3A3:0x5C28,
	0xE6A4A5:0x5C29,0xE6A3B9:0x5C2A,0xE6A3A0:0x5C2B,0xE6A3AF:0x5C2C,0xE6A4A8:0x5C2D,
	0xE6A4AA:0x5C2E,0xE6A49A:0x5C2F,0xE6A4A3:0x5C30,0xE6A4A1:0x5C31,0xE6A386:0x5C32,
	0xE6A5B9:0x5C33,0xE6A5B7:0x5C34,0xE6A59C:0x5C35,0xE6A5B8:0x5C36,0xE6A5AB:0x5C37,
	0xE6A594:0x5C38,0xE6A5BE:0x5C39,0xE6A5AE:0x5C3A,0xE6A4B9:0x5C3B,0xE6A5B4:0x5C3C,
	0xE6A4BD:0x5C3D,0xE6A599:0x5C3E,0xE6A4B0:0x5C3F,0xE6A5A1:0x5C40,0xE6A59E:0x5C41,
	0xE6A59D:0x5C42,0xE6A681:0x5C43,0xE6A5AA:0x5C44,0xE6A6B2:0x5C45,0xE6A6AE:0x5C46,
	0xE6A790:0x5C47,0xE6A6BF:0x5C48,0xE6A781:0x5C49,0xE6A793:0x5C4A,0xE6A6BE:0x5C4B,
	0xE6A78E:0x5C4C,0xE5AFA8:0x5C4D,0xE6A78A:0x5C4E,0xE6A79D:0x5C4F,0xE6A6BB:0x5C50,
	0xE6A783:0x5C51,0xE6A6A7:0x5C52,0xE6A8AE:0x5C53,0xE6A691:0x5C54,0xE6A6A0:0x5C55,
	0xE6A69C:0x5C56,0xE6A695:0x5C57,0xE6A6B4:0x5C58,0xE6A79E:0x5C59,0xE6A7A8:0x5C5A,
	0xE6A882:0x5C5B,0xE6A89B:0x5C5C,0xE6A7BF:0x5C5D,0xE6AC8A:0x5C5E,0xE6A7B9:0x5C5F,
	0xE6A7B2:0x5C60,0xE6A7A7:0x5C61,0xE6A885:0x5C62,0xE6A6B1:0x5C63,0xE6A89E:0x5C64,
	0xE6A7AD:0x5C65,0xE6A894:0x5C66,0xE6A7AB:0x5C67,0xE6A88A:0x5C68,0xE6A892:0x5C69,
	0xE6AB81:0x5C6A,0xE6A8A3:0x5C6B,0xE6A893:0x5C6C,0xE6A984:0x5C6D,0xE6A88C:0x5C6E,
	0xE6A9B2:0x5C6F,0xE6A8B6:0x5C70,0xE6A9B8:0x5C71,0xE6A987:0x5C72,0xE6A9A2:0x5C73,
	0xE6A999:0x5C74,0xE6A9A6:0x5C75,0xE6A988:0x5C76,0xE6A8B8:0x5C77,0xE6A8A2:0x5C78,
	0xE6AA90:0x5C79,0xE6AA8D:0x5C7A,0xE6AAA0:0x5C7B,0xE6AA84:0x5C7C,0xE6AAA2:0x5C7D,
	0xE6AAA3:0x5C7E,0xE6AA97:0x5D21,0xE89897:0x5D22,0xE6AABB:0x5D23,0xE6AB83:0x5D24,
	0xE6AB82:0x5D25,0xE6AAB8:0x5D26,0xE6AAB3:0x5D27,0xE6AAAC:0x5D28,0xE6AB9E:0x5D29,
	0xE6AB91:0x5D2A,0xE6AB9F:0x5D2B,0xE6AAAA:0x5D2C,0xE6AB9A:0x5D2D,0xE6ABAA:0x5D2E,
	0xE6ABBB:0x5D2F,0xE6AC85:0x5D30,0xE89896:0x5D31,0xE6ABBA:0x5D32,0xE6AC92:0x5D33,
	0xE6AC96:0x5D34,0xE9ACB1:0x5D35,0xE6AC9F:0x5D36,0xE6ACB8:0x5D37,0xE6ACB7:0x5D38,
	0xE79B9C:0x5D39,0xE6ACB9:0x5D3A,0xE9A3AE:0x5D3B,0xE6AD87:0x5D3C,0xE6AD83:0x5D3D,
	0xE6AD89:0x5D3E,0xE6AD90:0x5D3F,0xE6AD99:0x5D40,0xE6AD94:0x5D41,0xE6AD9B:0x5D42,
	0xE6AD9F:0x5D43,0xE6ADA1:0x5D44,0xE6ADB8:0x5D45,0xE6ADB9:0x5D46,0xE6ADBF:0x5D47,
	0xE6AE80:0x5D48,0xE6AE84:0x5D49,0xE6AE83:0x5D4A,0xE6AE8D:0x5D4B,0xE6AE98:0x5D4C,
	0xE6AE95:0x5D4D,0xE6AE9E:0x5D4E,0xE6AEA4:0x5D4F,0xE6AEAA:0x5D50,0xE6AEAB:0x5D51,
	0xE6AEAF:0x5D52,0xE6AEB2:0x5D53,0xE6AEB1:0x5D54,0xE6AEB3:0x5D55,0xE6AEB7:0x5D56,
	0xE6AEBC:0x5D57,0xE6AF86:0x5D58,0xE6AF8B:0x5D59,0xE6AF93:0x5D5A,0xE6AF9F:0x5D5B,
	0xE6AFAC:0x5D5C,0xE6AFAB:0x5D5D,0xE6AFB3:0x5D5E,0xE6AFAF:0x5D5F,0xE9BABE:0x5D60,
	0xE6B088:0x5D61,0xE6B093:0x5D62,0xE6B094:0x5D63,0xE6B09B:0x5D64,0xE6B0A4:0x5D65,
	0xE6B0A3:0x5D66,0xE6B19E:0x5D67,0xE6B195:0x5D68,0xE6B1A2:0x5D69,0xE6B1AA:0x5D6A,
	0xE6B282:0x5D6B,0xE6B28D:0x5D6C,0xE6B29A:0x5D6D,0xE6B281:0x5D6E,0xE6B29B:0x5D6F,
	0xE6B1BE:0x5D70,0xE6B1A8:0x5D71,0xE6B1B3:0x5D72,0xE6B292:0x5D73,0xE6B290:0x5D74,
	0xE6B384:0x5D75,0xE6B3B1:0x5D76,0xE6B393:0x5D77,0xE6B2BD:0x5D78,0xE6B397:0x5D79,
	0xE6B385:0x5D7A,0xE6B39D:0x5D7B,0xE6B2AE:0x5D7C,0xE6B2B1:0x5D7D,0xE6B2BE:0x5D7E,
	0xE6B2BA:0x5E21,0xE6B39B:0x5E22,0xE6B3AF:0x5E23,0xE6B399:0x5E24,0xE6B3AA:0x5E25,
	0xE6B49F:0x5E26,0xE8A18D:0x5E27,0xE6B4B6:0x5E28,0xE6B4AB:0x5E29,0xE6B4BD:0x5E2A,
	0xE6B4B8:0x5E2B,0xE6B499:0x5E2C,0xE6B4B5:0x5E2D,0xE6B4B3:0x5E2E,0xE6B492:0x5E2F,
	0xE6B48C:0x5E30,0xE6B5A3:0x5E31,0xE6B693:0x5E32,0xE6B5A4:0x5E33,0xE6B59A:0x5E34,
	0xE6B5B9:0x5E35,0xE6B599:0x5E36,0xE6B68E:0x5E37,0xE6B695:0x5E38,0xE6BFA4:0x5E39,
	0xE6B685:0x5E3A,0xE6B7B9:0x5E3B,0xE6B895:0x5E3C,0xE6B88A:0x5E3D,0xE6B6B5:0x5E3E,
	0xE6B787:0x5E3F,0xE6B7A6:0x5E40,0xE6B6B8:0x5E41,0xE6B786:0x5E42,0xE6B7AC:0x5E43,
	0xE6B79E:0x5E44,0xE6B78C:0x5E45,0xE6B7A8:0x5E46,0xE6B792:0x5E47,0xE6B785:0x5E48,
	0xE6B7BA:0x5E49,0xE6B799:0x5E4A,0xE6B7A4:0x5E4B,0xE6B795:0x5E4C,0xE6B7AA:0x5E4D,
	0xE6B7AE:0x5E4E,0xE6B8AD:0x5E4F,0xE6B9AE:0x5E50,0xE6B8AE:0x5E51,0xE6B899:0x5E52,
	0xE6B9B2:0x5E53,0xE6B99F:0x5E54,0xE6B8BE:0x5E55,0xE6B8A3:0x5E56,0xE6B9AB:0x5E57,
	0xE6B8AB:0x5E58,0xE6B9B6:0x5E59,0xE6B98D:0x5E5A,0xE6B89F:0x5E5B,0xE6B983:0x5E5C,
	0xE6B8BA:0x5E5D,0xE6B98E:0x5E5E,0xE6B8A4:0x5E5F,0xE6BBBF:0x5E60,0xE6B89D:0x5E61,
	0xE6B8B8:0x5E62,0xE6BA82:0x5E63,0xE6BAAA:0x5E64,0xE6BA98:0x5E65,0xE6BB89:0x5E66,
	0xE6BAB7:0x5E67,0xE6BB93:0x5E68,0xE6BABD:0x5E69,0xE6BAAF:0x5E6A,0xE6BB84:0x5E6B,
	0xE6BAB2:0x5E6C,0xE6BB94:0x5E6D,0xE6BB95:0x5E6E,0xE6BA8F:0x5E6F,0xE6BAA5:0x5E70,
	0xE6BB82:0x5E71,0xE6BA9F:0x5E72,0xE6BD81:0x5E73,0xE6BC91:0x5E74,0xE7818C:0x5E75,
	0xE6BBAC:0x5E76,0xE6BBB8:0x5E77,0xE6BBBE:0x5E78,0xE6BCBF:0x5E79,0xE6BBB2:0x5E7A,
	0xE6BCB1:0x5E7B,0xE6BBAF:0x5E7C,0xE6BCB2:0x5E7D,0xE6BB8C:0x5E7E,0xE6BCBE:0x5F21,
	0xE6BC93:0x5F22,0xE6BBB7:0x5F23,0xE6BE86:0x5F24,0xE6BDBA:0x5F25,0xE6BDB8:0x5F26,
	0xE6BE81:0x5F27,0xE6BE80:0x5F28,0xE6BDAF:0x5F29,0xE6BD9B:0x5F2A,0xE6BFB3:0x5F2B,
	0xE6BDAD:0x5F2C,0xE6BE82:0x5F2D,0xE6BDBC:0x5F2E,0xE6BD98:0x5F2F,0xE6BE8E:0x5F30,
	0xE6BE91:0x5F31,0xE6BF82:0x5F32,0xE6BDA6:0x5F33,0xE6BEB3:0x5F34,0xE6BEA3:0x5F35,
	0xE6BEA1:0x5F36,0xE6BEA4:0x5F37,0xE6BEB9:0x5F38,0xE6BF86:0x5F39,0xE6BEAA:0x5F3A,
	0xE6BF9F:0x5F3B,0xE6BF95:0x5F3C,0xE6BFAC:0x5F3D,0xE6BF94:0x5F3E,0xE6BF98:0x5F3F,
	0xE6BFB1:0x5F40,0xE6BFAE:0x5F41,0xE6BF9B:0x5F42,0xE78089:0x5F43,0xE7808B:0x5F44,
	0xE6BFBA:0x5F45,0xE78091:0x5F46,0xE78081:0x5F47,0xE7808F:0x5F48,0xE6BFBE:0x5F49,
	0xE7809B:0x5F4A,0xE7809A:0x5F4B,0xE6BDB4:0x5F4C,0xE7809D:0x5F4D,0xE78098:0x5F4E,
	0xE7809F:0x5F4F,0xE780B0:0x5F50,0xE780BE:0x5F51,0xE780B2:0x5F52,0xE78191:0x5F53,
	0xE781A3:0x5F54,0xE78299:0x5F55,0xE78292:0x5F56,0xE782AF:0x5F57,0xE783B1:0x5F58,
	0xE782AC:0x5F59,0xE782B8:0x5F5A,0xE782B3:0x5F5B,0xE782AE:0x5F5C,0xE7839F:0x5F5D,
	0xE7838B:0x5F5E,0xE7839D:0x5F5F,0xE78399:0x5F60,0xE78489:0x5F61,0xE783BD:0x5F62,
	0xE7849C:0x5F63,0xE78499:0x5F64,0xE785A5:0x5F65,0xE78595:0x5F66,0xE78688:0x5F67,
	0xE785A6:0x5F68,0xE785A2:0x5F69,0xE7858C:0x5F6A,0xE78596:0x5F6B,0xE785AC:0x5F6C,
	0xE7868F:0x5F6D,0xE787BB:0x5F6E,0xE78684:0x5F6F,0xE78695:0x5F70,0xE786A8:0x5F71,
	0xE786AC:0x5F72,0xE78797:0x5F73,0xE786B9:0x5F74,0xE786BE:0x5F75,0xE78792:0x5F76,
	0xE78789:0x5F77,0xE78794:0x5F78,0xE7878E:0x5F79,0xE787A0:0x5F7A,0xE787AC:0x5F7B,
	0xE787A7:0x5F7C,0xE787B5:0x5F7D,0xE787BC:0x5F7E,0xE787B9:0x6021,0xE787BF:0x6022,
	0xE7888D:0x6023,0xE78890:0x6024,0xE7889B:0x6025,0xE788A8:0x6026,0xE788AD:0x6027,
	0xE788AC:0x6028,0xE788B0:0x6029,0xE788B2:0x602A,0xE788BB:0x602B,0xE788BC:0x602C,
	0xE788BF:0x602D,0xE78980:0x602E,0xE78986:0x602F,0xE7898B:0x6030,0xE78998:0x6031,
	0xE789B4:0x6032,0xE789BE:0x6033,0xE78A82:0x6034,0xE78A81:0x6035,0xE78A87:0x6036,
	0xE78A92:0x6037,0xE78A96:0x6038,0xE78AA2:0x6039,0xE78AA7:0x603A,0xE78AB9:0x603B,
	0xE78AB2:0x603C,0xE78B83:0x603D,0xE78B86:0x603E,0xE78B84:0x603F,0xE78B8E:0x6040,
	0xE78B92:0x6041,0xE78BA2:0x6042,0xE78BA0:0x6043,0xE78BA1:0x6044,0xE78BB9:0x6045,
	0xE78BB7:0x6046,0xE5808F:0x6047,0xE78C97:0x6048,0xE78C8A:0x6049,0xE78C9C:0x604A,
	0xE78C96:0x604B,0xE78C9D:0x604C,0xE78CB4:0x604D,0xE78CAF:0x604E,0xE78CA9:0x604F,
	0xE78CA5:0x6050,0xE78CBE:0x6051,0xE78D8E:0x6052,0xE78D8F:0x6053,0xE9BB98:0x6054,
	0xE78D97:0x6055,0xE78DAA:0x6056,0xE78DA8:0x6057,0xE78DB0:0x6058,0xE78DB8:0x6059,
	0xE78DB5:0x605A,0xE78DBB:0x605B,0xE78DBA:0x605C,0xE78F88:0x605D,0xE78EB3:0x605E,
	0xE78F8E:0x605F,0xE78EBB:0x6060,0xE78F80:0x6061,0xE78FA5:0x6062,0xE78FAE:0x6063,
	0xE78F9E:0x6064,0xE792A2:0x6065,0xE79085:0x6066,0xE791AF:0x6067,0xE790A5:0x6068,
	0xE78FB8:0x6069,0xE790B2:0x606A,0xE790BA:0x606B,0xE79195:0x606C,0xE790BF:0x606D,
	0xE7919F:0x606E,0xE79199:0x606F,0xE79181:0x6070,0xE7919C:0x6071,0xE791A9:0x6072,
	0xE791B0:0x6073,0xE791A3:0x6074,0xE791AA:0x6075,0xE791B6:0x6076,0xE791BE:0x6077,
	0xE7928B:0x6078,0xE7929E:0x6079,0xE792A7:0x607A,0xE7938A:0x607B,0xE7938F:0x607C,
	0xE79394:0x607D,0xE78FB1:0x607E,0xE793A0:0x6121,0xE793A3:0x6122,0xE793A7:0x6123,
	0xE793A9:0x6124,0xE793AE:0x6125,0xE793B2:0x6126,0xE793B0:0x6127,0xE793B1:0x6128,
	0xE793B8:0x6129,0xE793B7:0x612A,0xE79484:0x612B,0xE79483:0x612C,0xE79485:0x612D,
	0xE7948C:0x612E,0xE7948E:0x612F,0xE7948D:0x6130,0xE79495:0x6131,0xE79493:0x6132,
	0xE7949E:0x6133,0xE794A6:0x6134,0xE794AC:0x6135,0xE794BC:0x6136,0xE79584:0x6137,
	0xE7958D:0x6138,0xE7958A:0x6139,0xE79589:0x613A,0xE7959B:0x613B,0xE79586:0x613C,
	0xE7959A:0x613D,0xE795A9:0x613E,0xE795A4:0x613F,0xE795A7:0x6140,0xE795AB:0x6141,
	0xE795AD:0x6142,0xE795B8:0x6143,0xE795B6:0x6144,0xE79686:0x6145,0xE79687:0x6146,
	0xE795B4:0x6147,0xE7968A:0x6148,0xE79689:0x6149,0xE79682:0x614A,0xE79694:0x614B,
	0xE7969A:0x614C,0xE7969D:0x614D,0xE796A5:0x614E,0xE796A3:0x614F,0xE79782:0x6150,
	0xE796B3:0x6151,0xE79783:0x6152,0xE796B5:0x6153,0xE796BD:0x6154,0xE796B8:0x6155,
	0xE796BC:0x6156,0xE796B1:0x6157,0xE7978D:0x6158,0xE7978A:0x6159,0xE79792:0x615A,
	0xE79799:0x615B,0xE797A3:0x615C,0xE7979E:0x615D,0xE797BE:0x615E,0xE797BF:0x615F,
	0xE797BC:0x6160,0xE79881:0x6161,0xE797B0:0x6162,0xE797BA:0x6163,0xE797B2:0x6164,
	0xE797B3:0x6165,0xE7988B:0x6166,0xE7988D:0x6167,0xE79889:0x6168,0xE7989F:0x6169,
	0xE798A7:0x616A,0xE798A0:0x616B,0xE798A1:0x616C,0xE798A2:0x616D,0xE798A4:0x616E,
	0xE798B4:0x616F,0xE798B0:0x6170,0xE798BB:0x6171,0xE79987:0x6172,0xE79988:0x6173,
	0xE79986:0x6174,0xE7999C:0x6175,0xE79998:0x6176,0xE799A1:0x6177,0xE799A2:0x6178,
	0xE799A8:0x6179,0xE799A9:0x617A,0xE799AA:0x617B,0xE799A7:0x617C,0xE799AC:0x617D,
	0xE799B0:0x617E,0xE799B2:0x6221,0xE799B6:0x6222,0xE799B8:0x6223,0xE799BC:0x6224,
	0xE79A80:0x6225,0xE79A83:0x6226,0xE79A88:0x6227,0xE79A8B:0x6228,0xE79A8E:0x6229,
	0xE79A96:0x622A,0xE79A93:0x622B,0xE79A99:0x622C,0xE79A9A:0x622D,0xE79AB0:0x622E,
	0xE79AB4:0x622F,0xE79AB8:0x6230,0xE79AB9:0x6231,0xE79ABA:0x6232,0xE79B82:0x6233,
	0xE79B8D:0x6234,0xE79B96:0x6235,0xE79B92:0x6236,0xE79B9E:0x6237,0xE79BA1:0x6238,
	0xE79BA5:0x6239,0xE79BA7:0x623A,0xE79BAA:0x623B,0xE898AF:0x623C,0xE79BBB:0x623D,
	0xE79C88:0x623E,0xE79C87:0x623F,0xE79C84:0x6240,0xE79CA9:0x6241,0xE79CA4:0x6242,
	0xE79C9E:0x6243,0xE79CA5:0x6244,0xE79CA6:0x6245,0xE79C9B:0x6246,0xE79CB7:0x6247,
	0xE79CB8:0x6248,0xE79D87:0x6249,0xE79D9A:0x624A,0xE79DA8:0x624B,0xE79DAB:0x624C,
	0xE79D9B:0x624D,0xE79DA5:0x624E,0xE79DBF:0x624F,0xE79DBE:0x6250,0xE79DB9:0x6251,
	0xE79E8E:0x6252,0xE79E8B:0x6253,0xE79E91:0x6254,0xE79EA0:0x6255,0xE79E9E:0x6256,
	0xE79EB0:0x6257,0xE79EB6:0x6258,0xE79EB9:0x6259,0xE79EBF:0x625A,0xE79EBC:0x625B,
	0xE79EBD:0x625C,0xE79EBB:0x625D,0xE79F87:0x625E,0xE79F8D:0x625F,0xE79F97:0x6260,
	0xE79F9A:0x6261,0xE79F9C:0x6262,0xE79FA3:0x6263,0xE79FAE:0x6264,0xE79FBC:0x6265,
	0xE7A08C:0x6266,0xE7A092:0x6267,0xE7A4A6:0x6268,0xE7A0A0:0x6269,0xE7A4AA:0x626A,
	0xE7A185:0x626B,0xE7A28E:0x626C,0xE7A1B4:0x626D,0xE7A286:0x626E,0xE7A1BC:0x626F,
	0xE7A29A:0x6270,0xE7A28C:0x6271,0xE7A2A3:0x6272,0xE7A2B5:0x6273,0xE7A2AA:0x6274,
	0xE7A2AF:0x6275,0xE7A391:0x6276,0xE7A386:0x6277,0xE7A38B:0x6278,0xE7A394:0x6279,
	0xE7A2BE:0x627A,0xE7A2BC:0x627B,0xE7A385:0x627C,0xE7A38A:0x627D,0xE7A3AC:0x627E,
	0xE7A3A7:0x6321,0xE7A39A:0x6322,0xE7A3BD:0x6323,0xE7A3B4:0x6324,0xE7A487:0x6325,
	0xE7A492:0x6326,0xE7A491:0x6327,0xE7A499:0x6328,0xE7A4AC:0x6329,0xE7A4AB:0x632A,
	0xE7A580:0x632B,0xE7A5A0:0x632C,0xE7A597:0x632D,0xE7A59F:0x632E,0xE7A59A:0x632F,
	0xE7A595:0x6330,0xE7A593:0x6331,0xE7A5BA:0x6332,0xE7A5BF:0x6333,0xE7A68A:0x6334,
	0xE7A69D:0x6335,0xE7A6A7:0x6336,0xE9BD8B:0x6337,0xE7A6AA:0x6338,0xE7A6AE:0x6339,
	0xE7A6B3:0x633A,0xE7A6B9:0x633B,0xE7A6BA:0x633C,0xE7A789:0x633D,0xE7A795:0x633E,
	0xE7A7A7:0x633F,0xE7A7AC:0x6340,0xE7A7A1:0x6341,0xE7A7A3:0x6342,0xE7A888:0x6343,
	0xE7A88D:0x6344,0xE7A898:0x6345,0xE7A899:0x6346,0xE7A8A0:0x6347,0xE7A89F:0x6348,
	0xE7A680:0x6349,0xE7A8B1:0x634A,0xE7A8BB:0x634B,0xE7A8BE:0x634C,0xE7A8B7:0x634D,
	0xE7A983:0x634E,0xE7A997:0x634F,0xE7A989:0x6350,0xE7A9A1:0x6351,0xE7A9A2:0x6352,
	0xE7A9A9:0x6353,0xE9BE9D:0x6354,0xE7A9B0:0x6355,0xE7A9B9:0x6356,0xE7A9BD:0x6357,
	0xE7AA88:0x6358,0xE7AA97:0x6359,0xE7AA95:0x635A,0xE7AA98:0x635B,0xE7AA96:0x635C,
	0xE7AAA9:0x635D,0xE7AB88:0x635E,0xE7AAB0:0x635F,0xE7AAB6:0x6360,0xE7AB85:0x6361,
	0xE7AB84:0x6362,0xE7AABF:0x6363,0xE98283:0x6364,0xE7AB87:0x6365,0xE7AB8A:0x6366,
	0xE7AB8D:0x6367,0xE7AB8F:0x6368,0xE7AB95:0x6369,0xE7AB93:0x636A,0xE7AB99:0x636B,
	0xE7AB9A:0x636C,0xE7AB9D:0x636D,0xE7ABA1:0x636E,0xE7ABA2:0x636F,0xE7ABA6:0x6370,
	0xE7ABAD:0x6371,0xE7ABB0:0x6372,0xE7AC82:0x6373,0xE7AC8F:0x6374,0xE7AC8A:0x6375,
	0xE7AC86:0x6376,0xE7ACB3:0x6377,0xE7AC98:0x6378,0xE7AC99:0x6379,0xE7AC9E:0x637A,
	0xE7ACB5:0x637B,0xE7ACA8:0x637C,0xE7ACB6:0x637D,0xE7AD90:0x637E,0xE7ADBA:0x6421,
	0xE7AC84:0x6422,0xE7AD8D:0x6423,0xE7AC8B:0x6424,0xE7AD8C:0x6425,0xE7AD85:0x6426,
	0xE7ADB5:0x6427,0xE7ADA5:0x6428,0xE7ADB4:0x6429,0xE7ADA7:0x642A,0xE7ADB0:0x642B,
	0xE7ADB1:0x642C,0xE7ADAC:0x642D,0xE7ADAE:0x642E,0xE7AE9D:0x642F,0xE7AE98:0x6430,
	0xE7AE9F:0x6431,0xE7AE8D:0x6432,0xE7AE9C:0x6433,0xE7AE9A:0x6434,0xE7AE8B:0x6435,
	0xE7AE92:0x6436,0xE7AE8F:0x6437,0xE7AD9D:0x6438,0xE7AE99:0x6439,0xE7AF8B:0x643A,
	0xE7AF81:0x643B,0xE7AF8C:0x643C,0xE7AF8F:0x643D,0xE7AEB4:0x643E,0xE7AF86:0x643F,
	0xE7AF9D:0x6440,0xE7AFA9:0x6441,0xE7B091:0x6442,0xE7B094:0x6443,0xE7AFA6:0x6444,
	0xE7AFA5:0x6445,0xE7B1A0:0x6446,0xE7B080:0x6447,0xE7B087:0x6448,0xE7B093:0x6449,
	0xE7AFB3:0x644A,0xE7AFB7:0x644B,0xE7B097:0x644C,0xE7B08D:0x644D,0xE7AFB6:0x644E,
	0xE7B0A3:0x644F,0xE7B0A7:0x6450,0xE7B0AA:0x6451,0xE7B09F:0x6452,0xE7B0B7:0x6453,
	0xE7B0AB:0x6454,0xE7B0BD:0x6455,0xE7B18C:0x6456,0xE7B183:0x6457,0xE7B194:0x6458,
	0xE7B18F:0x6459,0xE7B180:0x645A,0xE7B190:0x645B,0xE7B198:0x645C,0xE7B19F:0x645D,
	0xE7B1A4:0x645E,0xE7B196:0x645F,0xE7B1A5:0x6460,0xE7B1AC:0x6461,0xE7B1B5:0x6462,
	0xE7B283:0x6463,0xE7B290:0x6464,0xE7B2A4:0x6465,0xE7B2AD:0x6466,0xE7B2A2:0x6467,
	0xE7B2AB:0x6468,0xE7B2A1:0x6469,0xE7B2A8:0x646A,0xE7B2B3:0x646B,0xE7B2B2:0x646C,
	0xE7B2B1:0x646D,0xE7B2AE:0x646E,0xE7B2B9:0x646F,0xE7B2BD:0x6470,0xE7B380:0x6471,
	0xE7B385:0x6472,0xE7B382:0x6473,0xE7B398:0x6474,0xE7B392:0x6475,0xE7B39C:0x6476,
	0xE7B3A2:0x6477,0xE9ACBB:0x6478,0xE7B3AF:0x6479,0xE7B3B2:0x647A,0xE7B3B4:0x647B,
	0xE7B3B6:0x647C,0xE7B3BA:0x647D,0xE7B486:0x647E,0xE7B482:0x6521,0xE7B49C:0x6522,
	0xE7B495:0x6523,0xE7B48A:0x6524,0xE7B585:0x6525,0xE7B58B:0x6526,0xE7B4AE:0x6527,
	0xE7B4B2:0x6528,0xE7B4BF:0x6529,0xE7B4B5:0x652A,0xE7B586:0x652B,0xE7B5B3:0x652C,
	0xE7B596:0x652D,0xE7B58E:0x652E,0xE7B5B2:0x652F,0xE7B5A8:0x6530,0xE7B5AE:0x6531,
	0xE7B58F:0x6532,0xE7B5A3:0x6533,0xE7B693:0x6534,0xE7B689:0x6535,0xE7B59B:0x6536,
	0xE7B68F:0x6537,0xE7B5BD:0x6538,0xE7B69B:0x6539,0xE7B6BA:0x653A,0xE7B6AE:0x653B,
	0xE7B6A3:0x653C,0xE7B6B5:0x653D,0xE7B787:0x653E,0xE7B6BD:0x653F,0xE7B6AB:0x6540,
	0xE7B8BD:0x6541,0xE7B6A2:0x6542,0xE7B6AF:0x6543,0xE7B79C:0x6544,0xE7B6B8:0x6545,
	0xE7B69F:0x6546,0xE7B6B0:0x6547,0xE7B798:0x6548,0xE7B79D:0x6549,0xE7B7A4:0x654A,
	0xE7B79E:0x654B,0xE7B7BB:0x654C,0xE7B7B2:0x654D,0xE7B7A1:0x654E,0xE7B885:0x654F,
	0xE7B88A:0x6550,0xE7B8A3:0x6551,0xE7B8A1:0x6552,0xE7B892:0x6553,0xE7B8B1:0x6554,
	0xE7B89F:0x6555,0xE7B889:0x6556,0xE7B88B:0x6557,0xE7B8A2:0x6558,0xE7B986:0x6559,
	0xE7B9A6:0x655A,0xE7B8BB:0x655B,0xE7B8B5:0x655C,0xE7B8B9:0x655D,0xE7B983:0x655E,
	0xE7B8B7:0x655F,0xE7B8B2:0x6560,0xE7B8BA:0x6561,0xE7B9A7:0x6562,0xE7B99D:0x6563,
	0xE7B996:0x6564,0xE7B99E:0x6565,0xE7B999:0x6566,0xE7B99A:0x6567,0xE7B9B9:0x6568,
	0xE7B9AA:0x6569,0xE7B9A9:0x656A,0xE7B9BC:0x656B,0xE7B9BB:0x656C,0xE7BA83:0x656D,
	0xE7B795:0x656E,0xE7B9BD:0x656F,0xE8BEAE:0x6570,0xE7B9BF:0x6571,0xE7BA88:0x6572,
	0xE7BA89:0x6573,0xE7BA8C:0x6574,0xE7BA92:0x6575,0xE7BA90:0x6576,0xE7BA93:0x6577,
	0xE7BA94:0x6578,0xE7BA96:0x6579,0xE7BA8E:0x657A,0xE7BA9B:0x657B,0xE7BA9C:0x657C,
	0xE7BCB8:0x657D,0xE7BCBA:0x657E,0xE7BD85:0x6621,0xE7BD8C:0x6622,0xE7BD8D:0x6623,
	0xE7BD8E:0x6624,0xE7BD90:0x6625,0xE7BD91:0x6626,0xE7BD95:0x6627,0xE7BD94:0x6628,
	0xE7BD98:0x6629,0xE7BD9F:0x662A,0xE7BDA0:0x662B,0xE7BDA8:0x662C,0xE7BDA9:0x662D,
	0xE7BDA7:0x662E,0xE7BDB8:0x662F,0xE7BE82:0x6630,0xE7BE86:0x6631,0xE7BE83:0x6632,
	0xE7BE88:0x6633,0xE7BE87:0x6634,0xE7BE8C:0x6635,0xE7BE94:0x6636,0xE7BE9E:0x6637,
	0xE7BE9D:0x6638,0xE7BE9A:0x6639,0xE7BEA3:0x663A,0xE7BEAF:0x663B,0xE7BEB2:0x663C,
	0xE7BEB9:0x663D,0xE7BEAE:0x663E,0xE7BEB6:0x663F,0xE7BEB8:0x6640,0xE8ADB1:0x6641,
	0xE7BF85:0x6642,0xE7BF86:0x6643,0xE7BF8A:0x6644,0xE7BF95:0x6645,0xE7BF94:0x6646,
	0xE7BFA1:0x6647,0xE7BFA6:0x6648,0xE7BFA9:0x6649,0xE7BFB3:0x664A,0xE7BFB9:0x664B,
	0xE9A39C:0x664C,0xE88086:0x664D,0xE88084:0x664E,0xE8808B:0x664F,0xE88092:0x6650,
	0xE88098:0x6651,0xE88099:0x6652,0xE8809C:0x6653,0xE880A1:0x6654,0xE880A8:0x6655,
	0xE880BF:0x6656,0xE880BB:0x6657,0xE8818A:0x6658,0xE88186:0x6659,0xE88192:0x665A,
	0xE88198:0x665B,0xE8819A:0x665C,0xE8819F:0x665D,0xE881A2:0x665E,0xE881A8:0x665F,
	0xE881B3:0x6660,0xE881B2:0x6661,0xE881B0:0x6662,0xE881B6:0x6663,0xE881B9:0x6664,
	0xE881BD:0x6665,0xE881BF:0x6666,0xE88284:0x6667,0xE88286:0x6668,0xE88285:0x6669,
	0xE8829B:0x666A,0xE88293:0x666B,0xE8829A:0x666C,0xE882AD:0x666D,0xE58690:0x666E,
	0xE882AC:0x666F,0xE8839B:0x6670,0xE883A5:0x6671,0xE88399:0x6672,0xE8839D:0x6673,
	0xE88384:0x6674,0xE8839A:0x6675,0xE88396:0x6676,0xE88489:0x6677,0xE883AF:0x6678,
	0xE883B1:0x6679,0xE8849B:0x667A,0xE884A9:0x667B,0xE884A3:0x667C,0xE884AF:0x667D,
	0xE8858B:0x667E,0xE99A8B:0x6721,0xE88586:0x6722,0xE884BE:0x6723,0xE88593:0x6724,
	0xE88591:0x6725,0xE883BC:0x6726,0xE885B1:0x6727,0xE885AE:0x6728,0xE885A5:0x6729,
	0xE885A6:0x672A,0xE885B4:0x672B,0xE88683:0x672C,0xE88688:0x672D,0xE8868A:0x672E,
	0xE88680:0x672F,0xE88682:0x6730,0xE886A0:0x6731,0xE88695:0x6732,0xE886A4:0x6733,
	0xE886A3:0x6734,0xE8859F:0x6735,0xE88693:0x6736,0xE886A9:0x6737,0xE886B0:0x6738,
	0xE886B5:0x6739,0xE886BE:0x673A,0xE886B8:0x673B,0xE886BD:0x673C,0xE88780:0x673D,
	0xE88782:0x673E,0xE886BA:0x673F,0xE88789:0x6740,0xE8878D:0x6741,0xE88791:0x6742,
	0xE88799:0x6743,0xE88798:0x6744,0xE88788:0x6745,0xE8879A:0x6746,0xE8879F:0x6747,
	0xE887A0:0x6748,0xE887A7:0x6749,0xE887BA:0x674A,0xE887BB:0x674B,0xE887BE:0x674C,
	0xE88881:0x674D,0xE88882:0x674E,0xE88885:0x674F,0xE88887:0x6750,0xE8888A:0x6751,
	0xE8888D:0x6752,0xE88890:0x6753,0xE88896:0x6754,0xE888A9:0x6755,0xE888AB:0x6756,
	0xE888B8:0x6757,0xE888B3:0x6758,0xE88980:0x6759,0xE88999:0x675A,0xE88998:0x675B,
	0xE8899D:0x675C,0xE8899A:0x675D,0xE8899F:0x675E,0xE889A4:0x675F,0xE889A2:0x6760,
	0xE889A8:0x6761,0xE889AA:0x6762,0xE889AB:0x6763,0xE888AE:0x6764,0xE889B1:0x6765,
	0xE889B7:0x6766,0xE889B8:0x6767,0xE889BE:0x6768,0xE88A8D:0x6769,0xE88A92:0x676A,
	0xE88AAB:0x676B,0xE88A9F:0x676C,0xE88ABB:0x676D,0xE88AAC:0x676E,0xE88BA1:0x676F,
	0xE88BA3:0x6770,0xE88B9F:0x6771,0xE88B92:0x6772,0xE88BB4:0x6773,0xE88BB3:0x6774,
	0xE88BBA:0x6775,0xE88E93:0x6776,0xE88C83:0x6777,0xE88BBB:0x6778,0xE88BB9:0x6779,
	0xE88B9E:0x677A,0xE88C86:0x677B,0xE88B9C:0x677C,0xE88C89:0x677D,0xE88B99:0x677E,
	0xE88CB5:0x6821,0xE88CB4:0x6822,0xE88C96:0x6823,0xE88CB2:0x6824,0xE88CB1:0x6825,
	0xE88D80:0x6826,0xE88CB9:0x6827,0xE88D90:0x6828,0xE88D85:0x6829,0xE88CAF:0x682A,
	0xE88CAB:0x682B,0xE88C97:0x682C,0xE88C98:0x682D,0xE88E85:0x682E,0xE88E9A:0x682F,
	0xE88EAA:0x6830,0xE88E9F:0x6831,0xE88EA2:0x6832,0xE88E96:0x6833,0xE88CA3:0x6834,
	0xE88E8E:0x6835,0xE88E87:0x6836,0xE88E8A:0x6837,0xE88DBC:0x6838,0xE88EB5:0x6839,
	0xE88DB3:0x683A,0xE88DB5:0x683B,0xE88EA0:0x683C,0xE88E89:0x683D,0xE88EA8:0x683E,
	0xE88FB4:0x683F,0xE89093:0x6840,0xE88FAB:0x6841,0xE88F8E:0x6842,0xE88FBD:0x6843,
	0xE89083:0x6844,0xE88F98:0x6845,0xE8908B:0x6846,0xE88F81:0x6847,0xE88FB7:0x6848,
	0xE89087:0x6849,0xE88FA0:0x684A,0xE88FB2:0x684B,0xE8908D:0x684C,0xE890A2:0x684D,
	0xE890A0:0x684E,0xE88EBD:0x684F,0xE890B8:0x6850,0xE89486:0x6851,0xE88FBB:0x6852,
	0xE891AD:0x6853,0xE890AA:0x6854,0xE890BC:0x6855,0xE8959A:0x6856,0xE89284:0x6857,
	0xE891B7:0x6858,0xE891AB:0x6859,0xE892AD:0x685A,0xE891AE:0x685B,0xE89282:0x685C,
	0xE891A9:0x685D,0xE89186:0x685E,0xE890AC:0x685F,0xE891AF:0x6860,0xE891B9:0x6861,
	0xE890B5:0x6862,0xE8938A:0x6863,0xE891A2:0x6864,0xE892B9:0x6865,0xE892BF:0x6866,
	0xE8929F:0x6867,0xE89399:0x6868,0xE8938D:0x6869,0xE892BB:0x686A,0xE8939A:0x686B,
	0xE89390:0x686C,0xE89381:0x686D,0xE89386:0x686E,0xE89396:0x686F,0xE892A1:0x6870,
	0xE894A1:0x6871,0xE893BF:0x6872,0xE893B4:0x6873,0xE89497:0x6874,0xE89498:0x6875,
	0xE894AC:0x6876,0xE8949F:0x6877,0xE89495:0x6878,0xE89494:0x6879,0xE893BC:0x687A,
	0xE89580:0x687B,0xE895A3:0x687C,0xE89598:0x687D,0xE89588:0x687E,0xE89581:0x6921,
	0xE89882:0x6922,0xE8958B:0x6923,0xE89595:0x6924,0xE89680:0x6925,0xE896A4:0x6926,
	0xE89688:0x6927,0xE89691:0x6928,0xE8968A:0x6929,0xE896A8:0x692A,0xE895AD:0x692B,
	0xE89694:0x692C,0xE8969B:0x692D,0xE897AA:0x692E,0xE89687:0x692F,0xE8969C:0x6930,
	0xE895B7:0x6931,0xE895BE:0x6932,0xE89690:0x6933,0xE89789:0x6934,0xE896BA:0x6935,
	0xE8978F:0x6936,0xE896B9:0x6937,0xE89790:0x6938,0xE89795:0x6939,0xE8979D:0x693A,
	0xE897A5:0x693B,0xE8979C:0x693C,0xE897B9:0x693D,0xE8988A:0x693E,0xE89893:0x693F,
	0xE8988B:0x6940,0xE897BE:0x6941,0xE897BA:0x6942,0xE89886:0x6943,0xE898A2:0x6944,
	0xE8989A:0x6945,0xE898B0:0x6946,0xE898BF:0x6947,0xE8998D:0x6948,0xE4B995:0x6949,
	0xE89994:0x694A,0xE8999F:0x694B,0xE899A7:0x694C,0xE899B1:0x694D,0xE89A93:0x694E,
	0xE89AA3:0x694F,0xE89AA9:0x6950,0xE89AAA:0x6951,0xE89A8B:0x6952,0xE89A8C:0x6953,
	0xE89AB6:0x6954,0xE89AAF:0x6955,0xE89B84:0x6956,0xE89B86:0x6957,0xE89AB0:0x6958,
	0xE89B89:0x6959,0xE8A0A3:0x695A,0xE89AAB:0x695B,0xE89B94:0x695C,0xE89B9E:0x695D,
	0xE89BA9:0x695E,0xE89BAC:0x695F,0xE89B9F:0x6960,0xE89B9B:0x6961,0xE89BAF:0x6962,
	0xE89C92:0x6963,0xE89C86:0x6964,0xE89C88:0x6965,0xE89C80:0x6966,0xE89C83:0x6967,
	0xE89BBB:0x6968,0xE89C91:0x6969,0xE89C89:0x696A,0xE89C8D:0x696B,0xE89BB9:0x696C,
	0xE89C8A:0x696D,0xE89CB4:0x696E,0xE89CBF:0x696F,0xE89CB7:0x6970,0xE89CBB:0x6971,
	0xE89CA5:0x6972,0xE89CA9:0x6973,0xE89C9A:0x6974,0xE89DA0:0x6975,0xE89D9F:0x6976,
	0xE89DB8:0x6977,0xE89D8C:0x6978,0xE89D8E:0x6979,0xE89DB4:0x697A,0xE89D97:0x697B,
	0xE89DA8:0x697C,0xE89DAE:0x697D,0xE89D99:0x697E,0xE89D93:0x6A21,0xE89DA3:0x6A22,
	0xE89DAA:0x6A23,0xE8A085:0x6A24,0xE89EA2:0x6A25,0xE89E9F:0x6A26,0xE89E82:0x6A27,
	0xE89EAF:0x6A28,0xE89F8B:0x6A29,0xE89EBD:0x6A2A,0xE89F80:0x6A2B,0xE89F90:0x6A2C,
	0xE99B96:0x6A2D,0xE89EAB:0x6A2E,0xE89F84:0x6A2F,0xE89EB3:0x6A30,0xE89F87:0x6A31,
	0xE89F86:0x6A32,0xE89EBB:0x6A33,0xE89FAF:0x6A34,0xE89FB2:0x6A35,0xE89FA0:0x6A36,
	0xE8A08F:0x6A37,0xE8A08D:0x6A38,0xE89FBE:0x6A39,0xE89FB6:0x6A3A,0xE89FB7:0x6A3B,
	0xE8A08E:0x6A3C,0xE89F92:0x6A3D,0xE8A091:0x6A3E,0xE8A096:0x6A3F,0xE8A095:0x6A40,
	0xE8A0A2:0x6A41,0xE8A0A1:0x6A42,0xE8A0B1:0x6A43,0xE8A0B6:0x6A44,0xE8A0B9:0x6A45,
	0xE8A0A7:0x6A46,0xE8A0BB:0x6A47,0xE8A184:0x6A48,0xE8A182:0x6A49,0xE8A192:0x6A4A,
	0xE8A199:0x6A4B,0xE8A19E:0x6A4C,0xE8A1A2:0x6A4D,0xE8A1AB:0x6A4E,0xE8A281:0x6A4F,
	0xE8A1BE:0x6A50,0xE8A29E:0x6A51,0xE8A1B5:0x6A52,0xE8A1BD:0x6A53,0xE8A2B5:0x6A54,
	0xE8A1B2:0x6A55,0xE8A282:0x6A56,0xE8A297:0x6A57,0xE8A292:0x6A58,0xE8A2AE:0x6A59,
	0xE8A299:0x6A5A,0xE8A2A2:0x6A5B,0xE8A28D:0x6A5C,0xE8A2A4:0x6A5D,0xE8A2B0:0x6A5E,
	0xE8A2BF:0x6A5F,0xE8A2B1:0x6A60,0xE8A383:0x6A61,0xE8A384:0x6A62,0xE8A394:0x6A63,
	0xE8A398:0x6A64,0xE8A399:0x6A65,0xE8A39D:0x6A66,0xE8A3B9:0x6A67,0xE8A482:0x6A68,
	0xE8A3BC:0x6A69,0xE8A3B4:0x6A6A,0xE8A3A8:0x6A6B,0xE8A3B2:0x6A6C,0xE8A484:0x6A6D,
	0xE8A48C:0x6A6E,0xE8A48A:0x6A6F,0xE8A493:0x6A70,0xE8A583:0x6A71,0xE8A49E:0x6A72,
	0xE8A4A5:0x6A73,0xE8A4AA:0x6A74,0xE8A4AB:0x6A75,0xE8A581:0x6A76,0xE8A584:0x6A77,
	0xE8A4BB:0x6A78,0xE8A4B6:0x6A79,0xE8A4B8:0x6A7A,0xE8A58C:0x6A7B,0xE8A49D:0x6A7C,
	0xE8A5A0:0x6A7D,0xE8A59E:0x6A7E,0xE8A5A6:0x6B21,0xE8A5A4:0x6B22,0xE8A5AD:0x6B23,
	0xE8A5AA:0x6B24,0xE8A5AF:0x6B25,0xE8A5B4:0x6B26,0xE8A5B7:0x6B27,0xE8A5BE:0x6B28,
	0xE8A683:0x6B29,0xE8A688:0x6B2A,0xE8A68A:0x6B2B,0xE8A693:0x6B2C,0xE8A698:0x6B2D,
	0xE8A6A1:0x6B2E,0xE8A6A9:0x6B2F,0xE8A6A6:0x6B30,0xE8A6AC:0x6B31,0xE8A6AF:0x6B32,
	0xE8A6B2:0x6B33,0xE8A6BA:0x6B34,0xE8A6BD:0x6B35,0xE8A6BF:0x6B36,0xE8A780:0x6B37,
	0xE8A79A:0x6B38,0xE8A79C:0x6B39,0xE8A79D:0x6B3A,0xE8A7A7:0x6B3B,0xE8A7B4:0x6B3C,
	0xE8A7B8:0x6B3D,0xE8A883:0x6B3E,0xE8A896:0x6B3F,0xE8A890:0x6B40,0xE8A88C:0x6B41,
	0xE8A89B:0x6B42,0xE8A89D:0x6B43,0xE8A8A5:0x6B44,0xE8A8B6:0x6B45,0xE8A981:0x6B46,
	0xE8A99B:0x6B47,0xE8A992:0x6B48,0xE8A986:0x6B49,0xE8A988:0x6B4A,0xE8A9BC:0x6B4B,
	0xE8A9AD:0x6B4C,0xE8A9AC:0x6B4D,0xE8A9A2:0x6B4E,0xE8AA85:0x6B4F,0xE8AA82:0x6B50,
	0xE8AA84:0x6B51,0xE8AAA8:0x6B52,0xE8AAA1:0x6B53,0xE8AA91:0x6B54,0xE8AAA5:0x6B55,
	0xE8AAA6:0x6B56,0xE8AA9A:0x6B57,0xE8AAA3:0x6B58,0xE8AB84:0x6B59,0xE8AB8D:0x6B5A,
	0xE8AB82:0x6B5B,0xE8AB9A:0x6B5C,0xE8ABAB:0x6B5D,0xE8ABB3:0x6B5E,0xE8ABA7:0x6B5F,
	0xE8ABA4:0x6B60,0xE8ABB1:0x6B61,0xE8AC94:0x6B62,0xE8ABA0:0x6B63,0xE8ABA2:0x6B64,
	0xE8ABB7:0x6B65,0xE8AB9E:0x6B66,0xE8AB9B:0x6B67,0xE8AC8C:0x6B68,0xE8AC87:0x6B69,
	0xE8AC9A:0x6B6A,0xE8ABA1:0x6B6B,0xE8AC96:0x6B6C,0xE8AC90:0x6B6D,0xE8AC97:0x6B6E,
	0xE8ACA0:0x6B6F,0xE8ACB3:0x6B70,0xE99EAB:0x6B71,0xE8ACA6:0x6B72,0xE8ACAB:0x6B73,
	0xE8ACBE:0x6B74,0xE8ACA8:0x6B75,0xE8AD81:0x6B76,0xE8AD8C:0x6B77,0xE8AD8F:0x6B78,
	0xE8AD8E:0x6B79,0xE8AD89:0x6B7A,0xE8AD96:0x6B7B,0xE8AD9B:0x6B7C,0xE8AD9A:0x6B7D,
	0xE8ADAB:0x6B7E,0xE8AD9F:0x6C21,0xE8ADAC:0x6C22,0xE8ADAF:0x6C23,0xE8ADB4:0x6C24,
	0xE8ADBD:0x6C25,0xE8AE80:0x6C26,0xE8AE8C:0x6C27,0xE8AE8E:0x6C28,0xE8AE92:0x6C29,
	0xE8AE93:0x6C2A,0xE8AE96:0x6C2B,0xE8AE99:0x6C2C,0xE8AE9A:0x6C2D,0xE8B0BA:0x6C2E,
	0xE8B181:0x6C2F,0xE8B0BF:0x6C30,0xE8B188:0x6C31,0xE8B18C:0x6C32,0xE8B18E:0x6C33,
	0xE8B190:0x6C34,0xE8B195:0x6C35,0xE8B1A2:0x6C36,0xE8B1AC:0x6C37,0xE8B1B8:0x6C38,
	0xE8B1BA:0x6C39,0xE8B282:0x6C3A,0xE8B289:0x6C3B,0xE8B285:0x6C3C,0xE8B28A:0x6C3D,
	0xE8B28D:0x6C3E,0xE8B28E:0x6C3F,0xE8B294:0x6C40,0xE8B1BC:0x6C41,0xE8B298:0x6C42,
	0xE6889D:0x6C43,0xE8B2AD:0x6C44,0xE8B2AA:0x6C45,0xE8B2BD:0x6C46,0xE8B2B2:0x6C47,
	0xE8B2B3:0x6C48,0xE8B2AE:0x6C49,0xE8B2B6:0x6C4A,0xE8B388:0x6C4B,0xE8B381:0x6C4C,
	0xE8B3A4:0x6C4D,0xE8B3A3:0x6C4E,0xE8B39A:0x6C4F,0xE8B3BD:0x6C50,0xE8B3BA:0x6C51,
	0xE8B3BB:0x6C52,0xE8B484:0x6C53,0xE8B485:0x6C54,0xE8B48A:0x6C55,0xE8B487:0x6C56,
	0xE8B48F:0x6C57,0xE8B48D:0x6C58,0xE8B490:0x6C59,0xE9BD8E:0x6C5A,0xE8B493:0x6C5B,
	0xE8B38D:0x6C5C,0xE8B494:0x6C5D,0xE8B496:0x6C5E,0xE8B5A7:0x6C5F,0xE8B5AD:0x6C60,
	0xE8B5B1:0x6C61,0xE8B5B3:0x6C62,0xE8B681:0x6C63,0xE8B699:0x6C64,0xE8B782:0x6C65,
	0xE8B6BE:0x6C66,0xE8B6BA:0x6C67,0xE8B78F:0x6C68,0xE8B79A:0x6C69,0xE8B796:0x6C6A,
	0xE8B78C:0x6C6B,0xE8B79B:0x6C6C,0xE8B78B:0x6C6D,0xE8B7AA:0x6C6E,0xE8B7AB:0x6C6F,
	0xE8B79F:0x6C70,0xE8B7A3:0x6C71,0xE8B7BC:0x6C72,0xE8B888:0x6C73,0xE8B889:0x6C74,
	0xE8B7BF:0x6C75,0xE8B89D:0x6C76,0xE8B89E:0x6C77,0xE8B890:0x6C78,0xE8B89F:0x6C79,
	0xE8B982:0x6C7A,0xE8B8B5:0x6C7B,0xE8B8B0:0x6C7C,0xE8B8B4:0x6C7D,0xE8B98A:0x6C7E,
	0xE8B987:0x6D21,0xE8B989:0x6D22,0xE8B98C:0x6D23,0xE8B990:0x6D24,0xE8B988:0x6D25,
	0xE8B999:0x6D26,0xE8B9A4:0x6D27,0xE8B9A0:0x6D28,0xE8B8AA:0x6D29,0xE8B9A3:0x6D2A,
	0xE8B995:0x6D2B,0xE8B9B6:0x6D2C,0xE8B9B2:0x6D2D,0xE8B9BC:0x6D2E,0xE8BA81:0x6D2F,
	0xE8BA87:0x6D30,0xE8BA85:0x6D31,0xE8BA84:0x6D32,0xE8BA8B:0x6D33,0xE8BA8A:0x6D34,
	0xE8BA93:0x6D35,0xE8BA91:0x6D36,0xE8BA94:0x6D37,0xE8BA99:0x6D38,0xE8BAAA:0x6D39,
	0xE8BAA1:0x6D3A,0xE8BAAC:0x6D3B,0xE8BAB0:0x6D3C,0xE8BB86:0x6D3D,0xE8BAB1:0x6D3E,
	0xE8BABE:0x6D3F,0xE8BB85:0x6D40,0xE8BB88:0x6D41,0xE8BB8B:0x6D42,0xE8BB9B:0x6D43,
	0xE8BBA3:0x6D44,0xE8BBBC:0x6D45,0xE8BBBB:0x6D46,0xE8BBAB:0x6D47,0xE8BBBE:0x6D48,
	0xE8BC8A:0x6D49,0xE8BC85:0x6D4A,0xE8BC95:0x6D4B,0xE8BC92:0x6D4C,0xE8BC99:0x6D4D,
	0xE8BC93:0x6D4E,0xE8BC9C:0x6D4F,0xE8BC9F:0x6D50,0xE8BC9B:0x6D51,0xE8BC8C:0x6D52,
	0xE8BCA6:0x6D53,0xE8BCB3:0x6D54,0xE8BCBB:0x6D55,0xE8BCB9:0x6D56,0xE8BD85:0x6D57,
	0xE8BD82:0x6D58,0xE8BCBE:0x6D59,0xE8BD8C:0x6D5A,0xE8BD89:0x6D5B,0xE8BD86:0x6D5C,
	0xE8BD8E:0x6D5D,0xE8BD97:0x6D5E,0xE8BD9C:0x6D5F,0xE8BDA2:0x6D60,0xE8BDA3:0x6D61,
	0xE8BDA4:0x6D62,0xE8BE9C:0x6D63,0xE8BE9F:0x6D64,0xE8BEA3:0x6D65,0xE8BEAD:0x6D66,
	0xE8BEAF:0x6D67,0xE8BEB7:0x6D68,0xE8BF9A:0x6D69,0xE8BFA5:0x6D6A,0xE8BFA2:0x6D6B,
	0xE8BFAA:0x6D6C,0xE8BFAF:0x6D6D,0xE98287:0x6D6E,0xE8BFB4:0x6D6F,0xE98085:0x6D70,
	0xE8BFB9:0x6D71,0xE8BFBA:0x6D72,0xE98091:0x6D73,0xE98095:0x6D74,0xE980A1:0x6D75,
	0xE9808D:0x6D76,0xE9809E:0x6D77,0xE98096:0x6D78,0xE9808B:0x6D79,0xE980A7:0x6D7A,
	0xE980B6:0x6D7B,0xE980B5:0x6D7C,0xE980B9:0x6D7D,0xE8BFB8:0x6D7E,0xE9818F:0x6E21,
	0xE98190:0x6E22,0xE98191:0x6E23,0xE98192:0x6E24,0xE9808E:0x6E25,0xE98189:0x6E26,
	0xE980BE:0x6E27,0xE98196:0x6E28,0xE98198:0x6E29,0xE9819E:0x6E2A,0xE981A8:0x6E2B,
	0xE981AF:0x6E2C,0xE981B6:0x6E2D,0xE99AA8:0x6E2E,0xE981B2:0x6E2F,0xE98282:0x6E30,
	0xE981BD:0x6E31,0xE98281:0x6E32,0xE98280:0x6E33,0xE9828A:0x6E34,0xE98289:0x6E35,
	0xE9828F:0x6E36,0xE982A8:0x6E37,0xE982AF:0x6E38,0xE982B1:0x6E39,0xE982B5:0x6E3A,
	0xE983A2:0x6E3B,0xE983A4:0x6E3C,0xE68988:0x6E3D,0xE9839B:0x6E3E,0xE98482:0x6E3F,
	0xE98492:0x6E40,0xE98499:0x6E41,0xE984B2:0x6E42,0xE984B0:0x6E43,0xE9858A:0x6E44,
	0xE98596:0x6E45,0xE98598:0x6E46,0xE985A3:0x6E47,0xE985A5:0x6E48,0xE985A9:0x6E49,
	0xE985B3:0x6E4A,0xE985B2:0x6E4B,0xE9868B:0x6E4C,0xE98689:0x6E4D,0xE98682:0x6E4E,
	0xE986A2:0x6E4F,0xE986AB:0x6E50,0xE986AF:0x6E51,0xE986AA:0x6E52,0xE986B5:0x6E53,
	0xE986B4:0x6E54,0xE986BA:0x6E55,0xE98780:0x6E56,0xE98781:0x6E57,0xE98789:0x6E58,
	0xE9878B:0x6E59,0xE98790:0x6E5A,0xE98796:0x6E5B,0xE9879F:0x6E5C,0xE987A1:0x6E5D,
	0xE9879B:0x6E5E,0xE987BC:0x6E5F,0xE987B5:0x6E60,0xE987B6:0x6E61,0xE9889E:0x6E62,
	0xE987BF:0x6E63,0xE98894:0x6E64,0xE988AC:0x6E65,0xE98895:0x6E66,0xE98891:0x6E67,
	0xE9899E:0x6E68,0xE98997:0x6E69,0xE98985:0x6E6A,0xE98989:0x6E6B,0xE989A4:0x6E6C,
	0xE98988:0x6E6D,0xE98A95:0x6E6E,0xE988BF:0x6E6F,0xE9898B:0x6E70,0xE98990:0x6E71,
	0xE98A9C:0x6E72,0xE98A96:0x6E73,0xE98A93:0x6E74,0xE98A9B:0x6E75,0xE9899A:0x6E76,
	0xE98B8F:0x6E77,0xE98AB9:0x6E78,0xE98AB7:0x6E79,0xE98BA9:0x6E7A,0xE98C8F:0x6E7B,
	0xE98BBA:0x6E7C,0xE98D84:0x6E7D,0xE98CAE:0x6E7E,0xE98C99:0x6F21,0xE98CA2:0x6F22,
	0xE98C9A:0x6F23,0xE98CA3:0x6F24,0xE98CBA:0x6F25,0xE98CB5:0x6F26,0xE98CBB:0x6F27,
	0xE98D9C:0x6F28,0xE98DA0:0x6F29,0xE98DBC:0x6F2A,0xE98DAE:0x6F2B,0xE98D96:0x6F2C,
	0xE98EB0:0x6F2D,0xE98EAC:0x6F2E,0xE98EAD:0x6F2F,0xE98E94:0x6F30,0xE98EB9:0x6F31,
	0xE98F96:0x6F32,0xE98F97:0x6F33,0xE98FA8:0x6F34,0xE98FA5:0x6F35,0xE98F98:0x6F36,
	0xE98F83:0x6F37,0xE98F9D:0x6F38,0xE98F90:0x6F39,0xE98F88:0x6F3A,0xE98FA4:0x6F3B,
	0xE9909A:0x6F3C,0xE99094:0x6F3D,0xE99093:0x6F3E,0xE99083:0x6F3F,0xE99087:0x6F40,
	0xE99090:0x6F41,0xE990B6:0x6F42,0xE990AB:0x6F43,0xE990B5:0x6F44,0xE990A1:0x6F45,
	0xE990BA:0x6F46,0xE99181:0x6F47,0xE99192:0x6F48,0xE99184:0x6F49,0xE9919B:0x6F4A,
	0xE991A0:0x6F4B,0xE991A2:0x6F4C,0xE9919E:0x6F4D,0xE991AA:0x6F4E,0xE988A9:0x6F4F,
	0xE991B0:0x6F50,0xE991B5:0x6F51,0xE991B7:0x6F52,0xE991BD:0x6F53,0xE9919A:0x6F54,
	0xE991BC:0x6F55,0xE991BE:0x6F56,0xE99281:0x6F57,0xE991BF:0x6F58,0xE99682:0x6F59,
	0xE99687:0x6F5A,0xE9968A:0x6F5B,0xE99694:0x6F5C,0xE99696:0x6F5D,0xE99698:0x6F5E,
	0xE99699:0x6F5F,0xE996A0:0x6F60,0xE996A8:0x6F61,0xE996A7:0x6F62,0xE996AD:0x6F63,
	0xE996BC:0x6F64,0xE996BB:0x6F65,0xE996B9:0x6F66,0xE996BE:0x6F67,0xE9978A:0x6F68,
	0xE6BFB6:0x6F69,0xE99783:0x6F6A,0xE9978D:0x6F6B,0xE9978C:0x6F6C,0xE99795:0x6F6D,
	0xE99794:0x6F6E,0xE99796:0x6F6F,0xE9979C:0x6F70,0xE997A1:0x6F71,0xE997A5:0x6F72,
	0xE997A2:0x6F73,0xE998A1:0x6F74,0xE998A8:0x6F75,0xE998AE:0x6F76,0xE998AF:0x6F77,
	0xE99982:0x6F78,0xE9998C:0x6F79,0xE9998F:0x6F7A,0xE9998B:0x6F7B,0xE999B7:0x6F7C,
	0xE9999C:0x6F7D,0xE9999E:0x6F7E,0xE9999D:0x7021,0xE9999F:0x7022,0xE999A6:0x7023,
	0xE999B2:0x7024,0xE999AC:0x7025,0xE99A8D:0x7026,0xE99A98:0x7027,0xE99A95:0x7028,
	0xE99A97:0x7029,0xE99AAA:0x702A,0xE99AA7:0x702B,0xE99AB1:0x702C,0xE99AB2:0x702D,
	0xE99AB0:0x702E,0xE99AB4:0x702F,0xE99AB6:0x7030,0xE99AB8:0x7031,0xE99AB9:0x7032,
	0xE99B8E:0x7033,0xE99B8B:0x7034,0xE99B89:0x7035,0xE99B8D:0x7036,0xE8A58D:0x7037,
	0xE99B9C:0x7038,0xE99C8D:0x7039,0xE99B95:0x703A,0xE99BB9:0x703B,0xE99C84:0x703C,
	0xE99C86:0x703D,0xE99C88:0x703E,0xE99C93:0x703F,0xE99C8E:0x7040,0xE99C91:0x7041,
	0xE99C8F:0x7042,0xE99C96:0x7043,0xE99C99:0x7044,0xE99CA4:0x7045,0xE99CAA:0x7046,
	0xE99CB0:0x7047,0xE99CB9:0x7048,0xE99CBD:0x7049,0xE99CBE:0x704A,0xE99D84:0x704B,
	0xE99D86:0x704C,0xE99D88:0x704D,0xE99D82:0x704E,0xE99D89:0x704F,0xE99D9C:0x7050,
	0xE99DA0:0x7051,0xE99DA4:0x7052,0xE99DA6:0x7053,0xE99DA8:0x7054,0xE58B92:0x7055,
	0xE99DAB:0x7056,0xE99DB1:0x7057,0xE99DB9:0x7058,0xE99E85:0x7059,0xE99DBC:0x705A,
	0xE99E81:0x705B,0xE99DBA:0x705C,0xE99E86:0x705D,0xE99E8B:0x705E,0xE99E8F:0x705F,
	0xE99E90:0x7060,0xE99E9C:0x7061,0xE99EA8:0x7062,0xE99EA6:0x7063,0xE99EA3:0x7064,
	0xE99EB3:0x7065,0xE99EB4:0x7066,0xE99F83:0x7067,0xE99F86:0x7068,0xE99F88:0x7069,
	0xE99F8B:0x706A,0xE99F9C:0x706B,0xE99FAD:0x706C,0xE9BD8F:0x706D,0xE99FB2:0x706E,
	0xE7AB9F:0x706F,0xE99FB6:0x7070,0xE99FB5:0x7071,0xE9A08F:0x7072,0xE9A08C:0x7073,
	0xE9A0B8:0x7074,0xE9A0A4:0x7075,0xE9A0A1:0x7076,0xE9A0B7:0x7077,0xE9A0BD:0x7078,
	0xE9A186:0x7079,0xE9A18F:0x707A,0xE9A18B:0x707B,0xE9A1AB:0x707C,0xE9A1AF:0x707D,
	0xE9A1B0:0x707E,0xE9A1B1:0x7121,0xE9A1B4:0x7122,0xE9A1B3:0x7123,0xE9A2AA:0x7124,
	0xE9A2AF:0x7125,0xE9A2B1:0x7126,0xE9A2B6:0x7127,0xE9A384:0x7128,0xE9A383:0x7129,
	0xE9A386:0x712A,0xE9A3A9:0x712B,0xE9A3AB:0x712C,0xE9A483:0x712D,0xE9A489:0x712E,
	0xE9A492:0x712F,0xE9A494:0x7130,0xE9A498:0x7131,0xE9A4A1:0x7132,0xE9A49D:0x7133,
	0xE9A49E:0x7134,0xE9A4A4:0x7135,0xE9A4A0:0x7136,0xE9A4AC:0x7137,0xE9A4AE:0x7138,
	0xE9A4BD:0x7139,0xE9A4BE:0x713A,0xE9A582:0x713B,0xE9A589:0x713C,0xE9A585:0x713D,
	0xE9A590:0x713E,0xE9A58B:0x713F,0xE9A591:0x7140,0xE9A592:0x7141,0xE9A58C:0x7142,
	0xE9A595:0x7143,0xE9A697:0x7144,0xE9A698:0x7145,0xE9A6A5:0x7146,0xE9A6AD:0x7147,
	0xE9A6AE:0x7148,0xE9A6BC:0x7149,0xE9A79F:0x714A,0xE9A79B:0x714B,0xE9A79D:0x714C,
	0xE9A798:0x714D,0xE9A791:0x714E,0xE9A7AD:0x714F,0xE9A7AE:0x7150,0xE9A7B1:0x7151,
	0xE9A7B2:0x7152,0xE9A7BB:0x7153,0xE9A7B8:0x7154,0xE9A881:0x7155,0xE9A88F:0x7156,
	0xE9A885:0x7157,0xE9A7A2:0x7158,0xE9A899:0x7159,0xE9A8AB:0x715A,0xE9A8B7:0x715B,
	0xE9A985:0x715C,0xE9A982:0x715D,0xE9A980:0x715E,0xE9A983:0x715F,0xE9A8BE:0x7160,
	0xE9A995:0x7161,0xE9A98D:0x7162,0xE9A99B:0x7163,0xE9A997:0x7164,0xE9A99F:0x7165,
	0xE9A9A2:0x7166,0xE9A9A5:0x7167,0xE9A9A4:0x7168,0xE9A9A9:0x7169,0xE9A9AB:0x716A,
	0xE9A9AA:0x716B,0xE9AAAD:0x716C,0xE9AAB0:0x716D,0xE9AABC:0x716E,0xE9AB80:0x716F,
	0xE9AB8F:0x7170,0xE9AB91:0x7171,0xE9AB93:0x7172,0xE9AB94:0x7173,0xE9AB9E:0x7174,
	0xE9AB9F:0x7175,0xE9ABA2:0x7176,0xE9ABA3:0x7177,0xE9ABA6:0x7178,0xE9ABAF:0x7179,
	0xE9ABAB:0x717A,0xE9ABAE:0x717B,0xE9ABB4:0x717C,0xE9ABB1:0x717D,0xE9ABB7:0x717E,
	0xE9ABBB:0x7221,0xE9AC86:0x7222,0xE9AC98:0x7223,0xE9AC9A:0x7224,0xE9AC9F:0x7225,
	0xE9ACA2:0x7226,0xE9ACA3:0x7227,0xE9ACA5:0x7228,0xE9ACA7:0x7229,0xE9ACA8:0x722A,
	0xE9ACA9:0x722B,0xE9ACAA:0x722C,0xE9ACAE:0x722D,0xE9ACAF:0x722E,0xE9ACB2:0x722F,
	0xE9AD84:0x7230,0xE9AD83:0x7231,0xE9AD8F:0x7232,0xE9AD8D:0x7233,0xE9AD8E:0x7234,
	0xE9AD91:0x7235,0xE9AD98:0x7236,0xE9ADB4:0x7237,0xE9AE93:0x7238,0xE9AE83:0x7239,
	0xE9AE91:0x723A,0xE9AE96:0x723B,0xE9AE97:0x723C,0xE9AE9F:0x723D,0xE9AEA0:0x723E,
	0xE9AEA8:0x723F,0xE9AEB4:0x7240,0xE9AF80:0x7241,0xE9AF8A:0x7242,0xE9AEB9:0x7243,
	0xE9AF86:0x7244,0xE9AF8F:0x7245,0xE9AF91:0x7246,0xE9AF92:0x7247,0xE9AFA3:0x7248,
	0xE9AFA2:0x7249,0xE9AFA4:0x724A,0xE9AF94:0x724B,0xE9AFA1:0x724C,0xE9B0BA:0x724D,
	0xE9AFB2:0x724E,0xE9AFB1:0x724F,0xE9AFB0:0x7250,0xE9B095:0x7251,0xE9B094:0x7252,
	0xE9B089:0x7253,0xE9B093:0x7254,0xE9B08C:0x7255,0xE9B086:0x7256,0xE9B088:0x7257,
	0xE9B092:0x7258,0xE9B08A:0x7259,0xE9B084:0x725A,0xE9B0AE:0x725B,0xE9B09B:0x725C,
	0xE9B0A5:0x725D,0xE9B0A4:0x725E,0xE9B0A1:0x725F,0xE9B0B0:0x7260,0xE9B187:0x7261,
	0xE9B0B2:0x7262,0xE9B186:0x7263,0xE9B0BE:0x7264,0xE9B19A:0x7265,0xE9B1A0:0x7266,
	0xE9B1A7:0x7267,0xE9B1B6:0x7268,0xE9B1B8:0x7269,0xE9B3A7:0x726A,0xE9B3AC:0x726B,
	0xE9B3B0:0x726C,0xE9B489:0x726D,0xE9B488:0x726E,0xE9B3AB:0x726F,0xE9B483:0x7270,
	0xE9B486:0x7271,0xE9B4AA:0x7272,0xE9B4A6:0x7273,0xE9B6AF:0x7274,0xE9B4A3:0x7275,
	0xE9B49F:0x7276,0xE9B584:0x7277,0xE9B495:0x7278,0xE9B492:0x7279,0xE9B581:0x727A,
	0xE9B4BF:0x727B,0xE9B4BE:0x727C,0xE9B586:0x727D,0xE9B588:0x727E,0xE9B59D:0x7321,
	0xE9B59E:0x7322,0xE9B5A4:0x7323,0xE9B591:0x7324,0xE9B590:0x7325,0xE9B599:0x7326,
	0xE9B5B2:0x7327,0xE9B689:0x7328,0xE9B687:0x7329,0xE9B6AB:0x732A,0xE9B5AF:0x732B,
	0xE9B5BA:0x732C,0xE9B69A:0x732D,0xE9B6A4:0x732E,0xE9B6A9:0x732F,0xE9B6B2:0x7330,
	0xE9B784:0x7331,0xE9B781:0x7332,0xE9B6BB:0x7333,0xE9B6B8:0x7334,0xE9B6BA:0x7335,
	0xE9B786:0x7336,0xE9B78F:0x7337,0xE9B782:0x7338,0xE9B799:0x7339,0xE9B793:0x733A,
	0xE9B7B8:0x733B,0xE9B7A6:0x733C,0xE9B7AD:0x733D,0xE9B7AF:0x733E,0xE9B7BD:0x733F,
	0xE9B89A:0x7340,0xE9B89B:0x7341,0xE9B89E:0x7342,0xE9B9B5:0x7343,0xE9B9B9:0x7344,
	0xE9B9BD:0x7345,0xE9BA81:0x7346,0xE9BA88:0x7347,0xE9BA8B:0x7348,0xE9BA8C:0x7349,
	0xE9BA92:0x734A,0xE9BA95:0x734B,0xE9BA91:0x734C,0xE9BA9D:0x734D,0xE9BAA5:0x734E,
	0xE9BAA9:0x734F,0xE9BAB8:0x7350,0xE9BAAA:0x7351,0xE9BAAD:0x7352,0xE99DA1:0x7353,
	0xE9BB8C:0x7354,0xE9BB8E:0x7355,0xE9BB8F:0x7356,0xE9BB90:0x7357,0xE9BB94:0x7358,
	0xE9BB9C:0x7359,0xE9BB9E:0x735A,0xE9BB9D:0x735B,0xE9BBA0:0x735C,0xE9BBA5:0x735D,
	0xE9BBA8:0x735E,0xE9BBAF:0x735F,0xE9BBB4:0x7360,0xE9BBB6:0x7361,0xE9BBB7:0x7362,
	0xE9BBB9:0x7363,0xE9BBBB:0x7364,0xE9BBBC:0x7365,0xE9BBBD:0x7366,0xE9BC87:0x7367,
	0xE9BC88:0x7368,0xE79AB7:0x7369,0xE9BC95:0x736A,0xE9BCA1:0x736B,0xE9BCAC:0x736C,
	0xE9BCBE:0x736D,0xE9BD8A:0x736E,0xE9BD92:0x736F,0xE9BD94:0x7370,0xE9BDA3:0x7371,
	0xE9BD9F:0x7372,0xE9BDA0:0x7373,0xE9BDA1:0x7374,0xE9BDA6:0x7375,0xE9BDA7:0x7376,
	0xE9BDAC:0x7377,0xE9BDAA:0x7378,0xE9BDB7:0x7379,0xE9BDB2:0x737A,0xE9BDB6:0x737B,
	0xE9BE95:0x737C,0xE9BE9C:0x737D,0xE9BEA0:0x737E,0xE5A0AF:0x7421,0xE6A787:0x7422,
	0xE98199:0x7423,0xE791A4:0x7424,0xE5879C:0x7425,0xE78699:0x7426,

	0xE7BA8A:0x7921,0xE8A49C:0x7922,0xE98D88:0x7923,0xE98A88:0x7924,0xE8939C:0x7925,
	0xE4BF89:0x7926,0xE782BB:0x7927,0xE698B1:0x7928,0xE6A388:0x7929,0xE98BB9:0x792A,
	0xE69BBB:0x792B,0xE5BD85:0x792C,0xE4B8A8:0x792D,0xE4BBA1:0x792E,0xE4BBBC:0x792F,
	0xE4BC80:0x7930,0xE4BC83:0x7931,0xE4BCB9:0x7932,0xE4BD96:0x7933,0xE4BE92:0x7934,
	0xE4BE8A:0x7935,0xE4BE9A:0x7936,0xE4BE94:0x7937,0xE4BF8D:0x7938,0xE58180:0x7939,
	0xE580A2:0x793A,0xE4BFBF:0x793B,0xE5809E:0x793C,0xE58186:0x793D,0xE581B0:0x793E,
	0xE58182:0x793F,0xE58294:0x7940,0xE583B4:0x7941,0xE58398:0x7942,0xE5858A:0x7943,
	0xE585A4:0x7944,0xE5869D:0x7945,0xE586BE:0x7946,0xE587AC:0x7947,0xE58895:0x7948,
	0xE58A9C:0x7949,0xE58AA6:0x794A,0xE58B80:0x794B,0xE58B9B:0x794C,0xE58C80:0x794D,
	0xE58C87:0x794E,0xE58CA4:0x794F,0xE58DB2:0x7950,0xE58E93:0x7951,0xE58EB2:0x7952,
	0xE58F9D:0x7953,0xEFA88E:0x7954,0xE5929C:0x7955,0xE5928A:0x7956,0xE592A9:0x7957,
	0xE593BF:0x7958,0xE59686:0x7959,0xE59D99:0x795A,0xE59DA5:0x795B,0xE59EAC:0x795C,
	0xE59F88:0x795D,0xE59F87:0x795E,0xEFA88F:0x795F,0xEFA890:0x7960,0xE5A29E:0x7961,
	0xE5A2B2:0x7962,0xE5A48B:0x7963,0xE5A593:0x7964,0xE5A59B:0x7965,0xE5A59D:0x7966,
	0xE5A5A3:0x7967,0xE5A6A4:0x7968,0xE5A6BA:0x7969,0xE5AD96:0x796A,0xE5AF80:0x796B,
	0xE794AF:0x796C,0xE5AF98:0x796D,0xE5AFAC:0x796E,0xE5B09E:0x796F,0xE5B2A6:0x7970,
	0xE5B2BA:0x7971,0xE5B3B5:0x7972,0xE5B4A7:0x7973,0xE5B593:0x7974,0xEFA891:0x7975,
	0xE5B582:0x7976,0xE5B5AD:0x7977,0xE5B6B8:0x7978,0xE5B6B9:0x7979,0xE5B790:0x797A,
	0xE5BCA1:0x797B,0xE5BCB4:0x797C,0xE5BDA7:0x797D,0xE5BEB7:0x797E,0xE5BF9E:0x7A21,
	0xE6819D:0x7A22,0xE68285:0x7A23,0xE6828A:0x7A24,0xE6839E:0x7A25,0xE68395:0x7A26,
	0xE684A0:0x7A27,0xE683B2:0x7A28,0xE68491:0x7A29,0xE684B7:0x7A2A,0xE684B0:0x7A2B,
	0xE68698:0x7A2C,0xE68893:0x7A2D,0xE68AA6:0x7A2E,0xE68FB5:0x7A2F,0xE691A0:0x7A30,
	0xE6929D:0x7A31,0xE6938E:0x7A32,0xE6958E:0x7A33,0xE69880:0x7A34,0xE69895:0x7A35,
	0xE698BB:0x7A36,0xE69889:0x7A37,0xE698AE:0x7A38,0xE6989E:0x7A39,0xE698A4:0x7A3A,
	0xE699A5:0x7A3B,0xE69997:0x7A3C,0xE69999:0x7A3D,0xEFA892:0x7A3E,0xE699B3:0x7A3F,
	0xE69A99:0x7A40,0xE69AA0:0x7A41,0xE69AB2:0x7A42,0xE69ABF:0x7A43,0xE69BBA:0x7A44,
	0xE69C8E:0x7A45,0xEFA4A9:0x7A46,0xE69DA6:0x7A47,0xE69EBB:0x7A48,0xE6A192:0x7A49,
	0xE69F80:0x7A4A,0xE6A081:0x7A4B,0xE6A184:0x7A4C,0xE6A38F:0x7A4D,0xEFA893:0x7A4E,
	0xE6A5A8:0x7A4F,0xEFA894:0x7A50,0xE6A698:0x7A51,0xE6A7A2:0x7A52,0xE6A8B0:0x7A53,
	0xE6A9AB:0x7A54,0xE6A986:0x7A55,0xE6A9B3:0x7A56,0xE6A9BE:0x7A57,0xE6ABA2:0x7A58,
	0xE6ABA4:0x7A59,0xE6AF96:0x7A5A,0xE6B0BF:0x7A5B,0xE6B19C:0x7A5C,0xE6B286:0x7A5D,
	0xE6B1AF:0x7A5E,0xE6B39A:0x7A5F,0xE6B484:0x7A60,0xE6B687:0x7A61,0xE6B5AF:0x7A62,
	0xE6B696:0x7A63,0xE6B6AC:0x7A64,0xE6B78F:0x7A65,0xE6B7B8:0x7A66,0xE6B7B2:0x7A67,
	0xE6B7BC:0x7A68,0xE6B8B9:0x7A69,0xE6B99C:0x7A6A,0xE6B8A7:0x7A6B,0xE6B8BC:0x7A6C,
	0xE6BABF:0x7A6D,0xE6BE88:0x7A6E,0xE6BEB5:0x7A6F,0xE6BFB5:0x7A70,0xE78085:0x7A71,
	0xE78087:0x7A72,0xE780A8:0x7A73,0xE78285:0x7A74,0xE782AB:0x7A75,0xE7848F:0x7A76,
	0xE78484:0x7A77,0xE7859C:0x7A78,0xE78586:0x7A79,0xE78587:0x7A7A,0xEFA895:0x7A7B,
	0xE78781:0x7A7C,0xE787BE:0x7A7D,0xE78AB1:0x7A7E,0xE78ABE:0x7B21,0xE78CA4:0x7B22,
	0xEFA896:0x7B23,0xE78DB7:0x7B24,0xE78EBD:0x7B25,0xE78F89:0x7B26,0xE78F96:0x7B27,
	0xE78FA3:0x7B28,0xE78F92:0x7B29,0xE79087:0x7B2A,0xE78FB5:0x7B2B,0xE790A6:0x7B2C,
	0xE790AA:0x7B2D,0xE790A9:0x7B2E,0xE790AE:0x7B2F,0xE791A2:0x7B30,0xE79289:0x7B31,
	0xE7929F:0x7B32,0xE79481:0x7B33,0xE795AF:0x7B34,0xE79A82:0x7B35,0xE79A9C:0x7B36,
	0xE79A9E:0x7B37,0xE79A9B:0x7B38,0xE79AA6:0x7B39,0xEFA897:0x7B3A,0xE79D86:0x7B3B,
	0xE58AAF:0x7B3C,0xE7A0A1:0x7B3D,0xE7A18E:0x7B3E,0xE7A1A4:0x7B3F,0xE7A1BA:0x7B40,
	0xE7A4B0:0x7B41,0xEFA898:0x7B42,0xEFA899:0x7B43,0xEFA89A:0x7B44,0xE7A694:0x7B45,
	0xEFA89B:0x7B46,0xE7A69B:0x7B47,0xE7AB91:0x7B48,0xE7ABA7:0x7B49,0xEFA89C:0x7B4A,
	0xE7ABAB:0x7B4B,0xE7AE9E:0x7B4C,0xEFA89D:0x7B4D,0xE7B588:0x7B4E,0xE7B59C:0x7B4F,
	0xE7B6B7:0x7B50,0xE7B6A0:0x7B51,0xE7B796:0x7B52,0xE7B992:0x7B53,0xE7BD87:0x7B54,
	0xE7BEA1:0x7B55,0xEFA89E:0x7B56,0xE88C81:0x7B57,0xE88DA2:0x7B58,0xE88DBF:0x7B59,
	0xE88F87:0x7B5A,0xE88FB6:0x7B5B,0xE89188:0x7B5C,0xE892B4:0x7B5D,0xE89593:0x7B5E,
	0xE89599:0x7B5F,0xE895AB:0x7B60,0xEFA89F:0x7B61,0xE896B0:0x7B62,0xEFA8A0:0x7B63,
	0xEFA8A1:0x7B64,0xE8A087:0x7B65,0xE8A3B5:0x7B66,0xE8A892:0x7B67,0xE8A8B7:0x7B68,
	0xE8A9B9:0x7B69,0xE8AAA7:0x7B6A,0xE8AABE:0x7B6B,0xE8AB9F:0x7B6C,0xEFA8A2:0x7B6D,
	0xE8ABB6:0x7B6E,0xE8AD93:0x7B6F,0xE8ADBF:0x7B70,0xE8B3B0:0x7B71,0xE8B3B4:0x7B72,
	0xE8B492:0x7B73,0xE8B5B6:0x7B74,0xEFA8A3:0x7B75,0xE8BB8F:0x7B76,0xEFA8A4:0x7B77,
	0xEFA8A5:0x7B78,0xE981A7:0x7B79,0xE9839E:0x7B7A,0xEFA8A6:0x7B7B,0xE98495:0x7B7C,
	0xE984A7:0x7B7D,0xE9879A:0x7B7E,0xE98797:0x7C21,0xE9879E:0x7C22,0xE987AD:0x7C23,
	0xE987AE:0x7C24,0xE987A4:0x7C25,0xE987A5:0x7C26,0xE98886:0x7C27,0xE98890:0x7C28,
	0xE9888A:0x7C29,0xE988BA:0x7C2A,0xE98980:0x7C2B,0xE988BC:0x7C2C,0xE9898E:0x7C2D,
	0xE98999:0x7C2E,0xE98991:0x7C2F,0xE988B9:0x7C30,0xE989A7:0x7C31,0xE98AA7:0x7C32,
	0xE989B7:0x7C33,0xE989B8:0x7C34,0xE98BA7:0x7C35,0xE98B97:0x7C36,0xE98B99:0x7C37,
	0xE98B90:0x7C38,0xEFA8A7:0x7C39,0xE98B95:0x7C3A,0xE98BA0:0x7C3B,0xE98B93:0x7C3C,
	0xE98CA5:0x7C3D,0xE98CA1:0x7C3E,0xE98BBB:0x7C3F,0xEFA8A8:0x7C40,0xE98C9E:0x7C41,
	0xE98BBF:0x7C42,0xE98C9D:0x7C43,0xE98C82:0x7C44,0xE98DB0:0x7C45,0xE98D97:0x7C46,
	0xE98EA4:0x7C47,0xE98F86:0x7C48,0xE98F9E:0x7C49,0xE98FB8:0x7C4A,0xE990B1:0x7C4B,
	0xE99185:0x7C4C,0xE99188:0x7C4D,0xE99692:0x7C4E,0xEFA79C:0x7C4F,0xEFA8A9:0x7C50,
	0xE99A9D:0x7C51,0xE99AAF:0x7C52,0xE99CB3:0x7C53,0xE99CBB:0x7C54,0xE99D83:0x7C55,
	0xE99D8D:0x7C56,0xE99D8F:0x7C57,0xE99D91:0x7C58,0xE99D95:0x7C59,0xE9A197:0x7C5A,
	0xE9A1A5:0x7C5B,0xEFA8AA:0x7C5C,0xEFA8AB:0x7C5D,0xE9A4A7:0x7C5E,0xEFA8AC:0x7C5F,
	0xE9A69E:0x7C60,0xE9A98E:0x7C61,0xE9AB99:0x7C62,0xE9AB9C:0x7C63,0xE9ADB5:0x7C64,
	0xE9ADB2:0x7C65,0xE9AE8F:0x7C66,0xE9AEB1:0x7C67,0xE9AEBB:0x7C68,0xE9B080:0x7C69,
	0xE9B5B0:0x7C6A,0xE9B5AB:0x7C6B,0xEFA8AD:0x7C6C,0xE9B899:0x7C6D,0xE9BB91:0x7C6E,
	0xE285B0:0x7C71,0xE285B1:0x7C72,0xE285B2:0x7C73,0xE285B3:0x7C74,0xE285B4:0x7C75,
	0xE285B5:0x7C76,0xE285B6:0x7C77,0xE285B7:0x7C78,0xE285B8:0x7C79,0xE285B9:0x7C7A,
	0xEFBFA4:0x7C7C,0xEFBC87:0x7C7D,0xEFBC82:0x7C7E,

	//FIXME: mojibake
	0xE288A5:0x2142,
	0xEFBFA2:0x224C,
	0xE28892:0x1215D
	};

	/**
	 * The encoding conversion table for UTF-8 to JIS X 0212:1990 (Hojo-Kanji).
	 *
	 * @ignore
	 */
	var UTF8_TO_JISX0212_TABLE = {
	0xCB98:0x222F,0xCB87:0x2230,0xC2B8:0x2231,0xCB99:0x2232,0xCB9D:0x2233,
	0xC2AF:0x2234,0xCB9B:0x2235,0xCB9A:0x2236,0x7E:0x2237,0xCE84:0x2238,
	0xCE85:0x2239,0xC2A1:0x2242,0xC2A6:0x2243,0xC2BF:0x2244,0xC2BA:0x226B,
	0xC2AA:0x226C,0xC2A9:0x226D,0xC2AE:0x226E,0xE284A2:0x226F,0xC2A4:0x2270,
	0xE28496:0x2271,0xCE86:0x2661,0xCE88:0x2662,0xCE89:0x2663,0xCE8A:0x2664,
	0xCEAA:0x2665,0xCE8C:0x2667,0xCE8E:0x2669,0xCEAB:0x266A,0xCE8F:0x266C,
	0xCEAC:0x2671,0xCEAD:0x2672,0xCEAE:0x2673,0xCEAF:0x2674,0xCF8A:0x2675,
	0xCE90:0x2676,0xCF8C:0x2677,0xCF82:0x2678,0xCF8D:0x2679,0xCF8B:0x267A,
	0xCEB0:0x267B,0xCF8E:0x267C,0xD082:0x2742,0xD083:0x2743,0xD084:0x2744,
	0xD085:0x2745,0xD086:0x2746,0xD087:0x2747,0xD088:0x2748,0xD089:0x2749,
	0xD08A:0x274A,0xD08B:0x274B,0xD08C:0x274C,0xD08E:0x274D,0xD08F:0x274E,
	0xD192:0x2772,0xD193:0x2773,0xD194:0x2774,0xD195:0x2775,0xD196:0x2776,
	0xD197:0x2777,0xD198:0x2778,0xD199:0x2779,0xD19A:0x277A,0xD19B:0x277B,
	0xD19C:0x277C,0xD19E:0x277D,0xD19F:0x277E,0xC386:0x2921,0xC490:0x2922,
	0xC4A6:0x2924,0xC4B2:0x2926,0xC581:0x2928,0xC4BF:0x2929,0xC58A:0x292B,
	0xC398:0x292C,0xC592:0x292D,0xC5A6:0x292F,0xC39E:0x2930,0xC3A6:0x2941,
	0xC491:0x2942,0xC3B0:0x2943,0xC4A7:0x2944,0xC4B1:0x2945,0xC4B3:0x2946,
	0xC4B8:0x2947,0xC582:0x2948,0xC580:0x2949,0xC589:0x294A,0xC58B:0x294B,
	0xC3B8:0x294C,0xC593:0x294D,0xC39F:0x294E,0xC5A7:0x294F,0xC3BE:0x2950,
	0xC381:0x2A21,0xC380:0x2A22,0xC384:0x2A23,0xC382:0x2A24,0xC482:0x2A25,
	0xC78D:0x2A26,0xC480:0x2A27,0xC484:0x2A28,0xC385:0x2A29,0xC383:0x2A2A,
	0xC486:0x2A2B,0xC488:0x2A2C,0xC48C:0x2A2D,0xC387:0x2A2E,0xC48A:0x2A2F,
	0xC48E:0x2A30,0xC389:0x2A31,0xC388:0x2A32,0xC38B:0x2A33,0xC38A:0x2A34,
	0xC49A:0x2A35,0xC496:0x2A36,0xC492:0x2A37,0xC498:0x2A38,0xC49C:0x2A3A,
	0xC49E:0x2A3B,0xC4A2:0x2A3C,0xC4A0:0x2A3D,0xC4A4:0x2A3E,0xC38D:0x2A3F,
	0xC38C:0x2A40,0xC38F:0x2A41,0xC38E:0x2A42,0xC78F:0x2A43,0xC4B0:0x2A44,
	0xC4AA:0x2A45,0xC4AE:0x2A46,0xC4A8:0x2A47,0xC4B4:0x2A48,0xC4B6:0x2A49,
	0xC4B9:0x2A4A,0xC4BD:0x2A4B,0xC4BB:0x2A4C,0xC583:0x2A4D,0xC587:0x2A4E,
	0xC585:0x2A4F,0xC391:0x2A50,0xC393:0x2A51,0xC392:0x2A52,0xC396:0x2A53,
	0xC394:0x2A54,0xC791:0x2A55,0xC590:0x2A56,0xC58C:0x2A57,0xC395:0x2A58,
	0xC594:0x2A59,0xC598:0x2A5A,0xC596:0x2A5B,0xC59A:0x2A5C,0xC59C:0x2A5D,
	0xC5A0:0x2A5E,0xC59E:0x2A5F,0xC5A4:0x2A60,0xC5A2:0x2A61,0xC39A:0x2A62,
	0xC399:0x2A63,0xC39C:0x2A64,0xC39B:0x2A65,0xC5AC:0x2A66,0xC793:0x2A67,
	0xC5B0:0x2A68,0xC5AA:0x2A69,0xC5B2:0x2A6A,0xC5AE:0x2A6B,0xC5A8:0x2A6C,
	0xC797:0x2A6D,0xC79B:0x2A6E,0xC799:0x2A6F,0xC795:0x2A70,0xC5B4:0x2A71,
	0xC39D:0x2A72,0xC5B8:0x2A73,0xC5B6:0x2A74,0xC5B9:0x2A75,0xC5BD:0x2A76,
	0xC5BB:0x2A77,0xC3A1:0x2B21,0xC3A0:0x2B22,0xC3A4:0x2B23,0xC3A2:0x2B24,
	0xC483:0x2B25,0xC78E:0x2B26,0xC481:0x2B27,0xC485:0x2B28,0xC3A5:0x2B29,
	0xC3A3:0x2B2A,0xC487:0x2B2B,0xC489:0x2B2C,0xC48D:0x2B2D,0xC3A7:0x2B2E,
	0xC48B:0x2B2F,0xC48F:0x2B30,0xC3A9:0x2B31,0xC3A8:0x2B32,0xC3AB:0x2B33,
	0xC3AA:0x2B34,0xC49B:0x2B35,0xC497:0x2B36,0xC493:0x2B37,0xC499:0x2B38,
	0xC7B5:0x2B39,0xC49D:0x2B3A,0xC49F:0x2B3B,0xC4A1:0x2B3D,0xC4A5:0x2B3E,
	0xC3AD:0x2B3F,0xC3AC:0x2B40,0xC3AF:0x2B41,0xC3AE:0x2B42,0xC790:0x2B43,
	0xC4AB:0x2B45,0xC4AF:0x2B46,0xC4A9:0x2B47,0xC4B5:0x2B48,0xC4B7:0x2B49,
	0xC4BA:0x2B4A,0xC4BE:0x2B4B,0xC4BC:0x2B4C,0xC584:0x2B4D,0xC588:0x2B4E,
	0xC586:0x2B4F,0xC3B1:0x2B50,0xC3B3:0x2B51,0xC3B2:0x2B52,0xC3B6:0x2B53,
	0xC3B4:0x2B54,0xC792:0x2B55,0xC591:0x2B56,0xC58D:0x2B57,0xC3B5:0x2B58,
	0xC595:0x2B59,0xC599:0x2B5A,0xC597:0x2B5B,0xC59B:0x2B5C,0xC59D:0x2B5D,
	0xC5A1:0x2B5E,0xC59F:0x2B5F,0xC5A5:0x2B60,0xC5A3:0x2B61,0xC3BA:0x2B62,
	0xC3B9:0x2B63,0xC3BC:0x2B64,0xC3BB:0x2B65,0xC5AD:0x2B66,0xC794:0x2B67,
	0xC5B1:0x2B68,0xC5AB:0x2B69,0xC5B3:0x2B6A,0xC5AF:0x2B6B,0xC5A9:0x2B6C,
	0xC798:0x2B6D,0xC79C:0x2B6E,0xC79A:0x2B6F,0xC796:0x2B70,0xC5B5:0x2B71,
	0xC3BD:0x2B72,0xC3BF:0x2B73,0xC5B7:0x2B74,0xC5BA:0x2B75,0xC5BE:0x2B76,
	0xC5BC:0x2B77,
	0xE4B882:0x3021,0xE4B884:0x3022,0xE4B885:0x3023,0xE4B88C:0x3024,
	0xE4B892:0x3025,0xE4B89F:0x3026,0xE4B8A3:0x3027,0xE4B8A4:0x3028,0xE4B8A8:0x3029,
	0xE4B8AB:0x302A,0xE4B8AE:0x302B,0xE4B8AF:0x302C,0xE4B8B0:0x302D,0xE4B8B5:0x302E,
	0xE4B980:0x302F,0xE4B981:0x3030,0xE4B984:0x3031,0xE4B987:0x3032,0xE4B991:0x3033,
	0xE4B99A:0x3034,0xE4B99C:0x3035,0xE4B9A3:0x3036,0xE4B9A8:0x3037,0xE4B9A9:0x3038,
	0xE4B9B4:0x3039,0xE4B9B5:0x303A,0xE4B9B9:0x303B,0xE4B9BF:0x303C,0xE4BA8D:0x303D,
	0xE4BA96:0x303E,0xE4BA97:0x303F,0xE4BA9D:0x3040,0xE4BAAF:0x3041,0xE4BAB9:0x3042,
	0xE4BB83:0x3043,0xE4BB90:0x3044,0xE4BB9A:0x3045,0xE4BB9B:0x3046,0xE4BBA0:0x3047,
	0xE4BBA1:0x3048,0xE4BBA2:0x3049,0xE4BBA8:0x304A,0xE4BBAF:0x304B,0xE4BBB1:0x304C,
	0xE4BBB3:0x304D,0xE4BBB5:0x304E,0xE4BBBD:0x304F,0xE4BBBE:0x3050,0xE4BBBF:0x3051,
	0xE4BC80:0x3052,0xE4BC82:0x3053,0xE4BC83:0x3054,0xE4BC88:0x3055,0xE4BC8B:0x3056,
	0xE4BC8C:0x3057,0xE4BC92:0x3058,0xE4BC95:0x3059,0xE4BC96:0x305A,0xE4BC97:0x305B,
	0xE4BC99:0x305C,0xE4BCAE:0x305D,0xE4BCB1:0x305E,0xE4BDA0:0x305F,0xE4BCB3:0x3060,
	0xE4BCB5:0x3061,0xE4BCB7:0x3062,0xE4BCB9:0x3063,0xE4BCBB:0x3064,0xE4BCBE:0x3065,
	0xE4BD80:0x3066,0xE4BD82:0x3067,0xE4BD88:0x3068,0xE4BD89:0x3069,0xE4BD8B:0x306A,
	0xE4BD8C:0x306B,0xE4BD92:0x306C,0xE4BD94:0x306D,0xE4BD96:0x306E,0xE4BD98:0x306F,
	0xE4BD9F:0x3070,0xE4BDA3:0x3071,0xE4BDAA:0x3072,0xE4BDAC:0x3073,0xE4BDAE:0x3074,
	0xE4BDB1:0x3075,0xE4BDB7:0x3076,0xE4BDB8:0x3077,0xE4BDB9:0x3078,0xE4BDBA:0x3079,
	0xE4BDBD:0x307A,0xE4BDBE:0x307B,0xE4BE81:0x307C,0xE4BE82:0x307D,0xE4BE84:0x307E,
	0xE4BE85:0x3121,0xE4BE89:0x3122,0xE4BE8A:0x3123,0xE4BE8C:0x3124,0xE4BE8E:0x3125,
	0xE4BE90:0x3126,0xE4BE92:0x3127,0xE4BE93:0x3128,0xE4BE94:0x3129,0xE4BE97:0x312A,
	0xE4BE99:0x312B,0xE4BE9A:0x312C,0xE4BE9E:0x312D,0xE4BE9F:0x312E,0xE4BEB2:0x312F,
	0xE4BEB7:0x3130,0xE4BEB9:0x3131,0xE4BEBB:0x3132,0xE4BEBC:0x3133,0xE4BEBD:0x3134,
	0xE4BEBE:0x3135,0xE4BF80:0x3136,0xE4BF81:0x3137,0xE4BF85:0x3138,0xE4BF86:0x3139,
	0xE4BF88:0x313A,0xE4BF89:0x313B,0xE4BF8B:0x313C,0xE4BF8C:0x313D,0xE4BF8D:0x313E,
	0xE4BF8F:0x313F,0xE4BF92:0x3140,0xE4BF9C:0x3141,0xE4BFA0:0x3142,0xE4BFA2:0x3143,
	0xE4BFB0:0x3144,0xE4BFB2:0x3145,0xE4BFBC:0x3146,0xE4BFBD:0x3147,0xE4BFBF:0x3148,
	0xE58080:0x3149,0xE58081:0x314A,0xE58084:0x314B,0xE58087:0x314C,0xE5808A:0x314D,
	0xE5808C:0x314E,0xE5808E:0x314F,0xE58090:0x3150,0xE58093:0x3151,0xE58097:0x3152,
	0xE58098:0x3153,0xE5809B:0x3154,0xE5809C:0x3155,0xE5809D:0x3156,0xE5809E:0x3157,
	0xE580A2:0x3158,0xE580A7:0x3159,0xE580AE:0x315A,0xE580B0:0x315B,0xE580B2:0x315C,
	0xE580B3:0x315D,0xE580B5:0x315E,0xE58180:0x315F,0xE58181:0x3160,0xE58182:0x3161,
	0xE58185:0x3162,0xE58186:0x3163,0xE5818A:0x3164,0xE5818C:0x3165,0xE5818E:0x3166,
	0xE58191:0x3167,0xE58192:0x3168,0xE58193:0x3169,0xE58197:0x316A,0xE58199:0x316B,
	0xE5819F:0x316C,0xE581A0:0x316D,0xE581A2:0x316E,0xE581A3:0x316F,0xE581A6:0x3170,
	0xE581A7:0x3171,0xE581AA:0x3172,0xE581AD:0x3173,0xE581B0:0x3174,0xE581B1:0x3175,
	0xE580BB:0x3176,0xE58281:0x3177,0xE58283:0x3178,0xE58284:0x3179,0xE58286:0x317A,
	0xE5828A:0x317B,0xE5828E:0x317C,0xE5828F:0x317D,0xE58290:0x317E,0xE58292:0x3221,
	0xE58293:0x3222,0xE58294:0x3223,0xE58296:0x3224,0xE5829B:0x3225,0xE5829C:0x3226,
	0xE5829E:0x3227,0xE5829F:0x3228,0xE582A0:0x3229,0xE582A1:0x322A,0xE582A2:0x322B,
	0xE582AA:0x322C,0xE582AF:0x322D,0xE582B0:0x322E,0xE582B9:0x322F,0xE582BA:0x3230,
	0xE582BD:0x3231,0xE58380:0x3232,0xE58383:0x3233,0xE58384:0x3234,0xE58387:0x3235,
	0xE5838C:0x3236,0xE5838E:0x3237,0xE58390:0x3238,0xE58393:0x3239,0xE58394:0x323A,
	0xE58398:0x323B,0xE5839C:0x323C,0xE5839D:0x323D,0xE5839F:0x323E,0xE583A2:0x323F,
	0xE583A4:0x3240,0xE583A6:0x3241,0xE583A8:0x3242,0xE583A9:0x3243,0xE583AF:0x3244,
	0xE583B1:0x3245,0xE583B6:0x3246,0xE583BA:0x3247,0xE583BE:0x3248,0xE58483:0x3249,
	0xE58486:0x324A,0xE58487:0x324B,0xE58488:0x324C,0xE5848B:0x324D,0xE5848C:0x324E,
	0xE5848D:0x324F,0xE5848E:0x3250,0xE583B2:0x3251,0xE58490:0x3252,0xE58497:0x3253,
	0xE58499:0x3254,0xE5849B:0x3255,0xE5849C:0x3256,0xE5849D:0x3257,0xE5849E:0x3258,
	0xE584A3:0x3259,0xE584A7:0x325A,0xE584A8:0x325B,0xE584AC:0x325C,0xE584AD:0x325D,
	0xE584AF:0x325E,0xE584B1:0x325F,0xE584B3:0x3260,0xE584B4:0x3261,0xE584B5:0x3262,
	0xE584B8:0x3263,0xE584B9:0x3264,0xE58582:0x3265,0xE5858A:0x3266,0xE5858F:0x3267,
	0xE58593:0x3268,0xE58595:0x3269,0xE58597:0x326A,0xE58598:0x326B,0xE5859F:0x326C,
	0xE585A4:0x326D,0xE585A6:0x326E,0xE585BE:0x326F,0xE58683:0x3270,0xE58684:0x3271,
	0xE5868B:0x3272,0xE5868E:0x3273,0xE58698:0x3274,0xE5869D:0x3275,0xE586A1:0x3276,
	0xE586A3:0x3277,0xE586AD:0x3278,0xE586B8:0x3279,0xE586BA:0x327A,0xE586BC:0x327B,
	0xE586BE:0x327C,0xE586BF:0x327D,0xE58782:0x327E,0xE58788:0x3321,0xE5878F:0x3322,
	0xE58791:0x3323,0xE58792:0x3324,0xE58793:0x3325,0xE58795:0x3326,0xE58798:0x3327,
	0xE5879E:0x3328,0xE587A2:0x3329,0xE587A5:0x332A,0xE587AE:0x332B,0xE587B2:0x332C,
	0xE587B3:0x332D,0xE587B4:0x332E,0xE587B7:0x332F,0xE58881:0x3330,0xE58882:0x3331,
	0xE58885:0x3332,0xE58892:0x3333,0xE58893:0x3334,0xE58895:0x3335,0xE58896:0x3336,
	0xE58898:0x3337,0xE588A2:0x3338,0xE588A8:0x3339,0xE588B1:0x333A,0xE588B2:0x333B,
	0xE588B5:0x333C,0xE588BC:0x333D,0xE58985:0x333E,0xE58989:0x333F,0xE58995:0x3340,
	0xE58997:0x3341,0xE58998:0x3342,0xE5899A:0x3343,0xE5899C:0x3344,0xE5899F:0x3345,
	0xE589A0:0x3346,0xE589A1:0x3347,0xE589A6:0x3348,0xE589AE:0x3349,0xE589B7:0x334A,
	0xE589B8:0x334B,0xE589B9:0x334C,0xE58A80:0x334D,0xE58A82:0x334E,0xE58A85:0x334F,
	0xE58A8A:0x3350,0xE58A8C:0x3351,0xE58A93:0x3352,0xE58A95:0x3353,0xE58A96:0x3354,
	0xE58A97:0x3355,0xE58A98:0x3356,0xE58A9A:0x3357,0xE58A9C:0x3358,0xE58AA4:0x3359,
	0xE58AA5:0x335A,0xE58AA6:0x335B,0xE58AA7:0x335C,0xE58AAF:0x335D,0xE58AB0:0x335E,
	0xE58AB6:0x335F,0xE58AB7:0x3360,0xE58AB8:0x3361,0xE58ABA:0x3362,0xE58ABB:0x3363,
	0xE58ABD:0x3364,0xE58B80:0x3365,0xE58B84:0x3366,0xE58B86:0x3367,0xE58B88:0x3368,
	0xE58B8C:0x3369,0xE58B8F:0x336A,0xE58B91:0x336B,0xE58B94:0x336C,0xE58B96:0x336D,
	0xE58B9B:0x336E,0xE58B9C:0x336F,0xE58BA1:0x3370,0xE58BA5:0x3371,0xE58BA8:0x3372,
	0xE58BA9:0x3373,0xE58BAA:0x3374,0xE58BAC:0x3375,0xE58BB0:0x3376,0xE58BB1:0x3377,
	0xE58BB4:0x3378,0xE58BB6:0x3379,0xE58BB7:0x337A,0xE58C80:0x337B,0xE58C83:0x337C,
	0xE58C8A:0x337D,0xE58C8B:0x337E,0xE58C8C:0x3421,0xE58C91:0x3422,0xE58C93:0x3423,
	0xE58C98:0x3424,0xE58C9B:0x3425,0xE58C9C:0x3426,0xE58C9E:0x3427,0xE58C9F:0x3428,
	0xE58CA5:0x3429,0xE58CA7:0x342A,0xE58CA8:0x342B,0xE58CA9:0x342C,0xE58CAB:0x342D,
	0xE58CAC:0x342E,0xE58CAD:0x342F,0xE58CB0:0x3430,0xE58CB2:0x3431,0xE58CB5:0x3432,
	0xE58CBC:0x3433,0xE58CBD:0x3434,0xE58CBE:0x3435,0xE58D82:0x3436,0xE58D8C:0x3437,
	0xE58D8B:0x3438,0xE58D99:0x3439,0xE58D9B:0x343A,0xE58DA1:0x343B,0xE58DA3:0x343C,
	0xE58DA5:0x343D,0xE58DAC:0x343E,0xE58DAD:0x343F,0xE58DB2:0x3440,0xE58DB9:0x3441,
	0xE58DBE:0x3442,0xE58E83:0x3443,0xE58E87:0x3444,0xE58E88:0x3445,0xE58E8E:0x3446,
	0xE58E93:0x3447,0xE58E94:0x3448,0xE58E99:0x3449,0xE58E9D:0x344A,0xE58EA1:0x344B,
	0xE58EA4:0x344C,0xE58EAA:0x344D,0xE58EAB:0x344E,0xE58EAF:0x344F,0xE58EB2:0x3450,
	0xE58EB4:0x3451,0xE58EB5:0x3452,0xE58EB7:0x3453,0xE58EB8:0x3454,0xE58EBA:0x3455,
	0xE58EBD:0x3456,0xE58F80:0x3457,0xE58F85:0x3458,0xE58F8F:0x3459,0xE58F92:0x345A,
	0xE58F93:0x345B,0xE58F95:0x345C,0xE58F9A:0x345D,0xE58F9D:0x345E,0xE58F9E:0x345F,
	0xE58FA0:0x3460,0xE58FA6:0x3461,0xE58FA7:0x3462,0xE58FB5:0x3463,0xE59082:0x3464,
	0xE59093:0x3465,0xE5909A:0x3466,0xE590A1:0x3467,0xE590A7:0x3468,0xE590A8:0x3469,
	0xE590AA:0x346A,0xE590AF:0x346B,0xE590B1:0x346C,0xE590B4:0x346D,0xE590B5:0x346E,
	0xE59183:0x346F,0xE59184:0x3470,0xE59187:0x3471,0xE5918D:0x3472,0xE5918F:0x3473,
	0xE5919E:0x3474,0xE591A2:0x3475,0xE591A4:0x3476,0xE591A6:0x3477,0xE591A7:0x3478,
	0xE591A9:0x3479,0xE591AB:0x347A,0xE591AD:0x347B,0xE591AE:0x347C,0xE591B4:0x347D,
	0xE591BF:0x347E,0xE59281:0x3521,0xE59283:0x3522,0xE59285:0x3523,0xE59288:0x3524,
	0xE59289:0x3525,0xE5928D:0x3526,0xE59291:0x3527,0xE59295:0x3528,0xE59296:0x3529,
	0xE5929C:0x352A,0xE5929F:0x352B,0xE592A1:0x352C,0xE592A6:0x352D,0xE592A7:0x352E,
	0xE592A9:0x352F,0xE592AA:0x3530,0xE592AD:0x3531,0xE592AE:0x3532,0xE592B1:0x3533,
	0xE592B7:0x3534,0xE592B9:0x3535,0xE592BA:0x3536,0xE592BB:0x3537,0xE592BF:0x3538,
	0xE59386:0x3539,0xE5938A:0x353A,0xE5938D:0x353B,0xE5938E:0x353C,0xE593A0:0x353D,
	0xE593AA:0x353E,0xE593AC:0x353F,0xE593AF:0x3540,0xE593B6:0x3541,0xE593BC:0x3542,
	0xE593BE:0x3543,0xE593BF:0x3544,0xE59480:0x3545,0xE59481:0x3546,0xE59485:0x3547,
	0xE59488:0x3548,0xE59489:0x3549,0xE5948C:0x354A,0xE5948D:0x354B,0xE5948E:0x354C,
	0xE59495:0x354D,0xE594AA:0x354E,0xE594AB:0x354F,0xE594B2:0x3550,0xE594B5:0x3551,
	0xE594B6:0x3552,0xE594BB:0x3553,0xE594BC:0x3554,0xE594BD:0x3555,0xE59581:0x3556,
	0xE59587:0x3557,0xE59589:0x3558,0xE5958A:0x3559,0xE5958D:0x355A,0xE59590:0x355B,
	0xE59591:0x355C,0xE59598:0x355D,0xE5959A:0x355E,0xE5959B:0x355F,0xE5959E:0x3560,
	0xE595A0:0x3561,0xE595A1:0x3562,0xE595A4:0x3563,0xE595A6:0x3564,0xE595BF:0x3565,
	0xE59681:0x3566,0xE59682:0x3567,0xE59686:0x3568,0xE59688:0x3569,0xE5968E:0x356A,
	0xE5968F:0x356B,0xE59691:0x356C,0xE59692:0x356D,0xE59693:0x356E,0xE59694:0x356F,
	0xE59697:0x3570,0xE596A3:0x3571,0xE596A4:0x3572,0xE596AD:0x3573,0xE596B2:0x3574,
	0xE596BF:0x3575,0xE59781:0x3576,0xE59783:0x3577,0xE59786:0x3578,0xE59789:0x3579,
	0xE5978B:0x357A,0xE5978C:0x357B,0xE5978E:0x357C,0xE59791:0x357D,0xE59792:0x357E,
	0xE59793:0x3621,0xE59797:0x3622,0xE59798:0x3623,0xE5979B:0x3624,0xE5979E:0x3625,
	0xE597A2:0x3626,0xE597A9:0x3627,0xE597B6:0x3628,0xE597BF:0x3629,0xE59885:0x362A,
	0xE59888:0x362B,0xE5988A:0x362C,0xE5988D:0x362D,0xE5988E:0x362E,0xE5988F:0x362F,
	0xE59890:0x3630,0xE59891:0x3631,0xE59892:0x3632,0xE59899:0x3633,0xE598AC:0x3634,
	0xE598B0:0x3635,0xE598B3:0x3636,0xE598B5:0x3637,0xE598B7:0x3638,0xE598B9:0x3639,
	0xE598BB:0x363A,0xE598BC:0x363B,0xE598BD:0x363C,0xE598BF:0x363D,0xE59980:0x363E,
	0xE59981:0x363F,0xE59983:0x3640,0xE59984:0x3641,0xE59986:0x3642,0xE59989:0x3643,
	0xE5998B:0x3644,0xE5998D:0x3645,0xE5998F:0x3646,0xE59994:0x3647,0xE5999E:0x3648,
	0xE599A0:0x3649,0xE599A1:0x364A,0xE599A2:0x364B,0xE599A3:0x364C,0xE599A6:0x364D,
	0xE599A9:0x364E,0xE599AD:0x364F,0xE599AF:0x3650,0xE599B1:0x3651,0xE599B2:0x3652,
	0xE599B5:0x3653,0xE59A84:0x3654,0xE59A85:0x3655,0xE59A88:0x3656,0xE59A8B:0x3657,
	0xE59A8C:0x3658,0xE59A95:0x3659,0xE59A99:0x365A,0xE59A9A:0x365B,0xE59A9D:0x365C,
	0xE59A9E:0x365D,0xE59A9F:0x365E,0xE59AA6:0x365F,0xE59AA7:0x3660,0xE59AA8:0x3661,
	0xE59AA9:0x3662,0xE59AAB:0x3663,0xE59AAC:0x3664,0xE59AAD:0x3665,0xE59AB1:0x3666,
	0xE59AB3:0x3667,0xE59AB7:0x3668,0xE59ABE:0x3669,0xE59B85:0x366A,0xE59B89:0x366B,
	0xE59B8A:0x366C,0xE59B8B:0x366D,0xE59B8F:0x366E,0xE59B90:0x366F,0xE59B8C:0x3670,
	0xE59B8D:0x3671,0xE59B99:0x3672,0xE59B9C:0x3673,0xE59B9D:0x3674,0xE59B9F:0x3675,
	0xE59BA1:0x3676,0xE59BA4:0x3677,0xE59BA5:0x3678,0xE59BA6:0x3679,0xE59BA7:0x367A,
	0xE59BA8:0x367B,0xE59BB1:0x367C,0xE59BAB:0x367D,0xE59BAD:0x367E,0xE59BB6:0x3721,
	0xE59BB7:0x3722,0xE59C81:0x3723,0xE59C82:0x3724,0xE59C87:0x3725,0xE59C8A:0x3726,
	0xE59C8C:0x3727,0xE59C91:0x3728,0xE59C95:0x3729,0xE59C9A:0x372A,0xE59C9B:0x372B,
	0xE59C9D:0x372C,0xE59CA0:0x372D,0xE59CA2:0x372E,0xE59CA3:0x372F,0xE59CA4:0x3730,
	0xE59CA5:0x3731,0xE59CA9:0x3732,0xE59CAA:0x3733,0xE59CAC:0x3734,0xE59CAE:0x3735,
	0xE59CAF:0x3736,0xE59CB3:0x3737,0xE59CB4:0x3738,0xE59CBD:0x3739,0xE59CBE:0x373A,
	0xE59CBF:0x373B,0xE59D85:0x373C,0xE59D86:0x373D,0xE59D8C:0x373E,0xE59D8D:0x373F,
	0xE59D92:0x3740,0xE59DA2:0x3741,0xE59DA5:0x3742,0xE59DA7:0x3743,0xE59DA8:0x3744,
	0xE59DAB:0x3745,0xE59DAD:0x3746,0xE59DAE:0x3747,0xE59DAF:0x3748,0xE59DB0:0x3749,
	0xE59DB1:0x374A,0xE59DB3:0x374B,0xE59DB4:0x374C,0xE59DB5:0x374D,0xE59DB7:0x374E,
	0xE59DB9:0x374F,0xE59DBA:0x3750,0xE59DBB:0x3751,0xE59DBC:0x3752,0xE59DBE:0x3753,
	0xE59E81:0x3754,0xE59E83:0x3755,0xE59E8C:0x3756,0xE59E94:0x3757,0xE59E97:0x3758,
	0xE59E99:0x3759,0xE59E9A:0x375A,0xE59E9C:0x375B,0xE59E9D:0x375C,0xE59E9E:0x375D,
	0xE59E9F:0x375E,0xE59EA1:0x375F,0xE59E95:0x3760,0xE59EA7:0x3761,0xE59EA8:0x3762,
	0xE59EA9:0x3763,0xE59EAC:0x3764,0xE59EB8:0x3765,0xE59EBD:0x3766,0xE59F87:0x3767,
	0xE59F88:0x3768,0xE59F8C:0x3769,0xE59F8F:0x376A,0xE59F95:0x376B,0xE59F9D:0x376C,
	0xE59F9E:0x376D,0xE59FA4:0x376E,0xE59FA6:0x376F,0xE59FA7:0x3770,0xE59FA9:0x3771,
	0xE59FAD:0x3772,0xE59FB0:0x3773,0xE59FB5:0x3774,0xE59FB6:0x3775,0xE59FB8:0x3776,
	0xE59FBD:0x3777,0xE59FBE:0x3778,0xE59FBF:0x3779,0xE5A083:0x377A,0xE5A084:0x377B,
	0xE5A088:0x377C,0xE5A089:0x377D,0xE59FA1:0x377E,0xE5A08C:0x3821,0xE5A08D:0x3822,
	0xE5A09B:0x3823,0xE5A09E:0x3824,0xE5A09F:0x3825,0xE5A0A0:0x3826,0xE5A0A6:0x3827,
	0xE5A0A7:0x3828,0xE5A0AD:0x3829,0xE5A0B2:0x382A,0xE5A0B9:0x382B,0xE5A0BF:0x382C,
	0xE5A189:0x382D,0xE5A18C:0x382E,0xE5A18D:0x382F,0xE5A18F:0x3830,0xE5A190:0x3831,
	0xE5A195:0x3832,0xE5A19F:0x3833,0xE5A1A1:0x3834,0xE5A1A4:0x3835,0xE5A1A7:0x3836,
	0xE5A1A8:0x3837,0xE5A1B8:0x3838,0xE5A1BC:0x3839,0xE5A1BF:0x383A,0xE5A280:0x383B,
	0xE5A281:0x383C,0xE5A287:0x383D,0xE5A288:0x383E,0xE5A289:0x383F,0xE5A28A:0x3840,
	0xE5A28C:0x3841,0xE5A28D:0x3842,0xE5A28F:0x3843,0xE5A290:0x3844,0xE5A294:0x3845,
	0xE5A296:0x3846,0xE5A29D:0x3847,0xE5A2A0:0x3848,0xE5A2A1:0x3849,0xE5A2A2:0x384A,
	0xE5A2A6:0x384B,0xE5A2A9:0x384C,0xE5A2B1:0x384D,0xE5A2B2:0x384E,0xE5A384:0x384F,
	0xE5A2BC:0x3850,0xE5A382:0x3851,0xE5A388:0x3852,0xE5A38D:0x3853,0xE5A38E:0x3854,
	0xE5A390:0x3855,0xE5A392:0x3856,0xE5A394:0x3857,0xE5A396:0x3858,0xE5A39A:0x3859,
	0xE5A39D:0x385A,0xE5A3A1:0x385B,0xE5A3A2:0x385C,0xE5A3A9:0x385D,0xE5A3B3:0x385E,
	0xE5A485:0x385F,0xE5A486:0x3860,0xE5A48B:0x3861,0xE5A48C:0x3862,0xE5A492:0x3863,
	0xE5A493:0x3864,0xE5A494:0x3865,0xE89981:0x3866,0xE5A49D:0x3867,0xE5A4A1:0x3868,
	0xE5A4A3:0x3869,0xE5A4A4:0x386A,0xE5A4A8:0x386B,0xE5A4AF:0x386C,0xE5A4B0:0x386D,
	0xE5A4B3:0x386E,0xE5A4B5:0x386F,0xE5A4B6:0x3870,0xE5A4BF:0x3871,0xE5A583:0x3872,
	0xE5A586:0x3873,0xE5A592:0x3874,0xE5A593:0x3875,0xE5A599:0x3876,0xE5A59B:0x3877,
	0xE5A59D:0x3878,0xE5A59E:0x3879,0xE5A59F:0x387A,0xE5A5A1:0x387B,0xE5A5A3:0x387C,
	0xE5A5AB:0x387D,0xE5A5AD:0x387E,0xE5A5AF:0x3921,0xE5A5B2:0x3922,0xE5A5B5:0x3923,
	0xE5A5B6:0x3924,0xE5A5B9:0x3925,0xE5A5BB:0x3926,0xE5A5BC:0x3927,0xE5A68B:0x3928,
	0xE5A68C:0x3929,0xE5A68E:0x392A,0xE5A692:0x392B,0xE5A695:0x392C,0xE5A697:0x392D,
	0xE5A69F:0x392E,0xE5A6A4:0x392F,0xE5A6A7:0x3930,0xE5A6AD:0x3931,0xE5A6AE:0x3932,
	0xE5A6AF:0x3933,0xE5A6B0:0x3934,0xE5A6B3:0x3935,0xE5A6B7:0x3936,0xE5A6BA:0x3937,
	0xE5A6BC:0x3938,0xE5A781:0x3939,0xE5A783:0x393A,0xE5A784:0x393B,0xE5A788:0x393C,
	0xE5A78A:0x393D,0xE5A78D:0x393E,0xE5A792:0x393F,0xE5A79D:0x3940,0xE5A79E:0x3941,
	0xE5A79F:0x3942,0xE5A7A3:0x3943,0xE5A7A4:0x3944,0xE5A7A7:0x3945,0xE5A7AE:0x3946,
	0xE5A7AF:0x3947,0xE5A7B1:0x3948,0xE5A7B2:0x3949,0xE5A7B4:0x394A,0xE5A7B7:0x394B,
	0xE5A880:0x394C,0xE5A884:0x394D,0xE5A88C:0x394E,0xE5A88D:0x394F,0xE5A88E:0x3950,
	0xE5A892:0x3951,0xE5A893:0x3952,0xE5A89E:0x3953,0xE5A8A3:0x3954,0xE5A8A4:0x3955,
	0xE5A8A7:0x3956,0xE5A8A8:0x3957,0xE5A8AA:0x3958,0xE5A8AD:0x3959,0xE5A8B0:0x395A,
	0xE5A984:0x395B,0xE5A985:0x395C,0xE5A987:0x395D,0xE5A988:0x395E,0xE5A98C:0x395F,
	0xE5A990:0x3960,0xE5A995:0x3961,0xE5A99E:0x3962,0xE5A9A3:0x3963,0xE5A9A5:0x3964,
	0xE5A9A7:0x3965,0xE5A9AD:0x3966,0xE5A9B7:0x3967,0xE5A9BA:0x3968,0xE5A9BB:0x3969,
	0xE5A9BE:0x396A,0xE5AA8B:0x396B,0xE5AA90:0x396C,0xE5AA93:0x396D,0xE5AA96:0x396E,
	0xE5AA99:0x396F,0xE5AA9C:0x3970,0xE5AA9E:0x3971,0xE5AA9F:0x3972,0xE5AAA0:0x3973,
	0xE5AAA2:0x3974,0xE5AAA7:0x3975,0xE5AAAC:0x3976,0xE5AAB1:0x3977,0xE5AAB2:0x3978,
	0xE5AAB3:0x3979,0xE5AAB5:0x397A,0xE5AAB8:0x397B,0xE5AABA:0x397C,0xE5AABB:0x397D,
	0xE5AABF:0x397E,0xE5AB84:0x3A21,0xE5AB86:0x3A22,0xE5AB88:0x3A23,0xE5AB8F:0x3A24,
	0xE5AB9A:0x3A25,0xE5AB9C:0x3A26,0xE5ABA0:0x3A27,0xE5ABA5:0x3A28,0xE5ABAA:0x3A29,
	0xE5ABAE:0x3A2A,0xE5ABB5:0x3A2B,0xE5ABB6:0x3A2C,0xE5ABBD:0x3A2D,0xE5AC80:0x3A2E,
	0xE5AC81:0x3A2F,0xE5AC88:0x3A30,0xE5AC97:0x3A31,0xE5ACB4:0x3A32,0xE5AC99:0x3A33,
	0xE5AC9B:0x3A34,0xE5AC9D:0x3A35,0xE5ACA1:0x3A36,0xE5ACA5:0x3A37,0xE5ACAD:0x3A38,
	0xE5ACB8:0x3A39,0xE5AD81:0x3A3A,0xE5AD8B:0x3A3B,0xE5AD8C:0x3A3C,0xE5AD92:0x3A3D,
	0xE5AD96:0x3A3E,0xE5AD9E:0x3A3F,0xE5ADA8:0x3A40,0xE5ADAE:0x3A41,0xE5ADAF:0x3A42,
	0xE5ADBC:0x3A43,0xE5ADBD:0x3A44,0xE5ADBE:0x3A45,0xE5ADBF:0x3A46,0xE5AE81:0x3A47,
	0xE5AE84:0x3A48,0xE5AE86:0x3A49,0xE5AE8A:0x3A4A,0xE5AE8E:0x3A4B,0xE5AE90:0x3A4C,
	0xE5AE91:0x3A4D,0xE5AE93:0x3A4E,0xE5AE94:0x3A4F,0xE5AE96:0x3A50,0xE5AEA8:0x3A51,
	0xE5AEA9:0x3A52,0xE5AEAC:0x3A53,0xE5AEAD:0x3A54,0xE5AEAF:0x3A55,0xE5AEB1:0x3A56,
	0xE5AEB2:0x3A57,0xE5AEB7:0x3A58,0xE5AEBA:0x3A59,0xE5AEBC:0x3A5A,0xE5AF80:0x3A5B,
	0xE5AF81:0x3A5C,0xE5AF8D:0x3A5D,0xE5AF8F:0x3A5E,0xE5AF96:0x3A5F,0xE5AF97:0x3A60,
	0xE5AF98:0x3A61,0xE5AF99:0x3A62,0xE5AF9A:0x3A63,0xE5AFA0:0x3A64,0xE5AFAF:0x3A65,
	0xE5AFB1:0x3A66,0xE5AFB4:0x3A67,0xE5AFBD:0x3A68,0xE5B08C:0x3A69,0xE5B097:0x3A6A,
	0xE5B09E:0x3A6B,0xE5B09F:0x3A6C,0xE5B0A3:0x3A6D,0xE5B0A6:0x3A6E,0xE5B0A9:0x3A6F,
	0xE5B0AB:0x3A70,0xE5B0AC:0x3A71,0xE5B0AE:0x3A72,0xE5B0B0:0x3A73,0xE5B0B2:0x3A74,
	0xE5B0B5:0x3A75,0xE5B0B6:0x3A76,0xE5B199:0x3A77,0xE5B19A:0x3A78,0xE5B19C:0x3A79,
	0xE5B1A2:0x3A7A,0xE5B1A3:0x3A7B,0xE5B1A7:0x3A7C,0xE5B1A8:0x3A7D,0xE5B1A9:0x3A7E,
	0xE5B1AD:0x3B21,0xE5B1B0:0x3B22,0xE5B1B4:0x3B23,0xE5B1B5:0x3B24,0xE5B1BA:0x3B25,
	0xE5B1BB:0x3B26,0xE5B1BC:0x3B27,0xE5B1BD:0x3B28,0xE5B287:0x3B29,0xE5B288:0x3B2A,
	0xE5B28A:0x3B2B,0xE5B28F:0x3B2C,0xE5B292:0x3B2D,0xE5B29D:0x3B2E,0xE5B29F:0x3B2F,
	0xE5B2A0:0x3B30,0xE5B2A2:0x3B31,0xE5B2A3:0x3B32,0xE5B2A6:0x3B33,0xE5B2AA:0x3B34,
	0xE5B2B2:0x3B35,0xE5B2B4:0x3B36,0xE5B2B5:0x3B37,0xE5B2BA:0x3B38,0xE5B389:0x3B39,
	0xE5B38B:0x3B3A,0xE5B392:0x3B3B,0xE5B39D:0x3B3C,0xE5B397:0x3B3D,0xE5B3AE:0x3B3E,
	0xE5B3B1:0x3B3F,0xE5B3B2:0x3B40,0xE5B3B4:0x3B41,0xE5B481:0x3B42,0xE5B486:0x3B43,
	0xE5B48D:0x3B44,0xE5B492:0x3B45,0xE5B4AB:0x3B46,0xE5B4A3:0x3B47,0xE5B4A4:0x3B48,
	0xE5B4A6:0x3B49,0xE5B4A7:0x3B4A,0xE5B4B1:0x3B4B,0xE5B4B4:0x3B4C,0xE5B4B9:0x3B4D,
	0xE5B4BD:0x3B4E,0xE5B4BF:0x3B4F,0xE5B582:0x3B50,0xE5B583:0x3B51,0xE5B586:0x3B52,
	0xE5B588:0x3B53,0xE5B595:0x3B54,0xE5B591:0x3B55,0xE5B599:0x3B56,0xE5B58A:0x3B57,
	0xE5B59F:0x3B58,0xE5B5A0:0x3B59,0xE5B5A1:0x3B5A,0xE5B5A2:0x3B5B,0xE5B5A4:0x3B5C,
	0xE5B5AA:0x3B5D,0xE5B5AD:0x3B5E,0xE5B5B0:0x3B5F,0xE5B5B9:0x3B60,0xE5B5BA:0x3B61,
	0xE5B5BE:0x3B62,0xE5B5BF:0x3B63,0xE5B681:0x3B64,0xE5B683:0x3B65,0xE5B688:0x3B66,
	0xE5B68A:0x3B67,0xE5B692:0x3B68,0xE5B693:0x3B69,0xE5B694:0x3B6A,0xE5B695:0x3B6B,
	0xE5B699:0x3B6C,0xE5B69B:0x3B6D,0xE5B69F:0x3B6E,0xE5B6A0:0x3B6F,0xE5B6A7:0x3B70,
	0xE5B6AB:0x3B71,0xE5B6B0:0x3B72,0xE5B6B4:0x3B73,0xE5B6B8:0x3B74,0xE5B6B9:0x3B75,
	0xE5B783:0x3B76,0xE5B787:0x3B77,0xE5B78B:0x3B78,0xE5B790:0x3B79,0xE5B78E:0x3B7A,
	0xE5B798:0x3B7B,0xE5B799:0x3B7C,0xE5B7A0:0x3B7D,0xE5B7A4:0x3B7E,0xE5B7A9:0x3C21,
	0xE5B7B8:0x3C22,0xE5B7B9:0x3C23,0xE5B880:0x3C24,0xE5B887:0x3C25,0xE5B88D:0x3C26,
	0xE5B892:0x3C27,0xE5B894:0x3C28,0xE5B895:0x3C29,0xE5B898:0x3C2A,0xE5B89F:0x3C2B,
	0xE5B8A0:0x3C2C,0xE5B8AE:0x3C2D,0xE5B8A8:0x3C2E,0xE5B8B2:0x3C2F,0xE5B8B5:0x3C30,
	0xE5B8BE:0x3C31,0xE5B98B:0x3C32,0xE5B990:0x3C33,0xE5B989:0x3C34,0xE5B991:0x3C35,
	0xE5B996:0x3C36,0xE5B998:0x3C37,0xE5B99B:0x3C38,0xE5B99C:0x3C39,0xE5B99E:0x3C3A,
	0xE5B9A8:0x3C3B,0xE5B9AA:0x3C3C,0xE5B9AB:0x3C3D,0xE5B9AC:0x3C3E,0xE5B9AD:0x3C3F,
	0xE5B9AE:0x3C40,0xE5B9B0:0x3C41,0xE5BA80:0x3C42,0xE5BA8B:0x3C43,0xE5BA8E:0x3C44,
	0xE5BAA2:0x3C45,0xE5BAA4:0x3C46,0xE5BAA5:0x3C47,0xE5BAA8:0x3C48,0xE5BAAA:0x3C49,
	0xE5BAAC:0x3C4A,0xE5BAB1:0x3C4B,0xE5BAB3:0x3C4C,0xE5BABD:0x3C4D,0xE5BABE:0x3C4E,
	0xE5BABF:0x3C4F,0xE5BB86:0x3C50,0xE5BB8C:0x3C51,0xE5BB8B:0x3C52,0xE5BB8E:0x3C53,
	0xE5BB91:0x3C54,0xE5BB92:0x3C55,0xE5BB94:0x3C56,0xE5BB95:0x3C57,0xE5BB9C:0x3C58,
	0xE5BB9E:0x3C59,0xE5BBA5:0x3C5A,0xE5BBAB:0x3C5B,0xE5BC82:0x3C5C,0xE5BC86:0x3C5D,
	0xE5BC87:0x3C5E,0xE5BC88:0x3C5F,0xE5BC8E:0x3C60,0xE5BC99:0x3C61,0xE5BC9C:0x3C62,
	0xE5BC9D:0x3C63,0xE5BCA1:0x3C64,0xE5BCA2:0x3C65,0xE5BCA3:0x3C66,0xE5BCA4:0x3C67,
	0xE5BCA8:0x3C68,0xE5BCAB:0x3C69,0xE5BCAC:0x3C6A,0xE5BCAE:0x3C6B,0xE5BCB0:0x3C6C,
	0xE5BCB4:0x3C6D,0xE5BCB6:0x3C6E,0xE5BCBB:0x3C6F,0xE5BCBD:0x3C70,0xE5BCBF:0x3C71,
	0xE5BD80:0x3C72,0xE5BD84:0x3C73,0xE5BD85:0x3C74,0xE5BD87:0x3C75,0xE5BD8D:0x3C76,
	0xE5BD90:0x3C77,0xE5BD94:0x3C78,0xE5BD98:0x3C79,0xE5BD9B:0x3C7A,0xE5BDA0:0x3C7B,
	0xE5BDA3:0x3C7C,0xE5BDA4:0x3C7D,0xE5BDA7:0x3C7E,0xE5BDAF:0x3D21,0xE5BDB2:0x3D22,
	0xE5BDB4:0x3D23,0xE5BDB5:0x3D24,0xE5BDB8:0x3D25,0xE5BDBA:0x3D26,0xE5BDBD:0x3D27,
	0xE5BDBE:0x3D28,0xE5BE89:0x3D29,0xE5BE8D:0x3D2A,0xE5BE8F:0x3D2B,0xE5BE96:0x3D2C,
	0xE5BE9C:0x3D2D,0xE5BE9D:0x3D2E,0xE5BEA2:0x3D2F,0xE5BEA7:0x3D30,0xE5BEAB:0x3D31,
	0xE5BEA4:0x3D32,0xE5BEAC:0x3D33,0xE5BEAF:0x3D34,0xE5BEB0:0x3D35,0xE5BEB1:0x3D36,
	0xE5BEB8:0x3D37,0xE5BF84:0x3D38,0xE5BF87:0x3D39,0xE5BF88:0x3D3A,0xE5BF89:0x3D3B,
	0xE5BF8B:0x3D3C,0xE5BF90:0x3D3D,0xE5BF91:0x3D3E,0xE5BF92:0x3D3F,0xE5BF93:0x3D40,
	0xE5BF94:0x3D41,0xE5BF9E:0x3D42,0xE5BFA1:0x3D43,0xE5BFA2:0x3D44,0xE5BFA8:0x3D45,
	0xE5BFA9:0x3D46,0xE5BFAA:0x3D47,0xE5BFAC:0x3D48,0xE5BFAD:0x3D49,0xE5BFAE:0x3D4A,
	0xE5BFAF:0x3D4B,0xE5BFB2:0x3D4C,0xE5BFB3:0x3D4D,0xE5BFB6:0x3D4E,0xE5BFBA:0x3D4F,
	0xE5BFBC:0x3D50,0xE68087:0x3D51,0xE6808A:0x3D52,0xE6808D:0x3D53,0xE68093:0x3D54,
	0xE68094:0x3D55,0xE68097:0x3D56,0xE68098:0x3D57,0xE6809A:0x3D58,0xE6809F:0x3D59,
	0xE680A4:0x3D5A,0xE680AD:0x3D5B,0xE680B3:0x3D5C,0xE680B5:0x3D5D,0xE68180:0x3D5E,
	0xE68187:0x3D5F,0xE68188:0x3D60,0xE68189:0x3D61,0xE6818C:0x3D62,0xE68191:0x3D63,
	0xE68194:0x3D64,0xE68196:0x3D65,0xE68197:0x3D66,0xE6819D:0x3D67,0xE681A1:0x3D68,
	0xE681A7:0x3D69,0xE681B1:0x3D6A,0xE681BE:0x3D6B,0xE681BF:0x3D6C,0xE68282:0x3D6D,
	0xE68286:0x3D6E,0xE68288:0x3D6F,0xE6828A:0x3D70,0xE6828E:0x3D71,0xE68291:0x3D72,
	0xE68293:0x3D73,0xE68295:0x3D74,0xE68298:0x3D75,0xE6829D:0x3D76,0xE6829E:0x3D77,
	0xE682A2:0x3D78,0xE682A4:0x3D79,0xE682A5:0x3D7A,0xE682A8:0x3D7B,0xE682B0:0x3D7C,
	0xE682B1:0x3D7D,0xE682B7:0x3D7E,0xE682BB:0x3E21,0xE682BE:0x3E22,0xE68382:0x3E23,
	0xE68384:0x3E24,0xE68388:0x3E25,0xE68389:0x3E26,0xE6838A:0x3E27,0xE6838B:0x3E28,
	0xE6838E:0x3E29,0xE6838F:0x3E2A,0xE68394:0x3E2B,0xE68395:0x3E2C,0xE68399:0x3E2D,
	0xE6839B:0x3E2E,0xE6839D:0x3E2F,0xE6839E:0x3E30,0xE683A2:0x3E31,0xE683A5:0x3E32,
	0xE683B2:0x3E33,0xE683B5:0x3E34,0xE683B8:0x3E35,0xE683BC:0x3E36,0xE683BD:0x3E37,
	0xE68482:0x3E38,0xE68487:0x3E39,0xE6848A:0x3E3A,0xE6848C:0x3E3B,0xE68490:0x3E3C,
	0xE68491:0x3E3D,0xE68492:0x3E3E,0xE68493:0x3E3F,0xE68494:0x3E40,0xE68496:0x3E41,
	0xE68497:0x3E42,0xE68499:0x3E43,0xE6849C:0x3E44,0xE6849E:0x3E45,0xE684A2:0x3E46,
	0xE684AA:0x3E47,0xE684AB:0x3E48,0xE684B0:0x3E49,0xE684B1:0x3E4A,0xE684B5:0x3E4B,
	0xE684B6:0x3E4C,0xE684B7:0x3E4D,0xE684B9:0x3E4E,0xE68581:0x3E4F,0xE68585:0x3E50,
	0xE68586:0x3E51,0xE68589:0x3E52,0xE6859E:0x3E53,0xE685A0:0x3E54,0xE685AC:0x3E55,
	0xE685B2:0x3E56,0xE685B8:0x3E57,0xE685BB:0x3E58,0xE685BC:0x3E59,0xE685BF:0x3E5A,
	0xE68680:0x3E5B,0xE68681:0x3E5C,0xE68683:0x3E5D,0xE68684:0x3E5E,0xE6868B:0x3E5F,
	0xE6868D:0x3E60,0xE68692:0x3E61,0xE68693:0x3E62,0xE68697:0x3E63,0xE68698:0x3E64,
	0xE6869C:0x3E65,0xE6869D:0x3E66,0xE6869F:0x3E67,0xE686A0:0x3E68,0xE686A5:0x3E69,
	0xE686A8:0x3E6A,0xE686AA:0x3E6B,0xE686AD:0x3E6C,0xE686B8:0x3E6D,0xE686B9:0x3E6E,
	0xE686BC:0x3E6F,0xE68780:0x3E70,0xE68781:0x3E71,0xE68782:0x3E72,0xE6878E:0x3E73,
	0xE6878F:0x3E74,0xE68795:0x3E75,0xE6879C:0x3E76,0xE6879D:0x3E77,0xE6879E:0x3E78,
	0xE6879F:0x3E79,0xE687A1:0x3E7A,0xE687A2:0x3E7B,0xE687A7:0x3E7C,0xE687A9:0x3E7D,
	0xE687A5:0x3E7E,0xE687AC:0x3F21,0xE687AD:0x3F22,0xE687AF:0x3F23,0xE68881:0x3F24,
	0xE68883:0x3F25,0xE68884:0x3F26,0xE68887:0x3F27,0xE68893:0x3F28,0xE68895:0x3F29,
	0xE6889C:0x3F2A,0xE688A0:0x3F2B,0xE688A2:0x3F2C,0xE688A3:0x3F2D,0xE688A7:0x3F2E,
	0xE688A9:0x3F2F,0xE688AB:0x3F30,0xE688B9:0x3F31,0xE688BD:0x3F32,0xE68982:0x3F33,
	0xE68983:0x3F34,0xE68984:0x3F35,0xE68986:0x3F36,0xE6898C:0x3F37,0xE68990:0x3F38,
	0xE68991:0x3F39,0xE68992:0x3F3A,0xE68994:0x3F3B,0xE68996:0x3F3C,0xE6899A:0x3F3D,
	0xE6899C:0x3F3E,0xE689A4:0x3F3F,0xE689AD:0x3F40,0xE689AF:0x3F41,0xE689B3:0x3F42,
	0xE689BA:0x3F43,0xE689BD:0x3F44,0xE68A8D:0x3F45,0xE68A8E:0x3F46,0xE68A8F:0x3F47,
	0xE68A90:0x3F48,0xE68AA6:0x3F49,0xE68AA8:0x3F4A,0xE68AB3:0x3F4B,0xE68AB6:0x3F4C,
	0xE68AB7:0x3F4D,0xE68ABA:0x3F4E,0xE68ABE:0x3F4F,0xE68ABF:0x3F50,0xE68B84:0x3F51,
	0xE68B8E:0x3F52,0xE68B95:0x3F53,0xE68B96:0x3F54,0xE68B9A:0x3F55,0xE68BAA:0x3F56,
	0xE68BB2:0x3F57,0xE68BB4:0x3F58,0xE68BBC:0x3F59,0xE68BBD:0x3F5A,0xE68C83:0x3F5B,
	0xE68C84:0x3F5C,0xE68C8A:0x3F5D,0xE68C8B:0x3F5E,0xE68C8D:0x3F5F,0xE68C90:0x3F60,
	0xE68C93:0x3F61,0xE68C96:0x3F62,0xE68C98:0x3F63,0xE68CA9:0x3F64,0xE68CAA:0x3F65,
	0xE68CAD:0x3F66,0xE68CB5:0x3F67,0xE68CB6:0x3F68,0xE68CB9:0x3F69,0xE68CBC:0x3F6A,
	0xE68D81:0x3F6B,0xE68D82:0x3F6C,0xE68D83:0x3F6D,0xE68D84:0x3F6E,0xE68D86:0x3F6F,
	0xE68D8A:0x3F70,0xE68D8B:0x3F71,0xE68D8E:0x3F72,0xE68D92:0x3F73,0xE68D93:0x3F74,
	0xE68D94:0x3F75,0xE68D98:0x3F76,0xE68D9B:0x3F77,0xE68DA5:0x3F78,0xE68DA6:0x3F79,
	0xE68DAC:0x3F7A,0xE68DAD:0x3F7B,0xE68DB1:0x3F7C,0xE68DB4:0x3F7D,0xE68DB5:0x3F7E,
	0xE68DB8:0x4021,0xE68DBC:0x4022,0xE68DBD:0x4023,0xE68DBF:0x4024,0xE68E82:0x4025,
	0xE68E84:0x4026,0xE68E87:0x4027,0xE68E8A:0x4028,0xE68E90:0x4029,0xE68E94:0x402A,
	0xE68E95:0x402B,0xE68E99:0x402C,0xE68E9A:0x402D,0xE68E9E:0x402E,0xE68EA4:0x402F,
	0xE68EA6:0x4030,0xE68EAD:0x4031,0xE68EAE:0x4032,0xE68EAF:0x4033,0xE68EBD:0x4034,
	0xE68F81:0x4035,0xE68F85:0x4036,0xE68F88:0x4037,0xE68F8E:0x4038,0xE68F91:0x4039,
	0xE68F93:0x403A,0xE68F94:0x403B,0xE68F95:0x403C,0xE68F9C:0x403D,0xE68FA0:0x403E,
	0xE68FA5:0x403F,0xE68FAA:0x4040,0xE68FAC:0x4041,0xE68FB2:0x4042,0xE68FB3:0x4043,
	0xE68FB5:0x4044,0xE68FB8:0x4045,0xE68FB9:0x4046,0xE69089:0x4047,0xE6908A:0x4048,
	0xE69090:0x4049,0xE69092:0x404A,0xE69094:0x404B,0xE69098:0x404C,0xE6909E:0x404D,
	0xE690A0:0x404E,0xE690A2:0x404F,0xE690A4:0x4050,0xE690A5:0x4051,0xE690A9:0x4052,
	0xE690AA:0x4053,0xE690AF:0x4054,0xE690B0:0x4055,0xE690B5:0x4056,0xE690BD:0x4057,
	0xE690BF:0x4058,0xE6918B:0x4059,0xE6918F:0x405A,0xE69191:0x405B,0xE69192:0x405C,
	0xE69193:0x405D,0xE69194:0x405E,0xE6919A:0x405F,0xE6919B:0x4060,0xE6919C:0x4061,
	0xE6919D:0x4062,0xE6919F:0x4063,0xE691A0:0x4064,0xE691A1:0x4065,0xE691A3:0x4066,
	0xE691AD:0x4067,0xE691B3:0x4068,0xE691B4:0x4069,0xE691BB:0x406A,0xE691BD:0x406B,
	0xE69285:0x406C,0xE69287:0x406D,0xE6928F:0x406E,0xE69290:0x406F,0xE69291:0x4070,
	0xE69298:0x4071,0xE69299:0x4072,0xE6929B:0x4073,0xE6929D:0x4074,0xE6929F:0x4075,
	0xE692A1:0x4076,0xE692A3:0x4077,0xE692A6:0x4078,0xE692A8:0x4079,0xE692AC:0x407A,
	0xE692B3:0x407B,0xE692BD:0x407C,0xE692BE:0x407D,0xE692BF:0x407E,0xE69384:0x4121,
	0xE69389:0x4122,0xE6938A:0x4123,0xE6938B:0x4124,0xE6938C:0x4125,0xE6938E:0x4126,
	0xE69390:0x4127,0xE69391:0x4128,0xE69395:0x4129,0xE69397:0x412A,0xE693A4:0x412B,
	0xE693A5:0x412C,0xE693A9:0x412D,0xE693AA:0x412E,0xE693AD:0x412F,0xE693B0:0x4130,
	0xE693B5:0x4131,0xE693B7:0x4132,0xE693BB:0x4133,0xE693BF:0x4134,0xE69481:0x4135,
	0xE69484:0x4136,0xE69488:0x4137,0xE69489:0x4138,0xE6948A:0x4139,0xE6948F:0x413A,
	0xE69493:0x413B,0xE69494:0x413C,0xE69496:0x413D,0xE69499:0x413E,0xE6949B:0x413F,
	0xE6949E:0x4140,0xE6949F:0x4141,0xE694A2:0x4142,0xE694A6:0x4143,0xE694A9:0x4144,
	0xE694AE:0x4145,0xE694B1:0x4146,0xE694BA:0x4147,0xE694BC:0x4148,0xE694BD:0x4149,
	0xE69583:0x414A,0xE69587:0x414B,0xE69589:0x414C,0xE69590:0x414D,0xE69592:0x414E,
	0xE69594:0x414F,0xE6959F:0x4150,0xE695A0:0x4151,0xE695A7:0x4152,0xE695AB:0x4153,
	0xE695BA:0x4154,0xE695BD:0x4155,0xE69681:0x4156,0xE69685:0x4157,0xE6968A:0x4158,
	0xE69692:0x4159,0xE69695:0x415A,0xE69698:0x415B,0xE6969D:0x415C,0xE696A0:0x415D,
	0xE696A3:0x415E,0xE696A6:0x415F,0xE696AE:0x4160,0xE696B2:0x4161,0xE696B3:0x4162,
	0xE696B4:0x4163,0xE696BF:0x4164,0xE69782:0x4165,0xE69788:0x4166,0xE69789:0x4167,
	0xE6978E:0x4168,0xE69790:0x4169,0xE69794:0x416A,0xE69796:0x416B,0xE69798:0x416C,
	0xE6979F:0x416D,0xE697B0:0x416E,0xE697B2:0x416F,0xE697B4:0x4170,0xE697B5:0x4171,
	0xE697B9:0x4172,0xE697BE:0x4173,0xE697BF:0x4174,0xE69880:0x4175,0xE69884:0x4176,
	0xE69888:0x4177,0xE69889:0x4178,0xE6988D:0x4179,0xE69891:0x417A,0xE69892:0x417B,
	0xE69895:0x417C,0xE69896:0x417D,0xE6989D:0x417E,0xE6989E:0x4221,0xE698A1:0x4222,
	0xE698A2:0x4223,0xE698A3:0x4224,0xE698A4:0x4225,0xE698A6:0x4226,0xE698A9:0x4227,
	0xE698AA:0x4228,0xE698AB:0x4229,0xE698AC:0x422A,0xE698AE:0x422B,0xE698B0:0x422C,
	0xE698B1:0x422D,0xE698B3:0x422E,0xE698B9:0x422F,0xE698B7:0x4230,0xE69980:0x4231,
	0xE69985:0x4232,0xE69986:0x4233,0xE6998A:0x4234,0xE6998C:0x4235,0xE69991:0x4236,
	0xE6998E:0x4237,0xE69997:0x4238,0xE69998:0x4239,0xE69999:0x423A,0xE6999B:0x423B,
	0xE6999C:0x423C,0xE699A0:0x423D,0xE699A1:0x423E,0xE69BBB:0x423F,0xE699AA:0x4240,
	0xE699AB:0x4241,0xE699AC:0x4242,0xE699BE:0x4243,0xE699B3:0x4244,0xE699B5:0x4245,
	0xE699BF:0x4246,0xE699B7:0x4247,0xE699B8:0x4248,0xE699B9:0x4249,0xE699BB:0x424A,
	0xE69A80:0x424B,0xE699BC:0x424C,0xE69A8B:0x424D,0xE69A8C:0x424E,0xE69A8D:0x424F,
	0xE69A90:0x4250,0xE69A92:0x4251,0xE69A99:0x4252,0xE69A9A:0x4253,0xE69A9B:0x4254,
	0xE69A9C:0x4255,0xE69A9F:0x4256,0xE69AA0:0x4257,0xE69AA4:0x4258,0xE69AAD:0x4259,
	0xE69AB1:0x425A,0xE69AB2:0x425B,0xE69AB5:0x425C,0xE69ABB:0x425D,0xE69ABF:0x425E,
	0xE69B80:0x425F,0xE69B82:0x4260,0xE69B83:0x4261,0xE69B88:0x4262,0xE69B8C:0x4263,
	0xE69B8E:0x4264,0xE69B8F:0x4265,0xE69B94:0x4266,0xE69B9B:0x4267,0xE69B9F:0x4268,
	0xE69BA8:0x4269,0xE69BAB:0x426A,0xE69BAC:0x426B,0xE69BAE:0x426C,0xE69BBA:0x426D,
	0xE69C85:0x426E,0xE69C87:0x426F,0xE69C8E:0x4270,0xE69C93:0x4271,0xE69C99:0x4272,
	0xE69C9C:0x4273,0xE69CA0:0x4274,0xE69CA2:0x4275,0xE69CB3:0x4276,0xE69CBE:0x4277,
	0xE69D85:0x4278,0xE69D87:0x4279,0xE69D88:0x427A,0xE69D8C:0x427B,0xE69D94:0x427C,
	0xE69D95:0x427D,0xE69D9D:0x427E,0xE69DA6:0x4321,0xE69DAC:0x4322,0xE69DAE:0x4323,
	0xE69DB4:0x4324,0xE69DB6:0x4325,0xE69DBB:0x4326,0xE69E81:0x4327,0xE69E84:0x4328,
	0xE69E8E:0x4329,0xE69E8F:0x432A,0xE69E91:0x432B,0xE69E93:0x432C,0xE69E96:0x432D,
	0xE69E98:0x432E,0xE69E99:0x432F,0xE69E9B:0x4330,0xE69EB0:0x4331,0xE69EB1:0x4332,
	0xE69EB2:0x4333,0xE69EB5:0x4334,0xE69EBB:0x4335,0xE69EBC:0x4336,0xE69EBD:0x4337,
	0xE69FB9:0x4338,0xE69F80:0x4339,0xE69F82:0x433A,0xE69F83:0x433B,0xE69F85:0x433C,
	0xE69F88:0x433D,0xE69F89:0x433E,0xE69F92:0x433F,0xE69F97:0x4340,0xE69F99:0x4341,
	0xE69F9C:0x4342,0xE69FA1:0x4343,0xE69FA6:0x4344,0xE69FB0:0x4345,0xE69FB2:0x4346,
	0xE69FB6:0x4347,0xE69FB7:0x4348,0xE6A192:0x4349,0xE6A094:0x434A,0xE6A099:0x434B,
	0xE6A09D:0x434C,0xE6A09F:0x434D,0xE6A0A8:0x434E,0xE6A0A7:0x434F,0xE6A0AC:0x4350,
	0xE6A0AD:0x4351,0xE6A0AF:0x4352,0xE6A0B0:0x4353,0xE6A0B1:0x4354,0xE6A0B3:0x4355,
	0xE6A0BB:0x4356,0xE6A0BF:0x4357,0xE6A184:0x4358,0xE6A185:0x4359,0xE6A18A:0x435A,
	0xE6A18C:0x435B,0xE6A195:0x435C,0xE6A197:0x435D,0xE6A198:0x435E,0xE6A19B:0x435F,
	0xE6A1AB:0x4360,0xE6A1AE:0x4361,0xE6A1AF:0x4362,0xE6A1B0:0x4363,0xE6A1B1:0x4364,
	0xE6A1B2:0x4365,0xE6A1B5:0x4366,0xE6A1B9:0x4367,0xE6A1BA:0x4368,0xE6A1BB:0x4369,
	0xE6A1BC:0x436A,0xE6A282:0x436B,0xE6A284:0x436C,0xE6A286:0x436D,0xE6A288:0x436E,
	0xE6A296:0x436F,0xE6A298:0x4370,0xE6A29A:0x4371,0xE6A29C:0x4372,0xE6A2A1:0x4373,
	0xE6A2A3:0x4374,0xE6A2A5:0x4375,0xE6A2A9:0x4376,0xE6A2AA:0x4377,0xE6A2AE:0x4378,
	0xE6A2B2:0x4379,0xE6A2BB:0x437A,0xE6A385:0x437B,0xE6A388:0x437C,0xE6A38C:0x437D,
	0xE6A38F:0x437E,0xE6A390:0x4421,0xE6A391:0x4422,0xE6A393:0x4423,0xE6A396:0x4424,
	0xE6A399:0x4425,0xE6A39C:0x4426,0xE6A39D:0x4427,0xE6A3A5:0x4428,0xE6A3A8:0x4429,
	0xE6A3AA:0x442A,0xE6A3AB:0x442B,0xE6A3AC:0x442C,0xE6A3AD:0x442D,0xE6A3B0:0x442E,
	0xE6A3B1:0x442F,0xE6A3B5:0x4430,0xE6A3B6:0x4431,0xE6A3BB:0x4432,0xE6A3BC:0x4433,
	0xE6A3BD:0x4434,0xE6A486:0x4435,0xE6A489:0x4436,0xE6A48A:0x4437,0xE6A490:0x4438,
	0xE6A491:0x4439,0xE6A493:0x443A,0xE6A496:0x443B,0xE6A497:0x443C,0xE6A4B1:0x443D,
	0xE6A4B3:0x443E,0xE6A4B5:0x443F,0xE6A4B8:0x4440,0xE6A4BB:0x4441,0xE6A582:0x4442,
	0xE6A585:0x4443,0xE6A589:0x4444,0xE6A58E:0x4445,0xE6A597:0x4446,0xE6A59B:0x4447,
	0xE6A5A3:0x4448,0xE6A5A4:0x4449,0xE6A5A5:0x444A,0xE6A5A6:0x444B,0xE6A5A8:0x444C,
	0xE6A5A9:0x444D,0xE6A5AC:0x444E,0xE6A5B0:0x444F,0xE6A5B1:0x4450,0xE6A5B2:0x4451,
	0xE6A5BA:0x4452,0xE6A5BB:0x4453,0xE6A5BF:0x4454,0xE6A680:0x4455,0xE6A68D:0x4456,
	0xE6A692:0x4457,0xE6A696:0x4458,0xE6A698:0x4459,0xE6A6A1:0x445A,0xE6A6A5:0x445B,
	0xE6A6A6:0x445C,0xE6A6A8:0x445D,0xE6A6AB:0x445E,0xE6A6AD:0x445F,0xE6A6AF:0x4460,
	0xE6A6B7:0x4461,0xE6A6B8:0x4462,0xE6A6BA:0x4463,0xE6A6BC:0x4464,0xE6A785:0x4465,
	0xE6A788:0x4466,0xE6A791:0x4467,0xE6A796:0x4468,0xE6A797:0x4469,0xE6A7A2:0x446A,
	0xE6A7A5:0x446B,0xE6A7AE:0x446C,0xE6A7AF:0x446D,0xE6A7B1:0x446E,0xE6A7B3:0x446F,
	0xE6A7B5:0x4470,0xE6A7BE:0x4471,0xE6A880:0x4472,0xE6A881:0x4473,0xE6A883:0x4474,
	0xE6A88F:0x4475,0xE6A891:0x4476,0xE6A895:0x4477,0xE6A89A:0x4478,0xE6A89D:0x4479,
	0xE6A8A0:0x447A,0xE6A8A4:0x447B,0xE6A8A8:0x447C,0xE6A8B0:0x447D,0xE6A8B2:0x447E,
	0xE6A8B4:0x4521,0xE6A8B7:0x4522,0xE6A8BB:0x4523,0xE6A8BE:0x4524,0xE6A8BF:0x4525,
	0xE6A985:0x4526,0xE6A986:0x4527,0xE6A989:0x4528,0xE6A98A:0x4529,0xE6A98E:0x452A,
	0xE6A990:0x452B,0xE6A991:0x452C,0xE6A992:0x452D,0xE6A995:0x452E,0xE6A996:0x452F,
	0xE6A99B:0x4530,0xE6A9A4:0x4531,0xE6A9A7:0x4532,0xE6A9AA:0x4533,0xE6A9B1:0x4534,
	0xE6A9B3:0x4535,0xE6A9BE:0x4536,0xE6AA81:0x4537,0xE6AA83:0x4538,0xE6AA86:0x4539,
	0xE6AA87:0x453A,0xE6AA89:0x453B,0xE6AA8B:0x453C,0xE6AA91:0x453D,0xE6AA9B:0x453E,
	0xE6AA9D:0x453F,0xE6AA9E:0x4540,0xE6AA9F:0x4541,0xE6AAA5:0x4542,0xE6AAAB:0x4543,
	0xE6AAAF:0x4544,0xE6AAB0:0x4545,0xE6AAB1:0x4546,0xE6AAB4:0x4547,0xE6AABD:0x4548,
	0xE6AABE:0x4549,0xE6AABF:0x454A,0xE6AB86:0x454B,0xE6AB89:0x454C,0xE6AB88:0x454D,
	0xE6AB8C:0x454E,0xE6AB90:0x454F,0xE6AB94:0x4550,0xE6AB95:0x4551,0xE6AB96:0x4552,
	0xE6AB9C:0x4553,0xE6AB9D:0x4554,0xE6ABA4:0x4555,0xE6ABA7:0x4556,0xE6ABAC:0x4557,
	0xE6ABB0:0x4558,0xE6ABB1:0x4559,0xE6ABB2:0x455A,0xE6ABBC:0x455B,0xE6ABBD:0x455C,
	0xE6AC82:0x455D,0xE6AC83:0x455E,0xE6AC86:0x455F,0xE6AC87:0x4560,0xE6AC89:0x4561,
	0xE6AC8F:0x4562,0xE6AC90:0x4563,0xE6AC91:0x4564,0xE6AC97:0x4565,0xE6AC9B:0x4566,
	0xE6AC9E:0x4567,0xE6ACA4:0x4568,0xE6ACA8:0x4569,0xE6ACAB:0x456A,0xE6ACAC:0x456B,
	0xE6ACAF:0x456C,0xE6ACB5:0x456D,0xE6ACB6:0x456E,0xE6ACBB:0x456F,0xE6ACBF:0x4570,
	0xE6AD86:0x4571,0xE6AD8A:0x4572,0xE6AD8D:0x4573,0xE6AD92:0x4574,0xE6AD96:0x4575,
	0xE6AD98:0x4576,0xE6AD9D:0x4577,0xE6ADA0:0x4578,0xE6ADA7:0x4579,0xE6ADAB:0x457A,
	0xE6ADAE:0x457B,0xE6ADB0:0x457C,0xE6ADB5:0x457D,0xE6ADBD:0x457E,0xE6ADBE:0x4621,
	0xE6AE82:0x4622,0xE6AE85:0x4623,0xE6AE97:0x4624,0xE6AE9B:0x4625,0xE6AE9F:0x4626,
	0xE6AEA0:0x4627,0xE6AEA2:0x4628,0xE6AEA3:0x4629,0xE6AEA8:0x462A,0xE6AEA9:0x462B,
	0xE6AEAC:0x462C,0xE6AEAD:0x462D,0xE6AEAE:0x462E,0xE6AEB0:0x462F,0xE6AEB8:0x4630,
	0xE6AEB9:0x4631,0xE6AEBD:0x4632,0xE6AEBE:0x4633,0xE6AF83:0x4634,0xE6AF84:0x4635,
	0xE6AF89:0x4636,0xE6AF8C:0x4637,0xE6AF96:0x4638,0xE6AF9A:0x4639,0xE6AFA1:0x463A,
	0xE6AFA3:0x463B,0xE6AFA6:0x463C,0xE6AFA7:0x463D,0xE6AFAE:0x463E,0xE6AFB1:0x463F,
	0xE6AFB7:0x4640,0xE6AFB9:0x4641,0xE6AFBF:0x4642,0xE6B082:0x4643,0xE6B084:0x4644,
	0xE6B085:0x4645,0xE6B089:0x4646,0xE6B08D:0x4647,0xE6B08E:0x4648,0xE6B090:0x4649,
	0xE6B092:0x464A,0xE6B099:0x464B,0xE6B09F:0x464C,0xE6B0A6:0x464D,0xE6B0A7:0x464E,
	0xE6B0A8:0x464F,0xE6B0AC:0x4650,0xE6B0AE:0x4651,0xE6B0B3:0x4652,0xE6B0B5:0x4653,
	0xE6B0B6:0x4654,0xE6B0BA:0x4655,0xE6B0BB:0x4656,0xE6B0BF:0x4657,0xE6B18A:0x4658,
	0xE6B18B:0x4659,0xE6B18D:0x465A,0xE6B18F:0x465B,0xE6B192:0x465C,0xE6B194:0x465D,
	0xE6B199:0x465E,0xE6B19B:0x465F,0xE6B19C:0x4660,0xE6B1AB:0x4661,0xE6B1AD:0x4662,
	0xE6B1AF:0x4663,0xE6B1B4:0x4664,0xE6B1B6:0x4665,0xE6B1B8:0x4666,0xE6B1B9:0x4667,
	0xE6B1BB:0x4668,0xE6B285:0x4669,0xE6B286:0x466A,0xE6B287:0x466B,0xE6B289:0x466C,
	0xE6B294:0x466D,0xE6B295:0x466E,0xE6B297:0x466F,0xE6B298:0x4670,0xE6B29C:0x4671,
	0xE6B29F:0x4672,0xE6B2B0:0x4673,0xE6B2B2:0x4674,0xE6B2B4:0x4675,0xE6B382:0x4676,
	0xE6B386:0x4677,0xE6B38D:0x4678,0xE6B38F:0x4679,0xE6B390:0x467A,0xE6B391:0x467B,
	0xE6B392:0x467C,0xE6B394:0x467D,0xE6B396:0x467E,0xE6B39A:0x4721,0xE6B39C:0x4722,
	0xE6B3A0:0x4723,0xE6B3A7:0x4724,0xE6B3A9:0x4725,0xE6B3AB:0x4726,0xE6B3AC:0x4727,
	0xE6B3AE:0x4728,0xE6B3B2:0x4729,0xE6B3B4:0x472A,0xE6B484:0x472B,0xE6B487:0x472C,
	0xE6B48A:0x472D,0xE6B48E:0x472E,0xE6B48F:0x472F,0xE6B491:0x4730,0xE6B493:0x4731,
	0xE6B49A:0x4732,0xE6B4A6:0x4733,0xE6B4A7:0x4734,0xE6B4A8:0x4735,0xE6B1A7:0x4736,
	0xE6B4AE:0x4737,0xE6B4AF:0x4738,0xE6B4B1:0x4739,0xE6B4B9:0x473A,0xE6B4BC:0x473B,
	0xE6B4BF:0x473C,0xE6B597:0x473D,0xE6B59E:0x473E,0xE6B59F:0x473F,0xE6B5A1:0x4740,
	0xE6B5A5:0x4741,0xE6B5A7:0x4742,0xE6B5AF:0x4743,0xE6B5B0:0x4744,0xE6B5BC:0x4745,
	0xE6B682:0x4746,0xE6B687:0x4747,0xE6B691:0x4748,0xE6B692:0x4749,0xE6B694:0x474A,
	0xE6B696:0x474B,0xE6B697:0x474C,0xE6B698:0x474D,0xE6B6AA:0x474E,0xE6B6AC:0x474F,
	0xE6B6B4:0x4750,0xE6B6B7:0x4751,0xE6B6B9:0x4752,0xE6B6BD:0x4753,0xE6B6BF:0x4754,
	0xE6B784:0x4755,0xE6B788:0x4756,0xE6B78A:0x4757,0xE6B78E:0x4758,0xE6B78F:0x4759,
	0xE6B796:0x475A,0xE6B79B:0x475B,0xE6B79D:0x475C,0xE6B79F:0x475D,0xE6B7A0:0x475E,
	0xE6B7A2:0x475F,0xE6B7A5:0x4760,0xE6B7A9:0x4761,0xE6B7AF:0x4762,0xE6B7B0:0x4763,
	0xE6B7B4:0x4764,0xE6B7B6:0x4765,0xE6B7BC:0x4766,0xE6B880:0x4767,0xE6B884:0x4768,
	0xE6B89E:0x4769,0xE6B8A2:0x476A,0xE6B8A7:0x476B,0xE6B8B2:0x476C,0xE6B8B6:0x476D,
	0xE6B8B9:0x476E,0xE6B8BB:0x476F,0xE6B8BC:0x4770,0xE6B984:0x4771,0xE6B985:0x4772,
	0xE6B988:0x4773,0xE6B989:0x4774,0xE6B98B:0x4775,0xE6B98F:0x4776,0xE6B991:0x4777,
	0xE6B992:0x4778,0xE6B993:0x4779,0xE6B994:0x477A,0xE6B997:0x477B,0xE6B99C:0x477C,
	0xE6B99D:0x477D,0xE6B99E:0x477E,0xE6B9A2:0x4821,0xE6B9A3:0x4822,0xE6B9A8:0x4823,
	0xE6B9B3:0x4824,0xE6B9BB:0x4825,0xE6B9BD:0x4826,0xE6BA8D:0x4827,0xE6BA93:0x4828,
	0xE6BA99:0x4829,0xE6BAA0:0x482A,0xE6BAA7:0x482B,0xE6BAAD:0x482C,0xE6BAAE:0x482D,
	0xE6BAB1:0x482E,0xE6BAB3:0x482F,0xE6BABB:0x4830,0xE6BABF:0x4831,0xE6BB80:0x4832,
	0xE6BB81:0x4833,0xE6BB83:0x4834,0xE6BB87:0x4835,0xE6BB88:0x4836,0xE6BB8A:0x4837,
	0xE6BB8D:0x4838,0xE6BB8E:0x4839,0xE6BB8F:0x483A,0xE6BBAB:0x483B,0xE6BBAD:0x483C,
	0xE6BBAE:0x483D,0xE6BBB9:0x483E,0xE6BBBB:0x483F,0xE6BBBD:0x4840,0xE6BC84:0x4841,
	0xE6BC88:0x4842,0xE6BC8A:0x4843,0xE6BC8C:0x4844,0xE6BC8D:0x4845,0xE6BC96:0x4846,
	0xE6BC98:0x4847,0xE6BC9A:0x4848,0xE6BC9B:0x4849,0xE6BCA6:0x484A,0xE6BCA9:0x484B,
	0xE6BCAA:0x484C,0xE6BCAF:0x484D,0xE6BCB0:0x484E,0xE6BCB3:0x484F,0xE6BCB6:0x4850,
	0xE6BCBB:0x4851,0xE6BCBC:0x4852,0xE6BCAD:0x4853,0xE6BD8F:0x4854,0xE6BD91:0x4855,
	0xE6BD92:0x4856,0xE6BD93:0x4857,0xE6BD97:0x4858,0xE6BD99:0x4859,0xE6BD9A:0x485A,
	0xE6BD9D:0x485B,0xE6BD9E:0x485C,0xE6BDA1:0x485D,0xE6BDA2:0x485E,0xE6BDA8:0x485F,
	0xE6BDAC:0x4860,0xE6BDBD:0x4861,0xE6BDBE:0x4862,0xE6BE83:0x4863,0xE6BE87:0x4864,
	0xE6BE88:0x4865,0xE6BE8B:0x4866,0xE6BE8C:0x4867,0xE6BE8D:0x4868,0xE6BE90:0x4869,
	0xE6BE92:0x486A,0xE6BE93:0x486B,0xE6BE94:0x486C,0xE6BE96:0x486D,0xE6BE9A:0x486E,
	0xE6BE9F:0x486F,0xE6BEA0:0x4870,0xE6BEA5:0x4871,0xE6BEA6:0x4872,0xE6BEA7:0x4873,
	0xE6BEA8:0x4874,0xE6BEAE:0x4875,0xE6BEAF:0x4876,0xE6BEB0:0x4877,0xE6BEB5:0x4878,
	0xE6BEB6:0x4879,0xE6BEBC:0x487A,0xE6BF85:0x487B,0xE6BF87:0x487C,0xE6BF88:0x487D,
	0xE6BF8A:0x487E,0xE6BF9A:0x4921,0xE6BF9E:0x4922,0xE6BFA8:0x4923,0xE6BFA9:0x4924,
	0xE6BFB0:0x4925,0xE6BFB5:0x4926,0xE6BFB9:0x4927,0xE6BFBC:0x4928,0xE6BFBD:0x4929,
	0xE78080:0x492A,0xE78085:0x492B,0xE78086:0x492C,0xE78087:0x492D,0xE7808D:0x492E,
	0xE78097:0x492F,0xE780A0:0x4930,0xE780A3:0x4931,0xE780AF:0x4932,0xE780B4:0x4933,
	0xE780B7:0x4934,0xE780B9:0x4935,0xE780BC:0x4936,0xE78183:0x4937,0xE78184:0x4938,
	0xE78188:0x4939,0xE78189:0x493A,0xE7818A:0x493B,0xE7818B:0x493C,0xE78194:0x493D,
	0xE78195:0x493E,0xE7819D:0x493F,0xE7819E:0x4940,0xE7818E:0x4941,0xE781A4:0x4942,
	0xE781A5:0x4943,0xE781AC:0x4944,0xE781AE:0x4945,0xE781B5:0x4946,0xE781B6:0x4947,
	0xE781BE:0x4948,0xE78281:0x4949,0xE78285:0x494A,0xE78286:0x494B,0xE78294:0x494C,
	0xE78295:0x494D,0xE78296:0x494E,0xE78297:0x494F,0xE78298:0x4950,0xE7829B:0x4951,
	0xE782A4:0x4952,0xE782AB:0x4953,0xE782B0:0x4954,0xE782B1:0x4955,0xE782B4:0x4956,
	0xE782B7:0x4957,0xE7838A:0x4958,0xE78391:0x4959,0xE78393:0x495A,0xE78394:0x495B,
	0xE78395:0x495C,0xE78396:0x495D,0xE78398:0x495E,0xE7839C:0x495F,0xE783A4:0x4960,
	0xE783BA:0x4961,0xE78483:0x4962,0xE78484:0x4963,0xE78485:0x4964,0xE78486:0x4965,
	0xE78487:0x4966,0xE7848B:0x4967,0xE7848C:0x4968,0xE7848F:0x4969,0xE7849E:0x496A,
	0xE784A0:0x496B,0xE784AB:0x496C,0xE784AD:0x496D,0xE784AF:0x496E,0xE784B0:0x496F,
	0xE784B1:0x4970,0xE784B8:0x4971,0xE78581:0x4972,0xE78585:0x4973,0xE78586:0x4974,
	0xE78587:0x4975,0xE7858A:0x4976,0xE7858B:0x4977,0xE78590:0x4978,0xE78592:0x4979,
	0xE78597:0x497A,0xE7859A:0x497B,0xE7859C:0x497C,0xE7859E:0x497D,0xE785A0:0x497E,
	0xE785A8:0x4A21,0xE785B9:0x4A22,0xE78680:0x4A23,0xE78685:0x4A24,0xE78687:0x4A25,
	0xE7868C:0x4A26,0xE78692:0x4A27,0xE7869A:0x4A28,0xE7869B:0x4A29,0xE786A0:0x4A2A,
	0xE786A2:0x4A2B,0xE786AF:0x4A2C,0xE786B0:0x4A2D,0xE786B2:0x4A2E,0xE786B3:0x4A2F,
	0xE786BA:0x4A30,0xE786BF:0x4A31,0xE78780:0x4A32,0xE78781:0x4A33,0xE78784:0x4A34,
	0xE7878B:0x4A35,0xE7878C:0x4A36,0xE78793:0x4A37,0xE78796:0x4A38,0xE78799:0x4A39,
	0xE7879A:0x4A3A,0xE7879C:0x4A3B,0xE787B8:0x4A3C,0xE787BE:0x4A3D,0xE78880:0x4A3E,
	0xE78887:0x4A3F,0xE78888:0x4A40,0xE78889:0x4A41,0xE78893:0x4A42,0xE78897:0x4A43,
	0xE7889A:0x4A44,0xE7889D:0x4A45,0xE7889F:0x4A46,0xE788A4:0x4A47,0xE788AB:0x4A48,
	0xE788AF:0x4A49,0xE788B4:0x4A4A,0xE788B8:0x4A4B,0xE788B9:0x4A4C,0xE78981:0x4A4D,
	0xE78982:0x4A4E,0xE78983:0x4A4F,0xE78985:0x4A50,0xE7898E:0x4A51,0xE7898F:0x4A52,
	0xE78990:0x4A53,0xE78993:0x4A54,0xE78995:0x4A55,0xE78996:0x4A56,0xE7899A:0x4A57,
	0xE7899C:0x4A58,0xE7899E:0x4A59,0xE789A0:0x4A5A,0xE789A3:0x4A5B,0xE789A8:0x4A5C,
	0xE789AB:0x4A5D,0xE789AE:0x4A5E,0xE789AF:0x4A5F,0xE789B1:0x4A60,0xE789B7:0x4A61,
	0xE789B8:0x4A62,0xE789BB:0x4A63,0xE789BC:0x4A64,0xE789BF:0x4A65,0xE78A84:0x4A66,
	0xE78A89:0x4A67,0xE78A8D:0x4A68,0xE78A8E:0x4A69,0xE78A93:0x4A6A,0xE78A9B:0x4A6B,
	0xE78AA8:0x4A6C,0xE78AAD:0x4A6D,0xE78AAE:0x4A6E,0xE78AB1:0x4A6F,0xE78AB4:0x4A70,
	0xE78ABE:0x4A71,0xE78B81:0x4A72,0xE78B87:0x4A73,0xE78B89:0x4A74,0xE78B8C:0x4A75,
	0xE78B95:0x4A76,0xE78B96:0x4A77,0xE78B98:0x4A78,0xE78B9F:0x4A79,0xE78BA5:0x4A7A,
	0xE78BB3:0x4A7B,0xE78BB4:0x4A7C,0xE78BBA:0x4A7D,0xE78BBB:0x4A7E,0xE78BBE:0x4B21,
	0xE78C82:0x4B22,0xE78C84:0x4B23,0xE78C85:0x4B24,0xE78C87:0x4B25,0xE78C8B:0x4B26,
	0xE78C8D:0x4B27,0xE78C92:0x4B28,0xE78C93:0x4B29,0xE78C98:0x4B2A,0xE78C99:0x4B2B,
	0xE78C9E:0x4B2C,0xE78CA2:0x4B2D,0xE78CA4:0x4B2E,0xE78CA7:0x4B2F,0xE78CA8:0x4B30,
	0xE78CAC:0x4B31,0xE78CB1:0x4B32,0xE78CB2:0x4B33,0xE78CB5:0x4B34,0xE78CBA:0x4B35,
	0xE78CBB:0x4B36,0xE78CBD:0x4B37,0xE78D83:0x4B38,0xE78D8D:0x4B39,0xE78D90:0x4B3A,
	0xE78D92:0x4B3B,0xE78D96:0x4B3C,0xE78D98:0x4B3D,0xE78D9D:0x4B3E,0xE78D9E:0x4B3F,
	0xE78D9F:0x4B40,0xE78DA0:0x4B41,0xE78DA6:0x4B42,0xE78DA7:0x4B43,0xE78DA9:0x4B44,
	0xE78DAB:0x4B45,0xE78DAC:0x4B46,0xE78DAE:0x4B47,0xE78DAF:0x4B48,0xE78DB1:0x4B49,
	0xE78DB7:0x4B4A,0xE78DB9:0x4B4B,0xE78DBC:0x4B4C,0xE78E80:0x4B4D,0xE78E81:0x4B4E,
	0xE78E83:0x4B4F,0xE78E85:0x4B50,0xE78E86:0x4B51,0xE78E8E:0x4B52,0xE78E90:0x4B53,
	0xE78E93:0x4B54,0xE78E95:0x4B55,0xE78E97:0x4B56,0xE78E98:0x4B57,0xE78E9C:0x4B58,
	0xE78E9E:0x4B59,0xE78E9F:0x4B5A,0xE78EA0:0x4B5B,0xE78EA2:0x4B5C,0xE78EA5:0x4B5D,
	0xE78EA6:0x4B5E,0xE78EAA:0x4B5F,0xE78EAB:0x4B60,0xE78EAD:0x4B61,0xE78EB5:0x4B62,
	0xE78EB7:0x4B63,0xE78EB9:0x4B64,0xE78EBC:0x4B65,0xE78EBD:0x4B66,0xE78EBF:0x4B67,
	0xE78F85:0x4B68,0xE78F86:0x4B69,0xE78F89:0x4B6A,0xE78F8B:0x4B6B,0xE78F8C:0x4B6C,
	0xE78F8F:0x4B6D,0xE78F92:0x4B6E,0xE78F93:0x4B6F,0xE78F96:0x4B70,0xE78F99:0x4B71,
	0xE78F9D:0x4B72,0xE78FA1:0x4B73,0xE78FA3:0x4B74,0xE78FA6:0x4B75,0xE78FA7:0x4B76,
	0xE78FA9:0x4B77,0xE78FB4:0x4B78,0xE78FB5:0x4B79,0xE78FB7:0x4B7A,0xE78FB9:0x4B7B,
	0xE78FBA:0x4B7C,0xE78FBB:0x4B7D,0xE78FBD:0x4B7E,0xE78FBF:0x4C21,0xE79080:0x4C22,
	0xE79081:0x4C23,0xE79084:0x4C24,0xE79087:0x4C25,0xE7908A:0x4C26,0xE79091:0x4C27,
	0xE7909A:0x4C28,0xE7909B:0x4C29,0xE790A4:0x4C2A,0xE790A6:0x4C2B,0xE790A8:0x4C2C,
	0xE790A9:0x4C2D,0xE790AA:0x4C2E,0xE790AB:0x4C2F,0xE790AC:0x4C30,0xE790AD:0x4C31,
	0xE790AE:0x4C32,0xE790AF:0x4C33,0xE790B0:0x4C34,0xE790B1:0x4C35,0xE790B9:0x4C36,
	0xE79180:0x4C37,0xE79183:0x4C38,0xE79184:0x4C39,0xE79186:0x4C3A,0xE79187:0x4C3B,
	0xE7918B:0x4C3C,0xE7918D:0x4C3D,0xE79191:0x4C3E,0xE79192:0x4C3F,0xE79197:0x4C40,
	0xE7919D:0x4C41,0xE791A2:0x4C42,0xE791A6:0x4C43,0xE791A7:0x4C44,0xE791A8:0x4C45,
	0xE791AB:0x4C46,0xE791AD:0x4C47,0xE791AE:0x4C48,0xE791B1:0x4C49,0xE791B2:0x4C4A,
	0xE79280:0x4C4B,0xE79281:0x4C4C,0xE79285:0x4C4D,0xE79286:0x4C4E,0xE79287:0x4C4F,
	0xE79289:0x4C50,0xE7928F:0x4C51,0xE79290:0x4C52,0xE79291:0x4C53,0xE79292:0x4C54,
	0xE79298:0x4C55,0xE79299:0x4C56,0xE7929A:0x4C57,0xE7929C:0x4C58,0xE7929F:0x4C59,
	0xE792A0:0x4C5A,0xE792A1:0x4C5B,0xE792A3:0x4C5C,0xE792A6:0x4C5D,0xE792A8:0x4C5E,
	0xE792A9:0x4C5F,0xE792AA:0x4C60,0xE792AB:0x4C61,0xE792AE:0x4C62,0xE792AF:0x4C63,
	0xE792B1:0x4C64,0xE792B2:0x4C65,0xE792B5:0x4C66,0xE792B9:0x4C67,0xE792BB:0x4C68,
	0xE792BF:0x4C69,0xE79388:0x4C6A,0xE79389:0x4C6B,0xE7938C:0x4C6C,0xE79390:0x4C6D,
	0xE79393:0x4C6E,0xE79398:0x4C6F,0xE7939A:0x4C70,0xE7939B:0x4C71,0xE7939E:0x4C72,
	0xE7939F:0x4C73,0xE793A4:0x4C74,0xE793A8:0x4C75,0xE793AA:0x4C76,0xE793AB:0x4C77,
	0xE793AF:0x4C78,0xE793B4:0x4C79,0xE793BA:0x4C7A,0xE793BB:0x4C7B,0xE793BC:0x4C7C,
	0xE793BF:0x4C7D,0xE79486:0x4C7E,0xE79492:0x4D21,0xE79496:0x4D22,0xE79497:0x4D23,
	0xE794A0:0x4D24,0xE794A1:0x4D25,0xE794A4:0x4D26,0xE794A7:0x4D27,0xE794A9:0x4D28,
	0xE794AA:0x4D29,0xE794AF:0x4D2A,0xE794B6:0x4D2B,0xE794B9:0x4D2C,0xE794BD:0x4D2D,
	0xE794BE:0x4D2E,0xE794BF:0x4D2F,0xE79580:0x4D30,0xE79583:0x4D31,0xE79587:0x4D32,
	0xE79588:0x4D33,0xE7958E:0x4D34,0xE79590:0x4D35,0xE79592:0x4D36,0xE79597:0x4D37,
	0xE7959E:0x4D38,0xE7959F:0x4D39,0xE795A1:0x4D3A,0xE795AF:0x4D3B,0xE795B1:0x4D3C,
	0xE795B9:0x4D3D,0xE795BA:0x4D3E,0xE795BB:0x4D3F,0xE795BC:0x4D40,0xE795BD:0x4D41,
	0xE795BE:0x4D42,0xE79681:0x4D43,0xE79685:0x4D44,0xE79690:0x4D45,0xE79692:0x4D46,
	0xE79693:0x4D47,0xE79695:0x4D48,0xE79699:0x4D49,0xE7969C:0x4D4A,0xE796A2:0x4D4B,
	0xE796A4:0x4D4C,0xE796B4:0x4D4D,0xE796BA:0x4D4E,0xE796BF:0x4D4F,0xE79780:0x4D50,
	0xE79781:0x4D51,0xE79784:0x4D52,0xE79786:0x4D53,0xE7978C:0x4D54,0xE7978E:0x4D55,
	0xE7978F:0x4D56,0xE79797:0x4D57,0xE7979C:0x4D58,0xE7979F:0x4D59,0xE797A0:0x4D5A,
	0xE797A1:0x4D5B,0xE797A4:0x4D5C,0xE797A7:0x4D5D,0xE797AC:0x4D5E,0xE797AE:0x4D5F,
	0xE797AF:0x4D60,0xE797B1:0x4D61,0xE797B9:0x4D62,0xE79880:0x4D63,0xE79882:0x4D64,
	0xE79883:0x4D65,0xE79884:0x4D66,0xE79887:0x4D67,0xE79888:0x4D68,0xE7988A:0x4D69,
	0xE7988C:0x4D6A,0xE7988F:0x4D6B,0xE79892:0x4D6C,0xE79893:0x4D6D,0xE79895:0x4D6E,
	0xE79896:0x4D6F,0xE79899:0x4D70,0xE7989B:0x4D71,0xE7989C:0x4D72,0xE7989D:0x4D73,
	0xE7989E:0x4D74,0xE798A3:0x4D75,0xE798A5:0x4D76,0xE798A6:0x4D77,0xE798A9:0x4D78,
	0xE798AD:0x4D79,0xE798B2:0x4D7A,0xE798B3:0x4D7B,0xE798B5:0x4D7C,0xE798B8:0x4D7D,
	0xE798B9:0x4D7E,0xE798BA:0x4E21,0xE798BC:0x4E22,0xE7998A:0x4E23,0xE79980:0x4E24,
	0xE79981:0x4E25,0xE79983:0x4E26,0xE79984:0x4E27,0xE79985:0x4E28,0xE79989:0x4E29,
	0xE7998B:0x4E2A,0xE79995:0x4E2B,0xE79999:0x4E2C,0xE7999F:0x4E2D,0xE799A4:0x4E2E,
	0xE799A5:0x4E2F,0xE799AD:0x4E30,0xE799AE:0x4E31,0xE799AF:0x4E32,0xE799B1:0x4E33,
	0xE799B4:0x4E34,0xE79A81:0x4E35,0xE79A85:0x4E36,0xE79A8C:0x4E37,0xE79A8D:0x4E38,
	0xE79A95:0x4E39,0xE79A9B:0x4E3A,0xE79A9C:0x4E3B,0xE79A9D:0x4E3C,0xE79A9F:0x4E3D,
	0xE79AA0:0x4E3E,0xE79AA2:0x4E3F,0xE79AA3:0x4E40,0xE79AA4:0x4E41,0xE79AA5:0x4E42,
	0xE79AA6:0x4E43,0xE79AA7:0x4E44,0xE79AA8:0x4E45,0xE79AAA:0x4E46,0xE79AAD:0x4E47,
	0xE79ABD:0x4E48,0xE79B81:0x4E49,0xE79B85:0x4E4A,0xE79B89:0x4E4B,0xE79B8B:0x4E4C,
	0xE79B8C:0x4E4D,0xE79B8E:0x4E4E,0xE79B94:0x4E4F,0xE79B99:0x4E50,0xE79BA0:0x4E51,
	0xE79BA6:0x4E52,0xE79BA8:0x4E53,0xE79BAC:0x4E54,0xE79BB0:0x4E55,0xE79BB1:0x4E56,
	0xE79BB6:0x4E57,0xE79BB9:0x4E58,0xE79BBC:0x4E59,0xE79C80:0x4E5A,0xE79C86:0x4E5B,
	0xE79C8A:0x4E5C,0xE79C8E:0x4E5D,0xE79C92:0x4E5E,0xE79C94:0x4E5F,0xE79C95:0x4E60,
	0xE79C97:0x4E61,0xE79C99:0x4E62,0xE79C9A:0x4E63,0xE79C9C:0x4E64,0xE79CA2:0x4E65,
	0xE79CA8:0x4E66,0xE79CAD:0x4E67,0xE79CAE:0x4E68,0xE79CAF:0x4E69,0xE79CB4:0x4E6A,
	0xE79CB5:0x4E6B,0xE79CB6:0x4E6C,0xE79CB9:0x4E6D,0xE79CBD:0x4E6E,0xE79CBE:0x4E6F,
	0xE79D82:0x4E70,0xE79D85:0x4E71,0xE79D86:0x4E72,0xE79D8A:0x4E73,0xE79D8D:0x4E74,
	0xE79D8E:0x4E75,0xE79D8F:0x4E76,0xE79D92:0x4E77,0xE79D96:0x4E78,0xE79D97:0x4E79,
	0xE79D9C:0x4E7A,0xE79D9E:0x4E7B,0xE79D9F:0x4E7C,0xE79DA0:0x4E7D,0xE79DA2:0x4E7E,
	0xE79DA4:0x4F21,0xE79DA7:0x4F22,0xE79DAA:0x4F23,0xE79DAC:0x4F24,0xE79DB0:0x4F25,
	0xE79DB2:0x4F26,0xE79DB3:0x4F27,0xE79DB4:0x4F28,0xE79DBA:0x4F29,0xE79DBD:0x4F2A,
	0xE79E80:0x4F2B,0xE79E84:0x4F2C,0xE79E8C:0x4F2D,0xE79E8D:0x4F2E,0xE79E94:0x4F2F,
	0xE79E95:0x4F30,0xE79E96:0x4F31,0xE79E9A:0x4F32,0xE79E9F:0x4F33,0xE79EA2:0x4F34,
	0xE79EA7:0x4F35,0xE79EAA:0x4F36,0xE79EAE:0x4F37,0xE79EAF:0x4F38,0xE79EB1:0x4F39,
	0xE79EB5:0x4F3A,0xE79EBE:0x4F3B,0xE79F83:0x4F3C,0xE79F89:0x4F3D,0xE79F91:0x4F3E,
	0xE79F92:0x4F3F,0xE79F95:0x4F40,0xE79F99:0x4F41,0xE79F9E:0x4F42,0xE79F9F:0x4F43,
	0xE79FA0:0x4F44,0xE79FA4:0x4F45,0xE79FA6:0x4F46,0xE79FAA:0x4F47,0xE79FAC:0x4F48,
	0xE79FB0:0x4F49,0xE79FB1:0x4F4A,0xE79FB4:0x4F4B,0xE79FB8:0x4F4C,0xE79FBB:0x4F4D,
	0xE7A085:0x4F4E,0xE7A086:0x4F4F,0xE7A089:0x4F50,0xE7A08D:0x4F51,0xE7A08E:0x4F52,
	0xE7A091:0x4F53,0xE7A09D:0x4F54,0xE7A0A1:0x4F55,0xE7A0A2:0x4F56,0xE7A0A3:0x4F57,
	0xE7A0AD:0x4F58,0xE7A0AE:0x4F59,0xE7A0B0:0x4F5A,0xE7A0B5:0x4F5B,0xE7A0B7:0x4F5C,
	0xE7A183:0x4F5D,0xE7A184:0x4F5E,0xE7A187:0x4F5F,0xE7A188:0x4F60,0xE7A18C:0x4F61,
	0xE7A18E:0x4F62,0xE7A192:0x4F63,0xE7A19C:0x4F64,0xE7A19E:0x4F65,0xE7A1A0:0x4F66,
	0xE7A1A1:0x4F67,0xE7A1A3:0x4F68,0xE7A1A4:0x4F69,0xE7A1A8:0x4F6A,0xE7A1AA:0x4F6B,
	0xE7A1AE:0x4F6C,0xE7A1BA:0x4F6D,0xE7A1BE:0x4F6E,0xE7A28A:0x4F6F,0xE7A28F:0x4F70,
	0xE7A294:0x4F71,0xE7A298:0x4F72,0xE7A2A1:0x4F73,0xE7A29D:0x4F74,0xE7A29E:0x4F75,
	0xE7A29F:0x4F76,0xE7A2A4:0x4F77,0xE7A2A8:0x4F78,0xE7A2AC:0x4F79,0xE7A2AD:0x4F7A,
	0xE7A2B0:0x4F7B,0xE7A2B1:0x4F7C,0xE7A2B2:0x4F7D,0xE7A2B3:0x4F7E,0xE7A2BB:0x5021,
	0xE7A2BD:0x5022,0xE7A2BF:0x5023,0xE7A387:0x5024,0xE7A388:0x5025,0xE7A389:0x5026,
	0xE7A38C:0x5027,0xE7A38E:0x5028,0xE7A392:0x5029,0xE7A393:0x502A,0xE7A395:0x502B,
	0xE7A396:0x502C,0xE7A3A4:0x502D,0xE7A39B:0x502E,0xE7A39F:0x502F,0xE7A3A0:0x5030,
	0xE7A3A1:0x5031,0xE7A3A6:0x5032,0xE7A3AA:0x5033,0xE7A3B2:0x5034,0xE7A3B3:0x5035,
	0xE7A480:0x5036,0xE7A3B6:0x5037,0xE7A3B7:0x5038,0xE7A3BA:0x5039,0xE7A3BB:0x503A,
	0xE7A3BF:0x503B,0xE7A486:0x503C,0xE7A48C:0x503D,0xE7A490:0x503E,0xE7A49A:0x503F,
	0xE7A49C:0x5040,0xE7A49E:0x5041,0xE7A49F:0x5042,0xE7A4A0:0x5043,0xE7A4A5:0x5044,
	0xE7A4A7:0x5045,0xE7A4A9:0x5046,0xE7A4AD:0x5047,0xE7A4B1:0x5048,0xE7A4B4:0x5049,
	0xE7A4B5:0x504A,0xE7A4BB:0x504B,0xE7A4BD:0x504C,0xE7A4BF:0x504D,0xE7A584:0x504E,
	0xE7A585:0x504F,0xE7A586:0x5050,0xE7A58A:0x5051,0xE7A58B:0x5052,0xE7A58F:0x5053,
	0xE7A591:0x5054,0xE7A594:0x5055,0xE7A598:0x5056,0xE7A59B:0x5057,0xE7A59C:0x5058,
	0xE7A5A7:0x5059,0xE7A5A9:0x505A,0xE7A5AB:0x505B,0xE7A5B2:0x505C,0xE7A5B9:0x505D,
	0xE7A5BB:0x505E,0xE7A5BC:0x505F,0xE7A5BE:0x5060,0xE7A68B:0x5061,0xE7A68C:0x5062,
	0xE7A691:0x5063,0xE7A693:0x5064,0xE7A694:0x5065,0xE7A695:0x5066,0xE7A696:0x5067,
	0xE7A698:0x5068,0xE7A69B:0x5069,0xE7A69C:0x506A,0xE7A6A1:0x506B,0xE7A6A8:0x506C,
	0xE7A6A9:0x506D,0xE7A6AB:0x506E,0xE7A6AF:0x506F,0xE7A6B1:0x5070,0xE7A6B4:0x5071,
	0xE7A6B8:0x5072,0xE7A6BB:0x5073,0xE7A782:0x5074,0xE7A784:0x5075,0xE7A787:0x5076,
	0xE7A788:0x5077,0xE7A78A:0x5078,0xE7A78F:0x5079,0xE7A794:0x507A,0xE7A796:0x507B,
	0xE7A79A:0x507C,0xE7A79D:0x507D,0xE7A79E:0x507E,0xE7A7A0:0x5121,0xE7A7A2:0x5122,
	0xE7A7A5:0x5123,0xE7A7AA:0x5124,0xE7A7AB:0x5125,0xE7A7AD:0x5126,0xE7A7B1:0x5127,
	0xE7A7B8:0x5128,0xE7A7BC:0x5129,0xE7A882:0x512A,0xE7A883:0x512B,0xE7A887:0x512C,
	0xE7A889:0x512D,0xE7A88A:0x512E,0xE7A88C:0x512F,0xE7A891:0x5130,0xE7A895:0x5131,
	0xE7A89B:0x5132,0xE7A89E:0x5133,0xE7A8A1:0x5134,0xE7A8A7:0x5135,0xE7A8AB:0x5136,
	0xE7A8AD:0x5137,0xE7A8AF:0x5138,0xE7A8B0:0x5139,0xE7A8B4:0x513A,0xE7A8B5:0x513B,
	0xE7A8B8:0x513C,0xE7A8B9:0x513D,0xE7A8BA:0x513E,0xE7A984:0x513F,0xE7A985:0x5140,
	0xE7A987:0x5141,0xE7A988:0x5142,0xE7A98C:0x5143,0xE7A995:0x5144,0xE7A996:0x5145,
	0xE7A999:0x5146,0xE7A99C:0x5147,0xE7A99D:0x5148,0xE7A99F:0x5149,0xE7A9A0:0x514A,
	0xE7A9A5:0x514B,0xE7A9A7:0x514C,0xE7A9AA:0x514D,0xE7A9AD:0x514E,0xE7A9B5:0x514F,
	0xE7A9B8:0x5150,0xE7A9BE:0x5151,0xE7AA80:0x5152,0xE7AA82:0x5153,0xE7AA85:0x5154,
	0xE7AA86:0x5155,0xE7AA8A:0x5156,0xE7AA8B:0x5157,0xE7AA90:0x5158,0xE7AA91:0x5159,
	0xE7AA94:0x515A,0xE7AA9E:0x515B,0xE7AAA0:0x515C,0xE7AAA3:0x515D,0xE7AAAC:0x515E,
	0xE7AAB3:0x515F,0xE7AAB5:0x5160,0xE7AAB9:0x5161,0xE7AABB:0x5162,0xE7AABC:0x5163,
	0xE7AB86:0x5164,0xE7AB89:0x5165,0xE7AB8C:0x5166,0xE7AB8E:0x5167,0xE7AB91:0x5168,
	0xE7AB9B:0x5169,0xE7ABA8:0x516A,0xE7ABA9:0x516B,0xE7ABAB:0x516C,0xE7ABAC:0x516D,
	0xE7ABB1:0x516E,0xE7ABB4:0x516F,0xE7ABBB:0x5170,0xE7ABBD:0x5171,0xE7ABBE:0x5172,
	0xE7AC87:0x5173,0xE7AC94:0x5174,0xE7AC9F:0x5175,0xE7ACA3:0x5176,0xE7ACA7:0x5177,
	0xE7ACA9:0x5178,0xE7ACAA:0x5179,0xE7ACAB:0x517A,0xE7ACAD:0x517B,0xE7ACAE:0x517C,
	0xE7ACAF:0x517D,0xE7ACB0:0x517E,0xE7ACB1:0x5221,0xE7ACB4:0x5222,0xE7ACBD:0x5223,
	0xE7ACBF:0x5224,0xE7AD80:0x5225,0xE7AD81:0x5226,0xE7AD87:0x5227,0xE7AD8E:0x5228,
	0xE7AD95:0x5229,0xE7ADA0:0x522A,0xE7ADA4:0x522B,0xE7ADA6:0x522C,0xE7ADA9:0x522D,
	0xE7ADAA:0x522E,0xE7ADAD:0x522F,0xE7ADAF:0x5230,0xE7ADB2:0x5231,0xE7ADB3:0x5232,
	0xE7ADB7:0x5233,0xE7AE84:0x5234,0xE7AE89:0x5235,0xE7AE8E:0x5236,0xE7AE90:0x5237,
	0xE7AE91:0x5238,0xE7AE96:0x5239,0xE7AE9B:0x523A,0xE7AE9E:0x523B,0xE7AEA0:0x523C,
	0xE7AEA5:0x523D,0xE7AEAC:0x523E,0xE7AEAF:0x523F,0xE7AEB0:0x5240,0xE7AEB2:0x5241,
	0xE7AEB5:0x5242,0xE7AEB6:0x5243,0xE7AEBA:0x5244,0xE7AEBB:0x5245,0xE7AEBC:0x5246,
	0xE7AEBD:0x5247,0xE7AF82:0x5248,0xE7AF85:0x5249,0xE7AF88:0x524A,0xE7AF8A:0x524B,
	0xE7AF94:0x524C,0xE7AF96:0x524D,0xE7AF97:0x524E,0xE7AF99:0x524F,0xE7AF9A:0x5250,
	0xE7AF9B:0x5251,0xE7AFA8:0x5252,0xE7AFAA:0x5253,0xE7AFB2:0x5254,0xE7AFB4:0x5255,
	0xE7AFB5:0x5256,0xE7AFB8:0x5257,0xE7AFB9:0x5258,0xE7AFBA:0x5259,0xE7AFBC:0x525A,
	0xE7AFBE:0x525B,0xE7B081:0x525C,0xE7B082:0x525D,0xE7B083:0x525E,0xE7B084:0x525F,
	0xE7B086:0x5260,0xE7B089:0x5261,0xE7B08B:0x5262,0xE7B08C:0x5263,0xE7B08E:0x5264,
	0xE7B08F:0x5265,0xE7B099:0x5266,0xE7B09B:0x5267,0xE7B0A0:0x5268,0xE7B0A5:0x5269,
	0xE7B0A6:0x526A,0xE7B0A8:0x526B,0xE7B0AC:0x526C,0xE7B0B1:0x526D,0xE7B0B3:0x526E,
	0xE7B0B4:0x526F,0xE7B0B6:0x5270,0xE7B0B9:0x5271,0xE7B0BA:0x5272,0xE7B186:0x5273,
	0xE7B18A:0x5274,0xE7B195:0x5275,0xE7B191:0x5276,0xE7B192:0x5277,0xE7B193:0x5278,
	0xE7B199:0x5279,0xE7B19A:0x527A,0xE7B19B:0x527B,0xE7B19C:0x527C,0xE7B19D:0x527D,
	0xE7B19E:0x527E,0xE7B1A1:0x5321,0xE7B1A3:0x5322,0xE7B1A7:0x5323,0xE7B1A9:0x5324,
	0xE7B1AD:0x5325,0xE7B1AE:0x5326,0xE7B1B0:0x5327,0xE7B1B2:0x5328,0xE7B1B9:0x5329,
	0xE7B1BC:0x532A,0xE7B1BD:0x532B,0xE7B286:0x532C,0xE7B287:0x532D,0xE7B28F:0x532E,
	0xE7B294:0x532F,0xE7B29E:0x5330,0xE7B2A0:0x5331,0xE7B2A6:0x5332,0xE7B2B0:0x5333,
	0xE7B2B6:0x5334,0xE7B2B7:0x5335,0xE7B2BA:0x5336,0xE7B2BB:0x5337,0xE7B2BC:0x5338,
	0xE7B2BF:0x5339,0xE7B384:0x533A,0xE7B387:0x533B,0xE7B388:0x533C,0xE7B389:0x533D,
	0xE7B38D:0x533E,0xE7B38F:0x533F,0xE7B393:0x5340,0xE7B394:0x5341,0xE7B395:0x5342,
	0xE7B397:0x5343,0xE7B399:0x5344,0xE7B39A:0x5345,0xE7B39D:0x5346,0xE7B3A6:0x5347,
	0xE7B3A9:0x5348,0xE7B3AB:0x5349,0xE7B3B5:0x534A,0xE7B483:0x534B,0xE7B487:0x534C,
	0xE7B488:0x534D,0xE7B489:0x534E,0xE7B48F:0x534F,0xE7B491:0x5350,0xE7B492:0x5351,
	0xE7B493:0x5352,0xE7B496:0x5353,0xE7B49D:0x5354,0xE7B49E:0x5355,0xE7B4A3:0x5356,
	0xE7B4A6:0x5357,0xE7B4AA:0x5358,0xE7B4AD:0x5359,0xE7B4B1:0x535A,0xE7B4BC:0x535B,
	0xE7B4BD:0x535C,0xE7B4BE:0x535D,0xE7B580:0x535E,0xE7B581:0x535F,0xE7B587:0x5360,
	0xE7B588:0x5361,0xE7B58D:0x5362,0xE7B591:0x5363,0xE7B593:0x5364,0xE7B597:0x5365,
	0xE7B599:0x5366,0xE7B59A:0x5367,0xE7B59C:0x5368,0xE7B59D:0x5369,0xE7B5A5:0x536A,
	0xE7B5A7:0x536B,0xE7B5AA:0x536C,0xE7B5B0:0x536D,0xE7B5B8:0x536E,0xE7B5BA:0x536F,
	0xE7B5BB:0x5370,0xE7B5BF:0x5371,0xE7B681:0x5372,0xE7B682:0x5373,0xE7B683:0x5374,
	0xE7B685:0x5375,0xE7B686:0x5376,0xE7B688:0x5377,0xE7B68B:0x5378,0xE7B68C:0x5379,
	0xE7B68D:0x537A,0xE7B691:0x537B,0xE7B696:0x537C,0xE7B697:0x537D,0xE7B69D:0x537E,
	0xE7B69E:0x5421,0xE7B6A6:0x5422,0xE7B6A7:0x5423,0xE7B6AA:0x5424,0xE7B6B3:0x5425,
	0xE7B6B6:0x5426,0xE7B6B7:0x5427,0xE7B6B9:0x5428,0xE7B782:0x5429,0xE7B783:0x542A,
	0xE7B784:0x542B,0xE7B785:0x542C,0xE7B786:0x542D,0xE7B78C:0x542E,0xE7B78D:0x542F,
	0xE7B78E:0x5430,0xE7B797:0x5431,0xE7B799:0x5432,0xE7B880:0x5433,0xE7B7A2:0x5434,
	0xE7B7A5:0x5435,0xE7B7A6:0x5436,0xE7B7AA:0x5437,0xE7B7AB:0x5438,0xE7B7AD:0x5439,
	0xE7B7B1:0x543A,0xE7B7B5:0x543B,0xE7B7B6:0x543C,0xE7B7B9:0x543D,0xE7B7BA:0x543E,
	0xE7B888:0x543F,0xE7B890:0x5440,0xE7B891:0x5441,0xE7B895:0x5442,0xE7B897:0x5443,
	0xE7B89C:0x5444,0xE7B89D:0x5445,0xE7B8A0:0x5446,0xE7B8A7:0x5447,0xE7B8A8:0x5448,
	0xE7B8AC:0x5449,0xE7B8AD:0x544A,0xE7B8AF:0x544B,0xE7B8B3:0x544C,0xE7B8B6:0x544D,
	0xE7B8BF:0x544E,0xE7B984:0x544F,0xE7B985:0x5450,0xE7B987:0x5451,0xE7B98E:0x5452,
	0xE7B990:0x5453,0xE7B992:0x5454,0xE7B998:0x5455,0xE7B99F:0x5456,0xE7B9A1:0x5457,
	0xE7B9A2:0x5458,0xE7B9A5:0x5459,0xE7B9AB:0x545A,0xE7B9AE:0x545B,0xE7B9AF:0x545C,
	0xE7B9B3:0x545D,0xE7B9B8:0x545E,0xE7B9BE:0x545F,0xE7BA81:0x5460,0xE7BA86:0x5461,
	0xE7BA87:0x5462,0xE7BA8A:0x5463,0xE7BA8D:0x5464,0xE7BA91:0x5465,0xE7BA95:0x5466,
	0xE7BA98:0x5467,0xE7BA9A:0x5468,0xE7BA9D:0x5469,0xE7BA9E:0x546A,0xE7BCBC:0x546B,
	0xE7BCBB:0x546C,0xE7BCBD:0x546D,0xE7BCBE:0x546E,0xE7BCBF:0x546F,0xE7BD83:0x5470,
	0xE7BD84:0x5471,0xE7BD87:0x5472,0xE7BD8F:0x5473,0xE7BD92:0x5474,0xE7BD93:0x5475,
	0xE7BD9B:0x5476,0xE7BD9C:0x5477,0xE7BD9D:0x5478,0xE7BDA1:0x5479,0xE7BDA3:0x547A,
	0xE7BDA4:0x547B,0xE7BDA5:0x547C,0xE7BDA6:0x547D,0xE7BDAD:0x547E,0xE7BDB1:0x5521,
	0xE7BDBD:0x5522,0xE7BDBE:0x5523,0xE7BDBF:0x5524,0xE7BE80:0x5525,0xE7BE8B:0x5526,
	0xE7BE8D:0x5527,0xE7BE8F:0x5528,0xE7BE90:0x5529,0xE7BE91:0x552A,0xE7BE96:0x552B,
	0xE7BE97:0x552C,0xE7BE9C:0x552D,0xE7BEA1:0x552E,0xE7BEA2:0x552F,0xE7BEA6:0x5530,
	0xE7BEAA:0x5531,0xE7BEAD:0x5532,0xE7BEB4:0x5533,0xE7BEBC:0x5534,0xE7BEBF:0x5535,
	0xE7BF80:0x5536,0xE7BF83:0x5537,0xE7BF88:0x5538,0xE7BF8E:0x5539,0xE7BF8F:0x553A,
	0xE7BF9B:0x553B,0xE7BF9F:0x553C,0xE7BFA3:0x553D,0xE7BFA5:0x553E,0xE7BFA8:0x553F,
	0xE7BFAC:0x5540,0xE7BFAE:0x5541,0xE7BFAF:0x5542,0xE7BFB2:0x5543,0xE7BFBA:0x5544,
	0xE7BFBD:0x5545,0xE7BFBE:0x5546,0xE7BFBF:0x5547,0xE88087:0x5548,0xE88088:0x5549,
	0xE8808A:0x554A,0xE8808D:0x554B,0xE8808E:0x554C,0xE8808F:0x554D,0xE88091:0x554E,
	0xE88093:0x554F,0xE88094:0x5550,0xE88096:0x5551,0xE8809D:0x5552,0xE8809E:0x5553,
	0xE8809F:0x5554,0xE880A0:0x5555,0xE880A4:0x5556,0xE880A6:0x5557,0xE880AC:0x5558,
	0xE880AE:0x5559,0xE880B0:0x555A,0xE880B4:0x555B,0xE880B5:0x555C,0xE880B7:0x555D,
	0xE880B9:0x555E,0xE880BA:0x555F,0xE880BC:0x5560,0xE880BE:0x5561,0xE88180:0x5562,
	0xE88184:0x5563,0xE881A0:0x5564,0xE881A4:0x5565,0xE881A6:0x5566,0xE881AD:0x5567,
	0xE881B1:0x5568,0xE881B5:0x5569,0xE88281:0x556A,0xE88288:0x556B,0xE8828E:0x556C,
	0xE8829C:0x556D,0xE8829E:0x556E,0xE882A6:0x556F,0xE882A7:0x5570,0xE882AB:0x5571,
	0xE882B8:0x5572,0xE882B9:0x5573,0xE88388:0x5574,0xE8838D:0x5575,0xE8838F:0x5576,
	0xE88392:0x5577,0xE88394:0x5578,0xE88395:0x5579,0xE88397:0x557A,0xE88398:0x557B,
	0xE883A0:0x557C,0xE883AD:0x557D,0xE883AE:0x557E,0xE883B0:0x5621,0xE883B2:0x5622,
	0xE883B3:0x5623,0xE883B6:0x5624,0xE883B9:0x5625,0xE883BA:0x5626,0xE883BE:0x5627,
	0xE88483:0x5628,0xE8848B:0x5629,0xE88496:0x562A,0xE88497:0x562B,0xE88498:0x562C,
	0xE8849C:0x562D,0xE8849E:0x562E,0xE884A0:0x562F,0xE884A4:0x5630,0xE884A7:0x5631,
	0xE884AC:0x5632,0xE884B0:0x5633,0xE884B5:0x5634,0xE884BA:0x5635,0xE884BC:0x5636,
	0xE88585:0x5637,0xE88587:0x5638,0xE8858A:0x5639,0xE8858C:0x563A,0xE88592:0x563B,
	0xE88597:0x563C,0xE885A0:0x563D,0xE885A1:0x563E,0xE885A7:0x563F,0xE885A8:0x5640,
	0xE885A9:0x5641,0xE885AD:0x5642,0xE885AF:0x5643,0xE885B7:0x5644,0xE88681:0x5645,
	0xE88690:0x5646,0xE88684:0x5647,0xE88685:0x5648,0xE88686:0x5649,0xE8868B:0x564A,
	0xE8868E:0x564B,0xE88696:0x564C,0xE88698:0x564D,0xE8869B:0x564E,0xE8869E:0x564F,
	0xE886A2:0x5650,0xE886AE:0x5651,0xE886B2:0x5652,0xE886B4:0x5653,0xE886BB:0x5654,
	0xE8878B:0x5655,0xE88783:0x5656,0xE88785:0x5657,0xE8878A:0x5658,0xE8878E:0x5659,
	0xE8878F:0x565A,0xE88795:0x565B,0xE88797:0x565C,0xE8879B:0x565D,0xE8879D:0x565E,
	0xE8879E:0x565F,0xE887A1:0x5660,0xE887A4:0x5661,0xE887AB:0x5662,0xE887AC:0x5663,
	0xE887B0:0x5664,0xE887B1:0x5665,0xE887B2:0x5666,0xE887B5:0x5667,0xE887B6:0x5668,
	0xE887B8:0x5669,0xE887B9:0x566A,0xE887BD:0x566B,0xE887BF:0x566C,0xE88880:0x566D,
	0xE88883:0x566E,0xE8888F:0x566F,0xE88893:0x5670,0xE88894:0x5671,0xE88899:0x5672,
	0xE8889A:0x5673,0xE8889D:0x5674,0xE888A1:0x5675,0xE888A2:0x5676,0xE888A8:0x5677,
	0xE888B2:0x5678,0xE888B4:0x5679,0xE888BA:0x567A,0xE88983:0x567B,0xE88984:0x567C,
	0xE88985:0x567D,0xE88986:0x567E,0xE8898B:0x5721,0xE8898E:0x5722,0xE8898F:0x5723,
	0xE88991:0x5724,0xE88996:0x5725,0xE8899C:0x5726,0xE889A0:0x5727,0xE889A3:0x5728,
	0xE889A7:0x5729,0xE889AD:0x572A,0xE889B4:0x572B,0xE889BB:0x572C,0xE889BD:0x572D,
	0xE889BF:0x572E,0xE88A80:0x572F,0xE88A81:0x5730,0xE88A83:0x5731,0xE88A84:0x5732,
	0xE88A87:0x5733,0xE88A89:0x5734,0xE88A8A:0x5735,0xE88A8E:0x5736,0xE88A91:0x5737,
	0xE88A94:0x5738,0xE88A96:0x5739,0xE88A98:0x573A,0xE88A9A:0x573B,0xE88A9B:0x573C,
	0xE88AA0:0x573D,0xE88AA1:0x573E,0xE88AA3:0x573F,0xE88AA4:0x5740,0xE88AA7:0x5741,
	0xE88AA8:0x5742,0xE88AA9:0x5743,0xE88AAA:0x5744,0xE88AAE:0x5745,0xE88AB0:0x5746,
	0xE88AB2:0x5747,0xE88AB4:0x5748,0xE88AB7:0x5749,0xE88ABA:0x574A,0xE88ABC:0x574B,
	0xE88ABE:0x574C,0xE88ABF:0x574D,0xE88B86:0x574E,0xE88B90:0x574F,0xE88B95:0x5750,
	0xE88B9A:0x5751,0xE88BA0:0x5752,0xE88BA2:0x5753,0xE88BA4:0x5754,0xE88BA8:0x5755,
	0xE88BAA:0x5756,0xE88BAD:0x5757,0xE88BAF:0x5758,0xE88BB6:0x5759,0xE88BB7:0x575A,
	0xE88BBD:0x575B,0xE88BBE:0x575C,0xE88C80:0x575D,0xE88C81:0x575E,0xE88C87:0x575F,
	0xE88C88:0x5760,0xE88C8A:0x5761,0xE88C8B:0x5762,0xE88D94:0x5763,0xE88C9B:0x5764,
	0xE88C9D:0x5765,0xE88C9E:0x5766,0xE88C9F:0x5767,0xE88CA1:0x5768,0xE88CA2:0x5769,
	0xE88CAC:0x576A,0xE88CAD:0x576B,0xE88CAE:0x576C,0xE88CB0:0x576D,0xE88CB3:0x576E,
	0xE88CB7:0x576F,0xE88CBA:0x5770,0xE88CBC:0x5771,0xE88CBD:0x5772,0xE88D82:0x5773,
	0xE88D83:0x5774,0xE88D84:0x5775,0xE88D87:0x5776,0xE88D8D:0x5777,0xE88D8E:0x5778,
	0xE88D91:0x5779,0xE88D95:0x577A,0xE88D96:0x577B,0xE88D97:0x577C,0xE88DB0:0x577D,
	0xE88DB8:0x577E,0xE88DBD:0x5821,0xE88DBF:0x5822,0xE88E80:0x5823,0xE88E82:0x5824,
	0xE88E84:0x5825,0xE88E86:0x5826,0xE88E8D:0x5827,0xE88E92:0x5828,0xE88E94:0x5829,
	0xE88E95:0x582A,0xE88E98:0x582B,0xE88E99:0x582C,0xE88E9B:0x582D,0xE88E9C:0x582E,
	0xE88E9D:0x582F,0xE88EA6:0x5830,0xE88EA7:0x5831,0xE88EA9:0x5832,0xE88EAC:0x5833,
	0xE88EBE:0x5834,0xE88EBF:0x5835,0xE88F80:0x5836,0xE88F87:0x5837,0xE88F89:0x5838,
	0xE88F8F:0x5839,0xE88F90:0x583A,0xE88F91:0x583B,0xE88F94:0x583C,0xE88F9D:0x583D,
	0xE88D93:0x583E,0xE88FA8:0x583F,0xE88FAA:0x5840,0xE88FB6:0x5841,0xE88FB8:0x5842,
	0xE88FB9:0x5843,0xE88FBC:0x5844,0xE89081:0x5845,0xE89086:0x5846,0xE8908A:0x5847,
	0xE8908F:0x5848,0xE89091:0x5849,0xE89095:0x584A,0xE89099:0x584B,0xE88EAD:0x584C,
	0xE890AF:0x584D,0xE890B9:0x584E,0xE89185:0x584F,0xE89187:0x5850,0xE89188:0x5851,
	0xE8918A:0x5852,0xE8918D:0x5853,0xE8918F:0x5854,0xE89191:0x5855,0xE89192:0x5856,
	0xE89196:0x5857,0xE89198:0x5858,0xE89199:0x5859,0xE8919A:0x585A,0xE8919C:0x585B,
	0xE891A0:0x585C,0xE891A4:0x585D,0xE891A5:0x585E,0xE891A7:0x585F,0xE891AA:0x5860,
	0xE891B0:0x5861,0xE891B3:0x5862,0xE891B4:0x5863,0xE891B6:0x5864,0xE891B8:0x5865,
	0xE891BC:0x5866,0xE891BD:0x5867,0xE89281:0x5868,0xE89285:0x5869,0xE89292:0x586A,
	0xE89293:0x586B,0xE89295:0x586C,0xE8929E:0x586D,0xE892A6:0x586E,0xE892A8:0x586F,
	0xE892A9:0x5870,0xE892AA:0x5871,0xE892AF:0x5872,0xE892B1:0x5873,0xE892B4:0x5874,
	0xE892BA:0x5875,0xE892BD:0x5876,0xE892BE:0x5877,0xE89380:0x5878,0xE89382:0x5879,
	0xE89387:0x587A,0xE89388:0x587B,0xE8938C:0x587C,0xE8938F:0x587D,0xE89393:0x587E,
	0xE8939C:0x5921,0xE893A7:0x5922,0xE893AA:0x5923,0xE893AF:0x5924,0xE893B0:0x5925,
	0xE893B1:0x5926,0xE893B2:0x5927,0xE893B7:0x5928,0xE894B2:0x5929,0xE893BA:0x592A,
	0xE893BB:0x592B,0xE893BD:0x592C,0xE89482:0x592D,0xE89483:0x592E,0xE89487:0x592F,
	0xE8948C:0x5930,0xE8948E:0x5931,0xE89490:0x5932,0xE8949C:0x5933,0xE8949E:0x5934,
	0xE894A2:0x5935,0xE894A3:0x5936,0xE894A4:0x5937,0xE894A5:0x5938,0xE894A7:0x5939,
	0xE894AA:0x593A,0xE894AB:0x593B,0xE894AF:0x593C,0xE894B3:0x593D,0xE894B4:0x593E,
	0xE894B6:0x593F,0xE894BF:0x5940,0xE89586:0x5941,0xE8958F:0x5942,0xE89590:0x5943,
	0xE89591:0x5944,0xE89592:0x5945,0xE89593:0x5946,0xE89596:0x5947,0xE89599:0x5948,
	0xE8959C:0x5949,0xE8959D:0x594A,0xE8959E:0x594B,0xE8959F:0x594C,0xE895A0:0x594D,
	0xE895A1:0x594E,0xE895A2:0x594F,0xE895A4:0x5950,0xE895AB:0x5951,0xE895AF:0x5952,
	0xE895B9:0x5953,0xE895BA:0x5954,0xE895BB:0x5955,0xE895BD:0x5956,0xE895BF:0x5957,
	0xE89681:0x5958,0xE89685:0x5959,0xE89686:0x595A,0xE89689:0x595B,0xE8968B:0x595C,
	0xE8968C:0x595D,0xE8968F:0x595E,0xE89693:0x595F,0xE89698:0x5960,0xE8969D:0x5961,
	0xE8969F:0x5962,0xE896A0:0x5963,0xE896A2:0x5964,0xE896A5:0x5965,0xE896A7:0x5966,
	0xE896B4:0x5967,0xE896B6:0x5968,0xE896B7:0x5969,0xE896B8:0x596A,0xE896BC:0x596B,
	0xE896BD:0x596C,0xE896BE:0x596D,0xE896BF:0x596E,0xE89782:0x596F,0xE89787:0x5970,
	0xE8978A:0x5971,0xE8978B:0x5972,0xE8978E:0x5973,0xE896AD:0x5974,0xE89798:0x5975,
	0xE8979A:0x5976,0xE8979F:0x5977,0xE897A0:0x5978,0xE897A6:0x5979,0xE897A8:0x597A,
	0xE897AD:0x597B,0xE897B3:0x597C,0xE897B6:0x597D,0xE897BC:0x597E,0xE897BF:0x5A21,
	0xE89880:0x5A22,0xE89884:0x5A23,0xE89885:0x5A24,0xE8988D:0x5A25,0xE8988E:0x5A26,
	0xE89890:0x5A27,0xE89891:0x5A28,0xE89892:0x5A29,0xE89898:0x5A2A,0xE89899:0x5A2B,
	0xE8989B:0x5A2C,0xE8989E:0x5A2D,0xE898A1:0x5A2E,0xE898A7:0x5A2F,0xE898A9:0x5A30,
	0xE898B6:0x5A31,0xE898B8:0x5A32,0xE898BA:0x5A33,0xE898BC:0x5A34,0xE898BD:0x5A35,
	0xE89980:0x5A36,0xE89982:0x5A37,0xE89986:0x5A38,0xE89992:0x5A39,0xE89993:0x5A3A,
	0xE89996:0x5A3B,0xE89997:0x5A3C,0xE89998:0x5A3D,0xE89999:0x5A3E,0xE8999D:0x5A3F,
	0xE899A0:0x5A40,0xE899A1:0x5A41,0xE899A2:0x5A42,0xE899A3:0x5A43,0xE899A4:0x5A44,
	0xE899A9:0x5A45,0xE899AC:0x5A46,0xE899AF:0x5A47,0xE899B5:0x5A48,0xE899B6:0x5A49,
	0xE899B7:0x5A4A,0xE899BA:0x5A4B,0xE89A8D:0x5A4C,0xE89A91:0x5A4D,0xE89A96:0x5A4E,
	0xE89A98:0x5A4F,0xE89A9A:0x5A50,0xE89A9C:0x5A51,0xE89AA1:0x5A52,0xE89AA6:0x5A53,
	0xE89AA7:0x5A54,0xE89AA8:0x5A55,0xE89AAD:0x5A56,0xE89AB1:0x5A57,0xE89AB3:0x5A58,
	0xE89AB4:0x5A59,0xE89AB5:0x5A5A,0xE89AB7:0x5A5B,0xE89AB8:0x5A5C,0xE89AB9:0x5A5D,
	0xE89ABF:0x5A5E,0xE89B80:0x5A5F,0xE89B81:0x5A60,0xE89B83:0x5A61,0xE89B85:0x5A62,
	0xE89B91:0x5A63,0xE89B92:0x5A64,0xE89B95:0x5A65,0xE89B97:0x5A66,0xE89B9A:0x5A67,
	0xE89B9C:0x5A68,0xE89BA0:0x5A69,0xE89BA3:0x5A6A,0xE89BA5:0x5A6B,0xE89BA7:0x5A6C,
	0xE89A88:0x5A6D,0xE89BBA:0x5A6E,0xE89BBC:0x5A6F,0xE89BBD:0x5A70,0xE89C84:0x5A71,
	0xE89C85:0x5A72,0xE89C87:0x5A73,0xE89C8B:0x5A74,0xE89C8E:0x5A75,0xE89C8F:0x5A76,
	0xE89C90:0x5A77,0xE89C93:0x5A78,0xE89C94:0x5A79,0xE89C99:0x5A7A,0xE89C9E:0x5A7B,
	0xE89C9F:0x5A7C,0xE89CA1:0x5A7D,0xE89CA3:0x5A7E,0xE89CA8:0x5B21,0xE89CAE:0x5B22,
	0xE89CAF:0x5B23,0xE89CB1:0x5B24,0xE89CB2:0x5B25,0xE89CB9:0x5B26,0xE89CBA:0x5B27,
	0xE89CBC:0x5B28,0xE89CBD:0x5B29,0xE89CBE:0x5B2A,0xE89D80:0x5B2B,0xE89D83:0x5B2C,
	0xE89D85:0x5B2D,0xE89D8D:0x5B2E,0xE89D98:0x5B2F,0xE89D9D:0x5B30,0xE89DA1:0x5B31,
	0xE89DA4:0x5B32,0xE89DA5:0x5B33,0xE89DAF:0x5B34,0xE89DB1:0x5B35,0xE89DB2:0x5B36,
	0xE89DBB:0x5B37,0xE89E83:0x5B38,0xE89E84:0x5B39,0xE89E85:0x5B3A,0xE89E86:0x5B3B,
	0xE89E87:0x5B3C,0xE89E88:0x5B3D,0xE89E89:0x5B3E,0xE89E8B:0x5B3F,0xE89E8C:0x5B40,
	0xE89E90:0x5B41,0xE89E93:0x5B42,0xE89E95:0x5B43,0xE89E97:0x5B44,0xE89E98:0x5B45,
	0xE89E99:0x5B46,0xE89E9E:0x5B47,0xE89EA0:0x5B48,0xE89EA3:0x5B49,0xE89EA7:0x5B4A,
	0xE89EAC:0x5B4B,0xE89EAD:0x5B4C,0xE89EAE:0x5B4D,0xE89EB1:0x5B4E,0xE89EB5:0x5B4F,
	0xE89EBE:0x5B50,0xE89EBF:0x5B51,0xE89F81:0x5B52,0xE89F88:0x5B53,0xE89F89:0x5B54,
	0xE89F8A:0x5B55,0xE89F8E:0x5B56,0xE89F95:0x5B57,0xE89F96:0x5B58,0xE89F99:0x5B59,
	0xE89F9A:0x5B5A,0xE89F9C:0x5B5B,0xE89F9F:0x5B5C,0xE89FA2:0x5B5D,0xE89FA3:0x5B5E,
	0xE89FA4:0x5B5F,0xE89FAA:0x5B60,0xE89FAB:0x5B61,0xE89FAD:0x5B62,0xE89FB1:0x5B63,
	0xE89FB3:0x5B64,0xE89FB8:0x5B65,0xE89FBA:0x5B66,0xE89FBF:0x5B67,0xE8A081:0x5B68,
	0xE8A083:0x5B69,0xE8A086:0x5B6A,0xE8A089:0x5B6B,0xE8A08A:0x5B6C,0xE8A08B:0x5B6D,
	0xE8A090:0x5B6E,0xE8A099:0x5B6F,0xE8A092:0x5B70,0xE8A093:0x5B71,0xE8A094:0x5B72,
	0xE8A098:0x5B73,0xE8A09A:0x5B74,0xE8A09B:0x5B75,0xE8A09C:0x5B76,0xE8A09E:0x5B77,
	0xE8A09F:0x5B78,0xE8A0A8:0x5B79,0xE8A0AD:0x5B7A,0xE8A0AE:0x5B7B,0xE8A0B0:0x5B7C,
	0xE8A0B2:0x5B7D,0xE8A0B5:0x5B7E,0xE8A0BA:0x5C21,0xE8A0BC:0x5C22,0xE8A181:0x5C23,
	0xE8A183:0x5C24,0xE8A185:0x5C25,0xE8A188:0x5C26,0xE8A189:0x5C27,0xE8A18A:0x5C28,
	0xE8A18B:0x5C29,0xE8A18E:0x5C2A,0xE8A191:0x5C2B,0xE8A195:0x5C2C,0xE8A196:0x5C2D,
	0xE8A198:0x5C2E,0xE8A19A:0x5C2F,0xE8A19C:0x5C30,0xE8A19F:0x5C31,0xE8A1A0:0x5C32,
	0xE8A1A4:0x5C33,0xE8A1A9:0x5C34,0xE8A1B1:0x5C35,0xE8A1B9:0x5C36,0xE8A1BB:0x5C37,
	0xE8A280:0x5C38,0xE8A298:0x5C39,0xE8A29A:0x5C3A,0xE8A29B:0x5C3B,0xE8A29C:0x5C3C,
	0xE8A29F:0x5C3D,0xE8A2A0:0x5C3E,0xE8A2A8:0x5C3F,0xE8A2AA:0x5C40,0xE8A2BA:0x5C41,
	0xE8A2BD:0x5C42,0xE8A2BE:0x5C43,0xE8A380:0x5C44,0xE8A38A:0x5C45,0xE8A38B:0x5C46,
	0xE8A38C:0x5C47,0xE8A38D:0x5C48,0xE8A38E:0x5C49,0xE8A391:0x5C4A,0xE8A392:0x5C4B,
	0xE8A393:0x5C4C,0xE8A39B:0x5C4D,0xE8A39E:0x5C4E,0xE8A3A7:0x5C4F,0xE8A3AF:0x5C50,
	0xE8A3B0:0x5C51,0xE8A3B1:0x5C52,0xE8A3B5:0x5C53,0xE8A3B7:0x5C54,0xE8A481:0x5C55,
	0xE8A486:0x5C56,0xE8A48D:0x5C57,0xE8A48E:0x5C58,0xE8A48F:0x5C59,0xE8A495:0x5C5A,
	0xE8A496:0x5C5B,0xE8A498:0x5C5C,0xE8A499:0x5C5D,0xE8A49A:0x5C5E,0xE8A49C:0x5C5F,
	0xE8A4A0:0x5C60,0xE8A4A6:0x5C61,0xE8A4A7:0x5C62,0xE8A4A8:0x5C63,0xE8A4B0:0x5C64,
	0xE8A4B1:0x5C65,0xE8A4B2:0x5C66,0xE8A4B5:0x5C67,0xE8A4B9:0x5C68,0xE8A4BA:0x5C69,
	0xE8A4BE:0x5C6A,0xE8A580:0x5C6B,0xE8A582:0x5C6C,0xE8A585:0x5C6D,0xE8A586:0x5C6E,
	0xE8A589:0x5C6F,0xE8A58F:0x5C70,0xE8A592:0x5C71,0xE8A597:0x5C72,0xE8A59A:0x5C73,
	0xE8A59B:0x5C74,0xE8A59C:0x5C75,0xE8A5A1:0x5C76,0xE8A5A2:0x5C77,0xE8A5A3:0x5C78,
	0xE8A5AB:0x5C79,0xE8A5AE:0x5C7A,0xE8A5B0:0x5C7B,0xE8A5B3:0x5C7C,0xE8A5B5:0x5C7D,
	0xE8A5BA:0x5C7E,0xE8A5BB:0x5D21,0xE8A5BC:0x5D22,0xE8A5BD:0x5D23,0xE8A689:0x5D24,
	0xE8A68D:0x5D25,0xE8A690:0x5D26,0xE8A694:0x5D27,0xE8A695:0x5D28,0xE8A69B:0x5D29,
	0xE8A69C:0x5D2A,0xE8A69F:0x5D2B,0xE8A6A0:0x5D2C,0xE8A6A5:0x5D2D,0xE8A6B0:0x5D2E,
	0xE8A6B4:0x5D2F,0xE8A6B5:0x5D30,0xE8A6B6:0x5D31,0xE8A6B7:0x5D32,0xE8A6BC:0x5D33,
	0xE8A794:0x5D34,0xE8A795:0x5D35,0xE8A796:0x5D36,0xE8A797:0x5D37,0xE8A798:0x5D38,
	0xE8A7A5:0x5D39,0xE8A7A9:0x5D3A,0xE8A7AB:0x5D3B,0xE8A7AD:0x5D3C,0xE8A7B1:0x5D3D,
	0xE8A7B3:0x5D3E,0xE8A7B6:0x5D3F,0xE8A7B9:0x5D40,0xE8A7BD:0x5D41,0xE8A7BF:0x5D42,
	0xE8A884:0x5D43,0xE8A885:0x5D44,0xE8A887:0x5D45,0xE8A88F:0x5D46,0xE8A891:0x5D47,
	0xE8A892:0x5D48,0xE8A894:0x5D49,0xE8A895:0x5D4A,0xE8A89E:0x5D4B,0xE8A8A0:0x5D4C,
	0xE8A8A2:0x5D4D,0xE8A8A4:0x5D4E,0xE8A8A6:0x5D4F,0xE8A8AB:0x5D50,0xE8A8AC:0x5D51,
	0xE8A8AF:0x5D52,0xE8A8B5:0x5D53,0xE8A8B7:0x5D54,0xE8A8BD:0x5D55,0xE8A8BE:0x5D56,
	0xE8A980:0x5D57,0xE8A983:0x5D58,0xE8A985:0x5D59,0xE8A987:0x5D5A,0xE8A989:0x5D5B,
	0xE8A98D:0x5D5C,0xE8A98E:0x5D5D,0xE8A993:0x5D5E,0xE8A996:0x5D5F,0xE8A997:0x5D60,
	0xE8A998:0x5D61,0xE8A99C:0x5D62,0xE8A99D:0x5D63,0xE8A9A1:0x5D64,0xE8A9A5:0x5D65,
	0xE8A9A7:0x5D66,0xE8A9B5:0x5D67,0xE8A9B6:0x5D68,0xE8A9B7:0x5D69,0xE8A9B9:0x5D6A,
	0xE8A9BA:0x5D6B,0xE8A9BB:0x5D6C,0xE8A9BE:0x5D6D,0xE8A9BF:0x5D6E,0xE8AA80:0x5D6F,
	0xE8AA83:0x5D70,0xE8AA86:0x5D71,0xE8AA8B:0x5D72,0xE8AA8F:0x5D73,0xE8AA90:0x5D74,
	0xE8AA92:0x5D75,0xE8AA96:0x5D76,0xE8AA97:0x5D77,0xE8AA99:0x5D78,0xE8AA9F:0x5D79,
	0xE8AAA7:0x5D7A,0xE8AAA9:0x5D7B,0xE8AAAE:0x5D7C,0xE8AAAF:0x5D7D,0xE8AAB3:0x5D7E,
	0xE8AAB6:0x5E21,0xE8AAB7:0x5E22,0xE8AABB:0x5E23,0xE8AABE:0x5E24,0xE8AB83:0x5E25,
	0xE8AB86:0x5E26,0xE8AB88:0x5E27,0xE8AB89:0x5E28,0xE8AB8A:0x5E29,0xE8AB91:0x5E2A,
	0xE8AB93:0x5E2B,0xE8AB94:0x5E2C,0xE8AB95:0x5E2D,0xE8AB97:0x5E2E,0xE8AB9D:0x5E2F,
	0xE8AB9F:0x5E30,0xE8ABAC:0x5E31,0xE8ABB0:0x5E32,0xE8ABB4:0x5E33,0xE8ABB5:0x5E34,
	0xE8ABB6:0x5E35,0xE8ABBC:0x5E36,0xE8ABBF:0x5E37,0xE8AC85:0x5E38,0xE8AC86:0x5E39,
	0xE8AC8B:0x5E3A,0xE8AC91:0x5E3B,0xE8AC9C:0x5E3C,0xE8AC9E:0x5E3D,0xE8AC9F:0x5E3E,
	0xE8AC8A:0x5E3F,0xE8ACAD:0x5E40,0xE8ACB0:0x5E41,0xE8ACB7:0x5E42,0xE8ACBC:0x5E43,
	0xE8AD82:0x5E44,0xE8AD83:0x5E45,0xE8AD84:0x5E46,0xE8AD85:0x5E47,0xE8AD86:0x5E48,
	0xE8AD88:0x5E49,0xE8AD92:0x5E4A,0xE8AD93:0x5E4B,0xE8AD94:0x5E4C,0xE8AD99:0x5E4D,
	0xE8AD8D:0x5E4E,0xE8AD9E:0x5E4F,0xE8ADA3:0x5E50,0xE8ADAD:0x5E51,0xE8ADB6:0x5E52,
	0xE8ADB8:0x5E53,0xE8ADB9:0x5E54,0xE8ADBC:0x5E55,0xE8ADBE:0x5E56,0xE8AE81:0x5E57,
	0xE8AE84:0x5E58,0xE8AE85:0x5E59,0xE8AE8B:0x5E5A,0xE8AE8D:0x5E5B,0xE8AE8F:0x5E5C,
	0xE8AE94:0x5E5D,0xE8AE95:0x5E5E,0xE8AE9C:0x5E5F,0xE8AE9E:0x5E60,0xE8AE9F:0x5E61,
	0xE8B0B8:0x5E62,0xE8B0B9:0x5E63,0xE8B0BD:0x5E64,0xE8B0BE:0x5E65,0xE8B185:0x5E66,
	0xE8B187:0x5E67,0xE8B189:0x5E68,0xE8B18B:0x5E69,0xE8B18F:0x5E6A,0xE8B191:0x5E6B,
	0xE8B193:0x5E6C,0xE8B194:0x5E6D,0xE8B197:0x5E6E,0xE8B198:0x5E6F,0xE8B19B:0x5E70,
	0xE8B19D:0x5E71,0xE8B199:0x5E72,0xE8B1A3:0x5E73,0xE8B1A4:0x5E74,0xE8B1A6:0x5E75,
	0xE8B1A8:0x5E76,0xE8B1A9:0x5E77,0xE8B1AD:0x5E78,0xE8B1B3:0x5E79,0xE8B1B5:0x5E7A,
	0xE8B1B6:0x5E7B,0xE8B1BB:0x5E7C,0xE8B1BE:0x5E7D,0xE8B286:0x5E7E,0xE8B287:0x5F21,
	0xE8B28B:0x5F22,0xE8B290:0x5F23,0xE8B292:0x5F24,0xE8B293:0x5F25,0xE8B299:0x5F26,
	0xE8B29B:0x5F27,0xE8B29C:0x5F28,0xE8B2A4:0x5F29,0xE8B2B9:0x5F2A,0xE8B2BA:0x5F2B,
	0xE8B385:0x5F2C,0xE8B386:0x5F2D,0xE8B389:0x5F2E,0xE8B38B:0x5F2F,0xE8B38F:0x5F30,
	0xE8B396:0x5F31,0xE8B395:0x5F32,0xE8B399:0x5F33,0xE8B39D:0x5F34,0xE8B3A1:0x5F35,
	0xE8B3A8:0x5F36,0xE8B3AC:0x5F37,0xE8B3AF:0x5F38,0xE8B3B0:0x5F39,0xE8B3B2:0x5F3A,
	0xE8B3B5:0x5F3B,0xE8B3B7:0x5F3C,0xE8B3B8:0x5F3D,0xE8B3BE:0x5F3E,0xE8B3BF:0x5F3F,
	0xE8B481:0x5F40,0xE8B483:0x5F41,0xE8B489:0x5F42,0xE8B492:0x5F43,0xE8B497:0x5F44,
	0xE8B49B:0x5F45,0xE8B5A5:0x5F46,0xE8B5A9:0x5F47,0xE8B5AC:0x5F48,0xE8B5AE:0x5F49,
	0xE8B5BF:0x5F4A,0xE8B682:0x5F4B,0xE8B684:0x5F4C,0xE8B688:0x5F4D,0xE8B68D:0x5F4E,
	0xE8B690:0x5F4F,0xE8B691:0x5F50,0xE8B695:0x5F51,0xE8B69E:0x5F52,0xE8B69F:0x5F53,
	0xE8B6A0:0x5F54,0xE8B6A6:0x5F55,0xE8B6AB:0x5F56,0xE8B6AC:0x5F57,0xE8B6AF:0x5F58,
	0xE8B6B2:0x5F59,0xE8B6B5:0x5F5A,0xE8B6B7:0x5F5B,0xE8B6B9:0x5F5C,0xE8B6BB:0x5F5D,
	0xE8B780:0x5F5E,0xE8B785:0x5F5F,0xE8B786:0x5F60,0xE8B787:0x5F61,0xE8B788:0x5F62,
	0xE8B78A:0x5F63,0xE8B78E:0x5F64,0xE8B791:0x5F65,0xE8B794:0x5F66,0xE8B795:0x5F67,
	0xE8B797:0x5F68,0xE8B799:0x5F69,0xE8B7A4:0x5F6A,0xE8B7A5:0x5F6B,0xE8B7A7:0x5F6C,
	0xE8B7AC:0x5F6D,0xE8B7B0:0x5F6E,0xE8B6BC:0x5F6F,0xE8B7B1:0x5F70,0xE8B7B2:0x5F71,
	0xE8B7B4:0x5F72,0xE8B7BD:0x5F73,0xE8B881:0x5F74,0xE8B884:0x5F75,0xE8B885:0x5F76,
	0xE8B886:0x5F77,0xE8B88B:0x5F78,0xE8B891:0x5F79,0xE8B894:0x5F7A,0xE8B896:0x5F7B,
	0xE8B8A0:0x5F7C,0xE8B8A1:0x5F7D,0xE8B8A2:0x5F7E,0xE8B8A3:0x6021,0xE8B8A6:0x6022,
	0xE8B8A7:0x6023,0xE8B8B1:0x6024,0xE8B8B3:0x6025,0xE8B8B6:0x6026,0xE8B8B7:0x6027,
	0xE8B8B8:0x6028,0xE8B8B9:0x6029,0xE8B8BD:0x602A,0xE8B980:0x602B,0xE8B981:0x602C,
	0xE8B98B:0x602D,0xE8B98D:0x602E,0xE8B98E:0x602F,0xE8B98F:0x6030,0xE8B994:0x6031,
	0xE8B99B:0x6032,0xE8B99C:0x6033,0xE8B99D:0x6034,0xE8B99E:0x6035,0xE8B9A1:0x6036,
	0xE8B9A2:0x6037,0xE8B9A9:0x6038,0xE8B9AC:0x6039,0xE8B9AD:0x603A,0xE8B9AF:0x603B,
	0xE8B9B0:0x603C,0xE8B9B1:0x603D,0xE8B9B9:0x603E,0xE8B9BA:0x603F,0xE8B9BB:0x6040,
	0xE8BA82:0x6041,0xE8BA83:0x6042,0xE8BA89:0x6043,0xE8BA90:0x6044,0xE8BA92:0x6045,
	0xE8BA95:0x6046,0xE8BA9A:0x6047,0xE8BA9B:0x6048,0xE8BA9D:0x6049,0xE8BA9E:0x604A,
	0xE8BAA2:0x604B,0xE8BAA7:0x604C,0xE8BAA9:0x604D,0xE8BAAD:0x604E,0xE8BAAE:0x604F,
	0xE8BAB3:0x6050,0xE8BAB5:0x6051,0xE8BABA:0x6052,0xE8BABB:0x6053,0xE8BB80:0x6054,
	0xE8BB81:0x6055,0xE8BB83:0x6056,0xE8BB84:0x6057,0xE8BB87:0x6058,0xE8BB8F:0x6059,
	0xE8BB91:0x605A,0xE8BB94:0x605B,0xE8BB9C:0x605C,0xE8BBA8:0x605D,0xE8BBAE:0x605E,
	0xE8BBB0:0x605F,0xE8BBB1:0x6060,0xE8BBB7:0x6061,0xE8BBB9:0x6062,0xE8BBBA:0x6063,
	0xE8BBAD:0x6064,0xE8BC80:0x6065,0xE8BC82:0x6066,0xE8BC87:0x6067,0xE8BC88:0x6068,
	0xE8BC8F:0x6069,0xE8BC90:0x606A,0xE8BC96:0x606B,0xE8BC97:0x606C,0xE8BC98:0x606D,
	0xE8BC9E:0x606E,0xE8BCA0:0x606F,0xE8BCA1:0x6070,0xE8BCA3:0x6071,0xE8BCA5:0x6072,
	0xE8BCA7:0x6073,0xE8BCA8:0x6074,0xE8BCAC:0x6075,0xE8BCAD:0x6076,0xE8BCAE:0x6077,
	0xE8BCB4:0x6078,0xE8BCB5:0x6079,0xE8BCB6:0x607A,0xE8BCB7:0x607B,0xE8BCBA:0x607C,
	0xE8BD80:0x607D,0xE8BD81:0x607E,0xE8BD83:0x6121,0xE8BD87:0x6122,0xE8BD8F:0x6123,
	0xE8BD91:0x6124,0xE8BD92:0x6125,0xE8BD93:0x6126,0xE8BD94:0x6127,0xE8BD95:0x6128,
	0xE8BD98:0x6129,0xE8BD9D:0x612A,0xE8BD9E:0x612B,0xE8BDA5:0x612C,0xE8BE9D:0x612D,
	0xE8BEA0:0x612E,0xE8BEA1:0x612F,0xE8BEA4:0x6130,0xE8BEA5:0x6131,0xE8BEA6:0x6132,
	0xE8BEB5:0x6133,0xE8BEB6:0x6134,0xE8BEB8:0x6135,0xE8BEBE:0x6136,0xE8BF80:0x6137,
	0xE8BF81:0x6138,0xE8BF86:0x6139,0xE8BF8A:0x613A,0xE8BF8B:0x613B,0xE8BF8D:0x613C,
	0xE8BF90:0x613D,0xE8BF92:0x613E,0xE8BF93:0x613F,0xE8BF95:0x6140,0xE8BFA0:0x6141,
	0xE8BFA3:0x6142,0xE8BFA4:0x6143,0xE8BFA8:0x6144,0xE8BFAE:0x6145,0xE8BFB1:0x6146,
	0xE8BFB5:0x6147,0xE8BFB6:0x6148,0xE8BFBB:0x6149,0xE8BFBE:0x614A,0xE98082:0x614B,
	0xE98084:0x614C,0xE98088:0x614D,0xE9808C:0x614E,0xE98098:0x614F,0xE9809B:0x6150,
	0xE980A8:0x6151,0xE980A9:0x6152,0xE980AF:0x6153,0xE980AA:0x6154,0xE980AC:0x6155,
	0xE980AD:0x6156,0xE980B3:0x6157,0xE980B4:0x6158,0xE980B7:0x6159,0xE980BF:0x615A,
	0xE98183:0x615B,0xE98184:0x615C,0xE9818C:0x615D,0xE9819B:0x615E,0xE9819D:0x615F,
	0xE981A2:0x6160,0xE981A6:0x6161,0xE981A7:0x6162,0xE981AC:0x6163,0xE981B0:0x6164,
	0xE981B4:0x6165,0xE981B9:0x6166,0xE98285:0x6167,0xE98288:0x6168,0xE9828B:0x6169,
	0xE9828C:0x616A,0xE9828E:0x616B,0xE98290:0x616C,0xE98295:0x616D,0xE98297:0x616E,
	0xE98298:0x616F,0xE98299:0x6170,0xE9829B:0x6171,0xE982A0:0x6172,0xE982A1:0x6173,
	0xE982A2:0x6174,0xE982A5:0x6175,0xE982B0:0x6176,0xE982B2:0x6177,0xE982B3:0x6178,
	0xE982B4:0x6179,0xE982B6:0x617A,0xE982BD:0x617B,0xE9838C:0x617C,0xE982BE:0x617D,
	0xE98383:0x617E,0xE98384:0x6221,0xE98385:0x6222,0xE98387:0x6223,0xE98388:0x6224,
	0xE98395:0x6225,0xE98397:0x6226,0xE98398:0x6227,0xE98399:0x6228,0xE9839C:0x6229,
	0xE9839D:0x622A,0xE9839F:0x622B,0xE983A5:0x622C,0xE98392:0x622D,0xE983B6:0x622E,
	0xE983AB:0x622F,0xE983AF:0x6230,0xE983B0:0x6231,0xE983B4:0x6232,0xE983BE:0x6233,
	0xE983BF:0x6234,0xE98480:0x6235,0xE98484:0x6236,0xE98485:0x6237,0xE98486:0x6238,
	0xE98488:0x6239,0xE9848D:0x623A,0xE98490:0x623B,0xE98494:0x623C,0xE98496:0x623D,
	0xE98497:0x623E,0xE98498:0x623F,0xE9849A:0x6240,0xE9849C:0x6241,0xE9849E:0x6242,
	0xE984A0:0x6243,0xE984A5:0x6244,0xE984A2:0x6245,0xE984A3:0x6246,0xE984A7:0x6247,
	0xE984A9:0x6248,0xE984AE:0x6249,0xE984AF:0x624A,0xE984B1:0x624B,0xE984B4:0x624C,
	0xE984B6:0x624D,0xE984B7:0x624E,0xE984B9:0x624F,0xE984BA:0x6250,0xE984BC:0x6251,
	0xE984BD:0x6252,0xE98583:0x6253,0xE98587:0x6254,0xE98588:0x6255,0xE9858F:0x6256,
	0xE98593:0x6257,0xE98597:0x6258,0xE98599:0x6259,0xE9859A:0x625A,0xE9859B:0x625B,
	0xE985A1:0x625C,0xE985A4:0x625D,0xE985A7:0x625E,0xE985AD:0x625F,0xE985B4:0x6260,
	0xE985B9:0x6261,0xE985BA:0x6262,0xE985BB:0x6263,0xE98681:0x6264,0xE98683:0x6265,
	0xE98685:0x6266,0xE98686:0x6267,0xE9868A:0x6268,0xE9868E:0x6269,0xE98691:0x626A,
	0xE98693:0x626B,0xE98694:0x626C,0xE98695:0x626D,0xE98698:0x626E,0xE9869E:0x626F,
	0xE986A1:0x6270,0xE986A6:0x6271,0xE986A8:0x6272,0xE986AC:0x6273,0xE986AD:0x6274,
	0xE986AE:0x6275,0xE986B0:0x6276,0xE986B1:0x6277,0xE986B2:0x6278,0xE986B3:0x6279,
	0xE986B6:0x627A,0xE986BB:0x627B,0xE986BC:0x627C,0xE986BD:0x627D,0xE986BF:0x627E,
	0xE98782:0x6321,0xE98783:0x6322,0xE98785:0x6323,0xE98793:0x6324,0xE98794:0x6325,
	0xE98797:0x6326,0xE98799:0x6327,0xE9879A:0x6328,0xE9879E:0x6329,0xE987A4:0x632A,
	0xE987A5:0x632B,0xE987A9:0x632C,0xE987AA:0x632D,0xE987AC:0x632E,0xE987AD:0x632F,
	0xE987AE:0x6330,0xE987AF:0x6331,0xE987B0:0x6332,0xE987B1:0x6333,0xE987B7:0x6334,
	0xE987B9:0x6335,0xE987BB:0x6336,0xE987BD:0x6337,0xE98880:0x6338,0xE98881:0x6339,
	0xE98884:0x633A,0xE98885:0x633B,0xE98886:0x633C,0xE98887:0x633D,0xE98889:0x633E,
	0xE9888A:0x633F,0xE9888C:0x6340,0xE98890:0x6341,0xE98892:0x6342,0xE98893:0x6343,
	0xE98896:0x6344,0xE98898:0x6345,0xE9889C:0x6346,0xE9889D:0x6347,0xE988A3:0x6348,
	0xE988A4:0x6349,0xE988A5:0x634A,0xE988A6:0x634B,0xE988A8:0x634C,0xE988AE:0x634D,
	0xE988AF:0x634E,0xE988B0:0x634F,0xE988B3:0x6350,0xE988B5:0x6351,0xE988B6:0x6352,
	0xE988B8:0x6353,0xE988B9:0x6354,0xE988BA:0x6355,0xE988BC:0x6356,0xE988BE:0x6357,
	0xE98980:0x6358,0xE98982:0x6359,0xE98983:0x635A,0xE98986:0x635B,0xE98987:0x635C,
	0xE9898A:0x635D,0xE9898D:0x635E,0xE9898E:0x635F,0xE9898F:0x6360,0xE98991:0x6361,
	0xE98998:0x6362,0xE98999:0x6363,0xE9899C:0x6364,0xE9899D:0x6365,0xE989A0:0x6366,
	0xE989A1:0x6367,0xE989A5:0x6368,0xE989A7:0x6369,0xE989A8:0x636A,0xE989A9:0x636B,
	0xE989AE:0x636C,0xE989AF:0x636D,0xE989B0:0x636E,0xE989B5:0x636F,0xE989B6:0x6370,
	0xE989B7:0x6371,0xE989B8:0x6372,0xE989B9:0x6373,0xE989BB:0x6374,0xE989BC:0x6375,
	0xE989BD:0x6376,0xE989BF:0x6377,0xE98A88:0x6378,0xE98A89:0x6379,0xE98A8A:0x637A,
	0xE98A8D:0x637B,0xE98A8E:0x637C,0xE98A92:0x637D,0xE98A97:0x637E,0xE98A99:0x6421,
	0xE98A9F:0x6422,0xE98AA0:0x6423,0xE98AA4:0x6424,0xE98AA5:0x6425,0xE98AA7:0x6426,
	0xE98AA8:0x6427,0xE98AAB:0x6428,0xE98AAF:0x6429,0xE98AB2:0x642A,0xE98AB6:0x642B,
	0xE98AB8:0x642C,0xE98ABA:0x642D,0xE98ABB:0x642E,0xE98ABC:0x642F,0xE98ABD:0x6430,
	0xE98ABF:0x6431,0xE98B80:0x6432,0xE98B81:0x6433,0xE98B82:0x6434,0xE98B83:0x6435,
	0xE98B85:0x6436,0xE98B86:0x6437,0xE98B87:0x6438,0xE98B88:0x6439,0xE98B8B:0x643A,
	0xE98B8C:0x643B,0xE98B8D:0x643C,0xE98B8E:0x643D,0xE98B90:0x643E,0xE98B93:0x643F,
	0xE98B95:0x6440,0xE98B97:0x6441,0xE98B98:0x6442,0xE98B99:0x6443,0xE98B9C:0x6444,
	0xE98B9D:0x6445,0xE98B9F:0x6446,0xE98BA0:0x6447,0xE98BA1:0x6448,0xE98BA3:0x6449,
	0xE98BA5:0x644A,0xE98BA7:0x644B,0xE98BA8:0x644C,0xE98BAC:0x644D,0xE98BAE:0x644E,
	0xE98BB0:0x644F,0xE98BB9:0x6450,0xE98BBB:0x6451,0xE98BBF:0x6452,0xE98C80:0x6453,
	0xE98C82:0x6454,0xE98C88:0x6455,0xE98C8D:0x6456,0xE98C91:0x6457,0xE98C94:0x6458,
	0xE98C95:0x6459,0xE98C9C:0x645A,0xE98C9D:0x645B,0xE98C9E:0x645C,0xE98C9F:0x645D,
	0xE98CA1:0x645E,0xE98CA4:0x645F,0xE98CA5:0x6460,0xE98CA7:0x6461,0xE98CA9:0x6462,
	0xE98CAA:0x6463,0xE98CB3:0x6464,0xE98CB4:0x6465,0xE98CB6:0x6466,0xE98CB7:0x6467,
	0xE98D87:0x6468,0xE98D88:0x6469,0xE98D89:0x646A,0xE98D90:0x646B,0xE98D91:0x646C,
	0xE98D92:0x646D,0xE98D95:0x646E,0xE98D97:0x646F,0xE98D98:0x6470,0xE98D9A:0x6471,
	0xE98D9E:0x6472,0xE98DA4:0x6473,0xE98DA5:0x6474,0xE98DA7:0x6475,0xE98DA9:0x6476,
	0xE98DAA:0x6477,0xE98DAD:0x6478,0xE98DAF:0x6479,0xE98DB0:0x647A,0xE98DB1:0x647B,
	0xE98DB3:0x647C,0xE98DB4:0x647D,0xE98DB6:0x647E,0xE98DBA:0x6521,0xE98DBD:0x6522,
	0xE98DBF:0x6523,0xE98E80:0x6524,0xE98E81:0x6525,0xE98E82:0x6526,0xE98E88:0x6527,
	0xE98E8A:0x6528,0xE98E8B:0x6529,0xE98E8D:0x652A,0xE98E8F:0x652B,0xE98E92:0x652C,
	0xE98E95:0x652D,0xE98E98:0x652E,0xE98E9B:0x652F,0xE98E9E:0x6530,0xE98EA1:0x6531,
	0xE98EA3:0x6532,0xE98EA4:0x6533,0xE98EA6:0x6534,0xE98EA8:0x6535,0xE98EAB:0x6536,
	0xE98EB4:0x6537,0xE98EB5:0x6538,0xE98EB6:0x6539,0xE98EBA:0x653A,0xE98EA9:0x653B,
	0xE98F81:0x653C,0xE98F84:0x653D,0xE98F85:0x653E,0xE98F86:0x653F,0xE98F87:0x6540,
	0xE98F89:0x6541,0xE98F8A:0x6542,0xE98F8B:0x6543,0xE98F8C:0x6544,0xE98F8D:0x6545,
	0xE98F93:0x6546,0xE98F99:0x6547,0xE98F9C:0x6548,0xE98F9E:0x6549,0xE98F9F:0x654A,
	0xE98FA2:0x654B,0xE98FA6:0x654C,0xE98FA7:0x654D,0xE98FB9:0x654E,0xE98FB7:0x654F,
	0xE98FB8:0x6550,0xE98FBA:0x6551,0xE98FBB:0x6552,0xE98FBD:0x6553,0xE99081:0x6554,
	0xE99082:0x6555,0xE99084:0x6556,0xE99088:0x6557,0xE99089:0x6558,0xE9908D:0x6559,
	0xE9908E:0x655A,0xE9908F:0x655B,0xE99095:0x655C,0xE99096:0x655D,0xE99097:0x655E,
	0xE9909F:0x655F,0xE990AE:0x6560,0xE990AF:0x6561,0xE990B1:0x6562,0xE990B2:0x6563,
	0xE990B3:0x6564,0xE990B4:0x6565,0xE990BB:0x6566,0xE990BF:0x6567,0xE990BD:0x6568,
	0xE99183:0x6569,0xE99185:0x656A,0xE99188:0x656B,0xE9918A:0x656C,0xE9918C:0x656D,
	0xE99195:0x656E,0xE99199:0x656F,0xE9919C:0x6570,0xE9919F:0x6571,0xE991A1:0x6572,
	0xE991A3:0x6573,0xE991A8:0x6574,0xE991AB:0x6575,0xE991AD:0x6576,0xE991AE:0x6577,
	0xE991AF:0x6578,0xE991B1:0x6579,0xE991B2:0x657A,0xE99284:0x657B,0xE99283:0x657C,
	0xE995B8:0x657D,0xE995B9:0x657E,0xE995BE:0x6621,0xE99684:0x6622,0xE99688:0x6623,
	0xE9968C:0x6624,0xE9968D:0x6625,0xE9968E:0x6626,0xE9969D:0x6627,0xE9969E:0x6628,
	0xE9969F:0x6629,0xE996A1:0x662A,0xE996A6:0x662B,0xE996A9:0x662C,0xE996AB:0x662D,
	0xE996AC:0x662E,0xE996B4:0x662F,0xE996B6:0x6630,0xE996BA:0x6631,0xE996BD:0x6632,
	0xE996BF:0x6633,0xE99786:0x6634,0xE99788:0x6635,0xE99789:0x6636,0xE9978B:0x6637,
	0xE99790:0x6638,0xE99791:0x6639,0xE99792:0x663A,0xE99793:0x663B,0xE99799:0x663C,
	0xE9979A:0x663D,0xE9979D:0x663E,0xE9979E:0x663F,0xE9979F:0x6640,0xE997A0:0x6641,
	0xE997A4:0x6642,0xE997A6:0x6643,0xE9989D:0x6644,0xE9989E:0x6645,0xE998A2:0x6646,
	0xE998A4:0x6647,0xE998A5:0x6648,0xE998A6:0x6649,0xE998AC:0x664A,0xE998B1:0x664B,
	0xE998B3:0x664C,0xE998B7:0x664D,0xE998B8:0x664E,0xE998B9:0x664F,0xE998BA:0x6650,
	0xE998BC:0x6651,0xE998BD:0x6652,0xE99981:0x6653,0xE99992:0x6654,0xE99994:0x6655,
	0xE99996:0x6656,0xE99997:0x6657,0xE99998:0x6658,0xE999A1:0x6659,0xE999AE:0x665A,
	0xE999B4:0x665B,0xE999BB:0x665C,0xE999BC:0x665D,0xE999BE:0x665E,0xE999BF:0x665F,
	0xE99A81:0x6660,0xE99A82:0x6661,0xE99A83:0x6662,0xE99A84:0x6663,0xE99A89:0x6664,
	0xE99A91:0x6665,0xE99A96:0x6666,0xE99A9A:0x6667,0xE99A9D:0x6668,0xE99A9F:0x6669,
	0xE99AA4:0x666A,0xE99AA5:0x666B,0xE99AA6:0x666C,0xE99AA9:0x666D,0xE99AAE:0x666E,
	0xE99AAF:0x666F,0xE99AB3:0x6670,0xE99ABA:0x6671,0xE99B8A:0x6672,0xE99B92:0x6673,
	0xE5B6B2:0x6674,0xE99B98:0x6675,0xE99B9A:0x6676,0xE99B9D:0x6677,0xE99B9E:0x6678,
	0xE99B9F:0x6679,0xE99BA9:0x667A,0xE99BAF:0x667B,0xE99BB1:0x667C,0xE99BBA:0x667D,
	0xE99C82:0x667E,0xE99C83:0x6721,0xE99C85:0x6722,0xE99C89:0x6723,0xE99C9A:0x6724,
	0xE99C9B:0x6725,0xE99C9D:0x6726,0xE99CA1:0x6727,0xE99CA2:0x6728,0xE99CA3:0x6729,
	0xE99CA8:0x672A,0xE99CB1:0x672B,0xE99CB3:0x672C,0xE99D81:0x672D,0xE99D83:0x672E,
	0xE99D8A:0x672F,0xE99D8E:0x6730,0xE99D8F:0x6731,0xE99D95:0x6732,0xE99D97:0x6733,
	0xE99D98:0x6734,0xE99D9A:0x6735,0xE99D9B:0x6736,0xE99DA3:0x6737,0xE99DA7:0x6738,
	0xE99DAA:0x6739,0xE99DAE:0x673A,0xE99DB3:0x673B,0xE99DB6:0x673C,0xE99DB7:0x673D,
	0xE99DB8:0x673E,0xE99DBB:0x673F,0xE99DBD:0x6740,0xE99DBF:0x6741,0xE99E80:0x6742,
	0xE99E89:0x6743,0xE99E95:0x6744,0xE99E96:0x6745,0xE99E97:0x6746,0xE99E99:0x6747,
	0xE99E9A:0x6748,0xE99E9E:0x6749,0xE99E9F:0x674A,0xE99EA2:0x674B,0xE99EAC:0x674C,
	0xE99EAE:0x674D,0xE99EB1:0x674E,0xE99EB2:0x674F,0xE99EB5:0x6750,0xE99EB6:0x6751,
	0xE99EB8:0x6752,0xE99EB9:0x6753,0xE99EBA:0x6754,0xE99EBC:0x6755,0xE99EBE:0x6756,
	0xE99EBF:0x6757,0xE99F81:0x6758,0xE99F84:0x6759,0xE99F85:0x675A,0xE99F87:0x675B,
	0xE99F89:0x675C,0xE99F8A:0x675D,0xE99F8C:0x675E,0xE99F8D:0x675F,0xE99F8E:0x6760,
	0xE99F90:0x6761,0xE99F91:0x6762,0xE99F94:0x6763,0xE99F97:0x6764,0xE99F98:0x6765,
	0xE99F99:0x6766,0xE99F9D:0x6767,0xE99F9E:0x6768,0xE99FA0:0x6769,0xE99F9B:0x676A,
	0xE99FA1:0x676B,0xE99FA4:0x676C,0xE99FAF:0x676D,0xE99FB1:0x676E,0xE99FB4:0x676F,
	0xE99FB7:0x6770,0xE99FB8:0x6771,0xE99FBA:0x6772,0xE9A087:0x6773,0xE9A08A:0x6774,
	0xE9A099:0x6775,0xE9A08D:0x6776,0xE9A08E:0x6777,0xE9A094:0x6778,0xE9A096:0x6779,
	0xE9A09C:0x677A,0xE9A09E:0x677B,0xE9A0A0:0x677C,0xE9A0A3:0x677D,0xE9A0A6:0x677E,
	0xE9A0AB:0x6821,0xE9A0AE:0x6822,0xE9A0AF:0x6823,0xE9A0B0:0x6824,0xE9A0B2:0x6825,
	0xE9A0B3:0x6826,0xE9A0B5:0x6827,0xE9A0A5:0x6828,0xE9A0BE:0x6829,0xE9A184:0x682A,
	0xE9A187:0x682B,0xE9A18A:0x682C,0xE9A191:0x682D,0xE9A192:0x682E,0xE9A193:0x682F,
	0xE9A196:0x6830,0xE9A197:0x6831,0xE9A199:0x6832,0xE9A19A:0x6833,0xE9A1A2:0x6834,
	0xE9A1A3:0x6835,0xE9A1A5:0x6836,0xE9A1A6:0x6837,0xE9A1AA:0x6838,0xE9A1AC:0x6839,
	0xE9A2AB:0x683A,0xE9A2AD:0x683B,0xE9A2AE:0x683C,0xE9A2B0:0x683D,0xE9A2B4:0x683E,
	0xE9A2B7:0x683F,0xE9A2B8:0x6840,0xE9A2BA:0x6841,0xE9A2BB:0x6842,0xE9A2BF:0x6843,
	0xE9A382:0x6844,0xE9A385:0x6845,0xE9A388:0x6846,0xE9A38C:0x6847,0xE9A3A1:0x6848,
	0xE9A3A3:0x6849,0xE9A3A5:0x684A,0xE9A3A6:0x684B,0xE9A3A7:0x684C,0xE9A3AA:0x684D,
	0xE9A3B3:0x684E,0xE9A3B6:0x684F,0xE9A482:0x6850,0xE9A487:0x6851,0xE9A488:0x6852,
	0xE9A491:0x6853,0xE9A495:0x6854,0xE9A496:0x6855,0xE9A497:0x6856,0xE9A49A:0x6857,
	0xE9A49B:0x6858,0xE9A49C:0x6859,0xE9A49F:0x685A,0xE9A4A2:0x685B,0xE9A4A6:0x685C,
	0xE9A4A7:0x685D,0xE9A4AB:0x685E,0xE9A4B1:0x685F,0xE9A4B2:0x6860,0xE9A4B3:0x6861,
	0xE9A4B4:0x6862,0xE9A4B5:0x6863,0xE9A4B9:0x6864,0xE9A4BA:0x6865,0xE9A4BB:0x6866,
	0xE9A4BC:0x6867,0xE9A580:0x6868,0xE9A581:0x6869,0xE9A586:0x686A,0xE9A587:0x686B,
	0xE9A588:0x686C,0xE9A58D:0x686D,0xE9A58E:0x686E,0xE9A594:0x686F,0xE9A598:0x6870,
	0xE9A599:0x6871,0xE9A59B:0x6872,0xE9A59C:0x6873,0xE9A59E:0x6874,0xE9A59F:0x6875,
	0xE9A5A0:0x6876,0xE9A69B:0x6877,0xE9A69D:0x6878,0xE9A69F:0x6879,0xE9A6A6:0x687A,
	0xE9A6B0:0x687B,0xE9A6B1:0x687C,0xE9A6B2:0x687D,0xE9A6B5:0x687E,0xE9A6B9:0x6921,
	0xE9A6BA:0x6922,0xE9A6BD:0x6923,0xE9A6BF:0x6924,0xE9A783:0x6925,0xE9A789:0x6926,
	0xE9A793:0x6927,0xE9A794:0x6928,0xE9A799:0x6929,0xE9A79A:0x692A,0xE9A79C:0x692B,
	0xE9A79E:0x692C,0xE9A7A7:0x692D,0xE9A7AA:0x692E,0xE9A7AB:0x692F,0xE9A7AC:0x6930,
	0xE9A7B0:0x6931,0xE9A7B4:0x6932,0xE9A7B5:0x6933,0xE9A7B9:0x6934,0xE9A7BD:0x6935,
	0xE9A7BE:0x6936,0xE9A882:0x6937,0xE9A883:0x6938,0xE9A884:0x6939,0xE9A88B:0x693A,
	0xE9A88C:0x693B,0xE9A890:0x693C,0xE9A891:0x693D,0xE9A896:0x693E,0xE9A89E:0x693F,
	0xE9A8A0:0x6940,0xE9A8A2:0x6941,0xE9A8A3:0x6942,0xE9A8A4:0x6943,0xE9A8A7:0x6944,
	0xE9A8AD:0x6945,0xE9A8AE:0x6946,0xE9A8B3:0x6947,0xE9A8B5:0x6948,0xE9A8B6:0x6949,
	0xE9A8B8:0x694A,0xE9A987:0x694B,0xE9A981:0x694C,0xE9A984:0x694D,0xE9A98A:0x694E,
	0xE9A98B:0x694F,0xE9A98C:0x6950,0xE9A98E:0x6951,0xE9A991:0x6952,0xE9A994:0x6953,
	0xE9A996:0x6954,0xE9A99D:0x6955,0xE9AAAA:0x6956,0xE9AAAC:0x6957,0xE9AAAE:0x6958,
	0xE9AAAF:0x6959,0xE9AAB2:0x695A,0xE9AAB4:0x695B,0xE9AAB5:0x695C,0xE9AAB6:0x695D,
	0xE9AAB9:0x695E,0xE9AABB:0x695F,0xE9AABE:0x6960,0xE9AABF:0x6961,0xE9AB81:0x6962,
	0xE9AB83:0x6963,0xE9AB86:0x6964,0xE9AB88:0x6965,0xE9AB8E:0x6966,0xE9AB90:0x6967,
	0xE9AB92:0x6968,0xE9AB95:0x6969,0xE9AB96:0x696A,0xE9AB97:0x696B,0xE9AB9B:0x696C,
	0xE9AB9C:0x696D,0xE9ABA0:0x696E,0xE9ABA4:0x696F,0xE9ABA5:0x6970,0xE9ABA7:0x6971,
	0xE9ABA9:0x6972,0xE9ABAC:0x6973,0xE9ABB2:0x6974,0xE9ABB3:0x6975,0xE9ABB5:0x6976,
	0xE9ABB9:0x6977,0xE9ABBA:0x6978,0xE9ABBD:0x6979,0xE9ABBF:0x697A,0xE9AC80:0x697B,
	0xE9AC81:0x697C,0xE9AC82:0x697D,0xE9AC83:0x697E,0xE9AC84:0x6A21,0xE9AC85:0x6A22,
	0xE9AC88:0x6A23,0xE9AC89:0x6A24,0xE9AC8B:0x6A25,0xE9AC8C:0x6A26,0xE9AC8D:0x6A27,
	0xE9AC8E:0x6A28,0xE9AC90:0x6A29,0xE9AC92:0x6A2A,0xE9AC96:0x6A2B,0xE9AC99:0x6A2C,
	0xE9AC9B:0x6A2D,0xE9AC9C:0x6A2E,0xE9ACA0:0x6A2F,0xE9ACA6:0x6A30,0xE9ACAB:0x6A31,
	0xE9ACAD:0x6A32,0xE9ACB3:0x6A33,0xE9ACB4:0x6A34,0xE9ACB5:0x6A35,0xE9ACB7:0x6A36,
	0xE9ACB9:0x6A37,0xE9ACBA:0x6A38,0xE9ACBD:0x6A39,0xE9AD88:0x6A3A,0xE9AD8B:0x6A3B,
	0xE9AD8C:0x6A3C,0xE9AD95:0x6A3D,0xE9AD96:0x6A3E,0xE9AD97:0x6A3F,0xE9AD9B:0x6A40,
	0xE9AD9E:0x6A41,0xE9ADA1:0x6A42,0xE9ADA3:0x6A43,0xE9ADA5:0x6A44,0xE9ADA6:0x6A45,
	0xE9ADA8:0x6A46,0xE9ADAA:0x6A47,0xE9ADAB:0x6A48,0xE9ADAC:0x6A49,0xE9ADAD:0x6A4A,
	0xE9ADAE:0x6A4B,0xE9ADB3:0x6A4C,0xE9ADB5:0x6A4D,0xE9ADB7:0x6A4E,0xE9ADB8:0x6A4F,
	0xE9ADB9:0x6A50,0xE9ADBF:0x6A51,0xE9AE80:0x6A52,0xE9AE84:0x6A53,0xE9AE85:0x6A54,
	0xE9AE86:0x6A55,0xE9AE87:0x6A56,0xE9AE89:0x6A57,0xE9AE8A:0x6A58,0xE9AE8B:0x6A59,
	0xE9AE8D:0x6A5A,0xE9AE8F:0x6A5B,0xE9AE90:0x6A5C,0xE9AE94:0x6A5D,0xE9AE9A:0x6A5E,
	0xE9AE9D:0x6A5F,0xE9AE9E:0x6A60,0xE9AEA6:0x6A61,0xE9AEA7:0x6A62,0xE9AEA9:0x6A63,
	0xE9AEAC:0x6A64,0xE9AEB0:0x6A65,0xE9AEB1:0x6A66,0xE9AEB2:0x6A67,0xE9AEB7:0x6A68,
	0xE9AEB8:0x6A69,0xE9AEBB:0x6A6A,0xE9AEBC:0x6A6B,0xE9AEBE:0x6A6C,0xE9AEBF:0x6A6D,
	0xE9AF81:0x6A6E,0xE9AF87:0x6A6F,0xE9AF88:0x6A70,0xE9AF8E:0x6A71,0xE9AF90:0x6A72,
	0xE9AF97:0x6A73,0xE9AF98:0x6A74,0xE9AF9D:0x6A75,0xE9AF9F:0x6A76,0xE9AFA5:0x6A77,
	0xE9AFA7:0x6A78,0xE9AFAA:0x6A79,0xE9AFAB:0x6A7A,0xE9AFAF:0x6A7B,0xE9AFB3:0x6A7C,
	0xE9AFB7:0x6A7D,0xE9AFB8:0x6A7E,0xE9AFB9:0x6B21,0xE9AFBA:0x6B22,0xE9AFBD:0x6B23,
	0xE9AFBF:0x6B24,0xE9B080:0x6B25,0xE9B082:0x6B26,0xE9B08B:0x6B27,0xE9B08F:0x6B28,
	0xE9B091:0x6B29,0xE9B096:0x6B2A,0xE9B098:0x6B2B,0xE9B099:0x6B2C,0xE9B09A:0x6B2D,
	0xE9B09C:0x6B2E,0xE9B09E:0x6B2F,0xE9B0A2:0x6B30,0xE9B0A3:0x6B31,0xE9B0A6:0x6B32,
	0xE9B0A7:0x6B33,0xE9B0A8:0x6B34,0xE9B0A9:0x6B35,0xE9B0AA:0x6B36,0xE9B0B1:0x6B37,
	0xE9B0B5:0x6B38,0xE9B0B6:0x6B39,0xE9B0B7:0x6B3A,0xE9B0BD:0x6B3B,0xE9B181:0x6B3C,
	0xE9B183:0x6B3D,0xE9B184:0x6B3E,0xE9B185:0x6B3F,0xE9B189:0x6B40,0xE9B18A:0x6B41,
	0xE9B18E:0x6B42,0xE9B18F:0x6B43,0xE9B190:0x6B44,0xE9B193:0x6B45,0xE9B194:0x6B46,
	0xE9B196:0x6B47,0xE9B198:0x6B48,0xE9B19B:0x6B49,0xE9B19D:0x6B4A,0xE9B19E:0x6B4B,
	0xE9B19F:0x6B4C,0xE9B1A3:0x6B4D,0xE9B1A9:0x6B4E,0xE9B1AA:0x6B4F,0xE9B19C:0x6B50,
	0xE9B1AB:0x6B51,0xE9B1A8:0x6B52,0xE9B1AE:0x6B53,0xE9B1B0:0x6B54,0xE9B1B2:0x6B55,
	0xE9B1B5:0x6B56,0xE9B1B7:0x6B57,0xE9B1BB:0x6B58,0xE9B3A6:0x6B59,0xE9B3B2:0x6B5A,
	0xE9B3B7:0x6B5B,0xE9B3B9:0x6B5C,0xE9B48B:0x6B5D,0xE9B482:0x6B5E,0xE9B491:0x6B5F,
	0xE9B497:0x6B60,0xE9B498:0x6B61,0xE9B49C:0x6B62,0xE9B49D:0x6B63,0xE9B49E:0x6B64,
	0xE9B4AF:0x6B65,0xE9B4B0:0x6B66,0xE9B4B2:0x6B67,0xE9B4B3:0x6B68,0xE9B4B4:0x6B69,
	0xE9B4BA:0x6B6A,0xE9B4BC:0x6B6B,0xE9B585:0x6B6C,0xE9B4BD:0x6B6D,0xE9B582:0x6B6E,
	0xE9B583:0x6B6F,0xE9B587:0x6B70,0xE9B58A:0x6B71,0xE9B593:0x6B72,0xE9B594:0x6B73,
	0xE9B59F:0x6B74,0xE9B5A3:0x6B75,0xE9B5A2:0x6B76,0xE9B5A5:0x6B77,0xE9B5A9:0x6B78,
	0xE9B5AA:0x6B79,0xE9B5AB:0x6B7A,0xE9B5B0:0x6B7B,0xE9B5B6:0x6B7C,0xE9B5B7:0x6B7D,
	0xE9B5BB:0x6B7E,0xE9B5BC:0x6C21,0xE9B5BE:0x6C22,0xE9B683:0x6C23,0xE9B684:0x6C24,
	0xE9B686:0x6C25,0xE9B68A:0x6C26,0xE9B68D:0x6C27,0xE9B68E:0x6C28,0xE9B692:0x6C29,
	0xE9B693:0x6C2A,0xE9B695:0x6C2B,0xE9B696:0x6C2C,0xE9B697:0x6C2D,0xE9B698:0x6C2E,
	0xE9B6A1:0x6C2F,0xE9B6AA:0x6C30,0xE9B6AC:0x6C31,0xE9B6AE:0x6C32,0xE9B6B1:0x6C33,
	0xE9B6B5:0x6C34,0xE9B6B9:0x6C35,0xE9B6BC:0x6C36,0xE9B6BF:0x6C37,0xE9B783:0x6C38,
	0xE9B787:0x6C39,0xE9B789:0x6C3A,0xE9B78A:0x6C3B,0xE9B794:0x6C3C,0xE9B795:0x6C3D,
	0xE9B796:0x6C3E,0xE9B797:0x6C3F,0xE9B79A:0x6C40,0xE9B79E:0x6C41,0xE9B79F:0x6C42,
	0xE9B7A0:0x6C43,0xE9B7A5:0x6C44,0xE9B7A7:0x6C45,0xE9B7A9:0x6C46,0xE9B7AB:0x6C47,
	0xE9B7AE:0x6C48,0xE9B7B0:0x6C49,0xE9B7B3:0x6C4A,0xE9B7B4:0x6C4B,0xE9B7BE:0x6C4C,
	0xE9B88A:0x6C4D,0xE9B882:0x6C4E,0xE9B887:0x6C4F,0xE9B88E:0x6C50,0xE9B890:0x6C51,
	0xE9B891:0x6C52,0xE9B892:0x6C53,0xE9B895:0x6C54,0xE9B896:0x6C55,0xE9B899:0x6C56,
	0xE9B89C:0x6C57,0xE9B89D:0x6C58,0xE9B9BA:0x6C59,0xE9B9BB:0x6C5A,0xE9B9BC:0x6C5B,
	0xE9BA80:0x6C5C,0xE9BA82:0x6C5D,0xE9BA83:0x6C5E,0xE9BA84:0x6C5F,0xE9BA85:0x6C60,
	0xE9BA87:0x6C61,0xE9BA8E:0x6C62,0xE9BA8F:0x6C63,0xE9BA96:0x6C64,0xE9BA98:0x6C65,
	0xE9BA9B:0x6C66,0xE9BA9E:0x6C67,0xE9BAA4:0x6C68,0xE9BAA8:0x6C69,0xE9BAAC:0x6C6A,
	0xE9BAAE:0x6C6B,0xE9BAAF:0x6C6C,0xE9BAB0:0x6C6D,0xE9BAB3:0x6C6E,0xE9BAB4:0x6C6F,
	0xE9BAB5:0x6C70,0xE9BB86:0x6C71,0xE9BB88:0x6C72,0xE9BB8B:0x6C73,0xE9BB95:0x6C74,
	0xE9BB9F:0x6C75,0xE9BBA4:0x6C76,0xE9BBA7:0x6C77,0xE9BBAC:0x6C78,0xE9BBAD:0x6C79,
	0xE9BBAE:0x6C7A,0xE9BBB0:0x6C7B,0xE9BBB1:0x6C7C,0xE9BBB2:0x6C7D,0xE9BBB5:0x6C7E,
	0xE9BBB8:0x6D21,0xE9BBBF:0x6D22,0xE9BC82:0x6D23,0xE9BC83:0x6D24,0xE9BC89:0x6D25,
	0xE9BC8F:0x6D26,0xE9BC90:0x6D27,0xE9BC91:0x6D28,0xE9BC92:0x6D29,0xE9BC94:0x6D2A,
	0xE9BC96:0x6D2B,0xE9BC97:0x6D2C,0xE9BC99:0x6D2D,0xE9BC9A:0x6D2E,0xE9BC9B:0x6D2F,
	0xE9BC9F:0x6D30,0xE9BCA2:0x6D31,0xE9BCA6:0x6D32,0xE9BCAA:0x6D33,0xE9BCAB:0x6D34,
	0xE9BCAF:0x6D35,0xE9BCB1:0x6D36,0xE9BCB2:0x6D37,0xE9BCB4:0x6D38,0xE9BCB7:0x6D39,
	0xE9BCB9:0x6D3A,0xE9BCBA:0x6D3B,0xE9BCBC:0x6D3C,0xE9BCBD:0x6D3D,0xE9BCBF:0x6D3E,
	0xE9BD81:0x6D3F,0xE9BD83:0x6D40,0xE9BD84:0x6D41,0xE9BD85:0x6D42,0xE9BD86:0x6D43,
	0xE9BD87:0x6D44,0xE9BD93:0x6D45,0xE9BD95:0x6D46,0xE9BD96:0x6D47,0xE9BD97:0x6D48,
	0xE9BD98:0x6D49,0xE9BD9A:0x6D4A,0xE9BD9D:0x6D4B,0xE9BD9E:0x6D4C,0xE9BDA8:0x6D4D,
	0xE9BDA9:0x6D4E,0xE9BDAD:0x6D4F,0xE9BDAE:0x6D50,0xE9BDAF:0x6D51,0xE9BDB0:0x6D52,
	0xE9BDB1:0x6D53,0xE9BDB3:0x6D54,0xE9BDB5:0x6D55,0xE9BDBA:0x6D56,0xE9BDBD:0x6D57,
	0xE9BE8F:0x6D58,0xE9BE90:0x6D59,0xE9BE91:0x6D5A,0xE9BE92:0x6D5B,0xE9BE94:0x6D5C,
	0xE9BE96:0x6D5D,0xE9BE97:0x6D5E,0xE9BE9E:0x6D5F,0xE9BEA1:0x6D60,0xE9BEA2:0x6D61,
	0xE9BEA3:0x6D62,0xE9BEA5:0x6D63,

	//FIXME: mojibake
	0xE3809C:0x2141
	};


	/**
	 * Encoding conversion table for JIS to UTF-8.
	 *
	 * @ignore
	 */
	var JIS_TO_UTF8_TABLE = null;

	/**
	 * The encoding conversion table for JIS X 0212:1990 (Hojo-Kanji) to UTF-8.
	 *
	 * @ignore
	 */
	var JISX0212_TO_UTF8_TABLE = null;

	function init_JIS_TO_UTF8_TABLE() {
	  if (JIS_TO_UTF8_TABLE === null) {
	    JIS_TO_UTF8_TABLE = {};

	    var keys = getKeys(UTF8_TO_JIS_TABLE);
	    var i = 0;
	    var len = keys.length;
	    var key, value;

	    for (; i < len; i++) {
	      key = keys[i];
	      value = UTF8_TO_JIS_TABLE[key];
	      if (value > 0x5F) {
	        JIS_TO_UTF8_TABLE[value] = key | 0;
	      }
	    }

	    JISX0212_TO_UTF8_TABLE = {};
	    keys = getKeys(UTF8_TO_JISX0212_TABLE);
	    len = keys.length;

	    for (i = 0; i < len; i++) {
	      key = keys[i];
	      value = UTF8_TO_JISX0212_TABLE[key];
	      JISX0212_TO_UTF8_TABLE[value] = key | 0;
	    }
	  }
	}

	/**
	 * Katakana table
	 *
	 * @ignore
	 */
	var hankanaCase_table = {
	  0x3001:0xFF64,0x3002:0xFF61,0x300C:0xFF62,0x300D:0xFF63,0x309B:0xFF9E,
	  0x309C:0xFF9F,0x30A1:0xFF67,0x30A2:0xFF71,0x30A3:0xFF68,0x30A4:0xFF72,
	  0x30A5:0xFF69,0x30A6:0xFF73,0x30A7:0xFF6A,0x30A8:0xFF74,0x30A9:0xFF6B,
	  0x30AA:0xFF75,0x30AB:0xFF76,0x30AD:0xFF77,0x30AF:0xFF78,0x30B1:0xFF79,
	  0x30B3:0xFF7A,0x30B5:0xFF7B,0x30B7:0xFF7C,0x30B9:0xFF7D,0x30BB:0xFF7E,
	  0x30BD:0xFF7F,0x30BF:0xFF80,0x30C1:0xFF81,0x30C3:0xFF6F,0x30C4:0xFF82,
	  0x30C6:0xFF83,0x30C8:0xFF84,0x30CA:0xFF85,0x30CB:0xFF86,0x30CC:0xFF87,
	  0x30CD:0xFF88,0x30CE:0xFF89,0x30CF:0xFF8A,0x30D2:0xFF8B,0x30D5:0xFF8C,
	  0x30D8:0xFF8D,0x30DB:0xFF8E,0x30DE:0xFF8F,0x30DF:0xFF90,0x30E0:0xFF91,
	  0x30E1:0xFF92,0x30E2:0xFF93,0x30E3:0xFF6C,0x30E4:0xFF94,0x30E5:0xFF6D,
	  0x30E6:0xFF95,0x30E7:0xFF6E,0x30E8:0xFF96,0x30E9:0xFF97,0x30EA:0xFF98,
	  0x30EB:0xFF99,0x30EC:0xFF9A,0x30ED:0xFF9B,0x30EF:0xFF9C,0x30F2:0xFF66,
	  0x30F3:0xFF9D,0x30FB:0xFF65,0x30FC:0xFF70
	};

	/**
	 * @ignore
	 */
	var hankanaCase_sonants = {
	  0x30F4:0xFF73,
	  0x30F7:0xFF9C,
	  0x30FA:0xFF66
	};

	/**
	 * Sonant marks.
	 *
	 * @ignore
	 */
	var hankanaCase_marks = [0xFF9E, 0xFF9F];

	/**
	 * Zenkaku table [U+FF61] - [U+FF9F]
	 *
	 * @ignore
	 */
	var zenkanaCase_table = [
	  0x3002, 0x300C, 0x300D, 0x3001, 0x30FB, 0x30F2, 0x30A1, 0x30A3,
	  0x30A5, 0x30A7, 0x30A9, 0x30E3, 0x30E5, 0x30E7, 0x30C3, 0x30FC,
	  0x30A2, 0x30A4, 0x30A6, 0x30A8, 0x30AA, 0x30AB, 0x30AD, 0x30AF,
	  0x30B1, 0x30B3, 0x30B5, 0x30B7, 0x30B9, 0x30BB, 0x30BD, 0x30BF,
	  0x30C1, 0x30C4, 0x30C6, 0x30C8, 0x30CA, 0x30CB, 0x30CC, 0x30CD,
	  0x30CE, 0x30CF, 0x30D2, 0x30D5, 0x30D8, 0x30DB, 0x30DE, 0x30DF,
	  0x30E0, 0x30E1, 0x30E2, 0x30E4, 0x30E6, 0x30E8, 0x30E9, 0x30EA,
	  0x30EB, 0x30EC, 0x30ED, 0x30EF, 0x30F3, 0x309B, 0x309C
	];

	return Encoding;
	});


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {(function($){
	  $(function(){
	    //$('.button-collapse').sideNav();
	  });
	})($);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($, d3) {var topojson = __webpack_require__(43);
	(function($) {

	  var ua = navigator.userAgent; // ユーザーエージェントを代入
	  var isIE = false;
	  var isEdge = false;
	  if (ua.match("MSIE") || ua.match("Trident")) {
	    isIE = true;
	  }
	  if (ua.match("Edge")){
	    isEdge = true;
	  }
	  var captions = ['title', 'subtitle', 'subsubtitle'];
	  var ref_size = {
	    width :  420,
	    height:  330,
	    scale : 3200
	  };
	  function get_size(opt){
	    if(!opt) return ref_size;
	    if(!opt.width && !opt.height) return ref_size;
	    var new_size = {};
	    if(!opt.width || opt.width/opt.height > ref_size.width/ref_size.height){
	      new_size.height = opt.height;
	      new_size.width  = opt.height / ref_size.height * ref_size.width;
	      new_size.scale  = opt.height / ref_size.height * ref_size.scale;
	    }
	    else{
	      //if(opt.max_width) opt.width = opt.width > opt.max_width ? opt.max_width : opt.width;
	      new_size.width  = opt.width;
	      new_size.height = opt.width / ref_size.width * ref_size.height;
	      new_size.scale  = opt.width / ref_size.width * ref_size.scale;
	    }
	    return new_size;
	  }
	  function update_legend(legendView, options){
	    var domain = options.color_scale.domain();
	    var format_str;
	    if(options.format_str) format_str = options.format_str;
	    else format_str = (domain[0]%1===0 && domain[1]%1===0? ',.0f' : '0.2f' );
	    var legend = d3.legend.color()
	      .cells(11)
	      .shapeWidth(50)
	      .labelFormat(d3.format(format_str))
	      .scale(options.color_scale);
	    legendView.call(legend);
	  }
	  var geodata_topo = {};
	  var geodata_store = {};
	  var methods = {
	    init : function(option, callback){
	      var _this = this;
	      var defaults = {
	        geodata_file : 'data/00_hokkaido_topo.json',
	        title : 'title',
	        subtitle : 'subtitle',
	        subsubtitle : 'subsubtitle',
	        caption_sizes : [24,18,18],
	        map_filler : function(d){return '#ffffff'},
	        stroke_filler: "hsl(80,100%,0%)",
	        on_mouseover : null,
	        on_mouseout : null,
	        on_mousedown : null,
	        on_mouseup : null,
	        on_touchstart : null,
	        on_touchend : null,
	        on_click : null,
	        show_legend : true,
	        auto_resize : true,
	        max_width : null,
	        save_button : true,
	        save_filename : 'heatmap'
	      };
	      var options = $.extend(defaults,option);
	      this[0].hokkaidoHeatmap = options;
	      var selector = this.selector;
	      var geodata;

	      if(geodata_topo[options.geodata_file]){
	        // 地図データを読み込み済みだったら即表示
	        geodata = geodata_store[options.geodata_file];
	        display();
	      }
	      else{
	        // 地図データを読み込んでいなければ読み込み
	        d3.json(options.geodata_file, load_finished);
	      }

	      function load_finished(error, loaded){
	        geodata_topo[options.geodata_file] = loaded;
	        // TopoJSONデータ展開
	        geodata = topojson.feature(geodata_topo[options.geodata_file], geodata_topo[options.geodata_file].objects.hokkaido);
	        var exception_communes = ["色丹郡色丹村","国後郡泊村","国後郡留夜別村","択捉郡留別村","紗那郡紗那村","蘂取郡蘂取村"]; // 対象外の市町村
	        var remove_list = [];
	        geodata.features.forEach(function(d,i){
	          var commune;
	          if(d.properties.N03_003 == '札幌市') d.name = d.properties.N03_003;
	          else d.name = d.properties.N03_004;
	          if(exception_communes.indexOf(d.properties.N03_003 + d.properties.N03_004) != -1){
	            remove_list.push(i);
	          }
	        });
	        // 対象外の市町村を削除
	        remove_list.forEach(function(d){
	          geodata.features.splice(d,d);
	        });
	        geodata_store[options.geodata_file] = geodata;
	        display();
	      }
	      function display(){
	        var projection, path;

	        options.geodata = geodata;

	        // svg要素を作成し、データの受け皿となるg要素を追加
	        var size;
	        if( !options.width && !options.height ){
	          // 条件無指定の時は現在の枠の横幅に合わせる
	          size = get_size({
	            width: _this[0].offsetWidth,
	            height: _this[0].offsetWidth
	          });
	        }
	        else {
	          size = get_size(options);
	        }
	        var map_container = d3.select(selector).append('svg')
	        .attr('width', size.width)
	        .attr('height', size.height);
	        var map = map_container.append('g');

	        // Caption
	        var caption_container = map_container.append('g').attr('class','hokkaidoHeatmap_caption_container');
	        caption_container.selectAll('text')
	          .data(captions)
	          .enter()
	          .append('text')
	          .style('font',function(d,i){return options.caption_sizes[i]+'px "Noto Sans CJK JP" Arial'})
	          .attr('x',5)
	          .attr('y',function(d,i){var y=0;for(var j=0;j<=i;j++){y+=options.caption_sizes[j]+5}return y})
	          .text(function(d){return options[d]});

	        // 投影を処理する関数を用意した上でデータからSVGのPATHに変換
	        projection = d3.geo.mercator()
	        .scale(size.scale)
	        .center(d3.geo.centroid(geodata))  // データから中心点を計算
	        .translate([size.width / 2, size.height / 2]);

	        // pathジェネレータ関数
	        path = d3.geo.path().projection(projection);
	        map.selectAll('path')
	        .data(geodata.features)
	        .enter()
	        .append('path')
	        .attr('d', path)
	        .attr("fill", options.map_filler)
	        .attr("stroke", options.stroke_filler)
	        .attr("stroke-width","1")
	        .attr("stroke-opacity","0.2")
	        .on('mouseover', options.on_mouseover)
	        .on('mouseout', options.on_mouseout)
	        .on('mousedown', options.on_mousedown)
	        .on('mouseup', options.on_mouseup)
	        .on('touchstart', options.on_touchstart)
	        .on('touchend', options.on_touchend)
	        .on('click', options.on_click);

	        // 凡例作成
	        var legendView = map.append("g")
	          .attr("class", "legendQuant")
	          .style("font", '12px "Noto Sans CJK JP" Arial')
	          .attr("transform", "translate(20,90)");
	        if(options.show_legend && options.color_scale){
	          update_legend(legendView, options);
	        }
	        // 自動で大きさ変更
	        if(options.auto_resize){
	          $(window).on('load resize', function(){$(_this.selector).hokkaidoHeatmap('resize');});
	        }

	        // 保存ボタンを作成
	        if(!isEdge && !isIE && options.save_button){
	          $('<button>').text('画像として保存')
	            .on('click',　function (){
	              var width = map_container[0][0].offsetWidth;
	              var height = map_container[0][0].offsetHeight;
	              var proxy_canvas = $("<canvas>");
	              console.log(map_container);
	              proxy_canvas.attr('style','display:hidden;')
	                .attr('width', width)
	                .attr('height', height);
	              var ctx = proxy_canvas[0].getContext('2d');
	              //map_container.attr('viewBox', '0 0 '+size.width+' '+size.height);
	              var svg_data = new XMLSerializer().serializeToString(map_container[0][0]);
	              var img = "data:image/svg+xml;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(svg_data)));
	              var image = new Image();
	              image.onload = function(){
	                ctx.fillStyle = '#fff';
	                ctx.fillRect(0,0,width,height);
	                ctx.drawImage(image, 0, 0);
	                var downloader = $("<a>").attr('style','display:hidden')
	                  .attr('type','application/octet-stream')
	                  .attr('href', proxy_canvas[0].toDataURL("image/png"))
	                  .text('download')
	                  .attr('download',options.save_filename+'.png')
	                  .appendTo('body');
	                downloader[0].click();
	                proxy_canvas.remove();
	                downloader.remove();
	              }
	              image.src = img;
	            })
	            .attr('class','btn btn-default')
	            .appendTo(selector);
	        }

	        // 全処理が終了したらcallback呼び出し (即updateしたい場合に用いる)
	        if(typeof callback == 'function') callback();

	      }
	      return(this);
	    },
	    update : function( input_options ) {
	      var options = $(this.selector)[0].hokkaidoHeatmap;
	      options = $.extend(options, input_options);
	      d3.select(this.selector).selectAll('path')
	      .attr('fill', options.map_filler)
	      .on('mouseover', options.on_mouseover)
	      .on('mouseout', options.on_mouseout)
	      .on('mousedown', options.on_mousedown)
	      .on('mouseup', options.on_mouseup)
	      .on('touchstart', options.on_touchstart)
	      .on('touchend', options.on_touchend)
	      .on('click', options.on_click);

	      var caption_elems = d3.select(this.selector).select('.hokkaidoHeatmap_caption_container')
	        .selectAll('text')
	        .text(function(d){return options[d]});

	      //  凡例更新
	      if(options.show_legend && options.color_scale){
	        var legendView = d3.select(this.selector).select("g.legendQuant");
	        update_legend(legendView, options);
	      }
	    },
	    update_partial : function(filter, filler){
	      d3.select(this.selector).selectAll('path')
	      .filter(filter)
	      .attr('fill', filler);
	    },
	    resize : function( opt ){
	      if(!opt){
	        //  条件無指定の時は横幅に合わせて表示
	        opt = {
	          width: this[0].offsetWidth,
	          height: this[0].offsetWidth
	        };
	      }
	      var size = get_size(opt);
	      var map = d3.select(this.selector).select('svg')
	      .attr('width', size.width)
	      .attr('height', size.height);
	      // 投影を処理する関数を用意した上でデータからSVGのPATHに変換
	      projection = d3.geo.mercator()
	      .scale(size.scale)
	      .center(d3.geo.centroid(this[0].hokkaidoHeatmap.geodata))  // データから中心点を計算
	      .translate([size.width / 2, size.height / 2]);
	      // pathジェネレータ関数
	      path = d3.geo.path().projection(projection);
	      map.selectAll('path').attr('d', path);
	    }
	  };

	  $.fn.hokkaidoHeatmap = function( method ) {
	    if ( methods[method] ) {
	      return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
	    } else if ( typeof method === 'object' || ! method ) {
	      return methods.init.apply( this, arguments );
	    } else {
	      $.error( 'Method ' +  method + ' does not exist on jQuery.hokkaidoHeatmap' );
	    }
	  }

	})($);

	/*
	var options = {
	  map_filler:function(d){
	    var ratio = parseInt(Math.random()*100,10);
	    return "hsl(220,100%,"+ratio+"%)";
	  },
	  target_year : 2015
	};
	$('#map').hokkaidoHeatmap();
	*/
	/*setTimeout(function delayed(){
	  $('#map').hokkaidoHeatmap('update', options);
	}, 5000);*/
	/*d3.json(
	  'data/stat_2014.json',
	  function(error,d){
	    var options = {
	      map_filler:function(x){
	        try{
	          return color_generator(d.sum[x.name].sum, 13400000);
	        }
	        catch(e){
	          return '#fff';
	        }
	      }
	    };
	    $('#map').hokkaidoHeatmap('update', options);
	  }
	);

	setTimeout(function(){$('#map').hokkaidoHeatmap('resize', {width:800});},3000);


	*/

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8), __webpack_require__(1)))

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (factory((global.topojson = global.topojson || {})));
	}(this, function (exports) { 'use strict';

	  function noop() {}

	  function transformAbsolute(transform) {
	    if (!transform) return noop;
	    var x0,
	        y0,
	        kx = transform.scale[0],
	        ky = transform.scale[1],
	        dx = transform.translate[0],
	        dy = transform.translate[1];
	    return function(point, i) {
	      if (!i) x0 = y0 = 0;
	      point[0] = (x0 += point[0]) * kx + dx;
	      point[1] = (y0 += point[1]) * ky + dy;
	    };
	  }

	  function transformRelative(transform) {
	    if (!transform) return noop;
	    var x0,
	        y0,
	        kx = transform.scale[0],
	        ky = transform.scale[1],
	        dx = transform.translate[0],
	        dy = transform.translate[1];
	    return function(point, i) {
	      if (!i) x0 = y0 = 0;
	      var x1 = Math.round((point[0] - dx) / kx),
	          y1 = Math.round((point[1] - dy) / ky);
	      point[0] = x1 - x0;
	      point[1] = y1 - y0;
	      x0 = x1;
	      y0 = y1;
	    };
	  }

	  function reverse(array, n) {
	    var t, j = array.length, i = j - n;
	    while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
	  }

	  function bisect(a, x) {
	    var lo = 0, hi = a.length;
	    while (lo < hi) {
	      var mid = lo + hi >>> 1;
	      if (a[mid] < x) lo = mid + 1;
	      else hi = mid;
	    }
	    return lo;
	  }

	  function feature(topology, o) {
	    return o.type === "GeometryCollection" ? {
	      type: "FeatureCollection",
	      features: o.geometries.map(function(o) { return feature$1(topology, o); })
	    } : feature$1(topology, o);
	  }

	  function feature$1(topology, o) {
	    var f = {
	      type: "Feature",
	      id: o.id,
	      properties: o.properties || {},
	      geometry: object(topology, o)
	    };
	    if (o.id == null) delete f.id;
	    return f;
	  }

	  function object(topology, o) {
	    var absolute = transformAbsolute(topology.transform),
	        arcs = topology.arcs;

	    function arc(i, points) {
	      if (points.length) points.pop();
	      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {
	        points.push(p = a[k].slice());
	        absolute(p, k);
	      }
	      if (i < 0) reverse(points, n);
	    }

	    function point(p) {
	      p = p.slice();
	      absolute(p, 0);
	      return p;
	    }

	    function line(arcs) {
	      var points = [];
	      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
	      if (points.length < 2) points.push(points[0].slice());
	      return points;
	    }

	    function ring(arcs) {
	      var points = line(arcs);
	      while (points.length < 4) points.push(points[0].slice());
	      return points;
	    }

	    function polygon(arcs) {
	      return arcs.map(ring);
	    }

	    function geometry(o) {
	      var t = o.type;
	      return t === "GeometryCollection" ? {type: t, geometries: o.geometries.map(geometry)}
	          : t in geometryType ? {type: t, coordinates: geometryType[t](o)}
	          : null;
	    }

	    var geometryType = {
	      Point: function(o) { return point(o.coordinates); },
	      MultiPoint: function(o) { return o.coordinates.map(point); },
	      LineString: function(o) { return line(o.arcs); },
	      MultiLineString: function(o) { return o.arcs.map(line); },
	      Polygon: function(o) { return polygon(o.arcs); },
	      MultiPolygon: function(o) { return o.arcs.map(polygon); }
	    };

	    return geometry(o);
	  }

	  function stitchArcs(topology, arcs) {
	    var stitchedArcs = {},
	        fragmentByStart = {},
	        fragmentByEnd = {},
	        fragments = [],
	        emptyIndex = -1;

	    // Stitch empty arcs first, since they may be subsumed by other arcs.
	    arcs.forEach(function(i, j) {
	      var arc = topology.arcs[i < 0 ? ~i : i], t;
	      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
	        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
	      }
	    });

	    arcs.forEach(function(i) {
	      var e = ends(i),
	          start = e[0],
	          end = e[1],
	          f, g;

	      if (f = fragmentByEnd[start]) {
	        delete fragmentByEnd[f.end];
	        f.push(i);
	        f.end = end;
	        if (g = fragmentByStart[end]) {
	          delete fragmentByStart[g.start];
	          var fg = g === f ? f : f.concat(g);
	          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
	        } else {
	          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
	        }
	      } else if (f = fragmentByStart[end]) {
	        delete fragmentByStart[f.start];
	        f.unshift(i);
	        f.start = start;
	        if (g = fragmentByEnd[start]) {
	          delete fragmentByEnd[g.end];
	          var gf = g === f ? f : g.concat(f);
	          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
	        } else {
	          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
	        }
	      } else {
	        f = [i];
	        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
	      }
	    });

	    function ends(i) {
	      var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
	      if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
	      else p1 = arc[arc.length - 1];
	      return i < 0 ? [p1, p0] : [p0, p1];
	    }

	    function flush(fragmentByEnd, fragmentByStart) {
	      for (var k in fragmentByEnd) {
	        var f = fragmentByEnd[k];
	        delete fragmentByStart[f.start];
	        delete f.start;
	        delete f.end;
	        f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
	        fragments.push(f);
	      }
	    }

	    flush(fragmentByEnd, fragmentByStart);
	    flush(fragmentByStart, fragmentByEnd);
	    arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

	    return fragments;
	  }

	  function mesh(topology) {
	    return object(topology, meshArcs.apply(this, arguments));
	  }

	  function meshArcs(topology, o, filter) {
	    var arcs = [];

	    function arc(i) {
	      var j = i < 0 ? ~i : i;
	      (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
	    }

	    function line(arcs) {
	      arcs.forEach(arc);
	    }

	    function polygon(arcs) {
	      arcs.forEach(line);
	    }

	    function geometry(o) {
	      if (o.type === "GeometryCollection") o.geometries.forEach(geometry);
	      else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);
	    }

	    if (arguments.length > 1) {
	      var geomsByArc = [],
	          geom;

	      var geometryType = {
	        LineString: line,
	        MultiLineString: polygon,
	        Polygon: polygon,
	        MultiPolygon: function(arcs) { arcs.forEach(polygon); }
	      };

	      geometry(o);

	      geomsByArc.forEach(arguments.length < 3
	          ? function(geoms) { arcs.push(geoms[0].i); }
	          : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });
	    } else {
	      for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);
	    }

	    return {type: "MultiLineString", arcs: stitchArcs(topology, arcs)};
	  }

	  function cartesianTriangleArea(triangle) {
	    var a = triangle[0], b = triangle[1], c = triangle[2];
	    return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));
	  }

	  function ring(ring) {
	    var i = -1,
	        n = ring.length,
	        a,
	        b = ring[n - 1],
	        area = 0;

	    while (++i < n) {
	      a = b;
	      b = ring[i];
	      area += a[0] * b[1] - a[1] * b[0];
	    }

	    return area / 2;
	  }

	  function merge(topology) {
	    return object(topology, mergeArcs.apply(this, arguments));
	  }

	  function mergeArcs(topology, objects) {
	    var polygonsByArc = {},
	        polygons = [],
	        components = [];

	    objects.forEach(function(o) {
	      if (o.type === "Polygon") register(o.arcs);
	      else if (o.type === "MultiPolygon") o.arcs.forEach(register);
	    });

	    function register(polygon) {
	      polygon.forEach(function(ring$$) {
	        ring$$.forEach(function(arc) {
	          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
	        });
	      });
	      polygons.push(polygon);
	    }

	    function area(ring$$) {
	      return Math.abs(ring(object(topology, {type: "Polygon", arcs: [ring$$]}).coordinates[0]));
	    }

	    polygons.forEach(function(polygon) {
	      if (!polygon._) {
	        var component = [],
	            neighbors = [polygon];
	        polygon._ = 1;
	        components.push(component);
	        while (polygon = neighbors.pop()) {
	          component.push(polygon);
	          polygon.forEach(function(ring$$) {
	            ring$$.forEach(function(arc) {
	              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
	                if (!polygon._) {
	                  polygon._ = 1;
	                  neighbors.push(polygon);
	                }
	              });
	            });
	          });
	        }
	      }
	    });

	    polygons.forEach(function(polygon) {
	      delete polygon._;
	    });

	    return {
	      type: "MultiPolygon",
	      arcs: components.map(function(polygons) {
	        var arcs = [], n;

	        // Extract the exterior (unique) arcs.
	        polygons.forEach(function(polygon) {
	          polygon.forEach(function(ring$$) {
	            ring$$.forEach(function(arc) {
	              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
	                arcs.push(arc);
	              }
	            });
	          });
	        });

	        // Stitch the arcs into one or more rings.
	        arcs = stitchArcs(topology, arcs);

	        // If more than one ring is returned,
	        // at most one of these rings can be the exterior;
	        // choose the one with the greatest absolute area.
	        if ((n = arcs.length) > 1) {
	          for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
	            if ((ki = area(arcs[i])) > k) {
	              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
	            }
	          }
	        }

	        return arcs;
	      })
	    };
	  }

	  function neighbors(objects) {
	    var indexesByArc = {}, // arc index -> array of object indexes
	        neighbors = objects.map(function() { return []; });

	    function line(arcs, i) {
	      arcs.forEach(function(a) {
	        if (a < 0) a = ~a;
	        var o = indexesByArc[a];
	        if (o) o.push(i);
	        else indexesByArc[a] = [i];
	      });
	    }

	    function polygon(arcs, i) {
	      arcs.forEach(function(arc) { line(arc, i); });
	    }

	    function geometry(o, i) {
	      if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
	      else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
	    }

	    var geometryType = {
	      LineString: line,
	      MultiLineString: polygon,
	      Polygon: polygon,
	      MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
	    };

	    objects.forEach(geometry);

	    for (var i in indexesByArc) {
	      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
	        for (var k = j + 1; k < m; ++k) {
	          var ij = indexes[j], ik = indexes[k], n;
	          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
	          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
	        }
	      }
	    }

	    return neighbors;
	  }

	  function compareArea(a, b) {
	    return a[1][2] - b[1][2];
	  }

	  function minAreaHeap() {
	    var heap = {},
	        array = [],
	        size = 0;

	    heap.push = function(object) {
	      up(array[object._ = size] = object, size++);
	      return size;
	    };

	    heap.pop = function() {
	      if (size <= 0) return;
	      var removed = array[0], object;
	      if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);
	      return removed;
	    };

	    heap.remove = function(removed) {
	      var i = removed._, object;
	      if (array[i] !== removed) return; // invalid request
	      if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);
	      return i;
	    };

	    function up(object, i) {
	      while (i > 0) {
	        var j = ((i + 1) >> 1) - 1,
	            parent = array[j];
	        if (compareArea(object, parent) >= 0) break;
	        array[parent._ = i] = parent;
	        array[object._ = i = j] = object;
	      }
	    }

	    function down(object, i) {
	      while (true) {
	        var r = (i + 1) << 1,
	            l = r - 1,
	            j = i,
	            child = array[j];
	        if (l < size && compareArea(array[l], child) < 0) child = array[j = l];
	        if (r < size && compareArea(array[r], child) < 0) child = array[j = r];
	        if (j === i) break;
	        array[child._ = i] = child;
	        array[object._ = i = j] = object;
	      }
	    }

	    return heap;
	  }

	  function presimplify(topology, triangleArea) {
	    var absolute = transformAbsolute(topology.transform),
	        relative = transformRelative(topology.transform),
	        heap = minAreaHeap();

	    if (!triangleArea) triangleArea = cartesianTriangleArea;

	    topology.arcs.forEach(function(arc) {
	      var triangles = [],
	          maxArea = 0,
	          triangle,
	          i,
	          n,
	          p;

	      // To store each point’s effective area, we create a new array rather than
	      // extending the passed-in point to workaround a Chrome/V8 bug (getting
	      // stuck in smi mode). For midpoints, the initial effective area of
	      // Infinity will be computed in the next step.
	      for (i = 0, n = arc.length; i < n; ++i) {
	        p = arc[i];
	        absolute(arc[i] = [p[0], p[1], Infinity], i);
	      }

	      for (i = 1, n = arc.length - 1; i < n; ++i) {
	        triangle = arc.slice(i - 1, i + 2);
	        triangle[1][2] = triangleArea(triangle);
	        triangles.push(triangle);
	        heap.push(triangle);
	      }

	      for (i = 0, n = triangles.length; i < n; ++i) {
	        triangle = triangles[i];
	        triangle.previous = triangles[i - 1];
	        triangle.next = triangles[i + 1];
	      }

	      while (triangle = heap.pop()) {
	        var previous = triangle.previous,
	            next = triangle.next;

	        // If the area of the current point is less than that of the previous point
	        // to be eliminated, use the latter's area instead. This ensures that the
	        // current point cannot be eliminated without eliminating previously-
	        // eliminated points.
	        if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;
	        else maxArea = triangle[1][2];

	        if (previous) {
	          previous.next = next;
	          previous[2] = triangle[2];
	          update(previous);
	        }

	        if (next) {
	          next.previous = previous;
	          next[0] = triangle[0];
	          update(next);
	        }
	      }

	      arc.forEach(relative);
	    });

	    function update(triangle) {
	      heap.remove(triangle);
	      triangle[1][2] = triangleArea(triangle);
	      heap.push(triangle);
	    }

	    return topology;
	  }

	  var version = "1.6.26";

	  exports.version = version;
	  exports.mesh = mesh;
	  exports.meshArcs = meshArcs;
	  exports.merge = merge;
	  exports.mergeArcs = mergeArcs;
	  exports.feature = feature;
	  exports.neighbors = neighbors;
	  exports.presimplify = presimplify;

	}));

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(45);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(35)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js?minimize!./common.css", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js?minimize!./common.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(14)();
	// imports


	// module
	exports.push([module.id, "body{font-family:\\\\6E38\\30B4\\30B7\\30C3\\30AF\\4F53,Yu Gothic,YuGothic,sans-serif}#logo-container{font-size:16pt}h2{font-size:20pt}p{line-height:2rem}footer.page-footer{margin:0}@media only screen and (max-width:992px){.parallax-container .section{position:absolute;top:40%}#index-banner .section{top:10%}}@media only screen and (max-width:600px){#index-banner .section{top:0}}.icon-block{padding:0 15px}.icon-block .material-icons{font-size:inherit}.button-collapse{color:#26a69a}.parallax-container{min-height:300px;line-height:0;height:auto;color:hsla(0,0%,100%,.9)}.parallax-container .section{width:100%}select.browser-default{font-size:16pt}table#table_commune_data td,table#table_ranking td{padding:3px 5px}table#table_ranking tr:hover{color:#9e9d24}div#table_ranking_container{height:500px;overflow:auto}.card{padding:0}.card-action span{position:relative;top:-4px}table td{padding:3px 5px}div#ranking_container{height:500px;overflow:auto}.modal.bottom-sheet{max-height:100%}", ""]);

	// exports


/***/ }
/******/ ]);